ARM GAS  /tmp/ccC60hwS.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"mpu6050.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_ldivmod
  16              		.section	.text.get_st_biases,"ax",%progbits
  17              		.align	1
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	get_st_biases:
  25              	.LVL0:
  26              	.LFB99:
  27              		.file 1 "Src/mpu6050.c"
   1:Src/mpu6050.c **** /**
   2:Src/mpu6050.c ****   * This file was taken from InvenSense MotionApps v6.12 library and
   3:Src/mpu6050.c ****   * refactored for the hoverboard-sideboard-hack project.
   4:Src/mpu6050.c ****   *
   5:Src/mpu6050.c ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   6:Src/mpu6050.c ****   * Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
   7:Src/mpu6050.c ****   *
   8:Src/mpu6050.c ****   * This program is free software: you can redistribute it and/or modify
   9:Src/mpu6050.c ****   * it under the terms of the GNU General Public License as published by
  10:Src/mpu6050.c ****   * the Free Software Foundation, either version 3 of the License, or
  11:Src/mpu6050.c ****   * (at your option) any later version.
  12:Src/mpu6050.c ****   *
  13:Src/mpu6050.c ****   * This program is distributed in the hope that it will be useful,
  14:Src/mpu6050.c ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:Src/mpu6050.c ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:Src/mpu6050.c ****   * GNU General Public License for more details.
  17:Src/mpu6050.c ****   *
  18:Src/mpu6050.c ****   * You should have received a copy of the GNU General Public License
  19:Src/mpu6050.c ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  20:Src/mpu6050.c **** */
  21:Src/mpu6050.c **** 
  22:Src/mpu6050.c **** // Includes
  23:Src/mpu6050.c **** #include <stdio.h>
  24:Src/mpu6050.c **** #include <stdlib.h>
  25:Src/mpu6050.c **** #include <string.h>
  26:Src/mpu6050.c **** #include <math.h>
  27:Src/mpu6050.c **** #include "systick.h" 	
  28:Src/mpu6050.c **** #include "defines.h"
  29:Src/mpu6050.c **** #include "config.h"
  30:Src/mpu6050.c **** #include "util.h"
  31:Src/mpu6050.c **** #include "mpu6050.h"
ARM GAS  /tmp/ccC60hwS.s 			page 2


  32:Src/mpu6050.c **** #include "mpu6050_dmp.h"
  33:Src/mpu6050.c **** 
  34:Src/mpu6050.c **** 
  35:Src/mpu6050.c **** /* The following functions must be defined for this platform:
  36:Src/mpu6050.c ****  * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
  37:Src/mpu6050.c ****  *      unsigned char length, unsigned char const *data)
  38:Src/mpu6050.c ****  * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
  39:Src/mpu6050.c ****  *      unsigned char length, unsigned char *data)
  40:Src/mpu6050.c ****  * delay_ms(unsigned long num_ms)
  41:Src/mpu6050.c ****  * get_ms(unsigned long *count)
  42:Src/mpu6050.c ****  * labs(long x)
  43:Src/mpu6050.c ****  * fabsf(float x)
  44:Src/mpu6050.c ****  * min(int a, int b)
  45:Src/mpu6050.c ****  */
  46:Src/mpu6050.c **** 
  47:Src/mpu6050.c **** MPU_Data mpu;                                       // holds the MPU-6050 data
  48:Src/mpu6050.c **** 
  49:Src/mpu6050.c **** #ifdef SERIAL_AUX_RX
  50:Src/mpu6050.c **** uint8_t print_aux = 0;                              // print AUX serial data
  51:Src/mpu6050.c **** #endif
  52:Src/mpu6050.c **** 
  53:Src/mpu6050.c **** #ifdef  MPU_SENSOR_ENABLE
  54:Src/mpu6050.c **** 
  55:Src/mpu6050.c **** static signed char MPU_ORIENTATION[9] = {1, 0, 0,   // [-] MPU Sensor orientation matrix: set this 
  56:Src/mpu6050.c ****                                          0, 1, 0,
  57:Src/mpu6050.c ****                                          0, 0, 1};
  58:Src/mpu6050.c **** 
  59:Src/mpu6050.c **** 
  60:Src/mpu6050.c **** #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
  61:Src/mpu6050.c **** #error  Which gyro are you using? Define MPUxxxx in config.h
  62:Src/mpu6050.c **** #endif
  63:Src/mpu6050.c **** 
  64:Src/mpu6050.c **** 
  65:Src/mpu6050.c **** 
  66:Src/mpu6050.c **** /* Time for some messy macro work. =]
  67:Src/mpu6050.c ****  * #define MPU9150
  68:Src/mpu6050.c ****  * is equivalent to..
  69:Src/mpu6050.c ****  * #define MPU6050
  70:Src/mpu6050.c ****  * #define AK8975_SECONDARY
  71:Src/mpu6050.c ****  *
  72:Src/mpu6050.c ****  * #define MPU9250
  73:Src/mpu6050.c ****  * is equivalent to..
  74:Src/mpu6050.c ****  * #define MPU6500
  75:Src/mpu6050.c ****  * #define AK8963_SECONDARY
  76:Src/mpu6050.c ****  */
  77:Src/mpu6050.c **** #if defined MPU9150
  78:Src/mpu6050.c **** #ifndef MPU6050
  79:Src/mpu6050.c **** #define MPU6050
  80:Src/mpu6050.c **** #endif                          /* #ifndef MPU6050 */
  81:Src/mpu6050.c **** #if defined AK8963_SECONDARY
  82:Src/mpu6050.c **** #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
  83:Src/mpu6050.c **** #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
  84:Src/mpu6050.c **** #define AK8975_SECONDARY
  85:Src/mpu6050.c **** #endif                          /* #if defined AK8963_SECONDARY */
  86:Src/mpu6050.c **** #elif defined MPU9250           /* #if defined MPU9150 */
  87:Src/mpu6050.c **** #ifndef MPU6500
  88:Src/mpu6050.c **** #define MPU6500
ARM GAS  /tmp/ccC60hwS.s 			page 3


  89:Src/mpu6050.c **** #endif                          /* #ifndef MPU6500 */
  90:Src/mpu6050.c **** #if defined AK8975_SECONDARY
  91:Src/mpu6050.c **** #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
  92:Src/mpu6050.c **** #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
  93:Src/mpu6050.c **** #define AK8963_SECONDARY
  94:Src/mpu6050.c **** #endif                          /* #if defined AK8975_SECONDARY */
  95:Src/mpu6050.c **** #endif                          /* #if defined MPU9150 */
  96:Src/mpu6050.c **** 
  97:Src/mpu6050.c **** #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
  98:Src/mpu6050.c **** #define AK89xx_SECONDARY
  99:Src/mpu6050.c **** #else
 100:Src/mpu6050.c **** /* #warning "No compass = less profit for Invensense. Lame." */
 101:Src/mpu6050.c **** #endif
 102:Src/mpu6050.c **** 
 103:Src/mpu6050.c **** static int set_int_enable(unsigned char enable);
 104:Src/mpu6050.c **** 
 105:Src/mpu6050.c **** /* Hardware registers needed by driver. */
 106:Src/mpu6050.c **** struct gyro_reg_s {
 107:Src/mpu6050.c ****     unsigned char who_am_i;
 108:Src/mpu6050.c ****     unsigned char rate_div;
 109:Src/mpu6050.c ****     unsigned char lpf;
 110:Src/mpu6050.c ****     unsigned char prod_id;
 111:Src/mpu6050.c ****     unsigned char user_ctrl;
 112:Src/mpu6050.c ****     unsigned char fifo_en;
 113:Src/mpu6050.c ****     unsigned char gyro_cfg;
 114:Src/mpu6050.c ****     unsigned char accel_cfg;
 115:Src/mpu6050.c ****     unsigned char accel_cfg2;
 116:Src/mpu6050.c ****     unsigned char lp_accel_odr;
 117:Src/mpu6050.c ****     unsigned char motion_thr;
 118:Src/mpu6050.c ****     unsigned char motion_dur;
 119:Src/mpu6050.c ****     unsigned char fifo_count_h;
 120:Src/mpu6050.c ****     unsigned char fifo_r_w;
 121:Src/mpu6050.c ****     unsigned char raw_gyro;
 122:Src/mpu6050.c ****     unsigned char raw_accel;
 123:Src/mpu6050.c ****     unsigned char temp;
 124:Src/mpu6050.c ****     unsigned char int_enable;
 125:Src/mpu6050.c ****     unsigned char dmp_int_status;
 126:Src/mpu6050.c ****     unsigned char int_status;
 127:Src/mpu6050.c ****     unsigned char accel_intel;
 128:Src/mpu6050.c ****     unsigned char pwr_mgmt_1;
 129:Src/mpu6050.c ****     unsigned char pwr_mgmt_2;
 130:Src/mpu6050.c ****     unsigned char int_pin_cfg;
 131:Src/mpu6050.c ****     unsigned char mem_r_w;
 132:Src/mpu6050.c ****     unsigned char accel_offs;
 133:Src/mpu6050.c ****     unsigned char i2c_mst;
 134:Src/mpu6050.c ****     unsigned char bank_sel;
 135:Src/mpu6050.c ****     unsigned char mem_start_addr;
 136:Src/mpu6050.c ****     unsigned char prgm_start_h;
 137:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 138:Src/mpu6050.c ****     unsigned char s0_addr;
 139:Src/mpu6050.c ****     unsigned char s0_reg;
 140:Src/mpu6050.c ****     unsigned char s0_ctrl;
 141:Src/mpu6050.c ****     unsigned char s1_addr;
 142:Src/mpu6050.c ****     unsigned char s1_reg;
 143:Src/mpu6050.c ****     unsigned char s1_ctrl;
 144:Src/mpu6050.c ****     unsigned char s4_ctrl;
 145:Src/mpu6050.c ****     unsigned char s0_do;
ARM GAS  /tmp/ccC60hwS.s 			page 4


 146:Src/mpu6050.c ****     unsigned char s1_do;
 147:Src/mpu6050.c ****     unsigned char i2c_delay_ctrl;
 148:Src/mpu6050.c ****     unsigned char raw_compass;
 149:Src/mpu6050.c ****     /* The I2C_MST_VDDIO bit is in this register. */
 150:Src/mpu6050.c ****     unsigned char yg_offs_tc;
 151:Src/mpu6050.c **** #endif
 152:Src/mpu6050.c **** };
 153:Src/mpu6050.c **** 
 154:Src/mpu6050.c **** /* Information specific to a particular device. */
 155:Src/mpu6050.c **** struct hw_s {
 156:Src/mpu6050.c ****     unsigned char addr;
 157:Src/mpu6050.c ****     unsigned short max_fifo;
 158:Src/mpu6050.c ****     unsigned char num_reg;
 159:Src/mpu6050.c ****     unsigned short temp_sens;
 160:Src/mpu6050.c ****     short temp_offset;
 161:Src/mpu6050.c ****     unsigned short bank_size;
 162:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 163:Src/mpu6050.c ****     unsigned short compass_fsr;
 164:Src/mpu6050.c **** #endif
 165:Src/mpu6050.c **** };
 166:Src/mpu6050.c **** 
 167:Src/mpu6050.c **** /* When entering motion interrupt mode, the driver keeps track of the
 168:Src/mpu6050.c ****  * previous state so that it can be restored at a later time.
 169:Src/mpu6050.c ****  * TODO: This is tacky. Fix it.
 170:Src/mpu6050.c ****  */
 171:Src/mpu6050.c **** struct motion_int_cache_s {
 172:Src/mpu6050.c ****     unsigned short gyro_fsr;
 173:Src/mpu6050.c ****     unsigned char accel_fsr;
 174:Src/mpu6050.c ****     unsigned short lpf;
 175:Src/mpu6050.c ****     unsigned short sample_rate;
 176:Src/mpu6050.c ****     unsigned char sensors_on;
 177:Src/mpu6050.c ****     unsigned char fifo_sensors;
 178:Src/mpu6050.c ****     unsigned char dmp_on;
 179:Src/mpu6050.c **** };
 180:Src/mpu6050.c **** 
 181:Src/mpu6050.c **** /* Cached chip configuration data.
 182:Src/mpu6050.c ****  * TODO: A lot of these can be handled with a bitmask.
 183:Src/mpu6050.c ****  */
 184:Src/mpu6050.c **** struct chip_cfg_s {
 185:Src/mpu6050.c ****     /* Matches gyro_cfg >> 3 & 0x03 */
 186:Src/mpu6050.c ****     unsigned char gyro_fsr;
 187:Src/mpu6050.c ****     /* Matches accel_cfg >> 3 & 0x03 */
 188:Src/mpu6050.c ****     unsigned char accel_fsr;
 189:Src/mpu6050.c ****     /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
 190:Src/mpu6050.c ****     unsigned char sensors;
 191:Src/mpu6050.c ****     /* Matches config register. */
 192:Src/mpu6050.c ****     unsigned char lpf;
 193:Src/mpu6050.c ****     unsigned char clk_src;
 194:Src/mpu6050.c ****     /* Sample rate, NOT rate divider. */
 195:Src/mpu6050.c ****     unsigned short sample_rate;
 196:Src/mpu6050.c ****     /* Matches fifo_en register. */
 197:Src/mpu6050.c ****     unsigned char fifo_enable;
 198:Src/mpu6050.c ****     /* Matches int enable register. */
 199:Src/mpu6050.c ****     unsigned char int_enable;
 200:Src/mpu6050.c ****     /* 1 if devices on auxiliary I2C bus appear on the primary. */
 201:Src/mpu6050.c ****     unsigned char bypass_mode;
 202:Src/mpu6050.c ****     /* 1 if half-sensitivity.
ARM GAS  /tmp/ccC60hwS.s 			page 5


 203:Src/mpu6050.c ****      * NOTE: This doesn't belong here, but everything else in hw_s is const,
 204:Src/mpu6050.c ****      * and this allows us to save some precious RAM.
 205:Src/mpu6050.c ****      */
 206:Src/mpu6050.c ****     unsigned char accel_half;
 207:Src/mpu6050.c ****     /* 1 if device in low-power accel-only mode. */
 208:Src/mpu6050.c ****     unsigned char lp_accel_mode;
 209:Src/mpu6050.c ****     /* 1 if interrupts are only triggered on motion events. */
 210:Src/mpu6050.c ****     unsigned char int_motion_only;
 211:Src/mpu6050.c ****     struct motion_int_cache_s cache;
 212:Src/mpu6050.c ****     /* 1 for active low interrupts. */
 213:Src/mpu6050.c ****     unsigned char active_low_int;
 214:Src/mpu6050.c ****     /* 1 for latched interrupts. */
 215:Src/mpu6050.c ****     unsigned char latched_int;
 216:Src/mpu6050.c ****     /* 1 if DMP is enabled. */
 217:Src/mpu6050.c ****     unsigned char dmp_on;
 218:Src/mpu6050.c ****     /* Ensures that DMP will only be loaded once. */
 219:Src/mpu6050.c ****     unsigned char dmp_loaded;
 220:Src/mpu6050.c ****     /* Sampling rate used when DMP is enabled. */
 221:Src/mpu6050.c ****     unsigned short dmp_sample_rate;
 222:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 223:Src/mpu6050.c ****     /* Compass sample rate. */
 224:Src/mpu6050.c ****     unsigned short compass_sample_rate;
 225:Src/mpu6050.c ****     unsigned char compass_addr;
 226:Src/mpu6050.c ****     short mag_sens_adj[3];
 227:Src/mpu6050.c **** #endif
 228:Src/mpu6050.c **** };
 229:Src/mpu6050.c **** 
 230:Src/mpu6050.c **** /* Information for self-test. */
 231:Src/mpu6050.c **** struct test_s {
 232:Src/mpu6050.c ****     unsigned long gyro_sens;
 233:Src/mpu6050.c ****     unsigned long accel_sens;
 234:Src/mpu6050.c ****     unsigned char reg_rate_div;
 235:Src/mpu6050.c ****     unsigned char reg_lpf;
 236:Src/mpu6050.c ****     unsigned char reg_gyro_fsr;
 237:Src/mpu6050.c ****     unsigned char reg_accel_fsr;
 238:Src/mpu6050.c ****     unsigned short wait_ms;
 239:Src/mpu6050.c ****     unsigned char packet_thresh;
 240:Src/mpu6050.c ****     float min_dps;
 241:Src/mpu6050.c ****     float max_dps;
 242:Src/mpu6050.c ****     float max_gyro_var;
 243:Src/mpu6050.c ****     float min_g;
 244:Src/mpu6050.c ****     float max_g;
 245:Src/mpu6050.c ****     float max_accel_var;
 246:Src/mpu6050.c **** #ifdef MPU6500
 247:Src/mpu6050.c ****     float max_g_offset;
 248:Src/mpu6050.c ****     unsigned short sample_wait_ms;
 249:Src/mpu6050.c **** #endif
 250:Src/mpu6050.c **** };
 251:Src/mpu6050.c **** 
 252:Src/mpu6050.c **** /* Gyro driver state variables. */
 253:Src/mpu6050.c **** struct gyro_state_s {
 254:Src/mpu6050.c ****     const struct gyro_reg_s *reg;
 255:Src/mpu6050.c ****     const struct hw_s *hw;
 256:Src/mpu6050.c ****     struct chip_cfg_s chip_cfg;
 257:Src/mpu6050.c ****     const struct test_s *test;
 258:Src/mpu6050.c **** };
 259:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 6


 260:Src/mpu6050.c **** /* Filter configurations. */
 261:Src/mpu6050.c **** enum lpf_e {
 262:Src/mpu6050.c ****     INV_FILTER_256HZ_NOLPF2 = 0,
 263:Src/mpu6050.c ****     INV_FILTER_188HZ,
 264:Src/mpu6050.c ****     INV_FILTER_98HZ,
 265:Src/mpu6050.c ****     INV_FILTER_42HZ,
 266:Src/mpu6050.c ****     INV_FILTER_20HZ,
 267:Src/mpu6050.c ****     INV_FILTER_10HZ,
 268:Src/mpu6050.c ****     INV_FILTER_5HZ,
 269:Src/mpu6050.c ****     INV_FILTER_2100HZ_NOLPF,
 270:Src/mpu6050.c ****     NUM_FILTER
 271:Src/mpu6050.c **** };
 272:Src/mpu6050.c **** 
 273:Src/mpu6050.c **** /* Full scale ranges. */
 274:Src/mpu6050.c **** enum gyro_fsr_e {
 275:Src/mpu6050.c ****     INV_FSR_250DPS = 0,
 276:Src/mpu6050.c ****     INV_FSR_500DPS,
 277:Src/mpu6050.c ****     INV_FSR_1000DPS,
 278:Src/mpu6050.c ****     INV_FSR_2000DPS,
 279:Src/mpu6050.c ****     NUM_GYRO_FSR
 280:Src/mpu6050.c **** };
 281:Src/mpu6050.c **** 
 282:Src/mpu6050.c **** /* Full scale ranges. */
 283:Src/mpu6050.c **** enum accel_fsr_e {
 284:Src/mpu6050.c ****     INV_FSR_2G = 0,
 285:Src/mpu6050.c ****     INV_FSR_4G,
 286:Src/mpu6050.c ****     INV_FSR_8G,
 287:Src/mpu6050.c ****     INV_FSR_16G,
 288:Src/mpu6050.c ****     NUM_ACCEL_FSR
 289:Src/mpu6050.c **** };
 290:Src/mpu6050.c **** 
 291:Src/mpu6050.c **** /* Clock sources. */
 292:Src/mpu6050.c **** enum clock_sel_e {
 293:Src/mpu6050.c ****     INV_CLK_INTERNAL = 0,
 294:Src/mpu6050.c ****     INV_CLK_PLL,
 295:Src/mpu6050.c ****     NUM_CLK
 296:Src/mpu6050.c **** };
 297:Src/mpu6050.c **** 
 298:Src/mpu6050.c **** /* Low-power accel wakeup rates. */
 299:Src/mpu6050.c **** enum lp_accel_rate_e {
 300:Src/mpu6050.c **** #if defined MPU6050
 301:Src/mpu6050.c ****     INV_LPA_1_25HZ,
 302:Src/mpu6050.c ****     INV_LPA_5HZ,
 303:Src/mpu6050.c ****     INV_LPA_20HZ,
 304:Src/mpu6050.c ****     INV_LPA_40HZ
 305:Src/mpu6050.c **** #elif defined MPU6500
 306:Src/mpu6050.c ****     INV_LPA_0_3125HZ,
 307:Src/mpu6050.c ****     INV_LPA_0_625HZ,
 308:Src/mpu6050.c ****     INV_LPA_1_25HZ,
 309:Src/mpu6050.c ****     INV_LPA_2_5HZ,
 310:Src/mpu6050.c ****     INV_LPA_5HZ,
 311:Src/mpu6050.c ****     INV_LPA_10HZ,
 312:Src/mpu6050.c ****     INV_LPA_20HZ,
 313:Src/mpu6050.c ****     INV_LPA_40HZ,
 314:Src/mpu6050.c ****     INV_LPA_80HZ,
 315:Src/mpu6050.c ****     INV_LPA_160HZ,
 316:Src/mpu6050.c ****     INV_LPA_320HZ,
ARM GAS  /tmp/ccC60hwS.s 			page 7


 317:Src/mpu6050.c ****     INV_LPA_640HZ
 318:Src/mpu6050.c **** #endif
 319:Src/mpu6050.c **** };
 320:Src/mpu6050.c **** 
 321:Src/mpu6050.c **** #define BIT_I2C_MST_VDDIO   (0x80)
 322:Src/mpu6050.c **** #define BIT_FIFO_EN         (0x40)
 323:Src/mpu6050.c **** #define BIT_DMP_EN          (0x80)
 324:Src/mpu6050.c **** #define BIT_FIFO_RST        (0x04)
 325:Src/mpu6050.c **** #define BIT_DMP_RST         (0x08)
 326:Src/mpu6050.c **** #define BIT_FIFO_OVERFLOW   (0x10)
 327:Src/mpu6050.c **** #define BIT_DATA_RDY_EN     (0x01)
 328:Src/mpu6050.c **** #define BIT_DMP_INT_EN      (0x02)
 329:Src/mpu6050.c **** #define BIT_MOT_INT_EN      (0x40)
 330:Src/mpu6050.c **** #define BITS_FSR            (0x18)
 331:Src/mpu6050.c **** #define BITS_LPF            (0x07)
 332:Src/mpu6050.c **** #define BITS_HPF            (0x07)
 333:Src/mpu6050.c **** #define BITS_CLK            (0x07)
 334:Src/mpu6050.c **** #define BIT_FIFO_SIZE_1024  (0x40)
 335:Src/mpu6050.c **** #define BIT_FIFO_SIZE_2048  (0x80)
 336:Src/mpu6050.c **** #define BIT_FIFO_SIZE_4096  (0xC0)
 337:Src/mpu6050.c **** #define BIT_RESET           (0x80)
 338:Src/mpu6050.c **** #define BIT_SLEEP           (0x40)
 339:Src/mpu6050.c **** #define BIT_S0_DELAY_EN     (0x01)
 340:Src/mpu6050.c **** #define BIT_S2_DELAY_EN     (0x04)
 341:Src/mpu6050.c **** #define BITS_SLAVE_LENGTH   (0x0F)
 342:Src/mpu6050.c **** #define BIT_SLAVE_BYTE_SW   (0x40)
 343:Src/mpu6050.c **** #define BIT_SLAVE_GROUP     (0x10)
 344:Src/mpu6050.c **** #define BIT_SLAVE_EN        (0x80)
 345:Src/mpu6050.c **** #define BIT_I2C_READ        (0x80)
 346:Src/mpu6050.c **** #define BITS_I2C_MASTER_DLY (0x1F)
 347:Src/mpu6050.c **** #define BIT_AUX_IF_EN       (0x20)
 348:Src/mpu6050.c **** #define BIT_ACTL            (0x80)
 349:Src/mpu6050.c **** #define BIT_LATCH_EN        (0x20)
 350:Src/mpu6050.c **** #define BIT_ANY_RD_CLR      (0x10)
 351:Src/mpu6050.c **** #define BIT_BYPASS_EN       (0x02)
 352:Src/mpu6050.c **** #define BITS_WOM_EN         (0xC0)
 353:Src/mpu6050.c **** #define BIT_LPA_CYCLE       (0x20)
 354:Src/mpu6050.c **** #define BIT_STBY_XA         (0x20)
 355:Src/mpu6050.c **** #define BIT_STBY_YA         (0x10)
 356:Src/mpu6050.c **** #define BIT_STBY_ZA         (0x08)
 357:Src/mpu6050.c **** #define BIT_STBY_XG         (0x04)
 358:Src/mpu6050.c **** #define BIT_STBY_YG         (0x02)
 359:Src/mpu6050.c **** #define BIT_STBY_ZG         (0x01)
 360:Src/mpu6050.c **** #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
 361:Src/mpu6050.c **** #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
 362:Src/mpu6050.c **** 
 363:Src/mpu6050.c **** #if defined AK8975_SECONDARY
 364:Src/mpu6050.c **** #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
 365:Src/mpu6050.c **** #define AK89xx_FSR                  (9830)
 366:Src/mpu6050.c **** #elif defined AK8963_SECONDARY
 367:Src/mpu6050.c **** #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
 368:Src/mpu6050.c **** #define AK89xx_FSR                  (4915)
 369:Src/mpu6050.c **** #endif
 370:Src/mpu6050.c **** 
 371:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 372:Src/mpu6050.c **** #define AKM_REG_WHOAMI      (0x00)
 373:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 8


 374:Src/mpu6050.c **** #define AKM_REG_ST1         (0x02)
 375:Src/mpu6050.c **** #define AKM_REG_HXL         (0x03)
 376:Src/mpu6050.c **** #define AKM_REG_ST2         (0x09)
 377:Src/mpu6050.c **** 
 378:Src/mpu6050.c **** #define AKM_REG_CNTL        (0x0A)
 379:Src/mpu6050.c **** #define AKM_REG_ASTC        (0x0C)
 380:Src/mpu6050.c **** #define AKM_REG_ASAX        (0x10)
 381:Src/mpu6050.c **** #define AKM_REG_ASAY        (0x11)
 382:Src/mpu6050.c **** #define AKM_REG_ASAZ        (0x12)
 383:Src/mpu6050.c **** 
 384:Src/mpu6050.c **** #define AKM_DATA_READY      (0x01)
 385:Src/mpu6050.c **** #define AKM_DATA_OVERRUN    (0x02)
 386:Src/mpu6050.c **** #define AKM_OVERFLOW        (0x80)
 387:Src/mpu6050.c **** #define AKM_DATA_ERROR      (0x40)
 388:Src/mpu6050.c **** 
 389:Src/mpu6050.c **** #define AKM_BIT_SELF_TEST   (0x40)
 390:Src/mpu6050.c **** 
 391:Src/mpu6050.c **** #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
 392:Src/mpu6050.c **** #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
 393:Src/mpu6050.c **** #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
 394:Src/mpu6050.c **** #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
 395:Src/mpu6050.c **** 
 396:Src/mpu6050.c **** #define AKM_WHOAMI      (0x48)
 397:Src/mpu6050.c **** #endif
 398:Src/mpu6050.c **** 
 399:Src/mpu6050.c **** #if defined MPU6050
 400:Src/mpu6050.c **** const struct gyro_reg_s reg = {
 401:Src/mpu6050.c ****     .who_am_i       = 0x75,
 402:Src/mpu6050.c ****     .rate_div       = 0x19,
 403:Src/mpu6050.c ****     .lpf            = 0x1A,
 404:Src/mpu6050.c ****     .prod_id        = 0x0C,
 405:Src/mpu6050.c ****     .user_ctrl      = 0x6A,
 406:Src/mpu6050.c ****     .fifo_en        = 0x23,
 407:Src/mpu6050.c ****     .gyro_cfg       = 0x1B,
 408:Src/mpu6050.c ****     .accel_cfg      = 0x1C,
 409:Src/mpu6050.c ****     .motion_thr     = 0x1F,
 410:Src/mpu6050.c ****     .motion_dur     = 0x20,
 411:Src/mpu6050.c ****     .fifo_count_h   = 0x72,
 412:Src/mpu6050.c ****     .fifo_r_w       = 0x74,
 413:Src/mpu6050.c ****     .raw_gyro       = 0x43,
 414:Src/mpu6050.c ****     .raw_accel      = 0x3B,
 415:Src/mpu6050.c ****     .temp           = 0x41,
 416:Src/mpu6050.c ****     .int_enable     = 0x38,
 417:Src/mpu6050.c ****     .dmp_int_status = 0x39,
 418:Src/mpu6050.c ****     .int_status     = 0x3A,
 419:Src/mpu6050.c ****     .pwr_mgmt_1     = 0x6B,
 420:Src/mpu6050.c ****     .pwr_mgmt_2     = 0x6C,
 421:Src/mpu6050.c ****     .int_pin_cfg    = 0x37,
 422:Src/mpu6050.c ****     .mem_r_w        = 0x6F,
 423:Src/mpu6050.c ****     .accel_offs     = 0x06,
 424:Src/mpu6050.c ****     .i2c_mst        = 0x24,
 425:Src/mpu6050.c ****     .bank_sel       = 0x6D,
 426:Src/mpu6050.c ****     .mem_start_addr = 0x6E,
 427:Src/mpu6050.c ****     .prgm_start_h   = 0x70
 428:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 429:Src/mpu6050.c ****     ,.raw_compass   = 0x49,
 430:Src/mpu6050.c ****     .yg_offs_tc     = 0x01,
ARM GAS  /tmp/ccC60hwS.s 			page 9


 431:Src/mpu6050.c ****     .s0_addr        = 0x25,
 432:Src/mpu6050.c ****     .s0_reg         = 0x26,
 433:Src/mpu6050.c ****     .s0_ctrl        = 0x27,
 434:Src/mpu6050.c ****     .s1_addr        = 0x28,
 435:Src/mpu6050.c ****     .s1_reg         = 0x29,
 436:Src/mpu6050.c ****     .s1_ctrl        = 0x2A,
 437:Src/mpu6050.c ****     .s4_ctrl        = 0x34,
 438:Src/mpu6050.c ****     .s0_do          = 0x63,
 439:Src/mpu6050.c ****     .s1_do          = 0x64,
 440:Src/mpu6050.c ****     .i2c_delay_ctrl = 0x67
 441:Src/mpu6050.c **** #endif
 442:Src/mpu6050.c **** };
 443:Src/mpu6050.c **** const struct hw_s hw = {
 444:Src/mpu6050.c ****     .addr           = 0x68,
 445:Src/mpu6050.c ****     .max_fifo       = 1024,
 446:Src/mpu6050.c ****     .num_reg        = 118,
 447:Src/mpu6050.c ****     .temp_sens      = 340,
 448:Src/mpu6050.c ****     .temp_offset    = -521,
 449:Src/mpu6050.c ****     .bank_size      = 256
 450:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 451:Src/mpu6050.c ****     ,.compass_fsr    = AK89xx_FSR
 452:Src/mpu6050.c **** #endif
 453:Src/mpu6050.c **** };
 454:Src/mpu6050.c **** 
 455:Src/mpu6050.c **** const struct test_s test = {
 456:Src/mpu6050.c ****     .gyro_sens      = 32768/250,
 457:Src/mpu6050.c ****     .accel_sens     = 32768/16,
 458:Src/mpu6050.c ****     .reg_rate_div   = 0,    /* 1kHz. */
 459:Src/mpu6050.c ****     .reg_lpf        = 1,    /* 188Hz. */
 460:Src/mpu6050.c ****     .reg_gyro_fsr   = 0,    /* 250dps. */
 461:Src/mpu6050.c ****     .reg_accel_fsr  = 0x18, /* 16g. */
 462:Src/mpu6050.c ****     .wait_ms        = 50,
 463:Src/mpu6050.c ****     .packet_thresh  = 5,    /* 5% */
 464:Src/mpu6050.c ****     .min_dps        = 10.f,
 465:Src/mpu6050.c ****     .max_dps        = 105.f,
 466:Src/mpu6050.c ****     .max_gyro_var   = 0.14f,
 467:Src/mpu6050.c ****     .min_g          = 0.3f,
 468:Src/mpu6050.c ****     .max_g          = 0.95f,
 469:Src/mpu6050.c ****     .max_accel_var  = 0.14f
 470:Src/mpu6050.c **** };
 471:Src/mpu6050.c **** 
 472:Src/mpu6050.c **** static struct gyro_state_s st = {
 473:Src/mpu6050.c ****     .reg = &reg,
 474:Src/mpu6050.c ****     .hw = &hw,
 475:Src/mpu6050.c ****     .test = &test
 476:Src/mpu6050.c **** };
 477:Src/mpu6050.c **** #elif defined MPU6500
 478:Src/mpu6050.c **** const struct gyro_reg_s reg = {
 479:Src/mpu6050.c ****     .who_am_i       = 0x75,
 480:Src/mpu6050.c ****     .rate_div       = 0x19,
 481:Src/mpu6050.c ****     .lpf            = 0x1A,
 482:Src/mpu6050.c ****     .prod_id        = 0x0C,
 483:Src/mpu6050.c ****     .user_ctrl      = 0x6A,
 484:Src/mpu6050.c ****     .fifo_en        = 0x23,
 485:Src/mpu6050.c ****     .gyro_cfg       = 0x1B,
 486:Src/mpu6050.c ****     .accel_cfg      = 0x1C,
 487:Src/mpu6050.c ****     .accel_cfg2     = 0x1D,
ARM GAS  /tmp/ccC60hwS.s 			page 10


 488:Src/mpu6050.c ****     .lp_accel_odr   = 0x1E,
 489:Src/mpu6050.c ****     .motion_thr     = 0x1F,
 490:Src/mpu6050.c ****     .motion_dur     = 0x20,
 491:Src/mpu6050.c ****     .fifo_count_h   = 0x72,
 492:Src/mpu6050.c ****     .fifo_r_w       = 0x74,
 493:Src/mpu6050.c ****     .raw_gyro       = 0x43,
 494:Src/mpu6050.c ****     .raw_accel      = 0x3B,
 495:Src/mpu6050.c ****     .temp           = 0x41,
 496:Src/mpu6050.c ****     .int_enable     = 0x38,
 497:Src/mpu6050.c ****     .dmp_int_status = 0x39,
 498:Src/mpu6050.c ****     .int_status     = 0x3A,
 499:Src/mpu6050.c ****     .accel_intel    = 0x69,
 500:Src/mpu6050.c ****     .pwr_mgmt_1     = 0x6B,
 501:Src/mpu6050.c ****     .pwr_mgmt_2     = 0x6C,
 502:Src/mpu6050.c ****     .int_pin_cfg    = 0x37,
 503:Src/mpu6050.c ****     .mem_r_w        = 0x6F,
 504:Src/mpu6050.c ****     .accel_offs     = 0x77,
 505:Src/mpu6050.c ****     .i2c_mst        = 0x24,
 506:Src/mpu6050.c ****     .bank_sel       = 0x6D,
 507:Src/mpu6050.c ****     .mem_start_addr = 0x6E,
 508:Src/mpu6050.c ****     .prgm_start_h   = 0x70
 509:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 510:Src/mpu6050.c ****     ,.raw_compass   = 0x49,
 511:Src/mpu6050.c ****     .s0_addr        = 0x25,
 512:Src/mpu6050.c ****     .s0_reg         = 0x26,
 513:Src/mpu6050.c ****     .s0_ctrl        = 0x27,
 514:Src/mpu6050.c ****     .s1_addr        = 0x28,
 515:Src/mpu6050.c ****     .s1_reg         = 0x29,
 516:Src/mpu6050.c ****     .s1_ctrl        = 0x2A,
 517:Src/mpu6050.c ****     .s4_ctrl        = 0x34,
 518:Src/mpu6050.c ****     .s0_do          = 0x63,
 519:Src/mpu6050.c ****     .s1_do          = 0x64,
 520:Src/mpu6050.c ****     .i2c_delay_ctrl = 0x67
 521:Src/mpu6050.c **** #endif
 522:Src/mpu6050.c **** };
 523:Src/mpu6050.c **** const struct hw_s hw = {
 524:Src/mpu6050.c ****     .addr           = 0x68,
 525:Src/mpu6050.c ****     .max_fifo       = 1024,
 526:Src/mpu6050.c ****     .num_reg        = 128,
 527:Src/mpu6050.c ****     .temp_sens      = 321,
 528:Src/mpu6050.c ****     .temp_offset    = 0,
 529:Src/mpu6050.c ****     .bank_size      = 256
 530:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 531:Src/mpu6050.c ****     ,.compass_fsr    = AK89xx_FSR
 532:Src/mpu6050.c **** #endif
 533:Src/mpu6050.c **** };
 534:Src/mpu6050.c **** 
 535:Src/mpu6050.c **** const struct test_s test = {
 536:Src/mpu6050.c ****     .gyro_sens      = 32768/250,
 537:Src/mpu6050.c ****     .accel_sens     = 32768/2,  	    // FSR = +-2G = 16384 LSB/G
 538:Src/mpu6050.c ****     .reg_rate_div   = 0,    			// 1kHz.
 539:Src/mpu6050.c ****     .reg_lpf        = 2,    			// 92Hz low pass filter
 540:Src/mpu6050.c ****     .reg_gyro_fsr   = 0,    			// 250dps.
 541:Src/mpu6050.c ****     .reg_accel_fsr  = 0x0,  			// Accel FSR setting = 2g.
 542:Src/mpu6050.c ****     .wait_ms        = 200,   			// 200ms stabilization time
 543:Src/mpu6050.c ****     .packet_thresh  = 200,    		    // 200 samples
 544:Src/mpu6050.c ****     .min_dps        = 20.f,  			// 20 dps for Gyro Criteria C
ARM GAS  /tmp/ccC60hwS.s 			page 11


 545:Src/mpu6050.c ****     .max_dps        = 60.f, 			// Must exceed 60 dps threshold for Gyro Criteria B
 546:Src/mpu6050.c ****     .max_gyro_var   = .5f, 				// Must exceed +50% variation for Gyro Criteria A
 547:Src/mpu6050.c ****     .min_g          = .225f, 			// Accel must exceed Min 225 mg for Criteria B
 548:Src/mpu6050.c ****     .max_g          = .675f, 			// Accel cannot exceed Max 675 mg for Criteria B
 549:Src/mpu6050.c ****     .max_accel_var  = .5f,  			// Accel must be within 50% variation for Criteria A
 550:Src/mpu6050.c ****     .max_g_offset   = .5f,   			// 500 mg for Accel Criteria C
 551:Src/mpu6050.c ****     .sample_wait_ms = 10    			// 10ms sample time wait
 552:Src/mpu6050.c **** };
 553:Src/mpu6050.c **** 
 554:Src/mpu6050.c **** static struct gyro_state_s st = {
 555:Src/mpu6050.c ****     .reg = &reg,
 556:Src/mpu6050.c ****     .hw = &hw,
 557:Src/mpu6050.c ****     .test = &test
 558:Src/mpu6050.c **** };
 559:Src/mpu6050.c **** #endif
 560:Src/mpu6050.c **** 
 561:Src/mpu6050.c **** #define MAX_PACKET_LENGTH (12)
 562:Src/mpu6050.c **** #ifdef MPU6500
 563:Src/mpu6050.c **** #define HWST_MAX_PACKET_LENGTH (512)
 564:Src/mpu6050.c **** #endif
 565:Src/mpu6050.c **** 
 566:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 567:Src/mpu6050.c **** static int setup_compass(void);
 568:Src/mpu6050.c **** #define MAX_COMPASS_SAMPLE_RATE (100)
 569:Src/mpu6050.c **** #endif
 570:Src/mpu6050.c **** 
 571:Src/mpu6050.c **** /**
 572:Src/mpu6050.c ****  *  @brief      Enable/disable data ready interrupt.
 573:Src/mpu6050.c ****  *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready interrupt is used.
 574:Src/mpu6050.c ****  *  @param[in]  enable      1 to enable interrupt.
 575:Src/mpu6050.c ****  *  @return     0 if successful.
 576:Src/mpu6050.c ****  */
 577:Src/mpu6050.c **** static int set_int_enable(unsigned char enable)
 578:Src/mpu6050.c **** {
 579:Src/mpu6050.c ****     unsigned char tmp;
 580:Src/mpu6050.c **** 
 581:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
 582:Src/mpu6050.c ****         if (enable)
 583:Src/mpu6050.c ****             tmp = BIT_DMP_INT_EN;
 584:Src/mpu6050.c ****         else
 585:Src/mpu6050.c ****             tmp = 0x00;
 586:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 587:Src/mpu6050.c ****             return -1;
 588:Src/mpu6050.c ****         st.chip_cfg.int_enable = tmp;
 589:Src/mpu6050.c ****     } else {
 590:Src/mpu6050.c ****         if (!st.chip_cfg.sensors)
 591:Src/mpu6050.c ****             return -1;
 592:Src/mpu6050.c ****         if (enable && st.chip_cfg.int_enable)
 593:Src/mpu6050.c ****             return 0;
 594:Src/mpu6050.c ****         if (enable)
 595:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 596:Src/mpu6050.c ****         else
 597:Src/mpu6050.c ****             tmp = 0x00;
 598:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 599:Src/mpu6050.c ****             return -1;
 600:Src/mpu6050.c ****         st.chip_cfg.int_enable = tmp;
 601:Src/mpu6050.c ****     }
ARM GAS  /tmp/ccC60hwS.s 			page 12


 602:Src/mpu6050.c ****     return 0;
 603:Src/mpu6050.c **** }
 604:Src/mpu6050.c **** 
 605:Src/mpu6050.c **** /**
 606:Src/mpu6050.c ****  *  @brief      Register dump for testing.
 607:Src/mpu6050.c ****  *  @return     0 if successful.
 608:Src/mpu6050.c ****  */
 609:Src/mpu6050.c **** int mpu_reg_dump(void)
 610:Src/mpu6050.c **** {
 611:Src/mpu6050.c ****     unsigned char ii;
 612:Src/mpu6050.c ****     unsigned char data;
 613:Src/mpu6050.c **** 
 614:Src/mpu6050.c ****     for (ii = 0; ii < st.hw->num_reg; ii++) {
 615:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 616:Src/mpu6050.c ****             continue;
 617:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, ii, 1, &data))
 618:Src/mpu6050.c ****             return -1;
 619:Src/mpu6050.c ****             #ifdef SERIAL_DEBUG
 620:Src/mpu6050.c ****                 log_i("%#5x: %#5x\r\n", ii, data);
 621:Src/mpu6050.c ****             #endif
 622:Src/mpu6050.c ****     }
 623:Src/mpu6050.c ****     return 0;
 624:Src/mpu6050.c **** }
 625:Src/mpu6050.c **** 
 626:Src/mpu6050.c **** /**
 627:Src/mpu6050.c ****  *  @brief      Read from a single register.
 628:Src/mpu6050.c ****  *  NOTE: The memory and FIFO read/write registers cannot be accessed.
 629:Src/mpu6050.c ****  *  @param[in]  reg     Register address.
 630:Src/mpu6050.c ****  *  @param[out] data    Register data.
 631:Src/mpu6050.c ****  *  @return     0 if successful.
 632:Src/mpu6050.c ****  */
 633:Src/mpu6050.c **** int mpu_read_reg(unsigned char reg, unsigned char *data)
 634:Src/mpu6050.c **** {
 635:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 636:Src/mpu6050.c ****         return -1;
 637:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 638:Src/mpu6050.c ****         return -1;
 639:Src/mpu6050.c ****     return i2c_read(st.hw->addr, reg, 1, data);
 640:Src/mpu6050.c **** }
 641:Src/mpu6050.c **** 
 642:Src/mpu6050.c **** /**
 643:Src/mpu6050.c ****  *  @brief      Initialize hardware.
 644:Src/mpu6050.c ****  *  Initial configuration:\n
 645:Src/mpu6050.c ****  *  Gyro FSR: +/- 2000DPS\n
 646:Src/mpu6050.c ****  *  Accel FSR +/- 2G\n
 647:Src/mpu6050.c ****  *  DLPF: 42Hz\n
 648:Src/mpu6050.c ****  *  FIFO rate: 50Hz\n
 649:Src/mpu6050.c ****  *  Clock source: Gyro PLL\n
 650:Src/mpu6050.c ****  *  FIFO: Disabled.\n
 651:Src/mpu6050.c ****  *  Data ready interrupt: Disabled, active low, unlatched.
 652:Src/mpu6050.c ****  *  @param[in]  int_param   Platform-specific parameters to interrupt API.
 653:Src/mpu6050.c ****  *  @return     0 if successful.
 654:Src/mpu6050.c ****  */
 655:Src/mpu6050.c **** int mpu_init(void)
 656:Src/mpu6050.c **** {
 657:Src/mpu6050.c ****     unsigned char data[6];
 658:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 13


 659:Src/mpu6050.c ****     /* Reset device. */
 660:Src/mpu6050.c ****     data[0] = BIT_RESET;
 661:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 662:Src/mpu6050.c ****         return -1;
 663:Src/mpu6050.c ****     delay_ms(100);
 664:Src/mpu6050.c **** 
 665:Src/mpu6050.c ****     /* Wake up chip. */
 666:Src/mpu6050.c ****     data[0] = 0x00;
 667:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 668:Src/mpu6050.c ****         return -1;
 669:Src/mpu6050.c **** 
 670:Src/mpu6050.c ****    st.chip_cfg.accel_half = 0;
 671:Src/mpu6050.c **** 
 672:Src/mpu6050.c **** #ifdef MPU6500
 673:Src/mpu6050.c ****     /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
 674:Src/mpu6050.c ****      * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
 675:Src/mpu6050.c ****      */
 676:Src/mpu6050.c ****     data[0] = BIT_FIFO_SIZE_1024 | 0x8;
 677:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
 678:Src/mpu6050.c ****         return -1;
 679:Src/mpu6050.c **** #endif
 680:Src/mpu6050.c **** 
 681:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
 682:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 683:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 684:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 685:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 686:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 687:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 688:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 689:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 690:Src/mpu6050.c ****     st.chip_cfg.compass_sample_rate = 0xFFFF;
 691:Src/mpu6050.c **** #endif
 692:Src/mpu6050.c ****     /* mpu_set_sensors always preserves this setting. */
 693:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 694:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 695:Src/mpu6050.c ****     st.chip_cfg.active_low_int = 1;
 696:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 697:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 698:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 699:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 700:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 701:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 702:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = 0;
 703:Src/mpu6050.c **** 
 704:Src/mpu6050.c ****     if (mpu_set_gyro_fsr(MPU_GYRO_FSR))
 705:Src/mpu6050.c ****         return -1;
 706:Src/mpu6050.c ****     if (mpu_set_accel_fsr(MPU_ACCEL_FSR))
 707:Src/mpu6050.c ****         return -1;
 708:Src/mpu6050.c ****     if (mpu_set_lpf(42))
 709:Src/mpu6050.c ****         return -1;
 710:Src/mpu6050.c ****     if (mpu_set_sample_rate(50))
 711:Src/mpu6050.c ****         return -1;
 712:Src/mpu6050.c ****     if (mpu_configure_fifo(0))
 713:Src/mpu6050.c ****         return -1;
 714:Src/mpu6050.c **** 
 715:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
ARM GAS  /tmp/ccC60hwS.s 			page 14


 716:Src/mpu6050.c ****     setup_compass();
 717:Src/mpu6050.c ****     if (mpu_set_compass_sample_rate(10))
 718:Src/mpu6050.c ****         return -1;
 719:Src/mpu6050.c **** #else
 720:Src/mpu6050.c ****     /* Already disabled by setup_compass. */
 721:Src/mpu6050.c ****     if (mpu_set_bypass(0))
 722:Src/mpu6050.c ****         return -1;
 723:Src/mpu6050.c **** #endif
 724:Src/mpu6050.c **** 
 725:Src/mpu6050.c ****     mpu_set_sensors(0);
 726:Src/mpu6050.c ****     return 0;
 727:Src/mpu6050.c **** }
 728:Src/mpu6050.c **** 
 729:Src/mpu6050.c **** /**
 730:Src/mpu6050.c ****  *  @brief      Enter low-power accel-only mode.
 731:Src/mpu6050.c ****  *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
 732:Src/mpu6050.c ****  *  the accelerometer at one of the following frequencies:
 733:Src/mpu6050.c ****  *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
 734:Src/mpu6050.c ****  *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
 735:Src/mpu6050.c ****  *  \n If the requested rate is not one listed above, the device will be set to
 736:Src/mpu6050.c ****  *  the next highest rate. Requesting a rate above the maximum supported
 737:Src/mpu6050.c ****  *  frequency will result in an error.
 738:Src/mpu6050.c ****  *  \n To select a fractional wake-up frequency, round down the value passed to
 739:Src/mpu6050.c ****  *  @e rate.
 740:Src/mpu6050.c ****  *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
 741:Src/mpu6050.c ****  *                          accel mode.
 742:Src/mpu6050.c ****  *  @return     0 if successful.
 743:Src/mpu6050.c ****  */
 744:Src/mpu6050.c **** int mpu_lp_accel_mode(unsigned short rate)
 745:Src/mpu6050.c **** {
 746:Src/mpu6050.c ****     unsigned char tmp[2];
 747:Src/mpu6050.c **** 
 748:Src/mpu6050.c ****     if (rate > 40)
 749:Src/mpu6050.c ****         return -1;
 750:Src/mpu6050.c **** 
 751:Src/mpu6050.c ****     if (!rate) {
 752:Src/mpu6050.c ****         mpu_set_int_latched(0);
 753:Src/mpu6050.c ****         tmp[0] = 0;
 754:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 755:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 756:Src/mpu6050.c ****             return -1;
 757:Src/mpu6050.c ****         st.chip_cfg.lp_accel_mode = 0;
 758:Src/mpu6050.c ****         return 0;
 759:Src/mpu6050.c ****     }
 760:Src/mpu6050.c ****     /* For LP accel, we automatically configure the hardware to produce latched
 761:Src/mpu6050.c ****      * interrupts. In LP accel mode, the hardware cycles into sleep mode before
 762:Src/mpu6050.c ****      * it gets a chance to deassert the interrupt pin; therefore, we shift this
 763:Src/mpu6050.c ****      * responsibility over to the MCU.
 764:Src/mpu6050.c ****      *
 765:Src/mpu6050.c ****      * Any register read will clear the interrupt.
 766:Src/mpu6050.c ****      */
 767:Src/mpu6050.c ****     mpu_set_int_latched(1);
 768:Src/mpu6050.c **** #if defined MPU6050
 769:Src/mpu6050.c ****     tmp[0] = BIT_LPA_CYCLE;
 770:Src/mpu6050.c ****     if (rate == 1) {
 771:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 772:Src/mpu6050.c ****         mpu_set_lpf(5);
ARM GAS  /tmp/ccC60hwS.s 			page 15


 773:Src/mpu6050.c ****     } else if (rate <= 5) {
 774:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 775:Src/mpu6050.c ****         mpu_set_lpf(5);
 776:Src/mpu6050.c ****     } else if (rate <= 20) {
 777:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 778:Src/mpu6050.c ****         mpu_set_lpf(10);
 779:Src/mpu6050.c ****     } else {
 780:Src/mpu6050.c ****         tmp[1] = INV_LPA_40HZ;
 781:Src/mpu6050.c ****         mpu_set_lpf(20);
 782:Src/mpu6050.c ****     }
 783:Src/mpu6050.c ****     tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
 784:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 785:Src/mpu6050.c ****         return -1;
 786:Src/mpu6050.c **** #elif defined MPU6500
 787:Src/mpu6050.c ****     /* Set wake frequency. */
 788:Src/mpu6050.c ****     if (rate == 1)
 789:Src/mpu6050.c ****         tmp[0] = INV_LPA_1_25HZ;
 790:Src/mpu6050.c ****     else if (rate == 2)
 791:Src/mpu6050.c ****         tmp[0] = INV_LPA_2_5HZ;
 792:Src/mpu6050.c ****     else if (rate <= 5)
 793:Src/mpu6050.c ****         tmp[0] = INV_LPA_5HZ;
 794:Src/mpu6050.c ****     else if (rate <= 10)
 795:Src/mpu6050.c ****         tmp[0] = INV_LPA_10HZ;
 796:Src/mpu6050.c ****     else if (rate <= 20)
 797:Src/mpu6050.c ****         tmp[0] = INV_LPA_20HZ;
 798:Src/mpu6050.c ****     else if (rate <= 40)
 799:Src/mpu6050.c ****         tmp[0] = INV_LPA_40HZ;
 800:Src/mpu6050.c ****     else if (rate <= 80)
 801:Src/mpu6050.c ****         tmp[0] = INV_LPA_80HZ;
 802:Src/mpu6050.c ****     else if (rate <= 160)
 803:Src/mpu6050.c ****         tmp[0] = INV_LPA_160HZ;
 804:Src/mpu6050.c ****     else if (rate <= 320)
 805:Src/mpu6050.c ****         tmp[0] = INV_LPA_320HZ;
 806:Src/mpu6050.c ****     else
 807:Src/mpu6050.c ****         tmp[0] = INV_LPA_640HZ;
 808:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
 809:Src/mpu6050.c ****         return -1;
 810:Src/mpu6050.c ****     tmp[0] = BIT_LPA_CYCLE;
 811:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
 812:Src/mpu6050.c ****         return -1;
 813:Src/mpu6050.c **** #endif
 814:Src/mpu6050.c ****     st.chip_cfg.sensors = INV_XYZ_ACCEL;
 815:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 816:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 817:Src/mpu6050.c ****     mpu_configure_fifo(0);
 818:Src/mpu6050.c **** 
 819:Src/mpu6050.c ****     return 0;
 820:Src/mpu6050.c **** }
 821:Src/mpu6050.c **** 
 822:Src/mpu6050.c **** /**
 823:Src/mpu6050.c ****  *  @brief      Read raw gyro data directly from the registers.
 824:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
 825:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 826:Src/mpu6050.c ****  *  @return     0 if successful.
 827:Src/mpu6050.c ****  */
 828:Src/mpu6050.c **** int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
 829:Src/mpu6050.c **** {
ARM GAS  /tmp/ccC60hwS.s 			page 16


 830:Src/mpu6050.c ****     unsigned char tmp[6];
 831:Src/mpu6050.c **** 
 832:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
 833:Src/mpu6050.c ****         return -1;
 834:Src/mpu6050.c **** 
 835:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
 836:Src/mpu6050.c ****         return -1;
 837:Src/mpu6050.c ****     data[0] = (tmp[0] << 8) | tmp[1];
 838:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 839:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 840:Src/mpu6050.c ****     if (timestamp)
 841:Src/mpu6050.c ****         get_ms(timestamp);
 842:Src/mpu6050.c ****     return 0;
 843:Src/mpu6050.c **** }
 844:Src/mpu6050.c **** 
 845:Src/mpu6050.c **** /**
 846:Src/mpu6050.c ****  *  @brief      Read raw accel data directly from the registers.
 847:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
 848:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 849:Src/mpu6050.c ****  *  @return     0 if successful.
 850:Src/mpu6050.c ****  */
 851:Src/mpu6050.c **** int mpu_get_accel_reg(short *data, unsigned long *timestamp)
 852:Src/mpu6050.c **** {
 853:Src/mpu6050.c ****     unsigned char tmp[6];
 854:Src/mpu6050.c **** 
 855:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
 856:Src/mpu6050.c ****         return -1;
 857:Src/mpu6050.c **** 
 858:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
 859:Src/mpu6050.c ****         return -1;
 860:Src/mpu6050.c ****     data[0] = (tmp[0] << 8) | tmp[1];
 861:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 862:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 863:Src/mpu6050.c ****     if (timestamp)
 864:Src/mpu6050.c ****         get_ms(timestamp);
 865:Src/mpu6050.c ****     return 0;
 866:Src/mpu6050.c **** }
 867:Src/mpu6050.c **** 
 868:Src/mpu6050.c **** /**
 869:Src/mpu6050.c ****  *  @brief      Read temperature data directly from the registers.
 870:Src/mpu6050.c ****  *  @param[out] data        Data in q16 format.
 871:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 872:Src/mpu6050.c ****  *  @return     0 if successful.
 873:Src/mpu6050.c ****  */
 874:Src/mpu6050.c **** int mpu_get_temperature(long *data, unsigned long *timestamp)
 875:Src/mpu6050.c **** {
 876:Src/mpu6050.c ****     unsigned char tmp[2];
 877:Src/mpu6050.c ****     short raw;
 878:Src/mpu6050.c **** 
 879:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
 880:Src/mpu6050.c ****         return -1;
 881:Src/mpu6050.c **** 
 882:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
 883:Src/mpu6050.c ****         return -1;
 884:Src/mpu6050.c ****     raw = (tmp[0] << 8) | tmp[1];
 885:Src/mpu6050.c ****     if (timestamp)
 886:Src/mpu6050.c ****         get_ms(timestamp);
ARM GAS  /tmp/ccC60hwS.s 			page 17


 887:Src/mpu6050.c **** 
 888:Src/mpu6050.c ****     data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
 889:Src/mpu6050.c ****     return 0;
 890:Src/mpu6050.c **** }
 891:Src/mpu6050.c **** 
 892:Src/mpu6050.c **** /**
 893:Src/mpu6050.c ****  *  @brief      Read biases to the accel bias 6500 registers.
 894:Src/mpu6050.c ****  *  This function reads from the MPU6500 accel offset cancellations registers.
 895:Src/mpu6050.c ****  *  The format are G in +-8G format. The register is initialized with OTP 
 896:Src/mpu6050.c ****  *  factory trim values.
 897:Src/mpu6050.c ****  *  @param[in]  accel_bias  returned structure with the accel bias
 898:Src/mpu6050.c ****  *  @return     0 if successful.
 899:Src/mpu6050.c ****  */
 900:Src/mpu6050.c **** int mpu_read_6500_accel_bias(long *accel_bias) {
 901:Src/mpu6050.c ****     unsigned char data[6];
 902:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
 903:Src/mpu6050.c ****         return -1;
 904:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
 905:Src/mpu6050.c ****         return -1;
 906:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7D, 2, &data[4]))
 907:Src/mpu6050.c ****         return -1;
 908:Src/mpu6050.c ****     accel_bias[0] = ((long)data[0]<<8) | data[1];
 909:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 910:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 911:Src/mpu6050.c ****     return 0;
 912:Src/mpu6050.c **** }
 913:Src/mpu6050.c **** 
 914:Src/mpu6050.c **** /**
 915:Src/mpu6050.c ****  *  @brief      Read biases to the accel bias 6050 registers.
 916:Src/mpu6050.c ****  *  This function reads from the MPU6050 accel offset cancellations registers.
 917:Src/mpu6050.c ****  *  The format are G in +-8G format. The register is initialized with OTP 
 918:Src/mpu6050.c ****  *  factory trim values.
 919:Src/mpu6050.c ****  *  @param[in]  accel_bias  returned structure with the accel bias
 920:Src/mpu6050.c ****  *  @return     0 if successful.
 921:Src/mpu6050.c ****  */
 922:Src/mpu6050.c **** int mpu_read_6050_accel_bias(long *accel_bias) {
 923:Src/mpu6050.c ****     unsigned char data[6];
 924:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
 925:Src/mpu6050.c ****         return -1;
 926:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
 927:Src/mpu6050.c ****         return -1;
 928:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0A, 2, &data[4]))
 929:Src/mpu6050.c ****         return -1;
 930:Src/mpu6050.c ****     accel_bias[0] = ((long)data[0]<<8) | data[1];
 931:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 932:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 933:Src/mpu6050.c ****     return 0;
 934:Src/mpu6050.c **** }
 935:Src/mpu6050.c **** 
 936:Src/mpu6050.c **** int mpu_read_6500_gyro_bias(long *gyro_bias) {
 937:Src/mpu6050.c ****     unsigned char data[6];
 938:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
 939:Src/mpu6050.c ****         return -1;
 940:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
 941:Src/mpu6050.c ****         return -1;
 942:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x17, 2, &data[4]))
 943:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 18


 944:Src/mpu6050.c ****     gyro_bias[0] = ((long)data[0]<<8) | data[1];
 945:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 946:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 947:Src/mpu6050.c ****     return 0;
 948:Src/mpu6050.c **** }
 949:Src/mpu6050.c **** 
 950:Src/mpu6050.c **** /**
 951:Src/mpu6050.c ****  *  @brief      Push biases to the gyro bias 6500/6050 registers.
 952:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
 953:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
 954:Src/mpu6050.c ****  *  in +-1000dps format.
 955:Src/mpu6050.c ****  *  @param[in]  gyro_bias  New biases.
 956:Src/mpu6050.c ****  *  @return     0 if successful.
 957:Src/mpu6050.c ****  */
 958:Src/mpu6050.c **** int mpu_set_gyro_bias_reg(long *gyro_bias)
 959:Src/mpu6050.c **** {
 960:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 961:Src/mpu6050.c ****     int i=0;
 962:Src/mpu6050.c ****     for(i=0;i<3;i++) {
 963:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 964:Src/mpu6050.c ****     }
 965:Src/mpu6050.c ****     data[0] = (gyro_bias[0] >> 8) & 0xff;
 966:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 967:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 968:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 969:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 970:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 971:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 972:Src/mpu6050.c ****         return -1;
 973:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
 974:Src/mpu6050.c ****         return -1;
 975:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x17, 2, &data[4]))
 976:Src/mpu6050.c ****         return -1;
 977:Src/mpu6050.c ****     return 0;
 978:Src/mpu6050.c **** }
 979:Src/mpu6050.c **** 
 980:Src/mpu6050.c **** /**
 981:Src/mpu6050.c ****  *  @brief      Push biases to the accel bias 6050 registers.
 982:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
 983:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
 984:Src/mpu6050.c ****  *  in +-16G format.
 985:Src/mpu6050.c ****  *  @param[in]  accel_bias  New biases.
 986:Src/mpu6050.c ****  *  @return     0 if successful.
 987:Src/mpu6050.c ****  */
 988:Src/mpu6050.c **** int mpu_set_accel_bias_6050_reg(const long *accel_bias) {
 989:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 990:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 991:Src/mpu6050.c **** 
 992:Src/mpu6050.c ****     if(mpu_read_6050_accel_bias(accel_reg_bias))
 993:Src/mpu6050.c ****         return -1;
 994:Src/mpu6050.c **** 
 995:Src/mpu6050.c ****     accel_reg_bias[0] -= (accel_bias[0] & ~1);
 996:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 997:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 998:Src/mpu6050.c **** 
 999:Src/mpu6050.c ****     data[0] = (accel_reg_bias[0] >> 8) & 0xff;
1000:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
ARM GAS  /tmp/ccC60hwS.s 			page 19


1001:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
1002:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
1003:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
1004:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
1005:Src/mpu6050.c **** 
1006:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x06, 2, &data[0]))
1007:Src/mpu6050.c ****         return -1;
1008:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x08, 2, &data[2]))
1009:Src/mpu6050.c ****         return -1;
1010:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x0A, 2, &data[4]))
1011:Src/mpu6050.c ****         return -1;
1012:Src/mpu6050.c **** 
1013:Src/mpu6050.c ****     return 0;
1014:Src/mpu6050.c **** }
1015:Src/mpu6050.c **** 
1016:Src/mpu6050.c **** 
1017:Src/mpu6050.c **** 
1018:Src/mpu6050.c **** /**
1019:Src/mpu6050.c ****  *  @brief      Push biases to the accel bias 6500 registers.
1020:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
1021:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
1022:Src/mpu6050.c ****  *  in +-16G format.
1023:Src/mpu6050.c ****  *  @param[in]  accel_bias  New biases.
1024:Src/mpu6050.c ****  *  @return     0 if successful.
1025:Src/mpu6050.c ****  */
1026:Src/mpu6050.c **** int mpu_set_accel_bias_6500_reg(const long *accel_bias) {
1027:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
1028:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
1029:Src/mpu6050.c **** 
1030:Src/mpu6050.c ****     if(mpu_read_6500_accel_bias(accel_reg_bias))
1031:Src/mpu6050.c ****         return -1;
1032:Src/mpu6050.c **** 
1033:Src/mpu6050.c ****     // Preserve bit 0 of factory value (for temperature compensation)
1034:Src/mpu6050.c ****     accel_reg_bias[0] -= (accel_bias[0] & ~1);
1035:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
1036:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
1037:Src/mpu6050.c **** 
1038:Src/mpu6050.c ****     data[0] = (accel_reg_bias[0] >> 8) & 0xff;
1039:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
1040:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
1041:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
1042:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
1043:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
1044:Src/mpu6050.c **** 
1045:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x77, 2, &data[0]))
1046:Src/mpu6050.c ****         return -1;
1047:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x7A, 2, &data[2]))
1048:Src/mpu6050.c ****         return -1;
1049:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x7D, 2, &data[4]))
1050:Src/mpu6050.c ****         return -1;
1051:Src/mpu6050.c **** 
1052:Src/mpu6050.c ****     return 0;
1053:Src/mpu6050.c **** }
1054:Src/mpu6050.c **** 
1055:Src/mpu6050.c **** 
1056:Src/mpu6050.c **** /**
1057:Src/mpu6050.c ****  *  @brief  Reset FIFO read/write pointers.
ARM GAS  /tmp/ccC60hwS.s 			page 20


1058:Src/mpu6050.c ****  *  @return 0 if successful.
1059:Src/mpu6050.c ****  */
1060:Src/mpu6050.c **** int mpu_reset_fifo(void)
1061:Src/mpu6050.c **** {
1062:Src/mpu6050.c ****     unsigned char data;
1063:Src/mpu6050.c **** 
1064:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1065:Src/mpu6050.c ****         return -1;
1066:Src/mpu6050.c **** 
1067:Src/mpu6050.c ****     data = 0;
1068:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1069:Src/mpu6050.c ****         return -1;
1070:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
1071:Src/mpu6050.c ****         return -1;
1072:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1073:Src/mpu6050.c ****         return -1;
1074:Src/mpu6050.c **** 
1075:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
1076:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
1077:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1078:Src/mpu6050.c ****             return -1;
1079:Src/mpu6050.c ****         delay_ms(50);
1080:Src/mpu6050.c ****         data = BIT_DMP_EN | BIT_FIFO_EN;
1081:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1082:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
1083:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1084:Src/mpu6050.c ****             return -1;
1085:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
1086:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
1087:Src/mpu6050.c ****         else
1088:Src/mpu6050.c ****             data = 0;
1089:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1090:Src/mpu6050.c ****             return -1;
1091:Src/mpu6050.c ****         data = 0;
1092:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
1093:Src/mpu6050.c ****             return -1;
1094:Src/mpu6050.c ****     } else {
1095:Src/mpu6050.c ****         data = BIT_FIFO_RST;
1096:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1097:Src/mpu6050.c ****             return -1;
1098:Src/mpu6050.c ****         if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
1099:Src/mpu6050.c ****             data = BIT_FIFO_EN;
1100:Src/mpu6050.c ****         else
1101:Src/mpu6050.c ****             data = BIT_FIFO_EN | BIT_AUX_IF_EN;
1102:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1103:Src/mpu6050.c ****             return -1;
1104:Src/mpu6050.c ****         delay_ms(50);
1105:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
1106:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
1107:Src/mpu6050.c ****         else
1108:Src/mpu6050.c ****             data = 0;
1109:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1110:Src/mpu6050.c ****             return -1;
1111:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
1112:Src/mpu6050.c ****             return -1;
1113:Src/mpu6050.c ****     }
1114:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/ccC60hwS.s 			page 21


1115:Src/mpu6050.c **** }
1116:Src/mpu6050.c **** 
1117:Src/mpu6050.c **** /**
1118:Src/mpu6050.c ****  *  @brief      Get the gyro full-scale range.
1119:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
1120:Src/mpu6050.c ****  *  @return     0 if successful.
1121:Src/mpu6050.c ****  */
1122:Src/mpu6050.c **** int mpu_get_gyro_fsr(unsigned short *fsr)
1123:Src/mpu6050.c **** {
1124:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
1125:Src/mpu6050.c ****     case INV_FSR_250DPS:
1126:Src/mpu6050.c ****         fsr[0] = 250;
1127:Src/mpu6050.c ****         break;
1128:Src/mpu6050.c ****     case INV_FSR_500DPS:
1129:Src/mpu6050.c ****         fsr[0] = 500;
1130:Src/mpu6050.c ****         break;
1131:Src/mpu6050.c ****     case INV_FSR_1000DPS:
1132:Src/mpu6050.c ****         fsr[0] = 1000;
1133:Src/mpu6050.c ****         break;
1134:Src/mpu6050.c ****     case INV_FSR_2000DPS:
1135:Src/mpu6050.c ****         fsr[0] = 2000;
1136:Src/mpu6050.c ****         break;
1137:Src/mpu6050.c ****     default:
1138:Src/mpu6050.c ****         fsr[0] = 0;
1139:Src/mpu6050.c ****         break;
1140:Src/mpu6050.c ****     }
1141:Src/mpu6050.c ****     return 0;
1142:Src/mpu6050.c **** }
1143:Src/mpu6050.c **** 
1144:Src/mpu6050.c **** /**
1145:Src/mpu6050.c ****  *  @brief      Set the gyro full-scale range.
1146:Src/mpu6050.c ****  *  @param[in]  fsr Desired full-scale range.
1147:Src/mpu6050.c ****  *  @return     0 if successful.
1148:Src/mpu6050.c ****  */
1149:Src/mpu6050.c **** int mpu_set_gyro_fsr(unsigned short fsr)
1150:Src/mpu6050.c **** {
1151:Src/mpu6050.c ****     unsigned char data;
1152:Src/mpu6050.c **** 
1153:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1154:Src/mpu6050.c ****         return -1;
1155:Src/mpu6050.c **** 
1156:Src/mpu6050.c ****     switch (fsr) {
1157:Src/mpu6050.c ****     case 250:
1158:Src/mpu6050.c ****         data = INV_FSR_250DPS << 3;
1159:Src/mpu6050.c ****         break;
1160:Src/mpu6050.c ****     case 500:
1161:Src/mpu6050.c ****         data = INV_FSR_500DPS << 3;
1162:Src/mpu6050.c ****         break;
1163:Src/mpu6050.c ****     case 1000:
1164:Src/mpu6050.c ****         data = INV_FSR_1000DPS << 3;
1165:Src/mpu6050.c ****         break;
1166:Src/mpu6050.c ****     case 2000:
1167:Src/mpu6050.c ****         data = INV_FSR_2000DPS << 3;
1168:Src/mpu6050.c ****         break;
1169:Src/mpu6050.c ****     default:
1170:Src/mpu6050.c ****         return -1;
1171:Src/mpu6050.c ****     }
ARM GAS  /tmp/ccC60hwS.s 			page 22


1172:Src/mpu6050.c **** 
1173:Src/mpu6050.c ****     if (st.chip_cfg.gyro_fsr == (data >> 3))
1174:Src/mpu6050.c ****         return 0;
1175:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
1176:Src/mpu6050.c ****         return -1;
1177:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = data >> 3;
1178:Src/mpu6050.c ****     return 0;
1179:Src/mpu6050.c **** }
1180:Src/mpu6050.c **** 
1181:Src/mpu6050.c **** /**
1182:Src/mpu6050.c ****  *  @brief      Get the accel full-scale range.
1183:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
1184:Src/mpu6050.c ****  *  @return     0 if successful.
1185:Src/mpu6050.c ****  */
1186:Src/mpu6050.c **** int mpu_get_accel_fsr(unsigned char *fsr)
1187:Src/mpu6050.c **** {
1188:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
1189:Src/mpu6050.c ****     case INV_FSR_2G:
1190:Src/mpu6050.c ****         fsr[0] = 2;
1191:Src/mpu6050.c ****         break;
1192:Src/mpu6050.c ****     case INV_FSR_4G:
1193:Src/mpu6050.c ****         fsr[0] = 4;
1194:Src/mpu6050.c ****         break;
1195:Src/mpu6050.c ****     case INV_FSR_8G:
1196:Src/mpu6050.c ****         fsr[0] = 8;
1197:Src/mpu6050.c ****         break;
1198:Src/mpu6050.c ****     case INV_FSR_16G:
1199:Src/mpu6050.c ****         fsr[0] = 16;
1200:Src/mpu6050.c ****         break;
1201:Src/mpu6050.c ****     default:
1202:Src/mpu6050.c ****         return -1;
1203:Src/mpu6050.c ****     }
1204:Src/mpu6050.c ****     if (st.chip_cfg.accel_half)
1205:Src/mpu6050.c ****         fsr[0] <<= 1;
1206:Src/mpu6050.c ****     return 0;
1207:Src/mpu6050.c **** }
1208:Src/mpu6050.c **** 
1209:Src/mpu6050.c **** /**
1210:Src/mpu6050.c ****  *  @brief      Set the accel full-scale range.
1211:Src/mpu6050.c ****  *  @param[in]  fsr Desired full-scale range.
1212:Src/mpu6050.c ****  *  @return     0 if successful.
1213:Src/mpu6050.c ****  */
1214:Src/mpu6050.c **** int mpu_set_accel_fsr(unsigned char fsr)
1215:Src/mpu6050.c **** {
1216:Src/mpu6050.c ****     unsigned char data;
1217:Src/mpu6050.c **** 
1218:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1219:Src/mpu6050.c ****         return -1;
1220:Src/mpu6050.c **** 
1221:Src/mpu6050.c ****     switch (fsr) {
1222:Src/mpu6050.c ****     case 2:
1223:Src/mpu6050.c ****         data = INV_FSR_2G << 3;
1224:Src/mpu6050.c ****         break;
1225:Src/mpu6050.c ****     case 4:
1226:Src/mpu6050.c ****         data = INV_FSR_4G << 3;
1227:Src/mpu6050.c ****         break;
1228:Src/mpu6050.c ****     case 8:
ARM GAS  /tmp/ccC60hwS.s 			page 23


1229:Src/mpu6050.c ****         data = INV_FSR_8G << 3;
1230:Src/mpu6050.c ****         break;
1231:Src/mpu6050.c ****     case 16:
1232:Src/mpu6050.c ****         data = INV_FSR_16G << 3;
1233:Src/mpu6050.c ****         break;
1234:Src/mpu6050.c ****     default:
1235:Src/mpu6050.c ****         return -1;
1236:Src/mpu6050.c ****     }
1237:Src/mpu6050.c **** 
1238:Src/mpu6050.c ****     if (st.chip_cfg.accel_fsr == (data >> 3))
1239:Src/mpu6050.c ****         return 0;
1240:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
1241:Src/mpu6050.c ****         return -1;
1242:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = data >> 3;
1243:Src/mpu6050.c ****     return 0;
1244:Src/mpu6050.c **** }
1245:Src/mpu6050.c **** 
1246:Src/mpu6050.c **** /**
1247:Src/mpu6050.c ****  *  @brief      Get the current DLPF setting.
1248:Src/mpu6050.c ****  *  @param[out] lpf Current LPF setting.
1249:Src/mpu6050.c ****  *  0 if successful.
1250:Src/mpu6050.c ****  */
1251:Src/mpu6050.c **** int mpu_get_lpf(unsigned short *lpf)
1252:Src/mpu6050.c **** {
1253:Src/mpu6050.c ****     switch (st.chip_cfg.lpf) {
1254:Src/mpu6050.c ****     case INV_FILTER_188HZ:
1255:Src/mpu6050.c ****         lpf[0] = 188;
1256:Src/mpu6050.c ****         break;
1257:Src/mpu6050.c ****     case INV_FILTER_98HZ:
1258:Src/mpu6050.c ****         lpf[0] = 98;
1259:Src/mpu6050.c ****         break;
1260:Src/mpu6050.c ****     case INV_FILTER_42HZ:
1261:Src/mpu6050.c ****         lpf[0] = 42;
1262:Src/mpu6050.c ****         break;
1263:Src/mpu6050.c ****     case INV_FILTER_20HZ:
1264:Src/mpu6050.c ****         lpf[0] = 20;
1265:Src/mpu6050.c ****         break;
1266:Src/mpu6050.c ****     case INV_FILTER_10HZ:
1267:Src/mpu6050.c ****         lpf[0] = 10;
1268:Src/mpu6050.c ****         break;
1269:Src/mpu6050.c ****     case INV_FILTER_5HZ:
1270:Src/mpu6050.c ****         lpf[0] = 5;
1271:Src/mpu6050.c ****         break;
1272:Src/mpu6050.c ****     case INV_FILTER_256HZ_NOLPF2:
1273:Src/mpu6050.c ****     case INV_FILTER_2100HZ_NOLPF:
1274:Src/mpu6050.c ****     default:
1275:Src/mpu6050.c ****         lpf[0] = 0;
1276:Src/mpu6050.c ****         break;
1277:Src/mpu6050.c ****     }
1278:Src/mpu6050.c ****     return 0;
1279:Src/mpu6050.c **** }
1280:Src/mpu6050.c **** 
1281:Src/mpu6050.c **** /**
1282:Src/mpu6050.c ****  *  @brief      Set digital low pass filter.
1283:Src/mpu6050.c ****  *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
1284:Src/mpu6050.c ****  *  @param[in]  lpf Desired LPF setting.
1285:Src/mpu6050.c ****  *  @return     0 if successful.
ARM GAS  /tmp/ccC60hwS.s 			page 24


1286:Src/mpu6050.c ****  */
1287:Src/mpu6050.c **** int mpu_set_lpf(unsigned short lpf)
1288:Src/mpu6050.c **** {
1289:Src/mpu6050.c ****     unsigned char data;
1290:Src/mpu6050.c **** 
1291:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1292:Src/mpu6050.c ****         return -1;
1293:Src/mpu6050.c **** 
1294:Src/mpu6050.c ****     if (lpf >= 188)
1295:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
1296:Src/mpu6050.c ****     else if (lpf >= 98)
1297:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
1298:Src/mpu6050.c ****     else if (lpf >= 42)
1299:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
1300:Src/mpu6050.c ****     else if (lpf >= 20)
1301:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
1302:Src/mpu6050.c ****     else if (lpf >= 10)
1303:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
1304:Src/mpu6050.c ****     else
1305:Src/mpu6050.c ****         data = INV_FILTER_5HZ;
1306:Src/mpu6050.c **** 
1307:Src/mpu6050.c ****     if (st.chip_cfg.lpf == data)
1308:Src/mpu6050.c ****         return 0;
1309:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
1310:Src/mpu6050.c ****         return -1;
1311:Src/mpu6050.c ****     st.chip_cfg.lpf = data;
1312:Src/mpu6050.c ****     return 0;
1313:Src/mpu6050.c **** }
1314:Src/mpu6050.c **** 
1315:Src/mpu6050.c **** /**
1316:Src/mpu6050.c ****  *  @brief      Get sampling rate.
1317:Src/mpu6050.c ****  *  @param[out] rate    Current sampling rate (Hz).
1318:Src/mpu6050.c ****  *  @return     0 if successful.
1319:Src/mpu6050.c ****  */
1320:Src/mpu6050.c **** int mpu_get_sample_rate(unsigned short *rate)
1321:Src/mpu6050.c **** {
1322:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1323:Src/mpu6050.c ****         return -1;
1324:Src/mpu6050.c ****     else
1325:Src/mpu6050.c ****         rate[0] = st.chip_cfg.sample_rate;
1326:Src/mpu6050.c ****     return 0;
1327:Src/mpu6050.c **** }
1328:Src/mpu6050.c **** 
1329:Src/mpu6050.c **** /**
1330:Src/mpu6050.c ****  *  @brief      Set sampling rate.
1331:Src/mpu6050.c ****  *  Sampling rate must be between 4Hz and 1kHz.
1332:Src/mpu6050.c ****  *  @param[in]  rate    Desired sampling rate (Hz).
1333:Src/mpu6050.c ****  *  @return     0 if successful.
1334:Src/mpu6050.c ****  */
1335:Src/mpu6050.c **** int mpu_set_sample_rate(unsigned short rate)
1336:Src/mpu6050.c **** {
1337:Src/mpu6050.c ****     unsigned char data;
1338:Src/mpu6050.c **** 
1339:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1340:Src/mpu6050.c ****         return -1;
1341:Src/mpu6050.c **** 
1342:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
ARM GAS  /tmp/ccC60hwS.s 			page 25


1343:Src/mpu6050.c ****         return -1;
1344:Src/mpu6050.c ****     else {
1345:Src/mpu6050.c ****         if (st.chip_cfg.lp_accel_mode) {
1346:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
1347:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
1348:Src/mpu6050.c ****                 mpu_lp_accel_mode(rate);
1349:Src/mpu6050.c ****                 return 0;
1350:Src/mpu6050.c ****             }
1351:Src/mpu6050.c ****             /* Requested rate exceeds the allowed frequencies in LP accel mode,
1352:Src/mpu6050.c ****              * switch back to full-power mode.
1353:Src/mpu6050.c ****              */
1354:Src/mpu6050.c ****             mpu_lp_accel_mode(0);
1355:Src/mpu6050.c ****         }
1356:Src/mpu6050.c ****         if (rate < 4)
1357:Src/mpu6050.c ****             rate = 4;
1358:Src/mpu6050.c ****         else if (rate > 1000)
1359:Src/mpu6050.c ****             rate = 1000;
1360:Src/mpu6050.c **** 
1361:Src/mpu6050.c ****         data = 1000 / rate - 1;
1362:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
1363:Src/mpu6050.c ****             return -1;
1364:Src/mpu6050.c **** 
1365:Src/mpu6050.c ****         st.chip_cfg.sample_rate = 1000 / (1 + data);
1366:Src/mpu6050.c **** 
1367:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1368:Src/mpu6050.c ****         mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
1369:Src/mpu6050.c **** #endif
1370:Src/mpu6050.c **** 
1371:Src/mpu6050.c ****         /* Automatically set LPF to 1/2 sampling rate. */
1372:Src/mpu6050.c ****         mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
1373:Src/mpu6050.c ****         return 0;
1374:Src/mpu6050.c ****     }
1375:Src/mpu6050.c **** }
1376:Src/mpu6050.c **** 
1377:Src/mpu6050.c **** /**
1378:Src/mpu6050.c ****  *  @brief      Get compass sampling rate.
1379:Src/mpu6050.c ****  *  @param[out] rate    Current compass sampling rate (Hz).
1380:Src/mpu6050.c ****  *  @return     0 if successful.
1381:Src/mpu6050.c ****  */
1382:Src/mpu6050.c **** int mpu_get_compass_sample_rate(unsigned short *rate)
1383:Src/mpu6050.c **** {
1384:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1385:Src/mpu6050.c ****     rate[0] = st.chip_cfg.compass_sample_rate;
1386:Src/mpu6050.c ****     return 0;
1387:Src/mpu6050.c **** #else
1388:Src/mpu6050.c ****     rate[0] = 0;
1389:Src/mpu6050.c ****     return -1;
1390:Src/mpu6050.c **** #endif
1391:Src/mpu6050.c **** }
1392:Src/mpu6050.c **** 
1393:Src/mpu6050.c **** /**
1394:Src/mpu6050.c ****  *  @brief      Set compass sampling rate.
1395:Src/mpu6050.c ****  *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
1396:Src/mpu6050.c ****  *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
1397:Src/mpu6050.c ****  *  sampling rate.
1398:Src/mpu6050.c ****  *
1399:Src/mpu6050.c ****  *  \n WARNING: The new rate may be different than what was requested. Call
ARM GAS  /tmp/ccC60hwS.s 			page 26


1400:Src/mpu6050.c ****  *  mpu_get_compass_sample_rate to check the actual setting.
1401:Src/mpu6050.c ****  *  @param[in]  rate    Desired compass sampling rate (Hz).
1402:Src/mpu6050.c ****  *  @return     0 if successful.
1403:Src/mpu6050.c ****  */
1404:Src/mpu6050.c **** int mpu_set_compass_sample_rate(unsigned short rate)
1405:Src/mpu6050.c **** {
1406:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1407:Src/mpu6050.c ****     unsigned char div;
1408:Src/mpu6050.c ****     if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
1409:Src/mpu6050.c ****         return -1;
1410:Src/mpu6050.c **** 
1411:Src/mpu6050.c ****     div = st.chip_cfg.sample_rate / rate - 1;
1412:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
1413:Src/mpu6050.c ****         return -1;
1414:Src/mpu6050.c ****     st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
1415:Src/mpu6050.c ****     return 0;
1416:Src/mpu6050.c **** #else
1417:Src/mpu6050.c ****     return -1;
1418:Src/mpu6050.c **** #endif
1419:Src/mpu6050.c **** }
1420:Src/mpu6050.c **** 
1421:Src/mpu6050.c **** /**
1422:Src/mpu6050.c ****  *  @brief      Get gyro sensitivity scale factor.
1423:Src/mpu6050.c ****  *  @param[out] sens    Conversion from hardware units to dps.
1424:Src/mpu6050.c ****  *  @return     0 if successful.
1425:Src/mpu6050.c ****  */
1426:Src/mpu6050.c **** int mpu_get_gyro_sens(float *sens)
1427:Src/mpu6050.c **** {
1428:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
1429:Src/mpu6050.c ****     case INV_FSR_250DPS:
1430:Src/mpu6050.c ****         sens[0] = 131.f;
1431:Src/mpu6050.c ****         break;
1432:Src/mpu6050.c ****     case INV_FSR_500DPS:
1433:Src/mpu6050.c ****         sens[0] = 65.5f;
1434:Src/mpu6050.c ****         break;
1435:Src/mpu6050.c ****     case INV_FSR_1000DPS:
1436:Src/mpu6050.c ****         sens[0] = 32.8f;
1437:Src/mpu6050.c ****         break;
1438:Src/mpu6050.c ****     case INV_FSR_2000DPS:
1439:Src/mpu6050.c ****         sens[0] = 16.4f;
1440:Src/mpu6050.c ****         break;
1441:Src/mpu6050.c ****     default:
1442:Src/mpu6050.c ****         return -1;
1443:Src/mpu6050.c ****     }
1444:Src/mpu6050.c ****     return 0;
1445:Src/mpu6050.c **** }
1446:Src/mpu6050.c **** 
1447:Src/mpu6050.c **** /**
1448:Src/mpu6050.c ****  *  @brief      Get accel sensitivity scale factor.
1449:Src/mpu6050.c ****  *  @param[out] sens    Conversion from hardware units to g's.
1450:Src/mpu6050.c ****  *  @return     0 if successful.
1451:Src/mpu6050.c ****  */
1452:Src/mpu6050.c **** int mpu_get_accel_sens(unsigned short *sens)
1453:Src/mpu6050.c **** {
1454:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
1455:Src/mpu6050.c ****     case INV_FSR_2G:
1456:Src/mpu6050.c ****         sens[0] = 16384;
ARM GAS  /tmp/ccC60hwS.s 			page 27


1457:Src/mpu6050.c ****         break;
1458:Src/mpu6050.c ****     case INV_FSR_4G:
1459:Src/mpu6050.c ****         sens[0] = 8192;
1460:Src/mpu6050.c ****         break;
1461:Src/mpu6050.c ****     case INV_FSR_8G:
1462:Src/mpu6050.c ****         sens[0] = 4096;
1463:Src/mpu6050.c ****         break;
1464:Src/mpu6050.c ****     case INV_FSR_16G:
1465:Src/mpu6050.c ****         sens[0] = 2048;
1466:Src/mpu6050.c ****         break;
1467:Src/mpu6050.c ****     default:
1468:Src/mpu6050.c ****         return -1;
1469:Src/mpu6050.c ****     }
1470:Src/mpu6050.c ****     if (st.chip_cfg.accel_half)
1471:Src/mpu6050.c ****         sens[0] >>= 1;
1472:Src/mpu6050.c ****     return 0;
1473:Src/mpu6050.c **** }
1474:Src/mpu6050.c **** 
1475:Src/mpu6050.c **** /**
1476:Src/mpu6050.c ****  *  @brief      Get current FIFO configuration.
1477:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1478:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1479:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1480:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1481:Src/mpu6050.c ****  *  @param[out] sensors Mask of sensors in FIFO.
1482:Src/mpu6050.c ****  *  @return     0 if successful.
1483:Src/mpu6050.c ****  */
1484:Src/mpu6050.c **** int mpu_get_fifo_config(unsigned char *sensors)
1485:Src/mpu6050.c **** {
1486:Src/mpu6050.c ****     sensors[0] = st.chip_cfg.fifo_enable;
1487:Src/mpu6050.c ****     return 0;
1488:Src/mpu6050.c **** }
1489:Src/mpu6050.c **** 
1490:Src/mpu6050.c **** /**
1491:Src/mpu6050.c ****  *  @brief      Select which sensors are pushed to FIFO.
1492:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1493:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1494:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1495:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1496:Src/mpu6050.c ****  *  @param[in]  sensors Mask of sensors to push to FIFO.
1497:Src/mpu6050.c ****  *  @return     0 if successful.
1498:Src/mpu6050.c ****  */
1499:Src/mpu6050.c **** int mpu_configure_fifo(unsigned char sensors)
1500:Src/mpu6050.c **** {
1501:Src/mpu6050.c ****     unsigned char prev;
1502:Src/mpu6050.c ****     int result = 0;
1503:Src/mpu6050.c **** 
1504:Src/mpu6050.c ****     /* Compass data isn't going into the FIFO. Stop trying. */
1505:Src/mpu6050.c ****     sensors &= ~INV_XYZ_COMPASS;
1506:Src/mpu6050.c **** 
1507:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1508:Src/mpu6050.c ****         return 0;
1509:Src/mpu6050.c ****     else {
1510:Src/mpu6050.c ****         if (!(st.chip_cfg.sensors))
1511:Src/mpu6050.c ****             return -1;
1512:Src/mpu6050.c ****         prev = st.chip_cfg.fifo_enable;
1513:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
ARM GAS  /tmp/ccC60hwS.s 			page 28


1514:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
1515:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
1516:Src/mpu6050.c ****              * asleep.
1517:Src/mpu6050.c ****              */
1518:Src/mpu6050.c ****             result = -1;
1519:Src/mpu6050.c ****         else
1520:Src/mpu6050.c ****             result = 0;
1521:Src/mpu6050.c ****         if (sensors || st.chip_cfg.lp_accel_mode)
1522:Src/mpu6050.c ****             set_int_enable(1);
1523:Src/mpu6050.c ****         else
1524:Src/mpu6050.c ****             set_int_enable(0);
1525:Src/mpu6050.c ****         if (sensors) {
1526:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
1527:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
1528:Src/mpu6050.c ****                 return -1;
1529:Src/mpu6050.c ****             }
1530:Src/mpu6050.c ****         }
1531:Src/mpu6050.c ****     }
1532:Src/mpu6050.c **** 
1533:Src/mpu6050.c ****     return result;
1534:Src/mpu6050.c **** }
1535:Src/mpu6050.c **** 
1536:Src/mpu6050.c **** /**
1537:Src/mpu6050.c ****  *  @brief      Get current power state.
1538:Src/mpu6050.c ****  *  @param[in]  power_on    1 if turned on, 0 if suspended.
1539:Src/mpu6050.c ****  *  @return     0 if successful.
1540:Src/mpu6050.c ****  */
1541:Src/mpu6050.c **** int mpu_get_power_state(unsigned char *power_on)
1542:Src/mpu6050.c **** {
1543:Src/mpu6050.c ****     if (st.chip_cfg.sensors)
1544:Src/mpu6050.c ****         power_on[0] = 1;
1545:Src/mpu6050.c ****     else
1546:Src/mpu6050.c ****         power_on[0] = 0;
1547:Src/mpu6050.c ****     return 0;
1548:Src/mpu6050.c **** }
1549:Src/mpu6050.c **** 
1550:Src/mpu6050.c **** /**
1551:Src/mpu6050.c ****  *  @brief      Turn specific sensors on/off.
1552:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1553:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1554:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1555:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1556:Src/mpu6050.c ****  *  \n INV_XYZ_COMPASS
1557:Src/mpu6050.c ****  *  @param[in]  sensors    Mask of sensors to wake.
1558:Src/mpu6050.c ****  *  @return     0 if successful.
1559:Src/mpu6050.c ****  */
1560:Src/mpu6050.c **** int mpu_set_sensors(unsigned char sensors)
1561:Src/mpu6050.c **** {
1562:Src/mpu6050.c ****     unsigned char data;
1563:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1564:Src/mpu6050.c ****     unsigned char user_ctrl;
1565:Src/mpu6050.c **** #endif
1566:Src/mpu6050.c **** 
1567:Src/mpu6050.c ****     if (sensors & INV_XYZ_GYRO)
1568:Src/mpu6050.c ****         data = INV_CLK_PLL;
1569:Src/mpu6050.c ****     else if (sensors)
1570:Src/mpu6050.c ****         data = 0;
ARM GAS  /tmp/ccC60hwS.s 			page 29


1571:Src/mpu6050.c ****     else
1572:Src/mpu6050.c ****         data = BIT_SLEEP;
1573:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
1574:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
1575:Src/mpu6050.c ****         return -1;
1576:Src/mpu6050.c ****     }
1577:Src/mpu6050.c ****     st.chip_cfg.clk_src = data & ~BIT_SLEEP;
1578:Src/mpu6050.c **** 
1579:Src/mpu6050.c ****     data = 0;
1580:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
1581:Src/mpu6050.c ****         data |= BIT_STBY_XG;
1582:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
1583:Src/mpu6050.c ****         data |= BIT_STBY_YG;
1584:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
1585:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
1586:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
1587:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
1588:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
1589:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
1590:Src/mpu6050.c ****         return -1;
1591:Src/mpu6050.c ****     }
1592:Src/mpu6050.c **** 
1593:Src/mpu6050.c ****     if (sensors && (sensors != INV_XYZ_ACCEL))
1594:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
1595:Src/mpu6050.c ****         mpu_set_int_latched(0);
1596:Src/mpu6050.c **** 
1597:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1598:Src/mpu6050.c **** #ifdef AK89xx_BYPASS
1599:Src/mpu6050.c ****     if (sensors & INV_XYZ_COMPASS)
1600:Src/mpu6050.c ****         mpu_set_bypass(1);
1601:Src/mpu6050.c ****     else
1602:Src/mpu6050.c ****         mpu_set_bypass(0);
1603:Src/mpu6050.c **** #else
1604:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
1605:Src/mpu6050.c ****         return -1;
1606:Src/mpu6050.c ****     /* Handle AKM power management. */
1607:Src/mpu6050.c ****     if (sensors & INV_XYZ_COMPASS) {
1608:Src/mpu6050.c ****         data = AKM_SINGLE_MEASUREMENT;
1609:Src/mpu6050.c ****         user_ctrl |= BIT_AUX_IF_EN;
1610:Src/mpu6050.c ****     } else {
1611:Src/mpu6050.c ****         data = AKM_POWER_DOWN;
1612:Src/mpu6050.c ****         user_ctrl &= ~BIT_AUX_IF_EN;
1613:Src/mpu6050.c ****     }
1614:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1615:Src/mpu6050.c ****         user_ctrl |= BIT_DMP_EN;
1616:Src/mpu6050.c ****     else
1617:Src/mpu6050.c ****         user_ctrl &= ~BIT_DMP_EN;
1618:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
1619:Src/mpu6050.c ****         return -1;
1620:Src/mpu6050.c ****     /* Enable/disable I2C master mode. */
1621:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
1622:Src/mpu6050.c ****         return -1;
1623:Src/mpu6050.c **** #endif
1624:Src/mpu6050.c **** #endif
1625:Src/mpu6050.c **** 
1626:Src/mpu6050.c ****     st.chip_cfg.sensors = sensors;
1627:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
ARM GAS  /tmp/ccC60hwS.s 			page 30


1628:Src/mpu6050.c ****     delay_ms(50);
1629:Src/mpu6050.c ****     return 0;
1630:Src/mpu6050.c **** }
1631:Src/mpu6050.c **** 
1632:Src/mpu6050.c **** /**
1633:Src/mpu6050.c ****  *  @brief      Read the MPU interrupt status registers.
1634:Src/mpu6050.c ****  *  @param[out] status  Mask of interrupt bits.
1635:Src/mpu6050.c ****  *  @return     0 if successful.
1636:Src/mpu6050.c ****  */
1637:Src/mpu6050.c **** int mpu_get_int_status(short *status)
1638:Src/mpu6050.c **** {
1639:Src/mpu6050.c ****     unsigned char tmp[2];
1640:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1641:Src/mpu6050.c ****         return -1;
1642:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
1643:Src/mpu6050.c ****         return -1;
1644:Src/mpu6050.c ****     status[0] = (tmp[0] << 8) | tmp[1];
1645:Src/mpu6050.c ****     return 0;
1646:Src/mpu6050.c **** }
1647:Src/mpu6050.c **** 
1648:Src/mpu6050.c **** /**
1649:Src/mpu6050.c ****  *  @brief      Get one packet from the FIFO.
1650:Src/mpu6050.c ****  *  If @e sensors does not contain a particular sensor, disregard the data
1651:Src/mpu6050.c ****  *  returned to that pointer.
1652:Src/mpu6050.c ****  *  \n @e sensors can contain a combination of the following flags:
1653:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1654:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1655:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1656:Src/mpu6050.c ****  *  \n If the FIFO has no new data, @e sensors will be zero.
1657:Src/mpu6050.c ****  *  \n If the FIFO is disabled, @e sensors will be zero and this function will
1658:Src/mpu6050.c ****  *  return a non-zero error code.
1659:Src/mpu6050.c ****  *  @param[out] gyro        Gyro data in hardware units.
1660:Src/mpu6050.c ****  *  @param[out] accel       Accel data in hardware units.
1661:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds.
1662:Src/mpu6050.c ****  *  @param[out] sensors     Mask of sensors read from FIFO.
1663:Src/mpu6050.c ****  *  @param[out] more        Number of remaining packets.
1664:Src/mpu6050.c ****  *  @return     0 if successful.
1665:Src/mpu6050.c ****  */
1666:Src/mpu6050.c **** int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
1667:Src/mpu6050.c ****         unsigned char *sensors, unsigned char *more)
1668:Src/mpu6050.c **** {
1669:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
1670:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
1671:Src/mpu6050.c ****     unsigned char packet_size = 0;
1672:Src/mpu6050.c ****     unsigned short fifo_count, index = 0;
1673:Src/mpu6050.c **** 
1674:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1675:Src/mpu6050.c ****         return -1;
1676:Src/mpu6050.c **** 
1677:Src/mpu6050.c ****     sensors[0] = 0;
1678:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1679:Src/mpu6050.c ****         return -1;
1680:Src/mpu6050.c ****     if (!st.chip_cfg.fifo_enable)
1681:Src/mpu6050.c ****         return -1;
1682:Src/mpu6050.c **** 
1683:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_X_GYRO)
1684:Src/mpu6050.c ****         packet_size += 2;
ARM GAS  /tmp/ccC60hwS.s 			page 31


1685:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
1686:Src/mpu6050.c ****         packet_size += 2;
1687:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
1688:Src/mpu6050.c ****         packet_size += 2;
1689:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
1690:Src/mpu6050.c ****         packet_size += 6;
1691:Src/mpu6050.c **** 
1692:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
1693:Src/mpu6050.c ****         return -1;
1694:Src/mpu6050.c ****     fifo_count = (data[0] << 8) | data[1];
1695:Src/mpu6050.c ****     if (fifo_count < packet_size)
1696:Src/mpu6050.c ****         return 0;
1697:Src/mpu6050.c ****         // #ifdef SERIAL_DEBUG
1698:Src/mpu6050.c ****         // log_i("FIFO count: %hd\r\n", fifo_count);
1699:Src/mpu6050.c ****         // #endif
1700:Src/mpu6050.c ****     if (fifo_count > (st.hw->max_fifo >> 1)) {
1701:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
1702:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
1703:Src/mpu6050.c ****             return -1;
1704:Src/mpu6050.c ****         if (data[0] & BIT_FIFO_OVERFLOW) {
1705:Src/mpu6050.c ****             mpu_reset_fifo();
1706:Src/mpu6050.c ****             return -2;
1707:Src/mpu6050.c ****         }
1708:Src/mpu6050.c ****     }
1709:Src/mpu6050.c ****     get_ms((unsigned long*)timestamp);
1710:Src/mpu6050.c **** 
1711:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
1712:Src/mpu6050.c ****         return -1;
1713:Src/mpu6050.c ****     more[0] = fifo_count / packet_size - 1;
1714:Src/mpu6050.c ****     sensors[0] = 0;
1715:Src/mpu6050.c **** 
1716:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
1717:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
1718:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
1719:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
1720:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
1721:Src/mpu6050.c ****         index += 6;
1722:Src/mpu6050.c ****     }
1723:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
1724:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
1725:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
1726:Src/mpu6050.c ****         index += 2;
1727:Src/mpu6050.c ****     }
1728:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
1729:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
1730:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
1731:Src/mpu6050.c ****         index += 2;
1732:Src/mpu6050.c ****     }
1733:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
1734:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
1735:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
1736:Src/mpu6050.c ****         index += 2;
1737:Src/mpu6050.c ****     }
1738:Src/mpu6050.c **** 
1739:Src/mpu6050.c ****     return 0;
1740:Src/mpu6050.c **** }
1741:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 32


1742:Src/mpu6050.c **** /**
1743:Src/mpu6050.c ****  *  @brief      Get one unparsed packet from the FIFO.
1744:Src/mpu6050.c ****  *  This function should be used if the packet is to be parsed elsewhere.
1745:Src/mpu6050.c ****  *  @param[in]  length  Length of one FIFO packet.
1746:Src/mpu6050.c ****  *  @param[in]  data    FIFO packet.
1747:Src/mpu6050.c ****  *  @param[in]  more    Number of remaining packets.
1748:Src/mpu6050.c ****  */
1749:Src/mpu6050.c **** int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
1750:Src/mpu6050.c ****     unsigned char *more)
1751:Src/mpu6050.c **** {
1752:Src/mpu6050.c ****     unsigned char tmp[2];
1753:Src/mpu6050.c ****     unsigned short fifo_count;
1754:Src/mpu6050.c ****     if (!st.chip_cfg.dmp_on)
1755:Src/mpu6050.c ****         return -1;
1756:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1757:Src/mpu6050.c ****         return -1;
1758:Src/mpu6050.c **** 
1759:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
1760:Src/mpu6050.c ****         return -1;
1761:Src/mpu6050.c ****     fifo_count = (tmp[0] << 8) | tmp[1];
1762:Src/mpu6050.c ****     if (fifo_count < length) {
1763:Src/mpu6050.c ****         more[0] = 0;
1764:Src/mpu6050.c ****         return -1;
1765:Src/mpu6050.c ****     }
1766:Src/mpu6050.c ****     if (fifo_count > (st.hw->max_fifo >> 1)) {
1767:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
1768:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
1769:Src/mpu6050.c ****             return -1;
1770:Src/mpu6050.c ****         if (tmp[0] & BIT_FIFO_OVERFLOW) {
1771:Src/mpu6050.c ****             mpu_reset_fifo();
1772:Src/mpu6050.c ****             return -2;
1773:Src/mpu6050.c ****         }
1774:Src/mpu6050.c ****     }
1775:Src/mpu6050.c **** 
1776:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
1777:Src/mpu6050.c ****         return -1;
1778:Src/mpu6050.c ****     more[0] = fifo_count / length - 1;
1779:Src/mpu6050.c ****     return 0;
1780:Src/mpu6050.c **** }
1781:Src/mpu6050.c **** 
1782:Src/mpu6050.c **** /**
1783:Src/mpu6050.c ****  *  @brief      Set device to bypass mode.
1784:Src/mpu6050.c ****  *  @param[in]  bypass_on   1 to enable bypass mode.
1785:Src/mpu6050.c ****  *  @return     0 if successful.
1786:Src/mpu6050.c ****  */
1787:Src/mpu6050.c **** int mpu_set_bypass(unsigned char bypass_on)
1788:Src/mpu6050.c **** {
1789:Src/mpu6050.c ****     unsigned char tmp;
1790:Src/mpu6050.c **** 
1791:Src/mpu6050.c ****     if (st.chip_cfg.bypass_mode == bypass_on)
1792:Src/mpu6050.c ****         return 0;
1793:Src/mpu6050.c **** 
1794:Src/mpu6050.c ****     if (bypass_on) {
1795:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1796:Src/mpu6050.c ****             return -1;
1797:Src/mpu6050.c ****         tmp &= ~BIT_AUX_IF_EN;
1798:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
ARM GAS  /tmp/ccC60hwS.s 			page 33


1799:Src/mpu6050.c ****             return -1;
1800:Src/mpu6050.c ****         delay_ms(3);
1801:Src/mpu6050.c ****         tmp = BIT_BYPASS_EN;
1802:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
1803:Src/mpu6050.c ****             tmp |= BIT_ACTL;
1804:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
1805:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1806:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1807:Src/mpu6050.c ****             return -1;
1808:Src/mpu6050.c ****     } else {
1809:Src/mpu6050.c ****         /* Enable I2C master mode if compass is being used. */
1810:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1811:Src/mpu6050.c ****             return -1;
1812:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1813:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
1814:Src/mpu6050.c ****         else
1815:Src/mpu6050.c ****             tmp &= ~BIT_AUX_IF_EN;
1816:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1817:Src/mpu6050.c ****             return -1;
1818:Src/mpu6050.c ****         delay_ms(3);
1819:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
1820:Src/mpu6050.c ****             tmp = BIT_ACTL;
1821:Src/mpu6050.c ****         else
1822:Src/mpu6050.c ****             tmp = 0;
1823:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
1824:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1825:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1826:Src/mpu6050.c ****             return -1;
1827:Src/mpu6050.c ****     }
1828:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = bypass_on;
1829:Src/mpu6050.c ****     return 0;
1830:Src/mpu6050.c **** }
1831:Src/mpu6050.c **** 
1832:Src/mpu6050.c **** /**
1833:Src/mpu6050.c ****  *  @brief      Set interrupt level.
1834:Src/mpu6050.c ****  *  @param[in]  active_low  1 for active low, 0 for active high.
1835:Src/mpu6050.c ****  *  @return     0 if successful.
1836:Src/mpu6050.c ****  */
1837:Src/mpu6050.c **** int mpu_set_int_level(unsigned char active_low)
1838:Src/mpu6050.c **** {
1839:Src/mpu6050.c ****     st.chip_cfg.active_low_int = active_low;
1840:Src/mpu6050.c ****     return 0;
1841:Src/mpu6050.c **** }
1842:Src/mpu6050.c **** 
1843:Src/mpu6050.c **** /**
1844:Src/mpu6050.c ****  *  @brief      Enable latched interrupts.
1845:Src/mpu6050.c ****  *  Any MPU register will clear the interrupt.
1846:Src/mpu6050.c ****  *  @param[in]  enable  1 to enable, 0 to disable.
1847:Src/mpu6050.c ****  *  @return     0 if successful.
1848:Src/mpu6050.c ****  */
1849:Src/mpu6050.c **** int mpu_set_int_latched(unsigned char enable)
1850:Src/mpu6050.c **** {
1851:Src/mpu6050.c ****     unsigned char tmp;
1852:Src/mpu6050.c ****     if (st.chip_cfg.latched_int == enable)
1853:Src/mpu6050.c ****         return 0;
1854:Src/mpu6050.c **** 
1855:Src/mpu6050.c ****     if (enable)
ARM GAS  /tmp/ccC60hwS.s 			page 34


1856:Src/mpu6050.c ****         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
1857:Src/mpu6050.c ****     else
1858:Src/mpu6050.c ****         tmp = 0;
1859:Src/mpu6050.c ****     if (st.chip_cfg.bypass_mode)
1860:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
1861:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
1862:Src/mpu6050.c ****         tmp |= BIT_ACTL;
1863:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1864:Src/mpu6050.c ****         return -1;
1865:Src/mpu6050.c ****     st.chip_cfg.latched_int = enable;
1866:Src/mpu6050.c ****     return 0;
1867:Src/mpu6050.c **** }
1868:Src/mpu6050.c **** 
1869:Src/mpu6050.c **** #ifdef MPU6050
1870:Src/mpu6050.c **** static int get_accel_prod_shift(float *st_shift)
1871:Src/mpu6050.c **** {
1872:Src/mpu6050.c ****     unsigned char tmp[4], shift_code[3], ii;
1873:Src/mpu6050.c **** 
1874:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
1875:Src/mpu6050.c ****         return 0x07;
1876:Src/mpu6050.c **** 
1877:Src/mpu6050.c ****     shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
1878:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
1879:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
1880:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
1881:Src/mpu6050.c ****         if (!shift_code[ii]) {
1882:Src/mpu6050.c ****             st_shift[ii] = 0.f;
1883:Src/mpu6050.c ****             continue;
1884:Src/mpu6050.c ****         }
1885:Src/mpu6050.c ****         /* Equivalent to..
1886:Src/mpu6050.c ****          * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
1887:Src/mpu6050.c ****          */
1888:Src/mpu6050.c ****         st_shift[ii] = 0.34f;
1889:Src/mpu6050.c ****         while (--shift_code[ii])
1890:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
1891:Src/mpu6050.c ****     }
1892:Src/mpu6050.c ****     return 0;
1893:Src/mpu6050.c **** }
1894:Src/mpu6050.c **** 
1895:Src/mpu6050.c **** static int accel_self_test(long *bias_regular, long *bias_st)
1896:Src/mpu6050.c **** {
1897:Src/mpu6050.c ****     int jj, result = 0;
1898:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
1899:Src/mpu6050.c **** 
1900:Src/mpu6050.c ****     get_accel_prod_shift(st_shift);
1901:Src/mpu6050.c ****     for(jj = 0; jj < 3; jj++) {
1902:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
1903:Src/mpu6050.c ****         if (st_shift[jj]) {
1904:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
1905:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
1906:Src/mpu6050.c ****                 result |= 1 << jj;
1907:Src/mpu6050.c ****         } else if ((st_shift_cust < test.min_g) ||
1908:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
1909:Src/mpu6050.c ****             result |= 1 << jj;
1910:Src/mpu6050.c ****     }
1911:Src/mpu6050.c **** 
1912:Src/mpu6050.c ****     return result;
ARM GAS  /tmp/ccC60hwS.s 			page 35


1913:Src/mpu6050.c **** }
1914:Src/mpu6050.c **** 
1915:Src/mpu6050.c **** static int gyro_self_test(long *bias_regular, long *bias_st)
1916:Src/mpu6050.c **** {
1917:Src/mpu6050.c ****     int jj, result = 0;
1918:Src/mpu6050.c ****     unsigned char tmp[3];
1919:Src/mpu6050.c ****     float st_shift, st_shift_cust, st_shift_var;
1920:Src/mpu6050.c **** 
1921:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
1922:Src/mpu6050.c ****         return 0x07;
1923:Src/mpu6050.c **** 
1924:Src/mpu6050.c ****     tmp[0] &= 0x1F;
1925:Src/mpu6050.c ****     tmp[1] &= 0x1F;
1926:Src/mpu6050.c ****     tmp[2] &= 0x1F;
1927:Src/mpu6050.c **** 
1928:Src/mpu6050.c ****     for (jj = 0; jj < 3; jj++) {
1929:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
1930:Src/mpu6050.c ****         if (tmp[jj]) {
1931:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
1932:Src/mpu6050.c ****             while (--tmp[jj])
1933:Src/mpu6050.c ****                 st_shift *= 1.046f;
1934:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
1935:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
1936:Src/mpu6050.c ****                 result |= 1 << jj;
1937:Src/mpu6050.c ****         } else if ((st_shift_cust < test.min_dps) ||
1938:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
1939:Src/mpu6050.c ****             result |= 1 << jj;
1940:Src/mpu6050.c ****     }
1941:Src/mpu6050.c ****     return result;
1942:Src/mpu6050.c **** }
1943:Src/mpu6050.c **** 
1944:Src/mpu6050.c **** #endif 
1945:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1946:Src/mpu6050.c **** static int compass_self_test(void)
1947:Src/mpu6050.c **** {
1948:Src/mpu6050.c ****     unsigned char tmp[6];
1949:Src/mpu6050.c ****     unsigned char tries = 10;
1950:Src/mpu6050.c ****     int result = 0x07;
1951:Src/mpu6050.c ****     short data;
1952:Src/mpu6050.c **** 
1953:Src/mpu6050.c ****     mpu_set_bypass(1);
1954:Src/mpu6050.c **** 
1955:Src/mpu6050.c ****     tmp[0] = AKM_POWER_DOWN;
1956:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
1957:Src/mpu6050.c ****         return 0x07;
1958:Src/mpu6050.c ****     tmp[0] = AKM_BIT_SELF_TEST;
1959:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
1960:Src/mpu6050.c ****         goto AKM_restore;
1961:Src/mpu6050.c ****     tmp[0] = AKM_MODE_SELF_TEST;
1962:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
1963:Src/mpu6050.c ****         goto AKM_restore;
1964:Src/mpu6050.c **** 
1965:Src/mpu6050.c ****     do {
1966:Src/mpu6050.c ****         delay_ms(10);
1967:Src/mpu6050.c ****         if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
1968:Src/mpu6050.c ****             goto AKM_restore;
1969:Src/mpu6050.c ****         if (tmp[0] & AKM_DATA_READY)
ARM GAS  /tmp/ccC60hwS.s 			page 36


1970:Src/mpu6050.c ****             break;
1971:Src/mpu6050.c ****     } while (tries--);
1972:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY))
1973:Src/mpu6050.c ****         goto AKM_restore;
1974:Src/mpu6050.c **** 
1975:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
1976:Src/mpu6050.c ****         goto AKM_restore;
1977:Src/mpu6050.c **** 
1978:Src/mpu6050.c ****     result = 0;
1979:Src/mpu6050.c **** #if defined MPU9150
1980:Src/mpu6050.c ****     data = (short)(tmp[1] << 8) | tmp[0];
1981:Src/mpu6050.c ****     if ((data > 100) || (data < -100))
1982:Src/mpu6050.c ****         result |= 0x01;
1983:Src/mpu6050.c ****     data = (short)(tmp[3] << 8) | tmp[2];
1984:Src/mpu6050.c ****     if ((data > 100) || (data < -100))
1985:Src/mpu6050.c ****         result |= 0x02;
1986:Src/mpu6050.c ****     data = (short)(tmp[5] << 8) | tmp[4];
1987:Src/mpu6050.c ****     if ((data > -300) || (data < -1000))
1988:Src/mpu6050.c ****         result |= 0x04;
1989:Src/mpu6050.c **** #elif defined MPU9250
1990:Src/mpu6050.c ****     data = (short)(tmp[1] << 8) | tmp[0];
1991:Src/mpu6050.c ****     if ((data > 200) || (data < -200))  
1992:Src/mpu6050.c ****         result |= 0x01;
1993:Src/mpu6050.c ****     data = (short)(tmp[3] << 8) | tmp[2];
1994:Src/mpu6050.c ****     if ((data > 200) || (data < -200))  
1995:Src/mpu6050.c ****         result |= 0x02;
1996:Src/mpu6050.c ****     data = (short)(tmp[5] << 8) | tmp[4];
1997:Src/mpu6050.c ****     if ((data > -800) || (data < -3200))  
1998:Src/mpu6050.c ****         result |= 0x04;
1999:Src/mpu6050.c **** #endif
2000:Src/mpu6050.c **** AKM_restore:
2001:Src/mpu6050.c ****     tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
2002:Src/mpu6050.c ****     i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
2003:Src/mpu6050.c ****     tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
2004:Src/mpu6050.c ****     i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
2005:Src/mpu6050.c ****     mpu_set_bypass(0);
2006:Src/mpu6050.c ****     return result;
2007:Src/mpu6050.c **** }
2008:Src/mpu6050.c **** #endif
2009:Src/mpu6050.c **** 
2010:Src/mpu6050.c **** static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
2011:Src/mpu6050.c **** {
  28              		.loc 1 2011 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 0, uses_anonymous_args = 0
2012:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  32              		.loc 1 2012 5 view .LVU1
2013:Src/mpu6050.c ****     unsigned char packet_count, ii;
  33              		.loc 1 2013 5 view .LVU2
2014:Src/mpu6050.c ****     unsigned short fifo_count;
  34              		.loc 1 2014 5 view .LVU3
2015:Src/mpu6050.c **** 
2016:Src/mpu6050.c ****     data[0] = 0x01;
  35              		.loc 1 2016 5 view .LVU4
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  36              		.loc 1 2011 1 is_stmt 0 view .LVU5
ARM GAS  /tmp/ccC60hwS.s 			page 37


  37 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
  38              	.LCFI0:
  39              		.cfi_def_cfa_offset 28
  40              		.cfi_offset 4, -28
  41              		.cfi_offset 5, -24
  42              		.cfi_offset 6, -20
  43              		.cfi_offset 7, -16
  44              		.cfi_offset 8, -12
  45              		.cfi_offset 9, -8
  46              		.cfi_offset 14, -4
2017:Src/mpu6050.c ****     data[1] = 0;
  47              		.loc 1 2017 13 view .LVU6
  48 0004 0023     		movs	r3, #0
2016:Src/mpu6050.c ****     data[1] = 0;
  49              		.loc 1 2016 13 view .LVU7
  50 0006 0127     		movs	r7, #1
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  51              		.loc 1 2011 1 view .LVU8
  52 0008 85B0     		sub	sp, sp, #20
  53              	.LCFI1:
  54              		.cfi_def_cfa_offset 48
2018:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
  55              		.loc 1 2018 34 view .LVU9
  56 000a B64C     		ldr	r4, .L22
2017:Src/mpu6050.c ****     data[1] = 0;
  57              		.loc 1 2017 13 view .LVU10
  58 000c 8DF80530 		strb	r3, [sp, #5]
2016:Src/mpu6050.c ****     data[1] = 0;
  59              		.loc 1 2016 13 view .LVU11
  60 0010 8DF80470 		strb	r7, [sp, #4]
2017:Src/mpu6050.c ****     data[1] = 0;
  61              		.loc 1 2017 5 is_stmt 1 view .LVU12
  62              		.loc 1 2018 5 view .LVU13
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  63              		.loc 1 2011 1 is_stmt 0 view .LVU14
  64 0014 0646     		mov	r6, r0
  65 0016 0D46     		mov	r5, r1
  66              		.loc 1 2018 9 view .LVU15
  67 0018 D4E90010 		ldrd	r1, r0, [r4]
  68              	.LVL1:
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  69              		.loc 1 2011 1 view .LVU16
  70 001c 9046     		mov	r8, r2
  71              		.loc 1 2018 9 view .LVU17
  72 001e 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
  73 0020 0222     		movs	r2, #2
  74              	.LVL2:
  75              		.loc 1 2018 9 view .LVU18
  76 0022 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
  77 0024 01AB     		add	r3, sp, #4
  78 0026 FFF7FEFF 		bl	i2c_writeBytes
  79              	.LVL3:
  80              		.loc 1 2018 8 view .LVU19
  81 002a 8146     		mov	r9, r0
  82 002c 20B1     		cbz	r0, .L2
  83              	.L4:
2019:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 38


  84              		.loc 1 2019 16 view .LVU20
  85 002e 4FF0FF30 		mov	r0, #-1
  86              	.L1:
2020:Src/mpu6050.c ****     delay_ms(200);
2021:Src/mpu6050.c ****     data[0] = 0;
2022:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
2023:Src/mpu6050.c ****         return -1;
2024:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2025:Src/mpu6050.c ****         return -1;
2026:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
2027:Src/mpu6050.c ****         return -1;
2028:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2029:Src/mpu6050.c ****         return -1;
2030:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2031:Src/mpu6050.c ****         return -1;
2032:Src/mpu6050.c ****     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
2033:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2034:Src/mpu6050.c ****         return -1;
2035:Src/mpu6050.c ****     delay_ms(15);
2036:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
2037:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
2038:Src/mpu6050.c ****         return -1;
2039:Src/mpu6050.c ****     data[0] = st.test->reg_rate_div;
2040:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
2041:Src/mpu6050.c ****         return -1;
2042:Src/mpu6050.c ****     if (hw_test)
2043:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
2044:Src/mpu6050.c ****     else
2045:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr;
2046:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
2047:Src/mpu6050.c ****         return -1;
2048:Src/mpu6050.c **** 
2049:Src/mpu6050.c ****     if (hw_test)
2050:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
2051:Src/mpu6050.c ****     else
2052:Src/mpu6050.c ****         data[0] = test.reg_accel_fsr;
2053:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
2054:Src/mpu6050.c ****         return -1;
2055:Src/mpu6050.c ****     if (hw_test)
2056:Src/mpu6050.c ****         delay_ms(200);
2057:Src/mpu6050.c **** 
2058:Src/mpu6050.c ****     /* Fill FIFO for test.wait_ms milliseconds. */
2059:Src/mpu6050.c ****     data[0] = BIT_FIFO_EN;
2060:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2061:Src/mpu6050.c ****         return -1;
2062:Src/mpu6050.c **** 
2063:Src/mpu6050.c ****     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2064:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2065:Src/mpu6050.c ****         return -1;
2066:Src/mpu6050.c ****     delay_ms(test.wait_ms);
2067:Src/mpu6050.c ****     data[0] = 0;
2068:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2069:Src/mpu6050.c ****         return -1;
2070:Src/mpu6050.c **** 
2071:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
2072:Src/mpu6050.c ****         return -1;
2073:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 39


2074:Src/mpu6050.c ****     fifo_count = (data[0] << 8) | data[1];
2075:Src/mpu6050.c ****     packet_count = fifo_count / MAX_PACKET_LENGTH;
2076:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
2077:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
2078:Src/mpu6050.c **** 
2079:Src/mpu6050.c ****     for (ii = 0; ii < packet_count; ii++) {
2080:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
2081:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
2082:Src/mpu6050.c ****             return -1;
2083:Src/mpu6050.c ****         accel_cur[0] = ((short)data[0] << 8) | data[1];
2084:Src/mpu6050.c ****         accel_cur[1] = ((short)data[2] << 8) | data[3];
2085:Src/mpu6050.c ****         accel_cur[2] = ((short)data[4] << 8) | data[5];
2086:Src/mpu6050.c ****         accel[0] += (long)accel_cur[0];
2087:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
2088:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
2089:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
2090:Src/mpu6050.c ****         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
2091:Src/mpu6050.c ****         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
2092:Src/mpu6050.c ****         gyro[0] += (long)gyro_cur[0];
2093:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
2094:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
2095:Src/mpu6050.c ****     }
2096:Src/mpu6050.c **** #ifdef EMPL_NO_64BIT
2097:Src/mpu6050.c ****     gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
2098:Src/mpu6050.c ****     gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
2099:Src/mpu6050.c ****     gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
2100:Src/mpu6050.c ****     if (has_accel) {
2101:Src/mpu6050.c ****         accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
2102:Src/mpu6050.c ****             packet_count);
2103:Src/mpu6050.c ****         accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
2104:Src/mpu6050.c ****             packet_count);
2105:Src/mpu6050.c ****         accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
2106:Src/mpu6050.c ****             packet_count);
2107:Src/mpu6050.c ****         /* Don't remove gravity! */
2108:Src/mpu6050.c ****         accel[2] -= 65536L;
2109:Src/mpu6050.c ****     }
2110:Src/mpu6050.c **** #else
2111:Src/mpu6050.c ****     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
2112:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
2113:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
2114:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
2115:Src/mpu6050.c ****         packet_count);
2116:Src/mpu6050.c ****     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
2117:Src/mpu6050.c ****         packet_count);
2118:Src/mpu6050.c ****     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
2119:Src/mpu6050.c ****         packet_count);
2120:Src/mpu6050.c ****     /* Don't remove gravity! */
2121:Src/mpu6050.c ****     if (accel[2] > 0L)
2122:Src/mpu6050.c ****         accel[2] -= 65536L;
2123:Src/mpu6050.c ****     else
2124:Src/mpu6050.c ****         accel[2] += 65536L;
2125:Src/mpu6050.c **** #endif
2126:Src/mpu6050.c **** 
2127:Src/mpu6050.c ****     return 0;
2128:Src/mpu6050.c **** }
  87              		.loc 1 2128 1 view .LVU21
  88 0032 05B0     		add	sp, sp, #20
ARM GAS  /tmp/ccC60hwS.s 			page 40


  89              	.LCFI2:
  90              		.cfi_remember_state
  91              		.cfi_def_cfa_offset 28
  92              		@ sp needed
  93 0034 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
  94              	.LVL4:
  95              	.L2:
  96              	.LCFI3:
  97              		.cfi_restore_state
2020:Src/mpu6050.c ****     delay_ms(200);
  98              		.loc 1 2020 5 is_stmt 1 view .LVU22
  99 0038 C820     		movs	r0, #200
 100 003a FFF7FEFF 		bl	delay_1ms
 101              	.LVL5:
2021:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
 102              		.loc 1 2021 5 view .LVU23
2022:Src/mpu6050.c ****         return -1;
 103              		.loc 1 2022 9 is_stmt 0 view .LVU24
 104 003e D4E90010 		ldrd	r1, r0, [r4]
2021:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
 105              		.loc 1 2021 13 view .LVU25
 106 0042 8DF80490 		strb	r9, [sp, #4]
2022:Src/mpu6050.c ****         return -1;
 107              		.loc 1 2022 5 is_stmt 1 view .LVU26
2022:Src/mpu6050.c ****         return -1;
 108              		.loc 1 2022 9 is_stmt 0 view .LVU27
 109 0046 3A46     		mov	r2, r7
 110 0048 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 111 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 112 004c 01AB     		add	r3, sp, #4
 113 004e FFF7FEFF 		bl	i2c_writeBytes
 114              	.LVL6:
2022:Src/mpu6050.c ****         return -1;
 115              		.loc 1 2022 8 view .LVU28
 116 0052 0028     		cmp	r0, #0
 117 0054 EBD1     		bne	.L4
2024:Src/mpu6050.c ****         return -1;
 118              		.loc 1 2024 5 is_stmt 1 view .LVU29
2024:Src/mpu6050.c ****         return -1;
 119              		.loc 1 2024 9 is_stmt 0 view .LVU30
 120 0056 D4E90010 		ldrd	r1, r0, [r4]
 121 005a 3A46     		mov	r2, r7
 122 005c 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 123 005e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 124 0060 01AB     		add	r3, sp, #4
 125 0062 FFF7FEFF 		bl	i2c_writeBytes
 126              	.LVL7:
2024:Src/mpu6050.c ****         return -1;
 127              		.loc 1 2024 8 view .LVU31
 128 0066 0028     		cmp	r0, #0
 129 0068 E1D1     		bne	.L4
2026:Src/mpu6050.c ****         return -1;
 130              		.loc 1 2026 5 is_stmt 1 view .LVU32
2026:Src/mpu6050.c ****         return -1;
 131              		.loc 1 2026 9 is_stmt 0 view .LVU33
 132 006a D4E90010 		ldrd	r1, r0, [r4]
 133 006e 3A46     		mov	r2, r7
ARM GAS  /tmp/ccC60hwS.s 			page 41


 134 0070 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 135 0072 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 136 0074 01AB     		add	r3, sp, #4
 137 0076 FFF7FEFF 		bl	i2c_writeBytes
 138              	.LVL8:
2026:Src/mpu6050.c ****         return -1;
 139              		.loc 1 2026 8 view .LVU34
 140 007a 0028     		cmp	r0, #0
 141 007c D7D1     		bne	.L4
2028:Src/mpu6050.c ****         return -1;
 142              		.loc 1 2028 5 is_stmt 1 view .LVU35
2028:Src/mpu6050.c ****         return -1;
 143              		.loc 1 2028 9 is_stmt 0 view .LVU36
 144 007e D4E90010 		ldrd	r1, r0, [r4]
 145 0082 3A46     		mov	r2, r7
 146 0084 897E     		ldrb	r1, [r1, #26]	@ zero_extendqisi2
 147 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 148 0088 01AB     		add	r3, sp, #4
 149 008a FFF7FEFF 		bl	i2c_writeBytes
 150              	.LVL9:
2028:Src/mpu6050.c ****         return -1;
 151              		.loc 1 2028 8 view .LVU37
 152 008e 0028     		cmp	r0, #0
 153 0090 CDD1     		bne	.L4
2030:Src/mpu6050.c ****         return -1;
 154              		.loc 1 2030 5 is_stmt 1 view .LVU38
2030:Src/mpu6050.c ****         return -1;
 155              		.loc 1 2030 9 is_stmt 0 view .LVU39
 156 0092 D4E90010 		ldrd	r1, r0, [r4]
 157 0096 3A46     		mov	r2, r7
 158 0098 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 159 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 160 009c 01AB     		add	r3, sp, #4
 161 009e FFF7FEFF 		bl	i2c_writeBytes
 162              	.LVL10:
2030:Src/mpu6050.c ****         return -1;
 163              		.loc 1 2030 8 view .LVU40
 164 00a2 0028     		cmp	r0, #0
 165 00a4 C3D1     		bne	.L4
2032:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 166              		.loc 1 2032 5 is_stmt 1 view .LVU41
2033:Src/mpu6050.c ****         return -1;
 167              		.loc 1 2033 9 is_stmt 0 view .LVU42
 168 00a6 D4E90010 		ldrd	r1, r0, [r4]
2032:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 169              		.loc 1 2032 13 view .LVU43
 170 00aa 0C23     		movs	r3, #12
 171 00ac 8DF80430 		strb	r3, [sp, #4]
2033:Src/mpu6050.c ****         return -1;
 172              		.loc 1 2033 5 is_stmt 1 view .LVU44
2033:Src/mpu6050.c ****         return -1;
 173              		.loc 1 2033 9 is_stmt 0 view .LVU45
 174 00b0 3A46     		mov	r2, r7
 175 00b2 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 176 00b4 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 177 00b6 01AB     		add	r3, sp, #4
 178 00b8 FFF7FEFF 		bl	i2c_writeBytes
ARM GAS  /tmp/ccC60hwS.s 			page 42


 179              	.LVL11:
2033:Src/mpu6050.c ****         return -1;
 180              		.loc 1 2033 8 view .LVU46
 181 00bc 0028     		cmp	r0, #0
 182 00be B6D1     		bne	.L4
2035:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
 183              		.loc 1 2035 5 is_stmt 1 view .LVU47
 184 00c0 0F20     		movs	r0, #15
 185 00c2 FFF7FEFF 		bl	delay_1ms
 186              	.LVL12:
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 187              		.loc 1 2036 5 view .LVU48
2037:Src/mpu6050.c ****         return -1;
 188              		.loc 1 2037 9 is_stmt 0 view .LVU49
 189 00c6 D4E90010 		ldrd	r1, r0, [r4]
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 190              		.loc 1 2036 22 view .LVU50
 191 00ca A36A     		ldr	r3, [r4, #40]
2037:Src/mpu6050.c ****         return -1;
 192              		.loc 1 2037 9 view .LVU51
 193 00cc 3A46     		mov	r2, r7
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 194              		.loc 1 2036 13 view .LVU52
 195 00ce 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
2037:Src/mpu6050.c ****         return -1;
 196              		.loc 1 2037 9 view .LVU53
 197 00d0 8978     		ldrb	r1, [r1, #2]	@ zero_extendqisi2
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 198              		.loc 1 2036 13 view .LVU54
 199 00d2 8DF80430 		strb	r3, [sp, #4]
2037:Src/mpu6050.c ****         return -1;
 200              		.loc 1 2037 5 is_stmt 1 view .LVU55
2037:Src/mpu6050.c ****         return -1;
 201              		.loc 1 2037 9 is_stmt 0 view .LVU56
 202 00d6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 203 00d8 01AB     		add	r3, sp, #4
 204 00da FFF7FEFF 		bl	i2c_writeBytes
 205              	.LVL13:
2037:Src/mpu6050.c ****         return -1;
 206              		.loc 1 2037 8 view .LVU57
 207 00de 0028     		cmp	r0, #0
 208 00e0 A5D1     		bne	.L4
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 209              		.loc 1 2039 5 is_stmt 1 view .LVU58
2040:Src/mpu6050.c ****         return -1;
 210              		.loc 1 2040 9 is_stmt 0 view .LVU59
 211 00e2 D4E90010 		ldrd	r1, r0, [r4]
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 212              		.loc 1 2039 22 view .LVU60
 213 00e6 A36A     		ldr	r3, [r4, #40]
2040:Src/mpu6050.c ****         return -1;
 214              		.loc 1 2040 9 view .LVU61
 215 00e8 3A46     		mov	r2, r7
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 216              		.loc 1 2039 13 view .LVU62
 217 00ea 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
2040:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 43


 218              		.loc 1 2040 9 view .LVU63
 219 00ec 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 220              		.loc 1 2039 13 view .LVU64
 221 00ee 8DF80430 		strb	r3, [sp, #4]
2040:Src/mpu6050.c ****         return -1;
 222              		.loc 1 2040 5 is_stmt 1 view .LVU65
2040:Src/mpu6050.c ****         return -1;
 223              		.loc 1 2040 9 is_stmt 0 view .LVU66
 224 00f2 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 225 00f4 01AB     		add	r3, sp, #4
 226 00f6 FFF7FEFF 		bl	i2c_writeBytes
 227              	.LVL14:
2040:Src/mpu6050.c ****         return -1;
 228              		.loc 1 2040 8 view .LVU67
 229 00fa 0028     		cmp	r0, #0
 230 00fc 97D1     		bne	.L4
2042:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
 231              		.loc 1 2042 5 is_stmt 1 view .LVU68
2043:Src/mpu6050.c ****     else
 232              		.loc 1 2043 26 is_stmt 0 view .LVU69
 233 00fe A36A     		ldr	r3, [r4, #40]
 234 0100 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
2042:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
 235              		.loc 1 2042 8 view .LVU70
 236 0102 B8F1000F 		cmp	r8, #0
 237 0106 01D0     		beq	.L5
2043:Src/mpu6050.c ****     else
 238              		.loc 1 2043 9 is_stmt 1 view .LVU71
2043:Src/mpu6050.c ****     else
 239              		.loc 1 2043 17 is_stmt 0 view .LVU72
 240 0108 43F0E003 		orr	r3, r3, #224
 241              	.L5:
 242 010c 8DF80430 		strb	r3, [sp, #4]
2046:Src/mpu6050.c ****         return -1;
 243              		.loc 1 2046 5 is_stmt 1 view .LVU73
2046:Src/mpu6050.c ****         return -1;
 244              		.loc 1 2046 9 is_stmt 0 view .LVU74
 245 0110 D4E90010 		ldrd	r1, r0, [r4]
 246 0114 0122     		movs	r2, #1
 247 0116 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 248 0118 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 249 011a 01AB     		add	r3, sp, #4
 250 011c FFF7FEFF 		bl	i2c_writeBytes
 251              	.LVL15:
2046:Src/mpu6050.c ****         return -1;
 252              		.loc 1 2046 8 view .LVU75
 253 0120 0028     		cmp	r0, #0
 254 0122 84D1     		bne	.L4
2049:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
 255              		.loc 1 2049 5 is_stmt 1 view .LVU76
2049:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
 256              		.loc 1 2049 8 is_stmt 0 view .LVU77
 257 0124 B8F1000F 		cmp	r8, #0
 258 0128 00F0D980 		beq	.L14
2050:Src/mpu6050.c ****     else
 259              		.loc 1 2050 9 is_stmt 1 view .LVU78
ARM GAS  /tmp/ccC60hwS.s 			page 44


2050:Src/mpu6050.c ****     else
 260              		.loc 1 2050 26 is_stmt 0 view .LVU79
 261 012c A36A     		ldr	r3, [r4, #40]
2050:Src/mpu6050.c ****     else
 262              		.loc 1 2050 17 view .LVU80
 263 012e DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 264 0130 43F0E003 		orr	r3, r3, #224
 265              	.L6:
 266 0134 8DF80430 		strb	r3, [sp, #4]
2053:Src/mpu6050.c ****         return -1;
 267              		.loc 1 2053 5 is_stmt 1 view .LVU81
2053:Src/mpu6050.c ****         return -1;
 268              		.loc 1 2053 9 is_stmt 0 view .LVU82
 269 0138 D4E90010 		ldrd	r1, r0, [r4]
 270 013c 0122     		movs	r2, #1
 271 013e C979     		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 272 0140 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 273 0142 01AB     		add	r3, sp, #4
 274 0144 FFF7FEFF 		bl	i2c_writeBytes
 275              	.LVL16:
2053:Src/mpu6050.c ****         return -1;
 276              		.loc 1 2053 8 view .LVU83
 277 0148 0028     		cmp	r0, #0
 278 014a 7FF470AF 		bne	.L4
2055:Src/mpu6050.c ****         delay_ms(200);
 279              		.loc 1 2055 5 is_stmt 1 view .LVU84
2055:Src/mpu6050.c ****         delay_ms(200);
 280              		.loc 1 2055 8 is_stmt 0 view .LVU85
 281 014e B8F1000F 		cmp	r8, #0
 282 0152 02D0     		beq	.L7
2056:Src/mpu6050.c **** 
 283              		.loc 1 2056 9 is_stmt 1 view .LVU86
 284 0154 C820     		movs	r0, #200
 285 0156 FFF7FEFF 		bl	delay_1ms
 286              	.LVL17:
 287              	.L7:
2059:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 288              		.loc 1 2059 5 view .LVU87
2060:Src/mpu6050.c ****         return -1;
 289              		.loc 1 2060 9 is_stmt 0 view .LVU88
 290 015a D4E90010 		ldrd	r1, r0, [r4]
2059:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 291              		.loc 1 2059 13 view .LVU89
 292 015e 4023     		movs	r3, #64
 293 0160 8DF80430 		strb	r3, [sp, #4]
2060:Src/mpu6050.c ****         return -1;
 294              		.loc 1 2060 5 is_stmt 1 view .LVU90
2060:Src/mpu6050.c ****         return -1;
 295              		.loc 1 2060 9 is_stmt 0 view .LVU91
 296 0164 0122     		movs	r2, #1
 297 0166 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 298 0168 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 299 016a 01AB     		add	r3, sp, #4
 300 016c FFF7FEFF 		bl	i2c_writeBytes
 301              	.LVL18:
2060:Src/mpu6050.c ****         return -1;
 302              		.loc 1 2060 8 view .LVU92
ARM GAS  /tmp/ccC60hwS.s 			page 45


 303 0170 0028     		cmp	r0, #0
 304 0172 7FF45CAF 		bne	.L4
2063:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 305              		.loc 1 2063 5 is_stmt 1 view .LVU93
2064:Src/mpu6050.c ****         return -1;
 306              		.loc 1 2064 9 is_stmt 0 view .LVU94
 307 0176 D4E90010 		ldrd	r1, r0, [r4]
2063:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 308              		.loc 1 2063 13 view .LVU95
 309 017a 7823     		movs	r3, #120
 310 017c 8DF80430 		strb	r3, [sp, #4]
2064:Src/mpu6050.c ****         return -1;
 311              		.loc 1 2064 5 is_stmt 1 view .LVU96
2064:Src/mpu6050.c ****         return -1;
 312              		.loc 1 2064 9 is_stmt 0 view .LVU97
 313 0180 0122     		movs	r2, #1
 314 0182 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 315 0184 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 316 0186 01AB     		add	r3, sp, #4
 317 0188 FFF7FEFF 		bl	i2c_writeBytes
 318              	.LVL19:
2064:Src/mpu6050.c ****         return -1;
 319              		.loc 1 2064 8 view .LVU98
 320 018c 0746     		mov	r7, r0
 321 018e 0028     		cmp	r0, #0
 322 0190 7FF44DAF 		bne	.L4
2066:Src/mpu6050.c ****     data[0] = 0;
 323              		.loc 1 2066 5 is_stmt 1 view .LVU99
 324 0194 3220     		movs	r0, #50
 325 0196 FFF7FEFF 		bl	delay_1ms
 326              	.LVL20:
2067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 327              		.loc 1 2067 5 view .LVU100
2068:Src/mpu6050.c ****         return -1;
 328              		.loc 1 2068 9 is_stmt 0 view .LVU101
 329 019a D4E90010 		ldrd	r1, r0, [r4]
2067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 330              		.loc 1 2067 13 view .LVU102
 331 019e 8DF80470 		strb	r7, [sp, #4]
2068:Src/mpu6050.c ****         return -1;
 332              		.loc 1 2068 5 is_stmt 1 view .LVU103
2068:Src/mpu6050.c ****         return -1;
 333              		.loc 1 2068 9 is_stmt 0 view .LVU104
 334 01a2 0122     		movs	r2, #1
 335 01a4 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 336 01a6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 337 01a8 01AB     		add	r3, sp, #4
 338 01aa FFF7FEFF 		bl	i2c_writeBytes
 339              	.LVL21:
2068:Src/mpu6050.c ****         return -1;
 340              		.loc 1 2068 8 view .LVU105
 341 01ae 0028     		cmp	r0, #0
 342 01b0 7FF43DAF 		bne	.L4
2071:Src/mpu6050.c ****         return -1;
 343              		.loc 1 2071 5 is_stmt 1 view .LVU106
2071:Src/mpu6050.c ****         return -1;
 344              		.loc 1 2071 9 is_stmt 0 view .LVU107
ARM GAS  /tmp/ccC60hwS.s 			page 46


 345 01b4 D4E90010 		ldrd	r1, r0, [r4]
 346 01b8 0222     		movs	r2, #2
 347 01ba 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 348 01bc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 349 01be 01AB     		add	r3, sp, #4
 350 01c0 FFF7FEFF 		bl	i2c_readBytes
 351              	.LVL22:
2071:Src/mpu6050.c ****         return -1;
 352              		.loc 1 2071 8 view .LVU108
 353 01c4 0028     		cmp	r0, #0
 354 01c6 7FF432AF 		bne	.L4
2074:Src/mpu6050.c ****     packet_count = fifo_count / MAX_PACKET_LENGTH;
 355              		.loc 1 2074 5 is_stmt 1 view .LVU109
 356              	.LVL23:
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 357              		.loc 1 2075 5 view .LVU110
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 358              		.loc 1 2075 18 is_stmt 0 view .LVU111
 359 01ca 0C23     		movs	r3, #12
 360 01cc BDF80470 		ldrh	r7, [sp, #4]
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 361              		.loc 1 2079 5 view .LVU112
 362 01d0 8046     		mov	r8, r0
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 363              		.loc 1 2075 18 view .LVU113
 364 01d2 7FBA     		rev16	r7, r7
 365 01d4 BFB2     		uxth	r7, r7
 366 01d6 B7FBF3F7 		udiv	r7, r7, r3
2076:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 367              		.loc 1 2076 23 view .LVU114
 368 01da C6E90100 		strd	r0, r0, [r6, #4]
2076:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 369              		.loc 1 2076 13 view .LVU115
 370 01de 3060     		str	r0, [r6]
2077:Src/mpu6050.c **** 
 371              		.loc 1 2077 25 view .LVU116
 372 01e0 C5E90100 		strd	r0, r0, [r5, #4]
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 373              		.loc 1 2075 18 view .LVU117
 374 01e4 FFB2     		uxtb	r7, r7
 375              	.LVL24:
2076:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 376              		.loc 1 2076 5 is_stmt 1 view .LVU118
2077:Src/mpu6050.c **** 
 377              		.loc 1 2077 5 view .LVU119
2077:Src/mpu6050.c **** 
 378              		.loc 1 2077 14 is_stmt 0 view .LVU120
 379 01e6 2860     		str	r0, [r5]
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 380              		.loc 1 2079 5 is_stmt 1 view .LVU121
 381              	.LVL25:
 382              	.L8:
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 383              		.loc 1 2079 18 discriminator 1 view .LVU122
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 384              		.loc 1 2079 5 is_stmt 0 discriminator 1 view .LVU123
 385 01e8 5FFA88F3 		uxtb	r3, r8
ARM GAS  /tmp/ccC60hwS.s 			page 47


 386 01ec BB42     		cmp	r3, r7
 387 01ee 7BD3     		bcc	.L9
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 388              		.loc 1 2111 5 is_stmt 1 view .LVU124
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 389              		.loc 1 2111 23 is_stmt 0 view .LVU125
 390 01f0 3468     		ldr	r4, [r6]
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 391              		.loc 1 2111 47 view .LVU126
 392 01f2 8322     		movs	r2, #131
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 393              		.loc 1 2111 23 view .LVU127
 394 01f4 E117     		asrs	r1, r4, #31
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 395              		.loc 1 2111 41 view .LVU128
 396 01f6 0904     		lsls	r1, r1, #16
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 397              		.loc 1 2111 47 view .LVU129
 398 01f8 0023     		movs	r3, #0
 399 01fa 2004     		lsls	r0, r4, #16
 400 01fc 41EA1441 		orr	r1, r1, r4, lsr #16
 401 0200 FFF7FEFF 		bl	__aeabi_ldivmod
 402              	.LVL26:
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 403              		.loc 1 2111 64 view .LVU130
 404 0204 3A46     		mov	r2, r7
 405 0206 0023     		movs	r3, #0
 406 0208 FFF7FEFF 		bl	__aeabi_ldivmod
 407              	.LVL27:
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 408              		.loc 1 2112 23 view .LVU131
 409 020c 7468     		ldr	r4, [r6, #4]
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 410              		.loc 1 2112 47 view .LVU132
 411 020e 8322     		movs	r2, #131
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 412              		.loc 1 2112 23 view .LVU133
 413 0210 E117     		asrs	r1, r4, #31
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 414              		.loc 1 2112 41 view .LVU134
 415 0212 0904     		lsls	r1, r1, #16
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 416              		.loc 1 2112 47 view .LVU135
 417 0214 0023     		movs	r3, #0
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 418              		.loc 1 2111 15 view .LVU136
 419 0216 3060     		str	r0, [r6]
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 420              		.loc 1 2112 5 is_stmt 1 view .LVU137
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 421              		.loc 1 2112 47 is_stmt 0 view .LVU138
 422 0218 41EA1441 		orr	r1, r1, r4, lsr #16
 423 021c 2004     		lsls	r0, r4, #16
 424 021e FFF7FEFF 		bl	__aeabi_ldivmod
 425              	.LVL28:
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 426              		.loc 1 2112 64 view .LVU139
ARM GAS  /tmp/ccC60hwS.s 			page 48


 427 0222 3A46     		mov	r2, r7
 428 0224 0023     		movs	r3, #0
 429 0226 FFF7FEFF 		bl	__aeabi_ldivmod
 430              	.LVL29:
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 431              		.loc 1 2113 23 view .LVU140
 432 022a B468     		ldr	r4, [r6, #8]
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 433              		.loc 1 2113 47 view .LVU141
 434 022c 8322     		movs	r2, #131
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 435              		.loc 1 2113 23 view .LVU142
 436 022e E117     		asrs	r1, r4, #31
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 437              		.loc 1 2113 41 view .LVU143
 438 0230 0904     		lsls	r1, r1, #16
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 439              		.loc 1 2113 47 view .LVU144
 440 0232 0023     		movs	r3, #0
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 441              		.loc 1 2112 15 view .LVU145
 442 0234 7060     		str	r0, [r6, #4]
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 443              		.loc 1 2113 5 is_stmt 1 view .LVU146
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 444              		.loc 1 2113 47 is_stmt 0 view .LVU147
 445 0236 41EA1441 		orr	r1, r1, r4, lsr #16
 446 023a 2004     		lsls	r0, r4, #16
 447 023c FFF7FEFF 		bl	__aeabi_ldivmod
 448              	.LVL30:
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 449              		.loc 1 2113 64 view .LVU148
 450 0240 0023     		movs	r3, #0
 451 0242 3A46     		mov	r2, r7
 452 0244 FFF7FEFF 		bl	__aeabi_ldivmod
 453              	.LVL31:
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 454              		.loc 1 2113 15 view .LVU149
 455 0248 B060     		str	r0, [r6, #8]
2114:Src/mpu6050.c ****         packet_count);
 456              		.loc 1 2114 5 is_stmt 1 view .LVU150
2114:Src/mpu6050.c ****         packet_count);
 457              		.loc 1 2114 24 is_stmt 0 view .LVU151
 458 024a 2B68     		ldr	r3, [r5]
 459 024c D917     		asrs	r1, r3, #31
2114:Src/mpu6050.c ****         packet_count);
 460              		.loc 1 2114 43 view .LVU152
 461 024e 0904     		lsls	r1, r1, #16
2114:Src/mpu6050.c ****         packet_count);
 462              		.loc 1 2114 49 view .LVU153
 463 0250 51EA1341 		orrs	r1, r1, r3, lsr #16
2114:Src/mpu6050.c ****         packet_count);
 464              		.loc 1 2114 43 view .LVU154
 465 0254 4FEA0340 		lsl	r0, r3, #16
2114:Src/mpu6050.c ****         packet_count);
 466              		.loc 1 2114 49 view .LVU155
 467 0258 04D5     		bpl	.L10
ARM GAS  /tmp/ccC60hwS.s 			page 49


 468 025a 40F2FF73 		movw	r3, #2047
 469 025e C018     		adds	r0, r0, r3
 470 0260 41F10001 		adc	r1, r1, #0
 471              	.L10:
 472 0264 C00A     		lsrs	r0, r0, #11
2114:Src/mpu6050.c ****         packet_count);
 473              		.loc 1 2114 67 view .LVU156
 474 0266 0023     		movs	r3, #0
 475 0268 40EA4150 		orr	r0, r0, r1, lsl #21
 476 026c 3A46     		mov	r2, r7
 477 026e C912     		asrs	r1, r1, #11
 478 0270 FFF7FEFF 		bl	__aeabi_ldivmod
 479              	.LVL32:
2116:Src/mpu6050.c ****         packet_count);
 480              		.loc 1 2116 24 view .LVU157
 481 0274 6B68     		ldr	r3, [r5, #4]
2114:Src/mpu6050.c ****         packet_count);
 482              		.loc 1 2114 16 view .LVU158
 483 0276 2860     		str	r0, [r5]
2116:Src/mpu6050.c ****         packet_count);
 484              		.loc 1 2116 5 is_stmt 1 view .LVU159
2116:Src/mpu6050.c ****         packet_count);
 485              		.loc 1 2116 24 is_stmt 0 view .LVU160
 486 0278 D917     		asrs	r1, r3, #31
2116:Src/mpu6050.c ****         packet_count);
 487              		.loc 1 2116 43 view .LVU161
 488 027a 0904     		lsls	r1, r1, #16
2116:Src/mpu6050.c ****         packet_count);
 489              		.loc 1 2116 49 view .LVU162
 490 027c 51EA1341 		orrs	r1, r1, r3, lsr #16
2116:Src/mpu6050.c ****         packet_count);
 491              		.loc 1 2116 43 view .LVU163
 492 0280 4FEA0340 		lsl	r0, r3, #16
2116:Src/mpu6050.c ****         packet_count);
 493              		.loc 1 2116 49 view .LVU164
 494 0284 04D5     		bpl	.L11
 495 0286 40F2FF73 		movw	r3, #2047
 496 028a C018     		adds	r0, r0, r3
 497 028c 41F10001 		adc	r1, r1, #0
 498              	.L11:
 499 0290 C00A     		lsrs	r0, r0, #11
2116:Src/mpu6050.c ****         packet_count);
 500              		.loc 1 2116 67 view .LVU165
 501 0292 0023     		movs	r3, #0
 502 0294 40EA4150 		orr	r0, r0, r1, lsl #21
 503 0298 3A46     		mov	r2, r7
 504 029a C912     		asrs	r1, r1, #11
 505 029c FFF7FEFF 		bl	__aeabi_ldivmod
 506              	.LVL33:
2118:Src/mpu6050.c ****         packet_count);
 507              		.loc 1 2118 24 view .LVU166
 508 02a0 AB68     		ldr	r3, [r5, #8]
2116:Src/mpu6050.c ****         packet_count);
 509              		.loc 1 2116 16 view .LVU167
 510 02a2 6860     		str	r0, [r5, #4]
2118:Src/mpu6050.c ****         packet_count);
 511              		.loc 1 2118 5 is_stmt 1 view .LVU168
ARM GAS  /tmp/ccC60hwS.s 			page 50


2118:Src/mpu6050.c ****         packet_count);
 512              		.loc 1 2118 24 is_stmt 0 view .LVU169
 513 02a4 D917     		asrs	r1, r3, #31
2118:Src/mpu6050.c ****         packet_count);
 514              		.loc 1 2118 43 view .LVU170
 515 02a6 0904     		lsls	r1, r1, #16
2118:Src/mpu6050.c ****         packet_count);
 516              		.loc 1 2118 49 view .LVU171
 517 02a8 51EA1341 		orrs	r1, r1, r3, lsr #16
2118:Src/mpu6050.c ****         packet_count);
 518              		.loc 1 2118 43 view .LVU172
 519 02ac 4FEA0340 		lsl	r0, r3, #16
2118:Src/mpu6050.c ****         packet_count);
 520              		.loc 1 2118 49 view .LVU173
 521 02b0 04D5     		bpl	.L12
 522 02b2 40F2FF73 		movw	r3, #2047
 523 02b6 C018     		adds	r0, r0, r3
 524 02b8 41F10001 		adc	r1, r1, #0
 525              	.L12:
 526 02bc C00A     		lsrs	r0, r0, #11
2118:Src/mpu6050.c ****         packet_count);
 527              		.loc 1 2118 67 view .LVU174
 528 02be 40EA4150 		orr	r0, r0, r1, lsl #21
 529 02c2 3A46     		mov	r2, r7
 530 02c4 0023     		movs	r3, #0
 531 02c6 C912     		asrs	r1, r1, #11
 532 02c8 FFF7FEFF 		bl	__aeabi_ldivmod
 533              	.LVL34:
2121:Src/mpu6050.c ****         accel[2] -= 65536L;
 534              		.loc 1 2121 5 is_stmt 1 view .LVU175
2121:Src/mpu6050.c ****         accel[2] -= 65536L;
 535              		.loc 1 2121 8 is_stmt 0 view .LVU176
 536 02cc 0028     		cmp	r0, #0
2122:Src/mpu6050.c ****     else
 537              		.loc 1 2122 9 is_stmt 1 view .LVU177
2122:Src/mpu6050.c ****     else
 538              		.loc 1 2122 18 is_stmt 0 view .LVU178
 539 02ce CCBF     		ite	gt
 540 02d0 A0F58030 		subgt	r0, r0, #65536
2124:Src/mpu6050.c **** #endif
 541              		.loc 1 2124 9 is_stmt 1 view .LVU179
2124:Src/mpu6050.c **** #endif
 542              		.loc 1 2124 18 is_stmt 0 view .LVU180
 543 02d4 00F58030 		addle	r0, r0, #65536
 544 02d8 A860     		str	r0, [r5, #8]
2127:Src/mpu6050.c **** }
 545              		.loc 1 2127 12 view .LVU181
 546 02da 0020     		movs	r0, #0
 547 02dc A9E6     		b	.L1
 548              	.LVL35:
 549              	.L14:
2052:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
 550              		.loc 1 2052 17 view .LVU182
 551 02de 1823     		movs	r3, #24
 552 02e0 28E7     		b	.L6
 553              	.L23:
 554 02e2 00BF     		.align	2
ARM GAS  /tmp/ccC60hwS.s 			page 51


 555              	.L22:
 556 02e4 00000000 		.word	.LANCHOR0
 557              	.LVL36:
 558              	.L9:
 559              	.LBB7:
2080:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
 560              		.loc 1 2080 9 is_stmt 1 view .LVU183
2081:Src/mpu6050.c ****             return -1;
 561              		.loc 1 2081 9 view .LVU184
2081:Src/mpu6050.c ****             return -1;
 562              		.loc 1 2081 13 is_stmt 0 view .LVU185
 563 02e8 D4E90010 		ldrd	r1, r0, [r4]
 564 02ec 0C22     		movs	r2, #12
 565 02ee 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 566 02f0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 567 02f2 01AB     		add	r3, sp, #4
 568 02f4 FFF7FEFF 		bl	i2c_readBytes
 569              	.LVL37:
2081:Src/mpu6050.c ****             return -1;
 570              		.loc 1 2081 12 view .LVU186
 571 02f8 08F10108 		add	r8, r8, #1
 572              	.LVL38:
2081:Src/mpu6050.c ****             return -1;
 573              		.loc 1 2081 12 view .LVU187
 574 02fc 0028     		cmp	r0, #0
 575 02fe 7FF496AE 		bne	.L4
2083:Src/mpu6050.c ****         accel_cur[1] = ((short)data[2] << 8) | data[3];
 576              		.loc 1 2083 9 is_stmt 1 view .LVU188
 577              	.LVL39:
2084:Src/mpu6050.c ****         accel_cur[2] = ((short)data[4] << 8) | data[5];
 578              		.loc 1 2084 9 view .LVU189
 579 0302 BDF80630 		ldrh	r3, [sp, #6]
 580 0306 D9BA     		revsh	r1, r3
 581              	.LVL40:
2085:Src/mpu6050.c ****         accel[0] += (long)accel_cur[0];
 582              		.loc 1 2085 9 view .LVU190
 583 0308 BDF80830 		ldrh	r3, [sp, #8]
 584 030c DABA     		revsh	r2, r3
 585              	.LVL41:
2086:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 586              		.loc 1 2086 9 view .LVU191
2086:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 587              		.loc 1 2086 21 is_stmt 0 view .LVU192
 588 030e BDF80430 		ldrh	r3, [sp, #4]
 589 0312 D8BA     		revsh	r0, r3
2086:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 590              		.loc 1 2086 18 view .LVU193
 591 0314 2B68     		ldr	r3, [r5]
 592 0316 0344     		add	r3, r3, r0
 593 0318 2B60     		str	r3, [r5]
2087:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
 594              		.loc 1 2087 9 is_stmt 1 view .LVU194
2087:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
 595              		.loc 1 2087 18 is_stmt 0 view .LVU195
 596 031a 6B68     		ldr	r3, [r5, #4]
 597 031c 0B44     		add	r3, r3, r1
 598 031e 6B60     		str	r3, [r5, #4]
ARM GAS  /tmp/ccC60hwS.s 			page 52


2088:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
 599              		.loc 1 2088 9 is_stmt 1 view .LVU196
2088:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
 600              		.loc 1 2088 18 is_stmt 0 view .LVU197
 601 0320 AB68     		ldr	r3, [r5, #8]
 602 0322 1344     		add	r3, r3, r2
 603 0324 AB60     		str	r3, [r5, #8]
2089:Src/mpu6050.c ****         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
 604              		.loc 1 2089 9 is_stmt 1 view .LVU198
 605              	.LVL42:
2090:Src/mpu6050.c ****         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
 606              		.loc 1 2090 9 view .LVU199
 607 0326 BDF80C30 		ldrh	r3, [sp, #12]
 608 032a D9BA     		revsh	r1, r3
 609              	.LVL43:
2091:Src/mpu6050.c ****         gyro[0] += (long)gyro_cur[0];
 610              		.loc 1 2091 9 view .LVU200
 611 032c BDF80E30 		ldrh	r3, [sp, #14]
 612 0330 DABA     		revsh	r2, r3
 613              	.LVL44:
2092:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 614              		.loc 1 2092 9 view .LVU201
2092:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 615              		.loc 1 2092 20 is_stmt 0 view .LVU202
 616 0332 BDF80A30 		ldrh	r3, [sp, #10]
 617 0336 D8BA     		revsh	r0, r3
2092:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 618              		.loc 1 2092 17 view .LVU203
 619 0338 3368     		ldr	r3, [r6]
 620 033a 0344     		add	r3, r3, r0
 621 033c 3360     		str	r3, [r6]
2093:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
 622              		.loc 1 2093 9 is_stmt 1 view .LVU204
2093:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
 623              		.loc 1 2093 17 is_stmt 0 view .LVU205
 624 033e 7368     		ldr	r3, [r6, #4]
 625 0340 0B44     		add	r3, r3, r1
 626 0342 7360     		str	r3, [r6, #4]
2094:Src/mpu6050.c ****     }
 627              		.loc 1 2094 9 is_stmt 1 view .LVU206
2094:Src/mpu6050.c ****     }
 628              		.loc 1 2094 17 is_stmt 0 view .LVU207
 629 0344 B368     		ldr	r3, [r6, #8]
 630 0346 1344     		add	r3, r3, r2
 631 0348 B360     		str	r3, [r6, #8]
 632              	.LBE7:
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 633              		.loc 1 2079 37 is_stmt 1 view .LVU208
 634              	.LVL45:
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 635              		.loc 1 2079 37 is_stmt 0 view .LVU209
 636 034a 4DE7     		b	.L8
 637              		.cfi_endproc
 638              	.LFE99:
 640              		.section	.text.set_int_enable.isra.0,"ax",%progbits
 641              		.align	1
 642              		.syntax unified
ARM GAS  /tmp/ccC60hwS.s 			page 53


 643              		.thumb
 644              		.thumb_func
 645              		.fpu softvfp
 647              	set_int_enable.isra.0:
 648              	.LVL46:
 649              	.LFB124:
 577:Src/mpu6050.c **** {
 650              		.loc 1 577 12 is_stmt 1 view -0
 651              		.cfi_startproc
 652              		@ args = 0, pretend = 0, frame = 8
 653              		@ frame_needed = 0, uses_anonymous_args = 0
 579:Src/mpu6050.c **** 
 654              		.loc 1 579 5 view .LVU211
 581:Src/mpu6050.c ****         if (enable)
 655              		.loc 1 581 5 view .LVU212
 577:Src/mpu6050.c **** {
 656              		.loc 1 577 12 is_stmt 0 view .LVU213
 657 0000 13B5     		push	{r0, r1, r4, lr}
 658              	.LCFI4:
 659              		.cfi_def_cfa_offset 16
 660              		.cfi_offset 4, -8
 661              		.cfi_offset 14, -4
 581:Src/mpu6050.c ****         if (enable)
 662              		.loc 1 581 20 view .LVU214
 663 0002 114C     		ldr	r4, .L37
 581:Src/mpu6050.c ****         if (enable)
 664              		.loc 1 581 8 view .LVU215
 665 0004 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 666 0008 2BB1     		cbz	r3, .L25
 582:Src/mpu6050.c ****             tmp = BIT_DMP_INT_EN;
 667              		.loc 1 582 9 is_stmt 1 view .LVU216
 583:Src/mpu6050.c ****         else
 668              		.loc 1 583 17 is_stmt 0 view .LVU217
 669 000a 0028     		cmp	r0, #0
 670 000c 18BF     		it	ne
 671 000e 0220     		movne	r0, #2
 672              	.LVL47:
 673              	.L30:
 594:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 674              		.loc 1 594 9 is_stmt 1 view .LVU218
 597:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 675              		.loc 1 597 13 view .LVU219
 597:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 676              		.loc 1 597 17 is_stmt 0 view .LVU220
 677 0010 8DF80700 		strb	r0, [sp, #7]
 678 0014 08E0     		b	.L31
 679              	.LVL48:
 680              	.L25:
 590:Src/mpu6050.c ****             return -1;
 681              		.loc 1 590 9 is_stmt 1 view .LVU221
 590:Src/mpu6050.c ****             return -1;
 682              		.loc 1 590 12 is_stmt 0 view .LVU222
 683 0016 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 684 0018 9BB1     		cbz	r3, .L24
 592:Src/mpu6050.c ****             return 0;
 685              		.loc 1 592 9 is_stmt 1 view .LVU223
 592:Src/mpu6050.c ****             return 0;
ARM GAS  /tmp/ccC60hwS.s 			page 54


 686              		.loc 1 592 12 is_stmt 0 view .LVU224
 687 001a 0028     		cmp	r0, #0
 688 001c F8D0     		beq	.L30
 592:Src/mpu6050.c ****             return 0;
 689              		.loc 1 592 20 view .LVU225
 690 001e 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
 691 0020 7BB9     		cbnz	r3, .L24
 594:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 692              		.loc 1 594 9 is_stmt 1 view .LVU226
 595:Src/mpu6050.c ****         else
 693              		.loc 1 595 13 view .LVU227
 595:Src/mpu6050.c ****         else
 694              		.loc 1 595 17 is_stmt 0 view .LVU228
 695 0022 0123     		movs	r3, #1
 696 0024 8DF80730 		strb	r3, [sp, #7]
 697              	.LVL49:
 698              	.L31:
 598:Src/mpu6050.c ****             return -1;
 699              		.loc 1 598 9 is_stmt 1 view .LVU229
 598:Src/mpu6050.c ****             return -1;
 700              		.loc 1 598 13 is_stmt 0 view .LVU230
 701 0028 D4E90010 		ldrd	r1, r0, [r4]
 702 002c 0122     		movs	r2, #1
 703 002e 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 704 0030 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 705 0032 0DF10703 		add	r3, sp, #7
 706 0036 FFF7FEFF 		bl	i2c_writeBytes
 707              	.LVL50:
 598:Src/mpu6050.c ****             return -1;
 708              		.loc 1 598 12 view .LVU231
 709 003a 10B9     		cbnz	r0, .L24
 600:Src/mpu6050.c ****     }
 710              		.loc 1 600 9 is_stmt 1 view .LVU232
 600:Src/mpu6050.c ****     }
 711              		.loc 1 600 32 is_stmt 0 view .LVU233
 712 003c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 713 0040 6374     		strb	r3, [r4, #17]
 714              	.L24:
 603:Src/mpu6050.c **** 
 715              		.loc 1 603 1 view .LVU234
 716 0042 02B0     		add	sp, sp, #8
 717              	.LCFI5:
 718              		.cfi_def_cfa_offset 8
 719              		@ sp needed
 720 0044 10BD     		pop	{r4, pc}
 721              	.L38:
 722 0046 00BF     		.align	2
 723              	.L37:
 724 0048 00000000 		.word	.LANCHOR0
 725              		.cfi_endproc
 726              	.LFE124:
 728              		.section	.text.mpu_reg_dump,"ax",%progbits
 729              		.align	1
 730              		.global	mpu_reg_dump
 731              		.syntax unified
 732              		.thumb
 733              		.thumb_func
ARM GAS  /tmp/ccC60hwS.s 			page 55


 734              		.fpu softvfp
 736              	mpu_reg_dump:
 737              	.LFB60:
 610:Src/mpu6050.c ****     unsigned char ii;
 738              		.loc 1 610 1 is_stmt 1 view -0
 739              		.cfi_startproc
 740              		@ args = 0, pretend = 0, frame = 8
 741              		@ frame_needed = 0, uses_anonymous_args = 0
 611:Src/mpu6050.c ****     unsigned char data;
 742              		.loc 1 611 5 view .LVU236
 612:Src/mpu6050.c **** 
 743              		.loc 1 612 5 view .LVU237
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 744              		.loc 1 614 5 view .LVU238
 745              	.LVL51:
 610:Src/mpu6050.c ****     unsigned char ii;
 746              		.loc 1 610 1 is_stmt 0 view .LVU239
 747 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 748              	.LCFI6:
 749              		.cfi_def_cfa_offset 24
 750              		.cfi_offset 4, -12
 751              		.cfi_offset 5, -8
 752              		.cfi_offset 14, -4
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 753              		.loc 1 614 5 view .LVU240
 754 0002 0024     		movs	r4, #0
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 755              		.loc 1 614 25 view .LVU241
 756 0004 0E4D     		ldr	r5, .L46
 757              	.LVL52:
 758              	.L40:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 759              		.loc 1 614 25 discriminator 1 view .LVU242
 760 0006 6868     		ldr	r0, [r5, #4]
 761 0008 E1B2     		uxtb	r1, r4
 762              	.LVL53:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 763              		.loc 1 614 18 is_stmt 1 discriminator 1 view .LVU243
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 764              		.loc 1 614 5 is_stmt 0 discriminator 1 view .LVU244
 765 000a 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 766 000c 8B42     		cmp	r3, r1
 767 000e 02D8     		bhi	.L44
 623:Src/mpu6050.c **** }
 768              		.loc 1 623 12 view .LVU245
 769 0010 0020     		movs	r0, #0
 770              	.LVL54:
 771              	.L39:
 624:Src/mpu6050.c **** 
 772              		.loc 1 624 1 view .LVU246
 773 0012 03B0     		add	sp, sp, #12
 774              	.LCFI7:
 775              		.cfi_remember_state
 776              		.cfi_def_cfa_offset 12
 777              		@ sp needed
 778 0014 30BD     		pop	{r4, r5, pc}
 779              	.LVL55:
ARM GAS  /tmp/ccC60hwS.s 			page 56


 780              	.L44:
 781              	.LCFI8:
 782              		.cfi_restore_state
 615:Src/mpu6050.c ****             continue;
 783              		.loc 1 615 9 is_stmt 1 view .LVU247
 615:Src/mpu6050.c ****             continue;
 784              		.loc 1 615 21 is_stmt 0 view .LVU248
 785 0016 2B68     		ldr	r3, [r5]
 615:Src/mpu6050.c ****             continue;
 786              		.loc 1 615 12 view .LVU249
 787 0018 5A7B     		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 788 001a 8A42     		cmp	r2, r1
 789 001c 01D1     		bne	.L41
 790              	.LVL56:
 791              	.L42:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 792              		.loc 1 614 39 is_stmt 1 view .LVU250
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 793              		.loc 1 614 39 is_stmt 0 view .LVU251
 794 001e 0134     		adds	r4, r4, #1
 795              	.LVL57:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 796              		.loc 1 614 39 view .LVU252
 797 0020 F1E7     		b	.L40
 798              	.LVL58:
 799              	.L41:
 615:Src/mpu6050.c ****             continue;
 800              		.loc 1 615 36 discriminator 1 view .LVU253
 801 0022 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 802 0024 8B42     		cmp	r3, r1
 803 0026 FAD0     		beq	.L42
 617:Src/mpu6050.c ****             return -1;
 804              		.loc 1 617 9 is_stmt 1 view .LVU254
 617:Src/mpu6050.c ****             return -1;
 805              		.loc 1 617 13 is_stmt 0 view .LVU255
 806 0028 0122     		movs	r2, #1
 807 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 808 002c 0DF10703 		add	r3, sp, #7
 809 0030 FFF7FEFF 		bl	i2c_readBytes
 810              	.LVL59:
 617:Src/mpu6050.c ****             return -1;
 811              		.loc 1 617 12 view .LVU256
 812 0034 0028     		cmp	r0, #0
 813 0036 F2D0     		beq	.L42
 618:Src/mpu6050.c ****             #ifdef SERIAL_DEBUG
 814              		.loc 1 618 20 view .LVU257
 815 0038 4FF0FF30 		mov	r0, #-1
 816 003c E9E7     		b	.L39
 817              	.L47:
 818 003e 00BF     		.align	2
 819              	.L46:
 820 0040 00000000 		.word	.LANCHOR0
 821              		.cfi_endproc
 822              	.LFE60:
 824              		.section	.text.mpu_read_reg,"ax",%progbits
 825              		.align	1
 826              		.global	mpu_read_reg
ARM GAS  /tmp/ccC60hwS.s 			page 57


 827              		.syntax unified
 828              		.thumb
 829              		.thumb_func
 830              		.fpu softvfp
 832              	mpu_read_reg:
 833              	.LVL60:
 834              	.LFB61:
 634:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 835              		.loc 1 634 1 is_stmt 1 view -0
 836              		.cfi_startproc
 837              		@ args = 0, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 635:Src/mpu6050.c ****         return -1;
 839              		.loc 1 635 5 view .LVU259
 634:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 840              		.loc 1 634 1 is_stmt 0 view .LVU260
 841 0000 10B5     		push	{r4, lr}
 842              	.LCFI9:
 843              		.cfi_def_cfa_offset 8
 844              		.cfi_offset 4, -8
 845              		.cfi_offset 14, -4
 635:Src/mpu6050.c ****         return -1;
 846              		.loc 1 635 18 view .LVU261
 847 0002 0B4A     		ldr	r2, .L53
 634:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 848              		.loc 1 634 1 view .LVU262
 849 0004 0B46     		mov	r3, r1
 635:Src/mpu6050.c ****         return -1;
 850              		.loc 1 635 18 view .LVU263
 851 0006 1168     		ldr	r1, [r2]
 852              	.LVL61:
 635:Src/mpu6050.c ****         return -1;
 853              		.loc 1 635 8 view .LVU264
 854 0008 4C7B     		ldrb	r4, [r1, #13]	@ zero_extendqisi2
 855 000a 8442     		cmp	r4, r0
 856 000c 0CD0     		beq	.L52
 635:Src/mpu6050.c ****         return -1;
 857              		.loc 1 635 33 discriminator 1 view .LVU265
 858 000e 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 859 0010 8142     		cmp	r1, r0
 860 0012 09D0     		beq	.L52
 637:Src/mpu6050.c ****         return -1;
 861              		.loc 1 637 5 is_stmt 1 view .LVU266
 637:Src/mpu6050.c ****         return -1;
 862              		.loc 1 637 18 is_stmt 0 view .LVU267
 863 0014 5468     		ldr	r4, [r2, #4]
 637:Src/mpu6050.c ****         return -1;
 864              		.loc 1 637 8 view .LVU268
 865 0016 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 866 0018 8242     		cmp	r2, r0
 867 001a 05D9     		bls	.L52
 639:Src/mpu6050.c **** }
 868              		.loc 1 639 5 is_stmt 1 view .LVU269
 639:Src/mpu6050.c **** }
 869              		.loc 1 639 12 is_stmt 0 view .LVU270
 870 001c 0146     		mov	r1, r0
 871 001e 0122     		movs	r2, #1
ARM GAS  /tmp/ccC60hwS.s 			page 58


 872 0020 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 873              	.LVL62:
 639:Src/mpu6050.c **** }
 874              		.loc 1 639 12 view .LVU271
 875 0022 FFF7FEFF 		bl	i2c_readBytes
 876              	.LVL63:
 877              	.L48:
 640:Src/mpu6050.c **** 
 878              		.loc 1 640 1 view .LVU272
 879 0026 10BD     		pop	{r4, pc}
 880              	.LVL64:
 881              	.L52:
 636:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 882              		.loc 1 636 16 view .LVU273
 883 0028 4FF0FF30 		mov	r0, #-1
 884              	.LVL65:
 636:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 885              		.loc 1 636 16 view .LVU274
 886 002c FBE7     		b	.L48
 887              	.L54:
 888 002e 00BF     		.align	2
 889              	.L53:
 890 0030 00000000 		.word	.LANCHOR0
 891              		.cfi_endproc
 892              	.LFE61:
 894              		.section	.text.mpu_get_gyro_reg,"ax",%progbits
 895              		.align	1
 896              		.global	mpu_get_gyro_reg
 897              		.syntax unified
 898              		.thumb
 899              		.thumb_func
 900              		.fpu softvfp
 902              	mpu_get_gyro_reg:
 903              	.LVL66:
 904              	.LFB64:
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 905              		.loc 1 829 1 is_stmt 1 view -0
 906              		.cfi_startproc
 907              		@ args = 0, pretend = 0, frame = 8
 908              		@ frame_needed = 0, uses_anonymous_args = 0
 830:Src/mpu6050.c **** 
 909              		.loc 1 830 5 view .LVU276
 832:Src/mpu6050.c ****         return -1;
 910              		.loc 1 832 5 view .LVU277
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 911              		.loc 1 829 1 is_stmt 0 view .LVU278
 912 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 913              	.LCFI10:
 914              		.cfi_def_cfa_offset 24
 915              		.cfi_offset 4, -16
 916              		.cfi_offset 5, -12
 917              		.cfi_offset 6, -8
 918              		.cfi_offset 14, -4
 832:Src/mpu6050.c ****         return -1;
 919              		.loc 1 832 22 view .LVU279
 920 0002 144B     		ldr	r3, .L60
 829:Src/mpu6050.c ****     unsigned char tmp[6];
ARM GAS  /tmp/ccC60hwS.s 			page 59


 921              		.loc 1 829 1 view .LVU280
 922 0004 0546     		mov	r5, r0
 832:Src/mpu6050.c ****         return -1;
 923              		.loc 1 832 8 view .LVU281
 924 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 925              		.loc 1 829 1 view .LVU282
 926 0008 0C46     		mov	r4, r1
 832:Src/mpu6050.c ****         return -1;
 927              		.loc 1 832 8 view .LVU283
 928 000a 12F0700F 		tst	r2, #112
 929 000e 03D1     		bne	.L56
 930              	.LVL67:
 931              	.L58:
 833:Src/mpu6050.c **** 
 932              		.loc 1 833 16 view .LVU284
 933 0010 4FF0FF30 		mov	r0, #-1
 934              	.L55:
 843:Src/mpu6050.c **** 
 935              		.loc 1 843 1 view .LVU285
 936 0014 02B0     		add	sp, sp, #8
 937              	.LCFI11:
 938              		.cfi_remember_state
 939              		.cfi_def_cfa_offset 16
 940              		@ sp needed
 941 0016 70BD     		pop	{r4, r5, r6, pc}
 942              	.LVL68:
 943              	.L56:
 944              	.LCFI12:
 945              		.cfi_restore_state
 835:Src/mpu6050.c ****         return -1;
 946              		.loc 1 835 5 is_stmt 1 view .LVU286
 835:Src/mpu6050.c ****         return -1;
 947              		.loc 1 835 9 is_stmt 0 view .LVU287
 948 0018 D3E90010 		ldrd	r1, r0, [r3]
 949              	.LVL69:
 835:Src/mpu6050.c ****         return -1;
 950              		.loc 1 835 9 view .LVU288
 951 001c 0622     		movs	r2, #6
 952 001e 6B46     		mov	r3, sp
 953 0020 897B     		ldrb	r1, [r1, #14]	@ zero_extendqisi2
 954 0022 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 955 0024 FFF7FEFF 		bl	i2c_readBytes
 956              	.LVL70:
 835:Src/mpu6050.c ****         return -1;
 957              		.loc 1 835 8 view .LVU289
 958 0028 0646     		mov	r6, r0
 959 002a 0028     		cmp	r0, #0
 960 002c F0D1     		bne	.L58
 837:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 961              		.loc 1 837 5 is_stmt 1 view .LVU290
 837:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 962              		.loc 1 837 13 is_stmt 0 view .LVU291
 963 002e BDF80030 		ldrh	r3, [sp]
 841:Src/mpu6050.c ****     return 0;
 964              		.loc 1 841 9 view .LVU292
 965 0032 2046     		mov	r0, r4
ARM GAS  /tmp/ccC60hwS.s 			page 60


 837:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 966              		.loc 1 837 13 view .LVU293
 967 0034 5BBA     		rev16	r3, r3
 968 0036 2B80     		strh	r3, [r5]	@ movhi
 838:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 969              		.loc 1 838 5 is_stmt 1 view .LVU294
 838:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 970              		.loc 1 838 13 is_stmt 0 view .LVU295
 971 0038 BDF80230 		ldrh	r3, [sp, #2]
 972 003c 5BBA     		rev16	r3, r3
 973 003e 6B80     		strh	r3, [r5, #2]	@ movhi
 839:Src/mpu6050.c ****     if (timestamp)
 974              		.loc 1 839 5 is_stmt 1 view .LVU296
 839:Src/mpu6050.c ****     if (timestamp)
 975              		.loc 1 839 13 is_stmt 0 view .LVU297
 976 0040 BDF80430 		ldrh	r3, [sp, #4]
 977 0044 5BBA     		rev16	r3, r3
 978 0046 AB80     		strh	r3, [r5, #4]	@ movhi
 840:Src/mpu6050.c ****         get_ms(timestamp);
 979              		.loc 1 840 5 is_stmt 1 view .LVU298
 840:Src/mpu6050.c ****         get_ms(timestamp);
 980              		.loc 1 840 8 is_stmt 0 view .LVU299
 981 0048 002C     		cmp	r4, #0
 982 004a E3D0     		beq	.L55
 983              	.LVL71:
 841:Src/mpu6050.c ****     return 0;
 984              		.loc 1 841 9 is_stmt 1 view .LVU300
 985 004c FFF7FEFF 		bl	get_tick_count_ms
 986              	.LVL72:
 842:Src/mpu6050.c **** }
 987              		.loc 1 842 12 is_stmt 0 view .LVU301
 988 0050 3046     		mov	r0, r6
 989 0052 DFE7     		b	.L55
 990              	.L61:
 991              		.align	2
 992              	.L60:
 993 0054 00000000 		.word	.LANCHOR0
 994              		.cfi_endproc
 995              	.LFE64:
 997              		.section	.text.mpu_get_accel_reg,"ax",%progbits
 998              		.align	1
 999              		.global	mpu_get_accel_reg
 1000              		.syntax unified
 1001              		.thumb
 1002              		.thumb_func
 1003              		.fpu softvfp
 1005              	mpu_get_accel_reg:
 1006              	.LVL73:
 1007              	.LFB65:
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1008              		.loc 1 852 1 is_stmt 1 view -0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 8
 1011              		@ frame_needed = 0, uses_anonymous_args = 0
 853:Src/mpu6050.c **** 
 1012              		.loc 1 853 5 view .LVU303
 855:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 61


 1013              		.loc 1 855 5 view .LVU304
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1014              		.loc 1 852 1 is_stmt 0 view .LVU305
 1015 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1016              	.LCFI13:
 1017              		.cfi_def_cfa_offset 24
 1018              		.cfi_offset 4, -16
 1019              		.cfi_offset 5, -12
 1020              		.cfi_offset 6, -8
 1021              		.cfi_offset 14, -4
 855:Src/mpu6050.c ****         return -1;
 1022              		.loc 1 855 22 view .LVU306
 1023 0002 144B     		ldr	r3, .L67
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1024              		.loc 1 852 1 view .LVU307
 1025 0004 0546     		mov	r5, r0
 855:Src/mpu6050.c ****         return -1;
 1026              		.loc 1 855 8 view .LVU308
 1027 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1028              		.loc 1 852 1 view .LVU309
 1029 0008 0C46     		mov	r4, r1
 855:Src/mpu6050.c ****         return -1;
 1030              		.loc 1 855 8 view .LVU310
 1031 000a 1207     		lsls	r2, r2, #28
 1032 000c 03D4     		bmi	.L63
 1033              	.LVL74:
 1034              	.L65:
 856:Src/mpu6050.c **** 
 1035              		.loc 1 856 16 view .LVU311
 1036 000e 4FF0FF30 		mov	r0, #-1
 1037              	.L62:
 866:Src/mpu6050.c **** 
 1038              		.loc 1 866 1 view .LVU312
 1039 0012 02B0     		add	sp, sp, #8
 1040              	.LCFI14:
 1041              		.cfi_remember_state
 1042              		.cfi_def_cfa_offset 16
 1043              		@ sp needed
 1044 0014 70BD     		pop	{r4, r5, r6, pc}
 1045              	.LVL75:
 1046              	.L63:
 1047              	.LCFI15:
 1048              		.cfi_restore_state
 858:Src/mpu6050.c ****         return -1;
 1049              		.loc 1 858 5 is_stmt 1 view .LVU313
 858:Src/mpu6050.c ****         return -1;
 1050              		.loc 1 858 9 is_stmt 0 view .LVU314
 1051 0016 D3E90010 		ldrd	r1, r0, [r3]
 1052              	.LVL76:
 858:Src/mpu6050.c ****         return -1;
 1053              		.loc 1 858 9 view .LVU315
 1054 001a 0622     		movs	r2, #6
 1055 001c 6B46     		mov	r3, sp
 1056 001e C97B     		ldrb	r1, [r1, #15]	@ zero_extendqisi2
 1057 0020 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1058 0022 FFF7FEFF 		bl	i2c_readBytes
ARM GAS  /tmp/ccC60hwS.s 			page 62


 1059              	.LVL77:
 858:Src/mpu6050.c ****         return -1;
 1060              		.loc 1 858 8 view .LVU316
 1061 0026 0646     		mov	r6, r0
 1062 0028 0028     		cmp	r0, #0
 1063 002a F0D1     		bne	.L65
 860:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1064              		.loc 1 860 5 is_stmt 1 view .LVU317
 860:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1065              		.loc 1 860 13 is_stmt 0 view .LVU318
 1066 002c BDF80030 		ldrh	r3, [sp]
 864:Src/mpu6050.c ****     return 0;
 1067              		.loc 1 864 9 view .LVU319
 1068 0030 2046     		mov	r0, r4
 860:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1069              		.loc 1 860 13 view .LVU320
 1070 0032 5BBA     		rev16	r3, r3
 1071 0034 2B80     		strh	r3, [r5]	@ movhi
 861:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1072              		.loc 1 861 5 is_stmt 1 view .LVU321
 861:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1073              		.loc 1 861 13 is_stmt 0 view .LVU322
 1074 0036 BDF80230 		ldrh	r3, [sp, #2]
 1075 003a 5BBA     		rev16	r3, r3
 1076 003c 6B80     		strh	r3, [r5, #2]	@ movhi
 862:Src/mpu6050.c ****     if (timestamp)
 1077              		.loc 1 862 5 is_stmt 1 view .LVU323
 862:Src/mpu6050.c ****     if (timestamp)
 1078              		.loc 1 862 13 is_stmt 0 view .LVU324
 1079 003e BDF80430 		ldrh	r3, [sp, #4]
 1080 0042 5BBA     		rev16	r3, r3
 1081 0044 AB80     		strh	r3, [r5, #4]	@ movhi
 863:Src/mpu6050.c ****         get_ms(timestamp);
 1082              		.loc 1 863 5 is_stmt 1 view .LVU325
 863:Src/mpu6050.c ****         get_ms(timestamp);
 1083              		.loc 1 863 8 is_stmt 0 view .LVU326
 1084 0046 002C     		cmp	r4, #0
 1085 0048 E3D0     		beq	.L62
 1086              	.LVL78:
 864:Src/mpu6050.c ****     return 0;
 1087              		.loc 1 864 9 is_stmt 1 view .LVU327
 1088 004a FFF7FEFF 		bl	get_tick_count_ms
 1089              	.LVL79:
 865:Src/mpu6050.c **** }
 1090              		.loc 1 865 12 is_stmt 0 view .LVU328
 1091 004e 3046     		mov	r0, r6
 1092 0050 DFE7     		b	.L62
 1093              	.L68:
 1094 0052 00BF     		.align	2
 1095              	.L67:
 1096 0054 00000000 		.word	.LANCHOR0
 1097              		.cfi_endproc
 1098              	.LFE65:
 1100              		.global	__aeabi_i2f
 1101              		.global	__aeabi_fsub
 1102              		.global	__aeabi_fdiv
 1103              		.global	__aeabi_fadd
ARM GAS  /tmp/ccC60hwS.s 			page 63


 1104              		.global	__aeabi_fmul
 1105              		.global	__aeabi_f2iz
 1106              		.section	.text.mpu_get_temperature,"ax",%progbits
 1107              		.align	1
 1108              		.global	mpu_get_temperature
 1109              		.syntax unified
 1110              		.thumb
 1111              		.thumb_func
 1112              		.fpu softvfp
 1114              	mpu_get_temperature:
 1115              	.LVL80:
 1116              	.LFB66:
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1117              		.loc 1 875 1 is_stmt 1 view -0
 1118              		.cfi_startproc
 1119              		@ args = 0, pretend = 0, frame = 8
 1120              		@ frame_needed = 0, uses_anonymous_args = 0
 876:Src/mpu6050.c ****     short raw;
 1121              		.loc 1 876 5 view .LVU330
 877:Src/mpu6050.c **** 
 1122              		.loc 1 877 5 view .LVU331
 879:Src/mpu6050.c ****         return -1;
 1123              		.loc 1 879 5 view .LVU332
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1124              		.loc 1 875 1 is_stmt 0 view .LVU333
 1125 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1126              	.LCFI16:
 1127              		.cfi_def_cfa_offset 32
 1128              		.cfi_offset 4, -20
 1129              		.cfi_offset 5, -16
 1130              		.cfi_offset 6, -12
 1131              		.cfi_offset 7, -8
 1132              		.cfi_offset 14, -4
 879:Src/mpu6050.c ****         return -1;
 1133              		.loc 1 879 22 view .LVU334
 1134 0002 1D4C     		ldr	r4, .L77
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1135              		.loc 1 875 1 view .LVU335
 1136 0004 0646     		mov	r6, r0
 879:Src/mpu6050.c ****         return -1;
 1137              		.loc 1 879 8 view .LVU336
 1138 0006 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1139              		.loc 1 875 1 view .LVU337
 1140 0008 0D46     		mov	r5, r1
 879:Src/mpu6050.c ****         return -1;
 1141              		.loc 1 879 8 view .LVU338
 1142 000a 1BB9     		cbnz	r3, .L70
 1143              	.LVL81:
 1144              	.L72:
 880:Src/mpu6050.c **** 
 1145              		.loc 1 880 16 view .LVU339
 1146 000c 4FF0FF30 		mov	r0, #-1
 1147              	.LVL82:
 1148              	.L69:
 890:Src/mpu6050.c **** 
 1149              		.loc 1 890 1 view .LVU340
ARM GAS  /tmp/ccC60hwS.s 			page 64


 1150 0010 03B0     		add	sp, sp, #12
 1151              	.LCFI17:
 1152              		.cfi_remember_state
 1153              		.cfi_def_cfa_offset 20
 1154              		@ sp needed
 1155 0012 F0BD     		pop	{r4, r5, r6, r7, pc}
 1156              	.LVL83:
 1157              	.L70:
 1158              	.LCFI18:
 1159              		.cfi_restore_state
 882:Src/mpu6050.c ****         return -1;
 1160              		.loc 1 882 5 is_stmt 1 view .LVU341
 882:Src/mpu6050.c ****         return -1;
 1161              		.loc 1 882 9 is_stmt 0 view .LVU342
 1162 0014 D4E90010 		ldrd	r1, r0, [r4]
 1163              	.LVL84:
 882:Src/mpu6050.c ****         return -1;
 1164              		.loc 1 882 9 view .LVU343
 1165 0018 0222     		movs	r2, #2
 1166 001a 097C     		ldrb	r1, [r1, #16]	@ zero_extendqisi2
 1167 001c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1168 001e 01AB     		add	r3, sp, #4
 1169 0020 FFF7FEFF 		bl	i2c_readBytes
 1170              	.LVL85:
 882:Src/mpu6050.c ****         return -1;
 1171              		.loc 1 882 8 view .LVU344
 1172 0024 0028     		cmp	r0, #0
 1173 0026 F1D1     		bne	.L72
 884:Src/mpu6050.c ****     if (timestamp)
 1174              		.loc 1 884 5 is_stmt 1 view .LVU345
 1175 0028 BDF80470 		ldrh	r7, [sp, #4]
 1176 002c FFBA     		revsh	r7, r7
 1177              	.LVL86:
 885:Src/mpu6050.c ****         get_ms(timestamp);
 1178              		.loc 1 885 5 view .LVU346
 885:Src/mpu6050.c ****         get_ms(timestamp);
 1179              		.loc 1 885 8 is_stmt 0 view .LVU347
 1180 002e 15B1     		cbz	r5, .L73
 886:Src/mpu6050.c **** 
 1181              		.loc 1 886 9 is_stmt 1 view .LVU348
 1182 0030 2846     		mov	r0, r5
 1183 0032 FFF7FEFF 		bl	get_tick_count_ms
 1184              	.LVL87:
 1185              	.L73:
 888:Src/mpu6050.c ****     return 0;
 1186              		.loc 1 888 5 view .LVU349
 888:Src/mpu6050.c ****     return 0;
 1187              		.loc 1 888 34 is_stmt 0 view .LVU350
 1188 0036 3846     		mov	r0, r7
 1189 0038 FFF7FEFF 		bl	__aeabi_i2f
 1190              	.LVL88:
 888:Src/mpu6050.c ****     return 0;
 1191              		.loc 1 888 45 view .LVU351
 1192 003c 6568     		ldr	r5, [r4, #4]
 1193              	.LVL89:
 888:Src/mpu6050.c ****     return 0;
 1194              		.loc 1 888 34 view .LVU352
ARM GAS  /tmp/ccC60hwS.s 			page 65


 1195 003e 0446     		mov	r4, r0
 888:Src/mpu6050.c ****     return 0;
 1196              		.loc 1 888 36 view .LVU353
 1197 0040 B5F90800 		ldrsh	r0, [r5, #8]
 1198 0044 FFF7FEFF 		bl	__aeabi_i2f
 1199              	.LVL90:
 1200 0048 0146     		mov	r1, r0
 888:Src/mpu6050.c ****     return 0;
 1201              		.loc 1 888 34 view .LVU354
 1202 004a 2046     		mov	r0, r4
 1203 004c FFF7FEFF 		bl	__aeabi_fsub
 1204              	.LVL91:
 1205 0050 0446     		mov	r4, r0
 888:Src/mpu6050.c ****     return 0;
 1206              		.loc 1 888 63 view .LVU355
 1207 0052 E888     		ldrh	r0, [r5, #6]
 1208 0054 FFF7FEFF 		bl	__aeabi_i2f
 1209              	.LVL92:
 1210 0058 0146     		mov	r1, r0
 1211 005a 2046     		mov	r0, r4
 1212 005c FFF7FEFF 		bl	__aeabi_fdiv
 1213              	.LVL93:
 888:Src/mpu6050.c ****     return 0;
 1214              		.loc 1 888 26 view .LVU356
 1215 0060 0649     		ldr	r1, .L77+4
 1216 0062 FFF7FEFF 		bl	__aeabi_fadd
 1217              	.LVL94:
 888:Src/mpu6050.c ****     return 0;
 1218              		.loc 1 888 84 view .LVU357
 1219 0066 4FF08F41 		mov	r1, #1199570944
 1220 006a FFF7FEFF 		bl	__aeabi_fmul
 1221              	.LVL95:
 888:Src/mpu6050.c ****     return 0;
 1222              		.loc 1 888 15 view .LVU358
 1223 006e FFF7FEFF 		bl	__aeabi_f2iz
 1224              	.LVL96:
 1225 0072 3060     		str	r0, [r6]
 889:Src/mpu6050.c **** }
 1226              		.loc 1 889 5 is_stmt 1 view .LVU359
 889:Src/mpu6050.c **** }
 1227              		.loc 1 889 12 is_stmt 0 view .LVU360
 1228 0074 0020     		movs	r0, #0
 1229 0076 CBE7     		b	.L69
 1230              	.L78:
 1231              		.align	2
 1232              	.L77:
 1233 0078 00000000 		.word	.LANCHOR0
 1234 007c 00000C42 		.word	1108082688
 1235              		.cfi_endproc
 1236              	.LFE66:
 1238              		.section	.text.mpu_read_6500_accel_bias,"ax",%progbits
 1239              		.align	1
 1240              		.global	mpu_read_6500_accel_bias
 1241              		.syntax unified
 1242              		.thumb
 1243              		.thumb_func
 1244              		.fpu softvfp
ARM GAS  /tmp/ccC60hwS.s 			page 66


 1246              	mpu_read_6500_accel_bias:
 1247              	.LVL97:
 1248              	.LFB67:
 900:Src/mpu6050.c ****     unsigned char data[6];
 1249              		.loc 1 900 48 is_stmt 1 view -0
 1250              		.cfi_startproc
 1251              		@ args = 0, pretend = 0, frame = 8
 1252              		@ frame_needed = 0, uses_anonymous_args = 0
 901:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
 1253              		.loc 1 901 5 view .LVU362
 902:Src/mpu6050.c ****         return -1;
 1254              		.loc 1 902 5 view .LVU363
 900:Src/mpu6050.c ****     unsigned char data[6];
 1255              		.loc 1 900 48 is_stmt 0 view .LVU364
 1256 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1257              	.LCFI19:
 1258              		.cfi_def_cfa_offset 24
 1259              		.cfi_offset 4, -12
 1260              		.cfi_offset 5, -8
 1261              		.cfi_offset 14, -4
 902:Src/mpu6050.c ****         return -1;
 1262              		.loc 1 902 20 view .LVU365
 1263 0002 184D     		ldr	r5, .L83
 900:Src/mpu6050.c ****     unsigned char data[6];
 1264              		.loc 1 900 48 view .LVU366
 1265 0004 0446     		mov	r4, r0
 902:Src/mpu6050.c ****         return -1;
 1266              		.loc 1 902 9 view .LVU367
 1267 0006 6868     		ldr	r0, [r5, #4]
 1268              	.LVL98:
 902:Src/mpu6050.c ****         return -1;
 1269              		.loc 1 902 9 view .LVU368
 1270 0008 6B46     		mov	r3, sp
 1271 000a 0222     		movs	r2, #2
 1272 000c 7721     		movs	r1, #119
 1273 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1274 0010 FFF7FEFF 		bl	i2c_readBytes
 1275              	.LVL99:
 902:Src/mpu6050.c ****         return -1;
 1276              		.loc 1 902 8 view .LVU369
 1277 0014 18B1     		cbz	r0, .L80
 1278              	.L82:
 903:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
 1279              		.loc 1 903 16 view .LVU370
 1280 0016 4FF0FF30 		mov	r0, #-1
 1281              	.L79:
 912:Src/mpu6050.c **** 
 1282              		.loc 1 912 1 view .LVU371
 1283 001a 03B0     		add	sp, sp, #12
 1284              	.LCFI20:
 1285              		.cfi_remember_state
 1286              		.cfi_def_cfa_offset 12
 1287              		@ sp needed
 1288 001c 30BD     		pop	{r4, r5, pc}
 1289              	.LVL100:
 1290              	.L80:
 1291              	.LCFI21:
ARM GAS  /tmp/ccC60hwS.s 			page 67


 1292              		.cfi_restore_state
 904:Src/mpu6050.c ****         return -1;
 1293              		.loc 1 904 5 is_stmt 1 view .LVU372
 904:Src/mpu6050.c ****         return -1;
 1294              		.loc 1 904 9 is_stmt 0 view .LVU373
 1295 001e 6868     		ldr	r0, [r5, #4]
 1296 0020 0222     		movs	r2, #2
 1297 0022 7A21     		movs	r1, #122
 1298 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1299 0026 0DF10203 		add	r3, sp, #2
 1300 002a FFF7FEFF 		bl	i2c_readBytes
 1301              	.LVL101:
 904:Src/mpu6050.c ****         return -1;
 1302              		.loc 1 904 8 view .LVU374
 1303 002e 0028     		cmp	r0, #0
 1304 0030 F1D1     		bne	.L82
 906:Src/mpu6050.c ****         return -1;
 1305              		.loc 1 906 5 is_stmt 1 view .LVU375
 906:Src/mpu6050.c ****         return -1;
 1306              		.loc 1 906 9 is_stmt 0 view .LVU376
 1307 0032 6868     		ldr	r0, [r5, #4]
 1308 0034 0222     		movs	r2, #2
 1309 0036 7D21     		movs	r1, #125
 1310 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1311 003a 01AB     		add	r3, sp, #4
 1312 003c FFF7FEFF 		bl	i2c_readBytes
 1313              	.LVL102:
 906:Src/mpu6050.c ****         return -1;
 1314              		.loc 1 906 8 view .LVU377
 1315 0040 0028     		cmp	r0, #0
 1316 0042 E8D1     		bne	.L82
 908:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1317              		.loc 1 908 5 is_stmt 1 view .LVU378
 908:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1318              		.loc 1 908 19 is_stmt 0 view .LVU379
 1319 0044 BDF80030 		ldrh	r3, [sp]
 1320 0048 5BBA     		rev16	r3, r3
 1321 004a 9BB2     		uxth	r3, r3
 1322 004c 2360     		str	r3, [r4]
 909:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1323              		.loc 1 909 5 is_stmt 1 view .LVU380
 909:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1324              		.loc 1 909 19 is_stmt 0 view .LVU381
 1325 004e BDF80230 		ldrh	r3, [sp, #2]
 1326 0052 5BBA     		rev16	r3, r3
 1327 0054 9BB2     		uxth	r3, r3
 1328 0056 6360     		str	r3, [r4, #4]
 910:Src/mpu6050.c ****     return 0;
 1329              		.loc 1 910 5 is_stmt 1 view .LVU382
 910:Src/mpu6050.c ****     return 0;
 1330              		.loc 1 910 19 is_stmt 0 view .LVU383
 1331 0058 BDF80430 		ldrh	r3, [sp, #4]
 1332 005c 5BBA     		rev16	r3, r3
 1333 005e 9BB2     		uxth	r3, r3
 1334 0060 A360     		str	r3, [r4, #8]
 911:Src/mpu6050.c **** }
 1335              		.loc 1 911 5 is_stmt 1 view .LVU384
ARM GAS  /tmp/ccC60hwS.s 			page 68


 911:Src/mpu6050.c **** }
 1336              		.loc 1 911 12 is_stmt 0 view .LVU385
 1337 0062 DAE7     		b	.L79
 1338              	.L84:
 1339              		.align	2
 1340              	.L83:
 1341 0064 00000000 		.word	.LANCHOR0
 1342              		.cfi_endproc
 1343              	.LFE67:
 1345              		.section	.text.mpu_read_6050_accel_bias,"ax",%progbits
 1346              		.align	1
 1347              		.global	mpu_read_6050_accel_bias
 1348              		.syntax unified
 1349              		.thumb
 1350              		.thumb_func
 1351              		.fpu softvfp
 1353              	mpu_read_6050_accel_bias:
 1354              	.LVL103:
 1355              	.LFB68:
 922:Src/mpu6050.c ****     unsigned char data[6];
 1356              		.loc 1 922 48 is_stmt 1 view -0
 1357              		.cfi_startproc
 1358              		@ args = 0, pretend = 0, frame = 8
 1359              		@ frame_needed = 0, uses_anonymous_args = 0
 923:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
 1360              		.loc 1 923 5 view .LVU387
 924:Src/mpu6050.c ****         return -1;
 1361              		.loc 1 924 5 view .LVU388
 922:Src/mpu6050.c ****     unsigned char data[6];
 1362              		.loc 1 922 48 is_stmt 0 view .LVU389
 1363 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1364              	.LCFI22:
 1365              		.cfi_def_cfa_offset 24
 1366              		.cfi_offset 4, -12
 1367              		.cfi_offset 5, -8
 1368              		.cfi_offset 14, -4
 924:Src/mpu6050.c ****         return -1;
 1369              		.loc 1 924 20 view .LVU390
 1370 0002 184D     		ldr	r5, .L89
 922:Src/mpu6050.c ****     unsigned char data[6];
 1371              		.loc 1 922 48 view .LVU391
 1372 0004 0446     		mov	r4, r0
 924:Src/mpu6050.c ****         return -1;
 1373              		.loc 1 924 9 view .LVU392
 1374 0006 6868     		ldr	r0, [r5, #4]
 1375              	.LVL104:
 924:Src/mpu6050.c ****         return -1;
 1376              		.loc 1 924 9 view .LVU393
 1377 0008 6B46     		mov	r3, sp
 1378 000a 0222     		movs	r2, #2
 1379 000c 0621     		movs	r1, #6
 1380 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1381 0010 FFF7FEFF 		bl	i2c_readBytes
 1382              	.LVL105:
 924:Src/mpu6050.c ****         return -1;
 1383              		.loc 1 924 8 view .LVU394
 1384 0014 18B1     		cbz	r0, .L86
ARM GAS  /tmp/ccC60hwS.s 			page 69


 1385              	.L88:
 925:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
 1386              		.loc 1 925 16 view .LVU395
 1387 0016 4FF0FF30 		mov	r0, #-1
 1388              	.L85:
 934:Src/mpu6050.c **** 
 1389              		.loc 1 934 1 view .LVU396
 1390 001a 03B0     		add	sp, sp, #12
 1391              	.LCFI23:
 1392              		.cfi_remember_state
 1393              		.cfi_def_cfa_offset 12
 1394              		@ sp needed
 1395 001c 30BD     		pop	{r4, r5, pc}
 1396              	.LVL106:
 1397              	.L86:
 1398              	.LCFI24:
 1399              		.cfi_restore_state
 926:Src/mpu6050.c ****         return -1;
 1400              		.loc 1 926 5 is_stmt 1 view .LVU397
 926:Src/mpu6050.c ****         return -1;
 1401              		.loc 1 926 9 is_stmt 0 view .LVU398
 1402 001e 6868     		ldr	r0, [r5, #4]
 1403 0020 0222     		movs	r2, #2
 1404 0022 0821     		movs	r1, #8
 1405 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1406 0026 0DF10203 		add	r3, sp, #2
 1407 002a FFF7FEFF 		bl	i2c_readBytes
 1408              	.LVL107:
 926:Src/mpu6050.c ****         return -1;
 1409              		.loc 1 926 8 view .LVU399
 1410 002e 0028     		cmp	r0, #0
 1411 0030 F1D1     		bne	.L88
 928:Src/mpu6050.c ****         return -1;
 1412              		.loc 1 928 5 is_stmt 1 view .LVU400
 928:Src/mpu6050.c ****         return -1;
 1413              		.loc 1 928 9 is_stmt 0 view .LVU401
 1414 0032 6868     		ldr	r0, [r5, #4]
 1415 0034 0222     		movs	r2, #2
 1416 0036 0A21     		movs	r1, #10
 1417 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1418 003a 01AB     		add	r3, sp, #4
 1419 003c FFF7FEFF 		bl	i2c_readBytes
 1420              	.LVL108:
 928:Src/mpu6050.c ****         return -1;
 1421              		.loc 1 928 8 view .LVU402
 1422 0040 0028     		cmp	r0, #0
 1423 0042 E8D1     		bne	.L88
 930:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1424              		.loc 1 930 5 is_stmt 1 view .LVU403
 930:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1425              		.loc 1 930 19 is_stmt 0 view .LVU404
 1426 0044 BDF80030 		ldrh	r3, [sp]
 1427 0048 5BBA     		rev16	r3, r3
 1428 004a 9BB2     		uxth	r3, r3
 1429 004c 2360     		str	r3, [r4]
 931:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1430              		.loc 1 931 5 is_stmt 1 view .LVU405
ARM GAS  /tmp/ccC60hwS.s 			page 70


 931:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1431              		.loc 1 931 19 is_stmt 0 view .LVU406
 1432 004e BDF80230 		ldrh	r3, [sp, #2]
 1433 0052 5BBA     		rev16	r3, r3
 1434 0054 9BB2     		uxth	r3, r3
 1435 0056 6360     		str	r3, [r4, #4]
 932:Src/mpu6050.c ****     return 0;
 1436              		.loc 1 932 5 is_stmt 1 view .LVU407
 932:Src/mpu6050.c ****     return 0;
 1437              		.loc 1 932 19 is_stmt 0 view .LVU408
 1438 0058 BDF80430 		ldrh	r3, [sp, #4]
 1439 005c 5BBA     		rev16	r3, r3
 1440 005e 9BB2     		uxth	r3, r3
 1441 0060 A360     		str	r3, [r4, #8]
 933:Src/mpu6050.c **** }
 1442              		.loc 1 933 5 is_stmt 1 view .LVU409
 933:Src/mpu6050.c **** }
 1443              		.loc 1 933 12 is_stmt 0 view .LVU410
 1444 0062 DAE7     		b	.L85
 1445              	.L90:
 1446              		.align	2
 1447              	.L89:
 1448 0064 00000000 		.word	.LANCHOR0
 1449              		.cfi_endproc
 1450              	.LFE68:
 1452              		.section	.text.mpu_read_6500_gyro_bias,"ax",%progbits
 1453              		.align	1
 1454              		.global	mpu_read_6500_gyro_bias
 1455              		.syntax unified
 1456              		.thumb
 1457              		.thumb_func
 1458              		.fpu softvfp
 1460              	mpu_read_6500_gyro_bias:
 1461              	.LVL109:
 1462              	.LFB69:
 936:Src/mpu6050.c ****     unsigned char data[6];
 1463              		.loc 1 936 46 is_stmt 1 view -0
 1464              		.cfi_startproc
 1465              		@ args = 0, pretend = 0, frame = 8
 1466              		@ frame_needed = 0, uses_anonymous_args = 0
 937:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
 1467              		.loc 1 937 5 view .LVU412
 938:Src/mpu6050.c ****         return -1;
 1468              		.loc 1 938 5 view .LVU413
 936:Src/mpu6050.c ****     unsigned char data[6];
 1469              		.loc 1 936 46 is_stmt 0 view .LVU414
 1470 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1471              	.LCFI25:
 1472              		.cfi_def_cfa_offset 24
 1473              		.cfi_offset 4, -12
 1474              		.cfi_offset 5, -8
 1475              		.cfi_offset 14, -4
 938:Src/mpu6050.c ****         return -1;
 1476              		.loc 1 938 20 view .LVU415
 1477 0002 184D     		ldr	r5, .L95
 936:Src/mpu6050.c ****     unsigned char data[6];
 1478              		.loc 1 936 46 view .LVU416
ARM GAS  /tmp/ccC60hwS.s 			page 71


 1479 0004 0446     		mov	r4, r0
 938:Src/mpu6050.c ****         return -1;
 1480              		.loc 1 938 9 view .LVU417
 1481 0006 6868     		ldr	r0, [r5, #4]
 1482              	.LVL110:
 938:Src/mpu6050.c ****         return -1;
 1483              		.loc 1 938 9 view .LVU418
 1484 0008 6B46     		mov	r3, sp
 1485 000a 0222     		movs	r2, #2
 1486 000c 1321     		movs	r1, #19
 1487 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1488 0010 FFF7FEFF 		bl	i2c_readBytes
 1489              	.LVL111:
 938:Src/mpu6050.c ****         return -1;
 1490              		.loc 1 938 8 view .LVU419
 1491 0014 18B1     		cbz	r0, .L92
 1492              	.L94:
 939:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
 1493              		.loc 1 939 16 view .LVU420
 1494 0016 4FF0FF30 		mov	r0, #-1
 1495              	.L91:
 948:Src/mpu6050.c **** 
 1496              		.loc 1 948 1 view .LVU421
 1497 001a 03B0     		add	sp, sp, #12
 1498              	.LCFI26:
 1499              		.cfi_remember_state
 1500              		.cfi_def_cfa_offset 12
 1501              		@ sp needed
 1502 001c 30BD     		pop	{r4, r5, pc}
 1503              	.LVL112:
 1504              	.L92:
 1505              	.LCFI27:
 1506              		.cfi_restore_state
 940:Src/mpu6050.c ****         return -1;
 1507              		.loc 1 940 5 is_stmt 1 view .LVU422
 940:Src/mpu6050.c ****         return -1;
 1508              		.loc 1 940 9 is_stmt 0 view .LVU423
 1509 001e 6868     		ldr	r0, [r5, #4]
 1510 0020 0222     		movs	r2, #2
 1511 0022 1521     		movs	r1, #21
 1512 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1513 0026 0DF10203 		add	r3, sp, #2
 1514 002a FFF7FEFF 		bl	i2c_readBytes
 1515              	.LVL113:
 940:Src/mpu6050.c ****         return -1;
 1516              		.loc 1 940 8 view .LVU424
 1517 002e 0028     		cmp	r0, #0
 1518 0030 F1D1     		bne	.L94
 942:Src/mpu6050.c ****         return -1;
 1519              		.loc 1 942 5 is_stmt 1 view .LVU425
 942:Src/mpu6050.c ****         return -1;
 1520              		.loc 1 942 9 is_stmt 0 view .LVU426
 1521 0032 6868     		ldr	r0, [r5, #4]
 1522 0034 0222     		movs	r2, #2
 1523 0036 1721     		movs	r1, #23
 1524 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1525 003a 01AB     		add	r3, sp, #4
ARM GAS  /tmp/ccC60hwS.s 			page 72


 1526 003c FFF7FEFF 		bl	i2c_readBytes
 1527              	.LVL114:
 942:Src/mpu6050.c ****         return -1;
 1528              		.loc 1 942 8 view .LVU427
 1529 0040 0028     		cmp	r0, #0
 1530 0042 E8D1     		bne	.L94
 944:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 1531              		.loc 1 944 5 is_stmt 1 view .LVU428
 944:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 1532              		.loc 1 944 18 is_stmt 0 view .LVU429
 1533 0044 BDF80030 		ldrh	r3, [sp]
 1534 0048 5BBA     		rev16	r3, r3
 1535 004a 9BB2     		uxth	r3, r3
 1536 004c 2360     		str	r3, [r4]
 945:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 1537              		.loc 1 945 5 is_stmt 1 view .LVU430
 945:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 1538              		.loc 1 945 18 is_stmt 0 view .LVU431
 1539 004e BDF80230 		ldrh	r3, [sp, #2]
 1540 0052 5BBA     		rev16	r3, r3
 1541 0054 9BB2     		uxth	r3, r3
 1542 0056 6360     		str	r3, [r4, #4]
 946:Src/mpu6050.c ****     return 0;
 1543              		.loc 1 946 5 is_stmt 1 view .LVU432
 946:Src/mpu6050.c ****     return 0;
 1544              		.loc 1 946 18 is_stmt 0 view .LVU433
 1545 0058 BDF80430 		ldrh	r3, [sp, #4]
 1546 005c 5BBA     		rev16	r3, r3
 1547 005e 9BB2     		uxth	r3, r3
 1548 0060 A360     		str	r3, [r4, #8]
 947:Src/mpu6050.c **** }
 1549              		.loc 1 947 5 is_stmt 1 view .LVU434
 947:Src/mpu6050.c **** }
 1550              		.loc 1 947 12 is_stmt 0 view .LVU435
 1551 0062 DAE7     		b	.L91
 1552              	.L96:
 1553              		.align	2
 1554              	.L95:
 1555 0064 00000000 		.word	.LANCHOR0
 1556              		.cfi_endproc
 1557              	.LFE69:
 1559              		.section	.text.mpu_set_gyro_bias_reg,"ax",%progbits
 1560              		.align	1
 1561              		.global	mpu_set_gyro_bias_reg
 1562              		.syntax unified
 1563              		.thumb
 1564              		.thumb_func
 1565              		.fpu softvfp
 1567              	mpu_set_gyro_bias_reg:
 1568              	.LVL115:
 1569              	.LFB70:
 959:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1570              		.loc 1 959 1 is_stmt 1 view -0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 8
 1573              		@ frame_needed = 0, uses_anonymous_args = 0
 960:Src/mpu6050.c ****     int i=0;
ARM GAS  /tmp/ccC60hwS.s 			page 73


 1574              		.loc 1 960 5 view .LVU437
 961:Src/mpu6050.c ****     for(i=0;i<3;i++) {
 1575              		.loc 1 961 5 view .LVU438
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1576              		.loc 1 962 5 view .LVU439
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1577              		.loc 1 962 13 view .LVU440
 963:Src/mpu6050.c ****     }
 1578              		.loc 1 963 9 view .LVU441
 959:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1579              		.loc 1 959 1 is_stmt 0 view .LVU442
 1580 0000 13B5     		push	{r0, r1, r4, lr}
 1581              	.LCFI28:
 1582              		.cfi_def_cfa_offset 16
 1583              		.cfi_offset 4, -8
 1584              		.cfi_offset 14, -4
 963:Src/mpu6050.c ****     }
 1585              		.loc 1 963 24 view .LVU443
 1586 0002 4268     		ldr	r2, [r0, #4]
 1587 0004 0168     		ldr	r1, [r0]
 1588 0006 8368     		ldr	r3, [r0, #8]
 1589 0008 4942     		rsbs	r1, r1, #0
 1590 000a 5242     		rsbs	r2, r2, #0
 1591 000c 5B42     		rsbs	r3, r3, #0
 971:Src/mpu6050.c ****         return -1;
 1592              		.loc 1 971 21 view .LVU444
 1593 000e 1A4C     		ldr	r4, .L101
 963:Src/mpu6050.c ****     }
 1594              		.loc 1 963 21 view .LVU445
 1595 0010 0160     		str	r1, [r0]
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1596              		.loc 1 962 17 is_stmt 1 view .LVU446
 1597              	.LVL116:
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1598              		.loc 1 962 13 view .LVU447
 963:Src/mpu6050.c ****     }
 1599              		.loc 1 963 9 view .LVU448
 963:Src/mpu6050.c ****     }
 1600              		.loc 1 963 21 is_stmt 0 view .LVU449
 1601 0012 4260     		str	r2, [r0, #4]
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1602              		.loc 1 962 17 is_stmt 1 view .LVU450
 1603              	.LVL117:
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1604              		.loc 1 962 13 view .LVU451
 963:Src/mpu6050.c ****     }
 1605              		.loc 1 963 9 view .LVU452
 963:Src/mpu6050.c ****     }
 1606              		.loc 1 963 21 is_stmt 0 view .LVU453
 1607 0014 8360     		str	r3, [r0, #8]
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1608              		.loc 1 962 17 is_stmt 1 view .LVU454
 1609              	.LVL118:
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1610              		.loc 1 962 13 view .LVU455
 965:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1611              		.loc 1 965 5 view .LVU456
ARM GAS  /tmp/ccC60hwS.s 			page 74


 965:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1612              		.loc 1 965 29 is_stmt 0 view .LVU457
 1613 0016 0812     		asrs	r0, r1, #8
 1614              	.LVL119:
 965:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1615              		.loc 1 965 13 view .LVU458
 1616 0018 8DF80000 		strb	r0, [sp]
 966:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 1617              		.loc 1 966 5 is_stmt 1 view .LVU459
 966:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 1618              		.loc 1 966 13 is_stmt 0 view .LVU460
 1619 001c 8DF80110 		strb	r1, [sp, #1]
 967:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1620              		.loc 1 967 5 is_stmt 1 view .LVU461
 968:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 1621              		.loc 1 968 13 is_stmt 0 view .LVU462
 1622 0020 8DF80320 		strb	r2, [sp, #3]
 967:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1623              		.loc 1 967 29 view .LVU463
 1624 0024 1112     		asrs	r1, r2, #8
 971:Src/mpu6050.c ****         return -1;
 1625              		.loc 1 971 9 view .LVU464
 1626 0026 6068     		ldr	r0, [r4, #4]
 969:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1627              		.loc 1 969 29 view .LVU465
 1628 0028 1A12     		asrs	r2, r3, #8
 967:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1629              		.loc 1 967 13 view .LVU466
 1630 002a 8DF80210 		strb	r1, [sp, #2]
 968:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 1631              		.loc 1 968 5 is_stmt 1 view .LVU467
 969:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1632              		.loc 1 969 5 view .LVU468
 969:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1633              		.loc 1 969 13 is_stmt 0 view .LVU469
 1634 002e 8DF80420 		strb	r2, [sp, #4]
 970:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 1635              		.loc 1 970 5 is_stmt 1 view .LVU470
 970:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 1636              		.loc 1 970 13 is_stmt 0 view .LVU471
 1637 0032 8DF80530 		strb	r3, [sp, #5]
 971:Src/mpu6050.c ****         return -1;
 1638              		.loc 1 971 5 is_stmt 1 view .LVU472
 971:Src/mpu6050.c ****         return -1;
 1639              		.loc 1 971 9 is_stmt 0 view .LVU473
 1640 0036 0222     		movs	r2, #2
 1641 0038 6B46     		mov	r3, sp
 1642 003a 1321     		movs	r1, #19
 1643 003c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1644 003e FFF7FEFF 		bl	i2c_writeBytes
 1645              	.LVL120:
 971:Src/mpu6050.c ****         return -1;
 1646              		.loc 1 971 8 view .LVU474
 1647 0042 18B1     		cbz	r0, .L98
 1648              	.L100:
 972:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
 1649              		.loc 1 972 16 view .LVU475
ARM GAS  /tmp/ccC60hwS.s 			page 75


 1650 0044 4FF0FF30 		mov	r0, #-1
 1651              	.L97:
 978:Src/mpu6050.c **** 
 1652              		.loc 1 978 1 view .LVU476
 1653 0048 02B0     		add	sp, sp, #8
 1654              	.LCFI29:
 1655              		.cfi_remember_state
 1656              		.cfi_def_cfa_offset 8
 1657              		@ sp needed
 1658 004a 10BD     		pop	{r4, pc}
 1659              	.L98:
 1660              	.LCFI30:
 1661              		.cfi_restore_state
 973:Src/mpu6050.c ****         return -1;
 1662              		.loc 1 973 5 is_stmt 1 view .LVU477
 973:Src/mpu6050.c ****         return -1;
 1663              		.loc 1 973 9 is_stmt 0 view .LVU478
 1664 004c 6068     		ldr	r0, [r4, #4]
 1665 004e 0222     		movs	r2, #2
 1666 0050 1521     		movs	r1, #21
 1667 0052 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1668 0054 0DF10203 		add	r3, sp, #2
 1669 0058 FFF7FEFF 		bl	i2c_writeBytes
 1670              	.LVL121:
 973:Src/mpu6050.c ****         return -1;
 1671              		.loc 1 973 8 view .LVU479
 1672 005c 0028     		cmp	r0, #0
 1673 005e F1D1     		bne	.L100
 975:Src/mpu6050.c ****         return -1;
 1674              		.loc 1 975 5 is_stmt 1 view .LVU480
 975:Src/mpu6050.c ****         return -1;
 1675              		.loc 1 975 9 is_stmt 0 view .LVU481
 1676 0060 6068     		ldr	r0, [r4, #4]
 1677 0062 0222     		movs	r2, #2
 1678 0064 1721     		movs	r1, #23
 1679 0066 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1680 0068 01AB     		add	r3, sp, #4
 1681 006a FFF7FEFF 		bl	i2c_writeBytes
 1682              	.LVL122:
 975:Src/mpu6050.c ****         return -1;
 1683              		.loc 1 975 8 view .LVU482
 1684 006e 0038     		subs	r0, r0, #0
 1685 0070 18BF     		it	ne
 1686 0072 0120     		movne	r0, #1
 1687 0074 4042     		rsbs	r0, r0, #0
 1688 0076 E7E7     		b	.L97
 1689              	.L102:
 1690              		.align	2
 1691              	.L101:
 1692 0078 00000000 		.word	.LANCHOR0
 1693              		.cfi_endproc
 1694              	.LFE70:
 1696              		.section	.text.mpu_set_accel_bias_6050_reg,"ax",%progbits
 1697              		.align	1
 1698              		.global	mpu_set_accel_bias_6050_reg
 1699              		.syntax unified
 1700              		.thumb
ARM GAS  /tmp/ccC60hwS.s 			page 76


 1701              		.thumb_func
 1702              		.fpu softvfp
 1704              	mpu_set_accel_bias_6050_reg:
 1705              	.LVL123:
 1706              	.LFB71:
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1707              		.loc 1 988 57 is_stmt 1 view -0
 1708              		.cfi_startproc
 1709              		@ args = 0, pretend = 0, frame = 24
 1710              		@ frame_needed = 0, uses_anonymous_args = 0
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1711              		.loc 1 989 5 view .LVU484
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1712              		.loc 1 988 57 is_stmt 0 view .LVU485
 1713 0000 10B5     		push	{r4, lr}
 1714              	.LCFI31:
 1715              		.cfi_def_cfa_offset 8
 1716              		.cfi_offset 4, -8
 1717              		.cfi_offset 14, -4
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1718              		.loc 1 989 19 view .LVU486
 1719 0002 2A4B     		ldr	r3, .L107
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1720              		.loc 1 988 57 view .LVU487
 1721 0004 0446     		mov	r4, r0
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1722              		.loc 1 989 19 view .LVU488
 1723 0006 1868     		ldr	r0, [r3]	@ unaligned
 1724              	.LVL124:
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1725              		.loc 1 989 19 view .LVU489
 1726 0008 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1727              		.loc 1 988 57 view .LVU490
 1728 000a 86B0     		sub	sp, sp, #24
 1729              	.LCFI32:
 1730              		.cfi_def_cfa_offset 32
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1731              		.loc 1 989 19 view .LVU491
 1732 000c ADF80830 		strh	r3, [sp, #8]	@ unaligned
 990:Src/mpu6050.c **** 
 1733              		.loc 1 990 5 is_stmt 1 view .LVU492
 990:Src/mpu6050.c **** 
 1734              		.loc 1 990 10 is_stmt 0 view .LVU493
 1735 0010 0023     		movs	r3, #0
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1736              		.loc 1 989 19 view .LVU494
 1737 0012 0190     		str	r0, [sp, #4]
 992:Src/mpu6050.c ****         return -1;
 1738              		.loc 1 992 8 view .LVU495
 1739 0014 03A8     		add	r0, sp, #12
 990:Src/mpu6050.c **** 
 1740              		.loc 1 990 10 view .LVU496
 1741 0016 CDE90333 		strd	r3, r3, [sp, #12]
 1742 001a 0593     		str	r3, [sp, #20]
 992:Src/mpu6050.c ****         return -1;
 1743              		.loc 1 992 5 is_stmt 1 view .LVU497
ARM GAS  /tmp/ccC60hwS.s 			page 77


 992:Src/mpu6050.c ****         return -1;
 1744              		.loc 1 992 8 is_stmt 0 view .LVU498
 1745 001c FFF7FEFF 		bl	mpu_read_6050_accel_bias
 1746              	.LVL125:
 992:Src/mpu6050.c ****         return -1;
 1747              		.loc 1 992 7 view .LVU499
 1748 0020 18B1     		cbz	r0, .L104
 1749              	.LVL126:
 1750              	.L106:
 993:Src/mpu6050.c **** 
 1751              		.loc 1 993 16 view .LVU500
 1752 0022 4FF0FF30 		mov	r0, #-1
 1753              	.L103:
1014:Src/mpu6050.c **** 
 1754              		.loc 1 1014 1 view .LVU501
 1755 0026 06B0     		add	sp, sp, #24
 1756              	.LCFI33:
 1757              		.cfi_remember_state
 1758              		.cfi_def_cfa_offset 8
 1759              		@ sp needed
 1760 0028 10BD     		pop	{r4, pc}
 1761              	.LVL127:
 1762              	.L104:
 1763              	.LCFI34:
 1764              		.cfi_restore_state
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1765              		.loc 1 995 5 is_stmt 1 view .LVU502
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1766              		.loc 1 995 41 is_stmt 0 view .LVU503
 1767 002a 2168     		ldr	r1, [r4]
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1768              		.loc 1 996 41 view .LVU504
 1769 002c 6268     		ldr	r2, [r4, #4]
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1770              		.loc 1 995 41 view .LVU505
 1771 002e 21F00103 		bic	r3, r1, #1
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1772              		.loc 1 995 23 view .LVU506
 1773 0032 0399     		ldr	r1, [sp, #12]
 997:Src/mpu6050.c **** 
 1774              		.loc 1 997 41 view .LVU507
 1775 0034 A068     		ldr	r0, [r4, #8]
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1776              		.loc 1 995 23 view .LVU508
 1777 0036 C91A     		subs	r1, r1, r3
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1778              		.loc 1 996 41 view .LVU509
 1779 0038 22F00103 		bic	r3, r2, #1
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1780              		.loc 1 996 23 view .LVU510
 1781 003c 049A     		ldr	r2, [sp, #16]
 997:Src/mpu6050.c **** 
 1782              		.loc 1 997 41 view .LVU511
 1783 003e 20F00100 		bic	r0, r0, #1
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1784              		.loc 1 996 23 view .LVU512
 1785 0042 D21A     		subs	r2, r2, r3
ARM GAS  /tmp/ccC60hwS.s 			page 78


 997:Src/mpu6050.c **** 
 1786              		.loc 1 997 23 view .LVU513
 1787 0044 059B     		ldr	r3, [sp, #20]
1006:Src/mpu6050.c ****         return -1;
 1788              		.loc 1 1006 21 view .LVU514
 1789 0046 1A4C     		ldr	r4, .L107+4
 1790              	.LVL128:
 997:Src/mpu6050.c **** 
 1791              		.loc 1 997 23 view .LVU515
 1792 0048 1B1A     		subs	r3, r3, r0
 999:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1793              		.loc 1 999 34 view .LVU516
 1794 004a 0812     		asrs	r0, r1, #8
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1795              		.loc 1 995 23 view .LVU517
 1796 004c 0391     		str	r1, [sp, #12]
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1797              		.loc 1 996 5 is_stmt 1 view .LVU518
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1798              		.loc 1 996 23 is_stmt 0 view .LVU519
 1799 004e 0492     		str	r2, [sp, #16]
 997:Src/mpu6050.c **** 
 1800              		.loc 1 997 5 is_stmt 1 view .LVU520
 999:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1801              		.loc 1 999 13 is_stmt 0 view .LVU521
 1802 0050 8DF80400 		strb	r0, [sp, #4]
1000:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1803              		.loc 1 1000 13 view .LVU522
 1804 0054 8DF80510 		strb	r1, [sp, #5]
1002:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1805              		.loc 1 1002 13 view .LVU523
 1806 0058 8DF80720 		strb	r2, [sp, #7]
1001:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1807              		.loc 1 1001 34 view .LVU524
 1808 005c 1112     		asrs	r1, r2, #8
1006:Src/mpu6050.c ****         return -1;
 1809              		.loc 1 1006 9 view .LVU525
 1810 005e 6068     		ldr	r0, [r4, #4]
1003:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1811              		.loc 1 1003 34 view .LVU526
 1812 0060 1A12     		asrs	r2, r3, #8
 997:Src/mpu6050.c **** 
 1813              		.loc 1 997 23 view .LVU527
 1814 0062 0593     		str	r3, [sp, #20]
 999:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1815              		.loc 1 999 5 is_stmt 1 view .LVU528
1000:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1816              		.loc 1 1000 5 view .LVU529
1001:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1817              		.loc 1 1001 5 view .LVU530
1001:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1818              		.loc 1 1001 13 is_stmt 0 view .LVU531
 1819 0064 8DF80610 		strb	r1, [sp, #6]
1002:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1820              		.loc 1 1002 5 is_stmt 1 view .LVU532
1003:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1821              		.loc 1 1003 5 view .LVU533
ARM GAS  /tmp/ccC60hwS.s 			page 79


1003:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1822              		.loc 1 1003 13 is_stmt 0 view .LVU534
 1823 0068 8DF80820 		strb	r2, [sp, #8]
1004:Src/mpu6050.c **** 
 1824              		.loc 1 1004 5 is_stmt 1 view .LVU535
1004:Src/mpu6050.c **** 
 1825              		.loc 1 1004 13 is_stmt 0 view .LVU536
 1826 006c 8DF80930 		strb	r3, [sp, #9]
1006:Src/mpu6050.c ****         return -1;
 1827              		.loc 1 1006 5 is_stmt 1 view .LVU537
1006:Src/mpu6050.c ****         return -1;
 1828              		.loc 1 1006 9 is_stmt 0 view .LVU538
 1829 0070 0222     		movs	r2, #2
 1830 0072 0621     		movs	r1, #6
 1831 0074 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1832 0076 01AB     		add	r3, sp, #4
 1833 0078 FFF7FEFF 		bl	i2c_writeBytes
 1834              	.LVL129:
1006:Src/mpu6050.c ****         return -1;
 1835              		.loc 1 1006 8 view .LVU539
 1836 007c 0028     		cmp	r0, #0
 1837 007e D0D1     		bne	.L106
1008:Src/mpu6050.c ****         return -1;
 1838              		.loc 1 1008 5 is_stmt 1 view .LVU540
1008:Src/mpu6050.c ****         return -1;
 1839              		.loc 1 1008 9 is_stmt 0 view .LVU541
 1840 0080 6068     		ldr	r0, [r4, #4]
 1841 0082 0222     		movs	r2, #2
 1842 0084 0821     		movs	r1, #8
 1843 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1844 0088 0DF10603 		add	r3, sp, #6
 1845 008c FFF7FEFF 		bl	i2c_writeBytes
 1846              	.LVL130:
1008:Src/mpu6050.c ****         return -1;
 1847              		.loc 1 1008 8 view .LVU542
 1848 0090 0028     		cmp	r0, #0
 1849 0092 C6D1     		bne	.L106
1010:Src/mpu6050.c ****         return -1;
 1850              		.loc 1 1010 5 is_stmt 1 view .LVU543
1010:Src/mpu6050.c ****         return -1;
 1851              		.loc 1 1010 9 is_stmt 0 view .LVU544
 1852 0094 6068     		ldr	r0, [r4, #4]
 1853 0096 0222     		movs	r2, #2
 1854 0098 0A21     		movs	r1, #10
 1855 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1856 009c 02AB     		add	r3, sp, #8
 1857 009e FFF7FEFF 		bl	i2c_writeBytes
 1858              	.LVL131:
1010:Src/mpu6050.c ****         return -1;
 1859              		.loc 1 1010 8 view .LVU545
 1860 00a2 0038     		subs	r0, r0, #0
 1861 00a4 18BF     		it	ne
 1862 00a6 0120     		movne	r0, #1
 1863 00a8 4042     		rsbs	r0, r0, #0
 1864 00aa BCE7     		b	.L103
 1865              	.L108:
 1866              		.align	2
ARM GAS  /tmp/ccC60hwS.s 			page 80


 1867              	.L107:
 1868 00ac 00000000 		.word	.LANCHOR1
 1869 00b0 00000000 		.word	.LANCHOR0
 1870              		.cfi_endproc
 1871              	.LFE71:
 1873              		.section	.text.mpu_set_accel_bias_6500_reg,"ax",%progbits
 1874              		.align	1
 1875              		.global	mpu_set_accel_bias_6500_reg
 1876              		.syntax unified
 1877              		.thumb
 1878              		.thumb_func
 1879              		.fpu softvfp
 1881              	mpu_set_accel_bias_6500_reg:
 1882              	.LVL132:
 1883              	.LFB72:
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1884              		.loc 1 1026 57 is_stmt 1 view -0
 1885              		.cfi_startproc
 1886              		@ args = 0, pretend = 0, frame = 24
 1887              		@ frame_needed = 0, uses_anonymous_args = 0
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1888              		.loc 1 1027 5 view .LVU547
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1889              		.loc 1 1026 57 is_stmt 0 view .LVU548
 1890 0000 10B5     		push	{r4, lr}
 1891              	.LCFI35:
 1892              		.cfi_def_cfa_offset 8
 1893              		.cfi_offset 4, -8
 1894              		.cfi_offset 14, -4
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1895              		.loc 1 1027 19 view .LVU549
 1896 0002 2A4B     		ldr	r3, .L113
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1897              		.loc 1 1026 57 view .LVU550
 1898 0004 0446     		mov	r4, r0
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1899              		.loc 1 1027 19 view .LVU551
 1900 0006 1868     		ldr	r0, [r3]	@ unaligned
 1901              	.LVL133:
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1902              		.loc 1 1027 19 view .LVU552
 1903 0008 9B88     		ldrh	r3, [r3, #4]	@ unaligned
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1904              		.loc 1 1026 57 view .LVU553
 1905 000a 86B0     		sub	sp, sp, #24
 1906              	.LCFI36:
 1907              		.cfi_def_cfa_offset 32
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1908              		.loc 1 1027 19 view .LVU554
 1909 000c ADF80830 		strh	r3, [sp, #8]	@ unaligned
1028:Src/mpu6050.c **** 
 1910              		.loc 1 1028 5 is_stmt 1 view .LVU555
1028:Src/mpu6050.c **** 
 1911              		.loc 1 1028 10 is_stmt 0 view .LVU556
 1912 0010 0023     		movs	r3, #0
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1913              		.loc 1 1027 19 view .LVU557
ARM GAS  /tmp/ccC60hwS.s 			page 81


 1914 0012 0190     		str	r0, [sp, #4]
1030:Src/mpu6050.c ****         return -1;
 1915              		.loc 1 1030 8 view .LVU558
 1916 0014 03A8     		add	r0, sp, #12
1028:Src/mpu6050.c **** 
 1917              		.loc 1 1028 10 view .LVU559
 1918 0016 CDE90333 		strd	r3, r3, [sp, #12]
 1919 001a 0593     		str	r3, [sp, #20]
1030:Src/mpu6050.c ****         return -1;
 1920              		.loc 1 1030 5 is_stmt 1 view .LVU560
1030:Src/mpu6050.c ****         return -1;
 1921              		.loc 1 1030 8 is_stmt 0 view .LVU561
 1922 001c FFF7FEFF 		bl	mpu_read_6500_accel_bias
 1923              	.LVL134:
1030:Src/mpu6050.c ****         return -1;
 1924              		.loc 1 1030 7 view .LVU562
 1925 0020 18B1     		cbz	r0, .L110
 1926              	.LVL135:
 1927              	.L112:
1031:Src/mpu6050.c **** 
 1928              		.loc 1 1031 16 view .LVU563
 1929 0022 4FF0FF30 		mov	r0, #-1
 1930              	.L109:
1053:Src/mpu6050.c **** 
 1931              		.loc 1 1053 1 view .LVU564
 1932 0026 06B0     		add	sp, sp, #24
 1933              	.LCFI37:
 1934              		.cfi_remember_state
 1935              		.cfi_def_cfa_offset 8
 1936              		@ sp needed
 1937 0028 10BD     		pop	{r4, pc}
 1938              	.LVL136:
 1939              	.L110:
 1940              	.LCFI38:
 1941              		.cfi_restore_state
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1942              		.loc 1 1034 5 is_stmt 1 view .LVU565
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1943              		.loc 1 1034 41 is_stmt 0 view .LVU566
 1944 002a 2168     		ldr	r1, [r4]
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1945              		.loc 1 1035 41 view .LVU567
 1946 002c 6268     		ldr	r2, [r4, #4]
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1947              		.loc 1 1034 41 view .LVU568
 1948 002e 21F00103 		bic	r3, r1, #1
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1949              		.loc 1 1034 23 view .LVU569
 1950 0032 0399     		ldr	r1, [sp, #12]
1036:Src/mpu6050.c **** 
 1951              		.loc 1 1036 41 view .LVU570
 1952 0034 A068     		ldr	r0, [r4, #8]
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1953              		.loc 1 1034 23 view .LVU571
 1954 0036 C91A     		subs	r1, r1, r3
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1955              		.loc 1 1035 41 view .LVU572
ARM GAS  /tmp/ccC60hwS.s 			page 82


 1956 0038 22F00103 		bic	r3, r2, #1
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1957              		.loc 1 1035 23 view .LVU573
 1958 003c 049A     		ldr	r2, [sp, #16]
1036:Src/mpu6050.c **** 
 1959              		.loc 1 1036 41 view .LVU574
 1960 003e 20F00100 		bic	r0, r0, #1
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1961              		.loc 1 1035 23 view .LVU575
 1962 0042 D21A     		subs	r2, r2, r3
1036:Src/mpu6050.c **** 
 1963              		.loc 1 1036 23 view .LVU576
 1964 0044 059B     		ldr	r3, [sp, #20]
1045:Src/mpu6050.c ****         return -1;
 1965              		.loc 1 1045 21 view .LVU577
 1966 0046 1A4C     		ldr	r4, .L113+4
 1967              	.LVL137:
1036:Src/mpu6050.c **** 
 1968              		.loc 1 1036 23 view .LVU578
 1969 0048 1B1A     		subs	r3, r3, r0
1038:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1970              		.loc 1 1038 34 view .LVU579
 1971 004a 0812     		asrs	r0, r1, #8
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1972              		.loc 1 1034 23 view .LVU580
 1973 004c 0391     		str	r1, [sp, #12]
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1974              		.loc 1 1035 5 is_stmt 1 view .LVU581
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1975              		.loc 1 1035 23 is_stmt 0 view .LVU582
 1976 004e 0492     		str	r2, [sp, #16]
1036:Src/mpu6050.c **** 
 1977              		.loc 1 1036 5 is_stmt 1 view .LVU583
1038:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1978              		.loc 1 1038 13 is_stmt 0 view .LVU584
 1979 0050 8DF80400 		strb	r0, [sp, #4]
1039:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1980              		.loc 1 1039 13 view .LVU585
 1981 0054 8DF80510 		strb	r1, [sp, #5]
1041:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1982              		.loc 1 1041 13 view .LVU586
 1983 0058 8DF80720 		strb	r2, [sp, #7]
1040:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1984              		.loc 1 1040 34 view .LVU587
 1985 005c 1112     		asrs	r1, r2, #8
1045:Src/mpu6050.c ****         return -1;
 1986              		.loc 1 1045 9 view .LVU588
 1987 005e 6068     		ldr	r0, [r4, #4]
1042:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1988              		.loc 1 1042 34 view .LVU589
 1989 0060 1A12     		asrs	r2, r3, #8
1036:Src/mpu6050.c **** 
 1990              		.loc 1 1036 23 view .LVU590
 1991 0062 0593     		str	r3, [sp, #20]
1038:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1992              		.loc 1 1038 5 is_stmt 1 view .LVU591
1039:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
ARM GAS  /tmp/ccC60hwS.s 			page 83


 1993              		.loc 1 1039 5 view .LVU592
1040:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1994              		.loc 1 1040 5 view .LVU593
1040:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1995              		.loc 1 1040 13 is_stmt 0 view .LVU594
 1996 0064 8DF80610 		strb	r1, [sp, #6]
1041:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1997              		.loc 1 1041 5 is_stmt 1 view .LVU595
1042:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1998              		.loc 1 1042 5 view .LVU596
1042:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1999              		.loc 1 1042 13 is_stmt 0 view .LVU597
 2000 0068 8DF80820 		strb	r2, [sp, #8]
1043:Src/mpu6050.c **** 
 2001              		.loc 1 1043 5 is_stmt 1 view .LVU598
1043:Src/mpu6050.c **** 
 2002              		.loc 1 1043 13 is_stmt 0 view .LVU599
 2003 006c 8DF80930 		strb	r3, [sp, #9]
1045:Src/mpu6050.c ****         return -1;
 2004              		.loc 1 1045 5 is_stmt 1 view .LVU600
1045:Src/mpu6050.c ****         return -1;
 2005              		.loc 1 1045 9 is_stmt 0 view .LVU601
 2006 0070 0222     		movs	r2, #2
 2007 0072 7721     		movs	r1, #119
 2008 0074 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2009 0076 01AB     		add	r3, sp, #4
 2010 0078 FFF7FEFF 		bl	i2c_writeBytes
 2011              	.LVL138:
1045:Src/mpu6050.c ****         return -1;
 2012              		.loc 1 1045 8 view .LVU602
 2013 007c 0028     		cmp	r0, #0
 2014 007e D0D1     		bne	.L112
1047:Src/mpu6050.c ****         return -1;
 2015              		.loc 1 1047 5 is_stmt 1 view .LVU603
1047:Src/mpu6050.c ****         return -1;
 2016              		.loc 1 1047 9 is_stmt 0 view .LVU604
 2017 0080 6068     		ldr	r0, [r4, #4]
 2018 0082 0222     		movs	r2, #2
 2019 0084 7A21     		movs	r1, #122
 2020 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2021 0088 0DF10603 		add	r3, sp, #6
 2022 008c FFF7FEFF 		bl	i2c_writeBytes
 2023              	.LVL139:
1047:Src/mpu6050.c ****         return -1;
 2024              		.loc 1 1047 8 view .LVU605
 2025 0090 0028     		cmp	r0, #0
 2026 0092 C6D1     		bne	.L112
1049:Src/mpu6050.c ****         return -1;
 2027              		.loc 1 1049 5 is_stmt 1 view .LVU606
1049:Src/mpu6050.c ****         return -1;
 2028              		.loc 1 1049 9 is_stmt 0 view .LVU607
 2029 0094 6068     		ldr	r0, [r4, #4]
 2030 0096 0222     		movs	r2, #2
 2031 0098 7D21     		movs	r1, #125
 2032 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2033 009c 02AB     		add	r3, sp, #8
 2034 009e FFF7FEFF 		bl	i2c_writeBytes
ARM GAS  /tmp/ccC60hwS.s 			page 84


 2035              	.LVL140:
1049:Src/mpu6050.c ****         return -1;
 2036              		.loc 1 1049 8 view .LVU608
 2037 00a2 0038     		subs	r0, r0, #0
 2038 00a4 18BF     		it	ne
 2039 00a6 0120     		movne	r0, #1
 2040 00a8 4042     		rsbs	r0, r0, #0
 2041 00aa BCE7     		b	.L109
 2042              	.L114:
 2043              		.align	2
 2044              	.L113:
 2045 00ac 00000000 		.word	.LANCHOR1
 2046 00b0 00000000 		.word	.LANCHOR0
 2047              		.cfi_endproc
 2048              	.LFE72:
 2050              		.section	.text.mpu_reset_fifo,"ax",%progbits
 2051              		.align	1
 2052              		.global	mpu_reset_fifo
 2053              		.syntax unified
 2054              		.thumb
 2055              		.thumb_func
 2056              		.fpu softvfp
 2058              	mpu_reset_fifo:
 2059              	.LFB73:
1061:Src/mpu6050.c ****     unsigned char data;
 2060              		.loc 1 1061 1 is_stmt 1 view -0
 2061              		.cfi_startproc
 2062              		@ args = 0, pretend = 0, frame = 8
 2063              		@ frame_needed = 0, uses_anonymous_args = 0
1062:Src/mpu6050.c **** 
 2064              		.loc 1 1062 5 view .LVU610
1064:Src/mpu6050.c ****         return -1;
 2065              		.loc 1 1064 5 view .LVU611
1061:Src/mpu6050.c ****     unsigned char data;
 2066              		.loc 1 1061 1 is_stmt 0 view .LVU612
 2067 0000 13B5     		push	{r0, r1, r4, lr}
 2068              	.LCFI39:
 2069              		.cfi_def_cfa_offset 16
 2070              		.cfi_offset 4, -8
 2071              		.cfi_offset 14, -4
1064:Src/mpu6050.c ****         return -1;
 2072              		.loc 1 1064 22 view .LVU613
 2073 0002 584C     		ldr	r4, .L130
1064:Src/mpu6050.c ****         return -1;
 2074              		.loc 1 1064 8 view .LVU614
 2075 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2076 0006 1BB9     		cbnz	r3, .L116
 2077              	.L118:
1065:Src/mpu6050.c **** 
 2078              		.loc 1 1065 16 view .LVU615
 2079 0008 4FF0FF30 		mov	r0, #-1
 2080              	.L115:
1115:Src/mpu6050.c **** 
 2081              		.loc 1 1115 1 view .LVU616
 2082 000c 02B0     		add	sp, sp, #8
 2083              	.LCFI40:
 2084              		.cfi_remember_state
ARM GAS  /tmp/ccC60hwS.s 			page 85


 2085              		.cfi_def_cfa_offset 8
 2086              		@ sp needed
 2087 000e 10BD     		pop	{r4, pc}
 2088              	.L116:
 2089              	.LCFI41:
 2090              		.cfi_restore_state
1067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2091              		.loc 1 1067 5 is_stmt 1 view .LVU617
1067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2092              		.loc 1 1067 10 is_stmt 0 view .LVU618
 2093 0010 0023     		movs	r3, #0
1068:Src/mpu6050.c ****         return -1;
 2094              		.loc 1 1068 9 view .LVU619
 2095 0012 D4E90010 		ldrd	r1, r0, [r4]
1067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2096              		.loc 1 1067 10 view .LVU620
 2097 0016 8DF80730 		strb	r3, [sp, #7]
1068:Src/mpu6050.c ****         return -1;
 2098              		.loc 1 1068 5 is_stmt 1 view .LVU621
1068:Src/mpu6050.c ****         return -1;
 2099              		.loc 1 1068 9 is_stmt 0 view .LVU622
 2100 001a 0122     		movs	r2, #1
 2101 001c 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2102 001e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2103 0020 0DF10703 		add	r3, sp, #7
 2104 0024 FFF7FEFF 		bl	i2c_writeBytes
 2105              	.LVL141:
1068:Src/mpu6050.c ****         return -1;
 2106              		.loc 1 1068 8 view .LVU623
 2107 0028 0028     		cmp	r0, #0
 2108 002a EDD1     		bne	.L118
1070:Src/mpu6050.c ****         return -1;
 2109              		.loc 1 1070 5 is_stmt 1 view .LVU624
1070:Src/mpu6050.c ****         return -1;
 2110              		.loc 1 1070 9 is_stmt 0 view .LVU625
 2111 002c D4E90010 		ldrd	r1, r0, [r4]
 2112 0030 0122     		movs	r2, #1
 2113 0032 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 2114 0034 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2115 0036 0DF10703 		add	r3, sp, #7
 2116 003a FFF7FEFF 		bl	i2c_writeBytes
 2117              	.LVL142:
1070:Src/mpu6050.c ****         return -1;
 2118              		.loc 1 1070 8 view .LVU626
 2119 003e 0028     		cmp	r0, #0
 2120 0040 E2D1     		bne	.L118
1072:Src/mpu6050.c ****         return -1;
 2121              		.loc 1 1072 5 is_stmt 1 view .LVU627
1072:Src/mpu6050.c ****         return -1;
 2122              		.loc 1 1072 9 is_stmt 0 view .LVU628
 2123 0042 D4E90010 		ldrd	r1, r0, [r4]
 2124 0046 0122     		movs	r2, #1
 2125 0048 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2126 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2127 004c 0DF10703 		add	r3, sp, #7
 2128 0050 FFF7FEFF 		bl	i2c_writeBytes
 2129              	.LVL143:
ARM GAS  /tmp/ccC60hwS.s 			page 86


1072:Src/mpu6050.c ****         return -1;
 2130              		.loc 1 1072 8 view .LVU629
 2131 0054 0028     		cmp	r0, #0
 2132 0056 D7D1     		bne	.L118
1075:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
 2133              		.loc 1 1075 5 is_stmt 1 view .LVU630
1077:Src/mpu6050.c ****             return -1;
 2134              		.loc 1 1077 13 is_stmt 0 view .LVU631
 2135 0058 D4E90030 		ldrd	r3, r0, [r4]
 2136 005c 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
1075:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
 2137              		.loc 1 1075 8 view .LVU632
 2138 005e 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 2139 0062 002B     		cmp	r3, #0
 2140 0064 42D0     		beq	.L119
1076:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2141              		.loc 1 1076 9 is_stmt 1 view .LVU633
1076:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2142              		.loc 1 1076 14 is_stmt 0 view .LVU634
 2143 0066 0C23     		movs	r3, #12
 2144 0068 8DF80730 		strb	r3, [sp, #7]
1077:Src/mpu6050.c ****             return -1;
 2145              		.loc 1 1077 9 is_stmt 1 view .LVU635
1077:Src/mpu6050.c ****             return -1;
 2146              		.loc 1 1077 13 is_stmt 0 view .LVU636
 2147 006c 0122     		movs	r2, #1
 2148 006e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2149 0070 0DF10703 		add	r3, sp, #7
 2150 0074 FFF7FEFF 		bl	i2c_writeBytes
 2151              	.LVL144:
1077:Src/mpu6050.c ****             return -1;
 2152              		.loc 1 1077 12 view .LVU637
 2153 0078 0028     		cmp	r0, #0
 2154 007a C5D1     		bne	.L118
1079:Src/mpu6050.c ****         data = BIT_DMP_EN | BIT_FIFO_EN;
 2155              		.loc 1 1079 9 is_stmt 1 view .LVU638
 2156 007c 3220     		movs	r0, #50
 2157 007e FFF7FEFF 		bl	delay_1ms
 2158              	.LVL145:
1080:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
 2159              		.loc 1 1080 9 view .LVU639
1083:Src/mpu6050.c ****             return -1;
 2160              		.loc 1 1083 13 is_stmt 0 view .LVU640
 2161 0082 D4E90010 		ldrd	r1, r0, [r4]
1080:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
 2162              		.loc 1 1080 14 view .LVU641
 2163 0086 C023     		movs	r3, #192
 2164 0088 8DF80730 		strb	r3, [sp, #7]
1081:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2165              		.loc 1 1081 9 is_stmt 1 view .LVU642
1081:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2166              		.loc 1 1081 12 is_stmt 0 view .LVU643
 2167 008c A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
1083:Src/mpu6050.c ****             return -1;
 2168              		.loc 1 1083 13 view .LVU644
 2169 008e 0122     		movs	r2, #1
1081:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
ARM GAS  /tmp/ccC60hwS.s 			page 87


 2170              		.loc 1 1081 12 view .LVU645
 2171 0090 DB07     		lsls	r3, r3, #31
1082:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2172              		.loc 1 1082 13 is_stmt 1 view .LVU646
1082:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2173              		.loc 1 1082 18 is_stmt 0 view .LVU647
 2174 0092 44BF     		itt	mi
 2175 0094 E023     		movmi	r3, #224
 2176 0096 8DF80730 		strbmi	r3, [sp, #7]
1083:Src/mpu6050.c ****             return -1;
 2177              		.loc 1 1083 9 is_stmt 1 view .LVU648
1083:Src/mpu6050.c ****             return -1;
 2178              		.loc 1 1083 13 is_stmt 0 view .LVU649
 2179 009a 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2180 009c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2181 009e 0DF10703 		add	r3, sp, #7
 2182 00a2 FFF7FEFF 		bl	i2c_writeBytes
 2183              	.LVL146:
1083:Src/mpu6050.c ****             return -1;
 2184              		.loc 1 1083 12 view .LVU650
 2185 00a6 0028     		cmp	r0, #0
 2186 00a8 AED1     		bne	.L118
1085:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
 2187              		.loc 1 1085 9 is_stmt 1 view .LVU651
1089:Src/mpu6050.c ****             return -1;
 2188              		.loc 1 1089 13 is_stmt 0 view .LVU652
 2189 00aa D4E90010 		ldrd	r1, r0, [r4]
1085:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
 2190              		.loc 1 1085 24 view .LVU653
 2191 00ae 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
1089:Src/mpu6050.c ****             return -1;
 2192              		.loc 1 1089 13 view .LVU654
 2193 00b0 0122     		movs	r2, #1
1086:Src/mpu6050.c ****         else
 2194              		.loc 1 1086 18 view .LVU655
 2195 00b2 002B     		cmp	r3, #0
 2196 00b4 18BF     		it	ne
 2197 00b6 0223     		movne	r3, #2
 2198 00b8 8DF80730 		strb	r3, [sp, #7]
1089:Src/mpu6050.c ****             return -1;
 2199              		.loc 1 1089 9 is_stmt 1 view .LVU656
1089:Src/mpu6050.c ****             return -1;
 2200              		.loc 1 1089 13 is_stmt 0 view .LVU657
 2201 00bc 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2202 00be 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2203 00c0 0DF10703 		add	r3, sp, #7
 2204 00c4 FFF7FEFF 		bl	i2c_writeBytes
 2205              	.LVL147:
1089:Src/mpu6050.c ****             return -1;
 2206              		.loc 1 1089 12 view .LVU658
 2207 00c8 0028     		cmp	r0, #0
 2208 00ca 9DD1     		bne	.L118
1091:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
 2209              		.loc 1 1091 9 is_stmt 1 view .LVU659
1092:Src/mpu6050.c ****             return -1;
 2210              		.loc 1 1092 13 is_stmt 0 view .LVU660
 2211 00cc 0DF10703 		add	r3, sp, #7
ARM GAS  /tmp/ccC60hwS.s 			page 88


1091:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
 2212              		.loc 1 1091 14 view .LVU661
 2213 00d0 8DF80700 		strb	r0, [sp, #7]
1092:Src/mpu6050.c ****             return -1;
 2214              		.loc 1 1092 9 is_stmt 1 view .LVU662
1092:Src/mpu6050.c ****             return -1;
 2215              		.loc 1 1092 13 is_stmt 0 view .LVU663
 2216 00d4 D4E90010 		ldrd	r1, r0, [r4]
 2217              	.L129:
1111:Src/mpu6050.c ****             return -1;
 2218              		.loc 1 1111 13 view .LVU664
 2219 00d8 0122     		movs	r2, #1
 2220 00da 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 2221 00dc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2222 00de FFF7FEFF 		bl	i2c_writeBytes
 2223              	.LVL148:
1111:Src/mpu6050.c ****             return -1;
 2224              		.loc 1 1111 12 view .LVU665
 2225 00e2 0038     		subs	r0, r0, #0
 2226 00e4 18BF     		it	ne
 2227 00e6 0120     		movne	r0, #1
 2228 00e8 4042     		rsbs	r0, r0, #0
 2229 00ea 8FE7     		b	.L115
 2230              	.L119:
1095:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2231              		.loc 1 1095 9 is_stmt 1 view .LVU666
1095:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2232              		.loc 1 1095 14 is_stmt 0 view .LVU667
 2233 00ec 0423     		movs	r3, #4
 2234 00ee 8DF80730 		strb	r3, [sp, #7]
1096:Src/mpu6050.c ****             return -1;
 2235              		.loc 1 1096 9 is_stmt 1 view .LVU668
1096:Src/mpu6050.c ****             return -1;
 2236              		.loc 1 1096 13 is_stmt 0 view .LVU669
 2237 00f2 0122     		movs	r2, #1
 2238 00f4 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2239 00f6 0DF10703 		add	r3, sp, #7
 2240 00fa FFF7FEFF 		bl	i2c_writeBytes
 2241              	.LVL149:
1096:Src/mpu6050.c ****             return -1;
 2242              		.loc 1 1096 12 view .LVU670
 2243 00fe 0028     		cmp	r0, #0
 2244 0100 82D1     		bne	.L118
1098:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2245              		.loc 1 1098 9 is_stmt 1 view .LVU671
1098:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2246              		.loc 1 1098 12 is_stmt 0 view .LVU672
 2247 0102 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 2248 0104 63BB     		cbnz	r3, .L124
1098:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2249              		.loc 1 1098 37 discriminator 1 view .LVU673
 2250 0106 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
1101:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2251              		.loc 1 1101 18 discriminator 1 view .LVU674
 2252 0108 13F0010F 		tst	r3, #1
 2253 010c 0CBF     		ite	eq
 2254 010e 4023     		moveq	r3, #64
ARM GAS  /tmp/ccC60hwS.s 			page 89


 2255 0110 6023     		movne	r3, #96
 2256              	.L122:
1102:Src/mpu6050.c ****             return -1;
 2257              		.loc 1 1102 13 view .LVU675
 2258 0112 D4E90010 		ldrd	r1, r0, [r4]
 2259 0116 8DF80730 		strb	r3, [sp, #7]
1102:Src/mpu6050.c ****             return -1;
 2260              		.loc 1 1102 9 is_stmt 1 view .LVU676
1102:Src/mpu6050.c ****             return -1;
 2261              		.loc 1 1102 13 is_stmt 0 view .LVU677
 2262 011a 0122     		movs	r2, #1
 2263 011c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2264 011e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2265 0120 0DF10703 		add	r3, sp, #7
 2266 0124 FFF7FEFF 		bl	i2c_writeBytes
 2267              	.LVL150:
1102:Src/mpu6050.c ****             return -1;
 2268              		.loc 1 1102 12 view .LVU678
 2269 0128 0028     		cmp	r0, #0
 2270 012a 7FF46DAF 		bne	.L118
1104:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
 2271              		.loc 1 1104 9 is_stmt 1 view .LVU679
 2272 012e 3220     		movs	r0, #50
 2273 0130 FFF7FEFF 		bl	delay_1ms
 2274              	.LVL151:
1105:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2275              		.loc 1 1105 9 view .LVU680
1109:Src/mpu6050.c ****             return -1;
 2276              		.loc 1 1109 13 is_stmt 0 view .LVU681
 2277 0134 D4E90010 		ldrd	r1, r0, [r4]
1105:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2278              		.loc 1 1105 12 view .LVU682
 2279 0138 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
1109:Src/mpu6050.c ****             return -1;
 2280              		.loc 1 1109 13 view .LVU683
 2281 013a 0122     		movs	r2, #1
1105:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2282              		.loc 1 1105 12 view .LVU684
 2283 013c 003B     		subs	r3, r3, #0
 2284 013e 18BF     		it	ne
 2285 0140 0123     		movne	r3, #1
 2286 0142 8DF80730 		strb	r3, [sp, #7]
1109:Src/mpu6050.c ****             return -1;
 2287              		.loc 1 1109 9 is_stmt 1 view .LVU685
1109:Src/mpu6050.c ****             return -1;
 2288              		.loc 1 1109 13 is_stmt 0 view .LVU686
 2289 0146 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2290 0148 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2291 014a 0DF10703 		add	r3, sp, #7
 2292 014e FFF7FEFF 		bl	i2c_writeBytes
 2293              	.LVL152:
1109:Src/mpu6050.c ****             return -1;
 2294              		.loc 1 1109 12 view .LVU687
 2295 0152 0028     		cmp	r0, #0
 2296 0154 7FF458AF 		bne	.L118
1111:Src/mpu6050.c ****             return -1;
 2297              		.loc 1 1111 9 is_stmt 1 view .LVU688
ARM GAS  /tmp/ccC60hwS.s 			page 90


1111:Src/mpu6050.c ****             return -1;
 2298              		.loc 1 1111 13 is_stmt 0 view .LVU689
 2299 0158 D4E90010 		ldrd	r1, r0, [r4]
 2300 015c 024B     		ldr	r3, .L130+4
 2301 015e BBE7     		b	.L129
 2302              	.L124:
1099:Src/mpu6050.c ****         else
 2303              		.loc 1 1099 18 view .LVU690
 2304 0160 4023     		movs	r3, #64
 2305 0162 D6E7     		b	.L122
 2306              	.L131:
 2307              		.align	2
 2308              	.L130:
 2309 0164 00000000 		.word	.LANCHOR0
 2310 0168 10000000 		.word	.LANCHOR0+16
 2311              		.cfi_endproc
 2312              	.LFE73:
 2314              		.section	.text.mpu_get_gyro_fsr,"ax",%progbits
 2315              		.align	1
 2316              		.global	mpu_get_gyro_fsr
 2317              		.syntax unified
 2318              		.thumb
 2319              		.thumb_func
 2320              		.fpu softvfp
 2322              	mpu_get_gyro_fsr:
 2323              	.LVL153:
 2324              	.LFB74:
1123:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
 2325              		.loc 1 1123 1 is_stmt 1 view -0
 2326              		.cfi_startproc
 2327              		@ args = 0, pretend = 0, frame = 0
 2328              		@ frame_needed = 0, uses_anonymous_args = 0
 2329              		@ link register save eliminated.
1124:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2330              		.loc 1 1124 5 view .LVU692
1124:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2331              		.loc 1 1124 24 is_stmt 0 view .LVU693
 2332 0000 0B4B     		ldr	r3, .L141
1124:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2333              		.loc 1 1124 5 view .LVU694
 2334 0002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2335 0004 032B     		cmp	r3, #3
 2336 0006 10D8     		bhi	.L133
 2337 0008 DFE803F0 		tbb	[pc, r3]
 2338              	.L135:
 2339 000c 02       		.byte	(.L138-.L135)/2
 2340 000d 06       		.byte	(.L137-.L135)/2
 2341 000e 09       		.byte	(.L136-.L135)/2
 2342 000f 0C       		.byte	(.L134-.L135)/2
 2343              		.p2align 1
 2344              	.L138:
1126:Src/mpu6050.c ****         break;
 2345              		.loc 1 1126 9 is_stmt 1 view .LVU695
1126:Src/mpu6050.c ****         break;
 2346              		.loc 1 1126 16 is_stmt 0 view .LVU696
 2347 0010 FA23     		movs	r3, #250
 2348              	.L140:
ARM GAS  /tmp/ccC60hwS.s 			page 91


1138:Src/mpu6050.c ****         break;
 2349              		.loc 1 1138 16 view .LVU697
 2350 0012 0380     		strh	r3, [r0]	@ movhi
1139:Src/mpu6050.c ****     }
 2351              		.loc 1 1139 9 is_stmt 1 view .LVU698
1141:Src/mpu6050.c **** }
 2352              		.loc 1 1141 5 view .LVU699
1142:Src/mpu6050.c **** 
 2353              		.loc 1 1142 1 is_stmt 0 view .LVU700
 2354 0014 0020     		movs	r0, #0
 2355              	.LVL154:
1142:Src/mpu6050.c **** 
 2356              		.loc 1 1142 1 view .LVU701
 2357 0016 7047     		bx	lr
 2358              	.LVL155:
 2359              	.L137:
1129:Src/mpu6050.c ****         break;
 2360              		.loc 1 1129 9 is_stmt 1 view .LVU702
1129:Src/mpu6050.c ****         break;
 2361              		.loc 1 1129 16 is_stmt 0 view .LVU703
 2362 0018 4FF4FA73 		mov	r3, #500
 2363 001c F9E7     		b	.L140
 2364              	.L136:
1132:Src/mpu6050.c ****         break;
 2365              		.loc 1 1132 9 is_stmt 1 view .LVU704
1132:Src/mpu6050.c ****         break;
 2366              		.loc 1 1132 16 is_stmt 0 view .LVU705
 2367 001e 4FF47A73 		mov	r3, #1000
 2368 0022 F6E7     		b	.L140
 2369              	.L134:
1135:Src/mpu6050.c ****         break;
 2370              		.loc 1 1135 9 is_stmt 1 view .LVU706
1135:Src/mpu6050.c ****         break;
 2371              		.loc 1 1135 16 is_stmt 0 view .LVU707
 2372 0024 4FF4FA63 		mov	r3, #2000
 2373 0028 F3E7     		b	.L140
 2374              	.L133:
1138:Src/mpu6050.c ****         break;
 2375              		.loc 1 1138 9 is_stmt 1 view .LVU708
1138:Src/mpu6050.c ****         break;
 2376              		.loc 1 1138 16 is_stmt 0 view .LVU709
 2377 002a 0023     		movs	r3, #0
 2378 002c F1E7     		b	.L140
 2379              	.L142:
 2380 002e 00BF     		.align	2
 2381              	.L141:
 2382 0030 00000000 		.word	.LANCHOR0
 2383              		.cfi_endproc
 2384              	.LFE74:
 2386              		.section	.text.mpu_set_gyro_fsr,"ax",%progbits
 2387              		.align	1
 2388              		.global	mpu_set_gyro_fsr
 2389              		.syntax unified
 2390              		.thumb
 2391              		.thumb_func
 2392              		.fpu softvfp
 2394              	mpu_set_gyro_fsr:
ARM GAS  /tmp/ccC60hwS.s 			page 92


 2395              	.LVL156:
 2396              	.LFB75:
1150:Src/mpu6050.c ****     unsigned char data;
 2397              		.loc 1 1150 1 is_stmt 1 view -0
 2398              		.cfi_startproc
 2399              		@ args = 0, pretend = 0, frame = 8
 2400              		@ frame_needed = 0, uses_anonymous_args = 0
1151:Src/mpu6050.c **** 
 2401              		.loc 1 1151 5 view .LVU711
1153:Src/mpu6050.c ****         return -1;
 2402              		.loc 1 1153 5 view .LVU712
1150:Src/mpu6050.c ****     unsigned char data;
 2403              		.loc 1 1150 1 is_stmt 0 view .LVU713
 2404 0000 13B5     		push	{r0, r1, r4, lr}
 2405              	.LCFI42:
 2406              		.cfi_def_cfa_offset 16
 2407              		.cfi_offset 4, -8
 2408              		.cfi_offset 14, -4
1153:Src/mpu6050.c ****         return -1;
 2409              		.loc 1 1153 22 view .LVU714
 2410 0002 1A4C     		ldr	r4, .L156
1153:Src/mpu6050.c ****         return -1;
 2411              		.loc 1 1153 8 view .LVU715
 2412 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2413 0006 1BB9     		cbnz	r3, .L144
 2414              	.LVL157:
 2415              	.L155:
1156:Src/mpu6050.c ****     case 250:
 2416              		.loc 1 1156 5 view .LVU716
 2417 0008 4FF0FF30 		mov	r0, #-1
 2418              	.L143:
1179:Src/mpu6050.c **** 
 2419              		.loc 1 1179 1 view .LVU717
 2420 000c 02B0     		add	sp, sp, #8
 2421              	.LCFI43:
 2422              		.cfi_remember_state
 2423              		.cfi_def_cfa_offset 8
 2424              		@ sp needed
 2425 000e 10BD     		pop	{r4, pc}
 2426              	.LVL158:
 2427              	.L144:
 2428              	.LCFI44:
 2429              		.cfi_restore_state
1156:Src/mpu6050.c ****     case 250:
 2430              		.loc 1 1156 5 is_stmt 1 view .LVU718
 2431 0010 B0F57A7F 		cmp	r0, #1000
 2432 0014 25D0     		beq	.L146
 2433 0016 06D8     		bhi	.L147
 2434 0018 FA28     		cmp	r0, #250
 2435 001a 09D0     		beq	.L148
 2436 001c B0F5FA7F 		cmp	r0, #500
 2437 0020 F2D1     		bne	.L155
1161:Src/mpu6050.c ****         break;
 2438              		.loc 1 1161 9 view .LVU719
1161:Src/mpu6050.c ****         break;
 2439              		.loc 1 1161 14 is_stmt 0 view .LVU720
 2440 0022 0823     		movs	r3, #8
ARM GAS  /tmp/ccC60hwS.s 			page 93


 2441 0024 05E0     		b	.L154
 2442              	.L147:
1156:Src/mpu6050.c ****     case 250:
 2443              		.loc 1 1156 5 view .LVU721
 2444 0026 B0F5FA6F 		cmp	r0, #2000
 2445 002a EDD1     		bne	.L155
1167:Src/mpu6050.c ****         break;
 2446              		.loc 1 1167 9 is_stmt 1 view .LVU722
1167:Src/mpu6050.c ****         break;
 2447              		.loc 1 1167 14 is_stmt 0 view .LVU723
 2448 002c 1823     		movs	r3, #24
 2449 002e 00E0     		b	.L154
 2450              	.L148:
1158:Src/mpu6050.c ****         break;
 2451              		.loc 1 1158 9 is_stmt 1 view .LVU724
1158:Src/mpu6050.c ****         break;
 2452              		.loc 1 1158 14 is_stmt 0 view .LVU725
 2453 0030 0023     		movs	r3, #0
 2454              	.L154:
1167:Src/mpu6050.c ****         break;
 2455              		.loc 1 1167 14 view .LVU726
 2456 0032 8DF80730 		strb	r3, [sp, #7]
1168:Src/mpu6050.c ****     default:
 2457              		.loc 1 1168 9 is_stmt 1 view .LVU727
1173:Src/mpu6050.c ****         return 0;
 2458              		.loc 1 1173 5 view .LVU728
1173:Src/mpu6050.c ****         return 0;
 2459              		.loc 1 1173 30 is_stmt 0 view .LVU729
 2460 0036 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
1173:Src/mpu6050.c ****         return 0;
 2461              		.loc 1 1173 8 view .LVU730
 2462 003a 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 2463 003c B3EBD20F 		cmp	r3, r2, lsr #3
 2464 0040 11D0     		beq	.L153
1175:Src/mpu6050.c ****         return -1;
 2465              		.loc 1 1175 5 is_stmt 1 view .LVU731
1175:Src/mpu6050.c ****         return -1;
 2466              		.loc 1 1175 9 is_stmt 0 view .LVU732
 2467 0042 D4E90010 		ldrd	r1, r0, [r4]
 2468              	.LVL159:
1175:Src/mpu6050.c ****         return -1;
 2469              		.loc 1 1175 9 view .LVU733
 2470 0046 0122     		movs	r2, #1
 2471 0048 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 2472 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2473 004c 0DF10703 		add	r3, sp, #7
 2474 0050 FFF7FEFF 		bl	i2c_writeBytes
 2475              	.LVL160:
1175:Src/mpu6050.c ****         return -1;
 2476              		.loc 1 1175 8 view .LVU734
 2477 0054 0028     		cmp	r0, #0
 2478 0056 D7D1     		bne	.L155
1177:Src/mpu6050.c ****     return 0;
 2479              		.loc 1 1177 5 is_stmt 1 view .LVU735
1177:Src/mpu6050.c ****     return 0;
 2480              		.loc 1 1177 26 is_stmt 0 view .LVU736
 2481 0058 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 94


 2482 005c DB08     		lsrs	r3, r3, #3
 2483 005e 2372     		strb	r3, [r4, #8]
1178:Src/mpu6050.c **** }
 2484              		.loc 1 1178 5 is_stmt 1 view .LVU737
1178:Src/mpu6050.c **** }
 2485              		.loc 1 1178 12 is_stmt 0 view .LVU738
 2486 0060 D4E7     		b	.L143
 2487              	.LVL161:
 2488              	.L146:
1164:Src/mpu6050.c ****         break;
 2489              		.loc 1 1164 9 is_stmt 1 view .LVU739
1164:Src/mpu6050.c ****         break;
 2490              		.loc 1 1164 14 is_stmt 0 view .LVU740
 2491 0062 1023     		movs	r3, #16
 2492 0064 E5E7     		b	.L154
 2493              	.L153:
1174:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
 2494              		.loc 1 1174 16 view .LVU741
 2495 0066 0020     		movs	r0, #0
 2496              	.LVL162:
1174:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
 2497              		.loc 1 1174 16 view .LVU742
 2498 0068 D0E7     		b	.L143
 2499              	.L157:
 2500 006a 00BF     		.align	2
 2501              	.L156:
 2502 006c 00000000 		.word	.LANCHOR0
 2503              		.cfi_endproc
 2504              	.LFE75:
 2506              		.section	.text.mpu_get_accel_fsr,"ax",%progbits
 2507              		.align	1
 2508              		.global	mpu_get_accel_fsr
 2509              		.syntax unified
 2510              		.thumb
 2511              		.thumb_func
 2512              		.fpu softvfp
 2514              	mpu_get_accel_fsr:
 2515              	.LVL163:
 2516              	.LFB76:
1187:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
 2517              		.loc 1 1187 1 is_stmt 1 view -0
 2518              		.cfi_startproc
 2519              		@ args = 0, pretend = 0, frame = 0
 2520              		@ frame_needed = 0, uses_anonymous_args = 0
 2521              		@ link register save eliminated.
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2522              		.loc 1 1188 5 view .LVU744
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2523              		.loc 1 1188 24 is_stmt 0 view .LVU745
 2524 0000 0C4B     		ldr	r3, .L170
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2525              		.loc 1 1188 5 view .LVU746
 2526 0002 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 2527 0004 032A     		cmp	r2, #3
 2528 0006 12D8     		bhi	.L166
 2529 0008 DFE802F0 		tbb	[pc, r2]
 2530              	.L161:
ARM GAS  /tmp/ccC60hwS.s 			page 95


 2531 000c 02       		.byte	(.L164-.L161)/2
 2532 000d 0B       		.byte	(.L163-.L161)/2
 2533 000e 0D       		.byte	(.L162-.L161)/2
 2534 000f 0F       		.byte	(.L160-.L161)/2
 2535              		.p2align 1
 2536              	.L164:
1190:Src/mpu6050.c ****         break;
 2537              		.loc 1 1190 9 is_stmt 1 view .LVU747
1190:Src/mpu6050.c ****         break;
 2538              		.loc 1 1190 16 is_stmt 0 view .LVU748
 2539 0010 0222     		movs	r2, #2
 2540              	.L168:
1199:Src/mpu6050.c ****         break;
 2541              		.loc 1 1199 16 view .LVU749
 2542 0012 0270     		strb	r2, [r0]
1200:Src/mpu6050.c ****     default:
 2543              		.loc 1 1200 9 is_stmt 1 view .LVU750
1204:Src/mpu6050.c ****         fsr[0] <<= 1;
 2544              		.loc 1 1204 5 view .LVU751
1204:Src/mpu6050.c ****         fsr[0] <<= 1;
 2545              		.loc 1 1204 8 is_stmt 0 view .LVU752
 2546 0014 DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 2547 0016 13B1     		cbz	r3, .L169
1205:Src/mpu6050.c ****     return 0;
 2548              		.loc 1 1205 9 is_stmt 1 view .LVU753
1205:Src/mpu6050.c ****     return 0;
 2549              		.loc 1 1205 16 is_stmt 0 view .LVU754
 2550 0018 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 2551 001a 5B00     		lsls	r3, r3, #1
 2552 001c 0370     		strb	r3, [r0]
 2553              	.L169:
1206:Src/mpu6050.c **** }
 2554              		.loc 1 1206 12 view .LVU755
 2555 001e 0020     		movs	r0, #0
 2556              	.LVL164:
1206:Src/mpu6050.c **** }
 2557              		.loc 1 1206 12 view .LVU756
 2558 0020 7047     		bx	lr
 2559              	.LVL165:
 2560              	.L163:
1193:Src/mpu6050.c ****         break;
 2561              		.loc 1 1193 9 is_stmt 1 view .LVU757
1193:Src/mpu6050.c ****         break;
 2562              		.loc 1 1193 16 is_stmt 0 view .LVU758
 2563 0022 0422     		movs	r2, #4
 2564 0024 F5E7     		b	.L168
 2565              	.L162:
1196:Src/mpu6050.c ****         break;
 2566              		.loc 1 1196 9 is_stmt 1 view .LVU759
1196:Src/mpu6050.c ****         break;
 2567              		.loc 1 1196 16 is_stmt 0 view .LVU760
 2568 0026 0822     		movs	r2, #8
 2569 0028 F3E7     		b	.L168
 2570              	.L160:
1199:Src/mpu6050.c ****         break;
 2571              		.loc 1 1199 9 is_stmt 1 view .LVU761
1199:Src/mpu6050.c ****         break;
ARM GAS  /tmp/ccC60hwS.s 			page 96


 2572              		.loc 1 1199 16 is_stmt 0 view .LVU762
 2573 002a 1022     		movs	r2, #16
 2574 002c F1E7     		b	.L168
 2575              	.L166:
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2576              		.loc 1 1188 5 view .LVU763
 2577 002e 4FF0FF30 		mov	r0, #-1
 2578              	.LVL166:
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2579              		.loc 1 1188 5 view .LVU764
 2580 0032 7047     		bx	lr
 2581              	.L171:
 2582              		.align	2
 2583              	.L170:
 2584 0034 00000000 		.word	.LANCHOR0
 2585              		.cfi_endproc
 2586              	.LFE76:
 2588              		.section	.text.mpu_set_accel_fsr,"ax",%progbits
 2589              		.align	1
 2590              		.global	mpu_set_accel_fsr
 2591              		.syntax unified
 2592              		.thumb
 2593              		.thumb_func
 2594              		.fpu softvfp
 2596              	mpu_set_accel_fsr:
 2597              	.LVL167:
 2598              	.LFB77:
1215:Src/mpu6050.c ****     unsigned char data;
 2599              		.loc 1 1215 1 is_stmt 1 view -0
 2600              		.cfi_startproc
 2601              		@ args = 0, pretend = 0, frame = 8
 2602              		@ frame_needed = 0, uses_anonymous_args = 0
1216:Src/mpu6050.c **** 
 2603              		.loc 1 1216 5 view .LVU766
1218:Src/mpu6050.c ****         return -1;
 2604              		.loc 1 1218 5 view .LVU767
1215:Src/mpu6050.c ****     unsigned char data;
 2605              		.loc 1 1215 1 is_stmt 0 view .LVU768
 2606 0000 13B5     		push	{r0, r1, r4, lr}
 2607              	.LCFI45:
 2608              		.cfi_def_cfa_offset 16
 2609              		.cfi_offset 4, -8
 2610              		.cfi_offset 14, -4
1218:Src/mpu6050.c ****         return -1;
 2611              		.loc 1 1218 22 view .LVU769
 2612 0002 184C     		ldr	r4, .L185
1218:Src/mpu6050.c ****         return -1;
 2613              		.loc 1 1218 8 view .LVU770
 2614 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2615 0006 1BB9     		cbnz	r3, .L173
 2616              	.LVL168:
 2617              	.L184:
1221:Src/mpu6050.c ****     case 2:
 2618              		.loc 1 1221 5 view .LVU771
 2619 0008 4FF0FF30 		mov	r0, #-1
 2620              	.L172:
1244:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 97


 2621              		.loc 1 1244 1 view .LVU772
 2622 000c 02B0     		add	sp, sp, #8
 2623              	.LCFI46:
 2624              		.cfi_remember_state
 2625              		.cfi_def_cfa_offset 8
 2626              		@ sp needed
 2627 000e 10BD     		pop	{r4, pc}
 2628              	.LVL169:
 2629              	.L173:
 2630              	.LCFI47:
 2631              		.cfi_restore_state
1221:Src/mpu6050.c ****     case 2:
 2632              		.loc 1 1221 5 is_stmt 1 view .LVU773
 2633 0010 0828     		cmp	r0, #8
 2634 0012 23D0     		beq	.L175
 2635 0014 05D8     		bhi	.L176
 2636 0016 0228     		cmp	r0, #2
 2637 0018 07D0     		beq	.L177
 2638 001a 0428     		cmp	r0, #4
 2639 001c F4D1     		bne	.L184
1226:Src/mpu6050.c ****         break;
 2640              		.loc 1 1226 9 view .LVU774
1226:Src/mpu6050.c ****         break;
 2641              		.loc 1 1226 14 is_stmt 0 view .LVU775
 2642 001e 0823     		movs	r3, #8
 2643 0020 04E0     		b	.L183
 2644              	.L176:
1221:Src/mpu6050.c ****     case 2:
 2645              		.loc 1 1221 5 view .LVU776
 2646 0022 1028     		cmp	r0, #16
 2647 0024 F0D1     		bne	.L184
1232:Src/mpu6050.c ****         break;
 2648              		.loc 1 1232 9 is_stmt 1 view .LVU777
1232:Src/mpu6050.c ****         break;
 2649              		.loc 1 1232 14 is_stmt 0 view .LVU778
 2650 0026 1823     		movs	r3, #24
 2651 0028 00E0     		b	.L183
 2652              	.L177:
1223:Src/mpu6050.c ****         break;
 2653              		.loc 1 1223 9 is_stmt 1 view .LVU779
1223:Src/mpu6050.c ****         break;
 2654              		.loc 1 1223 14 is_stmt 0 view .LVU780
 2655 002a 0023     		movs	r3, #0
 2656              	.L183:
1232:Src/mpu6050.c ****         break;
 2657              		.loc 1 1232 14 view .LVU781
 2658 002c 8DF80730 		strb	r3, [sp, #7]
1233:Src/mpu6050.c ****     default:
 2659              		.loc 1 1233 9 is_stmt 1 view .LVU782
1238:Src/mpu6050.c ****         return 0;
 2660              		.loc 1 1238 5 view .LVU783
1238:Src/mpu6050.c ****         return 0;
 2661              		.loc 1 1238 31 is_stmt 0 view .LVU784
 2662 0030 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
1238:Src/mpu6050.c ****         return 0;
 2663              		.loc 1 1238 8 view .LVU785
 2664 0034 637A     		ldrb	r3, [r4, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 98


 2665 0036 B3EBD20F 		cmp	r3, r2, lsr #3
 2666 003a 11D0     		beq	.L182
1240:Src/mpu6050.c ****         return -1;
 2667              		.loc 1 1240 5 is_stmt 1 view .LVU786
1240:Src/mpu6050.c ****         return -1;
 2668              		.loc 1 1240 9 is_stmt 0 view .LVU787
 2669 003c D4E90010 		ldrd	r1, r0, [r4]
 2670              	.LVL170:
1240:Src/mpu6050.c ****         return -1;
 2671              		.loc 1 1240 9 view .LVU788
 2672 0040 0122     		movs	r2, #1
 2673 0042 C979     		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 2674 0044 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2675 0046 0DF10703 		add	r3, sp, #7
 2676 004a FFF7FEFF 		bl	i2c_writeBytes
 2677              	.LVL171:
1240:Src/mpu6050.c ****         return -1;
 2678              		.loc 1 1240 8 view .LVU789
 2679 004e 0028     		cmp	r0, #0
 2680 0050 DAD1     		bne	.L184
1242:Src/mpu6050.c ****     return 0;
 2681              		.loc 1 1242 5 is_stmt 1 view .LVU790
1242:Src/mpu6050.c ****     return 0;
 2682              		.loc 1 1242 27 is_stmt 0 view .LVU791
 2683 0052 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2684 0056 DB08     		lsrs	r3, r3, #3
 2685 0058 6372     		strb	r3, [r4, #9]
1243:Src/mpu6050.c **** }
 2686              		.loc 1 1243 5 is_stmt 1 view .LVU792
1243:Src/mpu6050.c **** }
 2687              		.loc 1 1243 12 is_stmt 0 view .LVU793
 2688 005a D7E7     		b	.L172
 2689              	.LVL172:
 2690              	.L175:
1229:Src/mpu6050.c ****         break;
 2691              		.loc 1 1229 9 is_stmt 1 view .LVU794
1229:Src/mpu6050.c ****         break;
 2692              		.loc 1 1229 14 is_stmt 0 view .LVU795
 2693 005c 1023     		movs	r3, #16
 2694 005e E5E7     		b	.L183
 2695              	.L182:
1239:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
 2696              		.loc 1 1239 16 view .LVU796
 2697 0060 0020     		movs	r0, #0
 2698              	.LVL173:
1239:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
 2699              		.loc 1 1239 16 view .LVU797
 2700 0062 D3E7     		b	.L172
 2701              	.L186:
 2702              		.align	2
 2703              	.L185:
 2704 0064 00000000 		.word	.LANCHOR0
 2705              		.cfi_endproc
 2706              	.LFE77:
 2708              		.section	.text.mpu_get_lpf,"ax",%progbits
 2709              		.align	1
 2710              		.global	mpu_get_lpf
ARM GAS  /tmp/ccC60hwS.s 			page 99


 2711              		.syntax unified
 2712              		.thumb
 2713              		.thumb_func
 2714              		.fpu softvfp
 2716              	mpu_get_lpf:
 2717              	.LVL174:
 2718              	.LFB78:
1252:Src/mpu6050.c ****     switch (st.chip_cfg.lpf) {
 2719              		.loc 1 1252 1 is_stmt 1 view -0
 2720              		.cfi_startproc
 2721              		@ args = 0, pretend = 0, frame = 0
 2722              		@ frame_needed = 0, uses_anonymous_args = 0
 2723              		@ link register save eliminated.
1253:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2724              		.loc 1 1253 5 view .LVU799
1253:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2725              		.loc 1 1253 24 is_stmt 0 view .LVU800
 2726 0000 0C4B     		ldr	r3, .L198
1253:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2727              		.loc 1 1253 5 view .LVU801
 2728 0002 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 2729 0004 013B     		subs	r3, r3, #1
 2730 0006 052B     		cmp	r3, #5
 2731 0008 12D8     		bhi	.L188
 2732 000a DFE803F0 		tbb	[pc, r3]
 2733              	.L190:
 2734 000e 03       		.byte	(.L195-.L190)/2
 2735 000f 07       		.byte	(.L194-.L190)/2
 2736 0010 09       		.byte	(.L193-.L190)/2
 2737 0011 0B       		.byte	(.L192-.L190)/2
 2738 0012 0D       		.byte	(.L191-.L190)/2
 2739 0013 0F       		.byte	(.L189-.L190)/2
 2740              		.p2align 1
 2741              	.L195:
1255:Src/mpu6050.c ****         break;
 2742              		.loc 1 1255 9 is_stmt 1 view .LVU802
1255:Src/mpu6050.c ****         break;
 2743              		.loc 1 1255 16 is_stmt 0 view .LVU803
 2744 0014 BC23     		movs	r3, #188
 2745              	.L197:
1275:Src/mpu6050.c ****         break;
 2746              		.loc 1 1275 16 view .LVU804
 2747 0016 0380     		strh	r3, [r0]	@ movhi
1276:Src/mpu6050.c ****     }
 2748              		.loc 1 1276 9 is_stmt 1 view .LVU805
1278:Src/mpu6050.c **** }
 2749              		.loc 1 1278 5 view .LVU806
1279:Src/mpu6050.c **** 
 2750              		.loc 1 1279 1 is_stmt 0 view .LVU807
 2751 0018 0020     		movs	r0, #0
 2752              	.LVL175:
1279:Src/mpu6050.c **** 
 2753              		.loc 1 1279 1 view .LVU808
 2754 001a 7047     		bx	lr
 2755              	.LVL176:
 2756              	.L194:
1258:Src/mpu6050.c ****         break;
ARM GAS  /tmp/ccC60hwS.s 			page 100


 2757              		.loc 1 1258 9 is_stmt 1 view .LVU809
1258:Src/mpu6050.c ****         break;
 2758              		.loc 1 1258 16 is_stmt 0 view .LVU810
 2759 001c 6223     		movs	r3, #98
 2760 001e FAE7     		b	.L197
 2761              	.L193:
1261:Src/mpu6050.c ****         break;
 2762              		.loc 1 1261 9 is_stmt 1 view .LVU811
1261:Src/mpu6050.c ****         break;
 2763              		.loc 1 1261 16 is_stmt 0 view .LVU812
 2764 0020 2A23     		movs	r3, #42
 2765 0022 F8E7     		b	.L197
 2766              	.L192:
1264:Src/mpu6050.c ****         break;
 2767              		.loc 1 1264 9 is_stmt 1 view .LVU813
1264:Src/mpu6050.c ****         break;
 2768              		.loc 1 1264 16 is_stmt 0 view .LVU814
 2769 0024 1423     		movs	r3, #20
 2770 0026 F6E7     		b	.L197
 2771              	.L191:
1267:Src/mpu6050.c ****         break;
 2772              		.loc 1 1267 9 is_stmt 1 view .LVU815
1267:Src/mpu6050.c ****         break;
 2773              		.loc 1 1267 16 is_stmt 0 view .LVU816
 2774 0028 0A23     		movs	r3, #10
 2775 002a F4E7     		b	.L197
 2776              	.L189:
1270:Src/mpu6050.c ****         break;
 2777              		.loc 1 1270 9 is_stmt 1 view .LVU817
1270:Src/mpu6050.c ****         break;
 2778              		.loc 1 1270 16 is_stmt 0 view .LVU818
 2779 002c 0523     		movs	r3, #5
 2780 002e F2E7     		b	.L197
 2781              	.L188:
1275:Src/mpu6050.c ****         break;
 2782              		.loc 1 1275 9 is_stmt 1 view .LVU819
1275:Src/mpu6050.c ****         break;
 2783              		.loc 1 1275 16 is_stmt 0 view .LVU820
 2784 0030 0023     		movs	r3, #0
 2785 0032 F0E7     		b	.L197
 2786              	.L199:
 2787              		.align	2
 2788              	.L198:
 2789 0034 00000000 		.word	.LANCHOR0
 2790              		.cfi_endproc
 2791              	.LFE78:
 2793              		.section	.text.mpu_set_lpf,"ax",%progbits
 2794              		.align	1
 2795              		.global	mpu_set_lpf
 2796              		.syntax unified
 2797              		.thumb
 2798              		.thumb_func
 2799              		.fpu softvfp
 2801              	mpu_set_lpf:
 2802              	.LVL177:
 2803              	.LFB79:
1288:Src/mpu6050.c ****     unsigned char data;
ARM GAS  /tmp/ccC60hwS.s 			page 101


 2804              		.loc 1 1288 1 is_stmt 1 view -0
 2805              		.cfi_startproc
 2806              		@ args = 0, pretend = 0, frame = 8
 2807              		@ frame_needed = 0, uses_anonymous_args = 0
1289:Src/mpu6050.c **** 
 2808              		.loc 1 1289 5 view .LVU822
1291:Src/mpu6050.c ****         return -1;
 2809              		.loc 1 1291 5 view .LVU823
1288:Src/mpu6050.c ****     unsigned char data;
 2810              		.loc 1 1288 1 is_stmt 0 view .LVU824
 2811 0000 13B5     		push	{r0, r1, r4, lr}
 2812              	.LCFI48:
 2813              		.cfi_def_cfa_offset 16
 2814              		.cfi_offset 4, -8
 2815              		.cfi_offset 14, -4
1291:Src/mpu6050.c ****         return -1;
 2816              		.loc 1 1291 22 view .LVU825
 2817 0002 194C     		ldr	r4, .L212
1291:Src/mpu6050.c ****         return -1;
 2818              		.loc 1 1291 8 view .LVU826
 2819 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2820 0006 1BB9     		cbnz	r3, .L201
 2821              	.LVL178:
 2822              	.L209:
1292:Src/mpu6050.c **** 
 2823              		.loc 1 1292 16 view .LVU827
 2824 0008 4FF0FF30 		mov	r0, #-1
 2825              	.L200:
1313:Src/mpu6050.c **** 
 2826              		.loc 1 1313 1 view .LVU828
 2827 000c 02B0     		add	sp, sp, #8
 2828              	.LCFI49:
 2829              		.cfi_remember_state
 2830              		.cfi_def_cfa_offset 8
 2831              		@ sp needed
 2832 000e 10BD     		pop	{r4, pc}
 2833              	.LVL179:
 2834              	.L201:
 2835              	.LCFI50:
 2836              		.cfi_restore_state
1294:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
 2837              		.loc 1 1294 5 is_stmt 1 view .LVU829
1294:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
 2838              		.loc 1 1294 8 is_stmt 0 view .LVU830
 2839 0010 BB28     		cmp	r0, #187
 2840 0012 16D9     		bls	.L203
1295:Src/mpu6050.c ****     else if (lpf >= 98)
 2841              		.loc 1 1295 9 is_stmt 1 view .LVU831
1295:Src/mpu6050.c ****     else if (lpf >= 98)
 2842              		.loc 1 1295 14 is_stmt 0 view .LVU832
 2843 0014 0123     		movs	r3, #1
 2844              	.L211:
1305:Src/mpu6050.c **** 
 2845              		.loc 1 1305 14 view .LVU833
 2846 0016 8DF80730 		strb	r3, [sp, #7]
1307:Src/mpu6050.c ****         return 0;
 2847              		.loc 1 1307 5 is_stmt 1 view .LVU834
ARM GAS  /tmp/ccC60hwS.s 			page 102


1307:Src/mpu6050.c ****         return 0;
 2848              		.loc 1 1307 8 is_stmt 0 view .LVU835
 2849 001a E27A     		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 2850 001c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2851 0020 9A42     		cmp	r2, r3
 2852 0022 1FD0     		beq	.L210
1309:Src/mpu6050.c ****         return -1;
 2853              		.loc 1 1309 5 is_stmt 1 view .LVU836
1309:Src/mpu6050.c ****         return -1;
 2854              		.loc 1 1309 9 is_stmt 0 view .LVU837
 2855 0024 D4E90010 		ldrd	r1, r0, [r4]
 2856              	.LVL180:
1309:Src/mpu6050.c ****         return -1;
 2857              		.loc 1 1309 9 view .LVU838
 2858 0028 0122     		movs	r2, #1
 2859 002a 8978     		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 2860 002c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2861 002e 0DF10703 		add	r3, sp, #7
 2862 0032 FFF7FEFF 		bl	i2c_writeBytes
 2863              	.LVL181:
1309:Src/mpu6050.c ****         return -1;
 2864              		.loc 1 1309 8 view .LVU839
 2865 0036 0028     		cmp	r0, #0
 2866 0038 E6D1     		bne	.L209
1311:Src/mpu6050.c ****     return 0;
 2867              		.loc 1 1311 5 is_stmt 1 view .LVU840
1311:Src/mpu6050.c ****     return 0;
 2868              		.loc 1 1311 21 is_stmt 0 view .LVU841
 2869 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2870 003e E372     		strb	r3, [r4, #11]
1312:Src/mpu6050.c **** }
 2871              		.loc 1 1312 5 is_stmt 1 view .LVU842
1312:Src/mpu6050.c **** }
 2872              		.loc 1 1312 12 is_stmt 0 view .LVU843
 2873 0040 E4E7     		b	.L200
 2874              	.LVL182:
 2875              	.L203:
1296:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
 2876              		.loc 1 1296 10 is_stmt 1 view .LVU844
1296:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
 2877              		.loc 1 1296 13 is_stmt 0 view .LVU845
 2878 0042 6128     		cmp	r0, #97
 2879 0044 01D9     		bls	.L205
1297:Src/mpu6050.c ****     else if (lpf >= 42)
 2880              		.loc 1 1297 9 is_stmt 1 view .LVU846
1297:Src/mpu6050.c ****     else if (lpf >= 42)
 2881              		.loc 1 1297 14 is_stmt 0 view .LVU847
 2882 0046 0223     		movs	r3, #2
 2883 0048 E5E7     		b	.L211
 2884              	.L205:
1298:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
 2885              		.loc 1 1298 10 is_stmt 1 view .LVU848
1298:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
 2886              		.loc 1 1298 13 is_stmt 0 view .LVU849
 2887 004a 2928     		cmp	r0, #41
 2888 004c 01D9     		bls	.L206
1299:Src/mpu6050.c ****     else if (lpf >= 20)
ARM GAS  /tmp/ccC60hwS.s 			page 103


 2889              		.loc 1 1299 9 is_stmt 1 view .LVU850
1299:Src/mpu6050.c ****     else if (lpf >= 20)
 2890              		.loc 1 1299 14 is_stmt 0 view .LVU851
 2891 004e 0323     		movs	r3, #3
 2892 0050 E1E7     		b	.L211
 2893              	.L206:
1300:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
 2894              		.loc 1 1300 10 is_stmt 1 view .LVU852
1300:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
 2895              		.loc 1 1300 13 is_stmt 0 view .LVU853
 2896 0052 1328     		cmp	r0, #19
 2897 0054 01D9     		bls	.L207
1301:Src/mpu6050.c ****     else if (lpf >= 10)
 2898              		.loc 1 1301 9 is_stmt 1 view .LVU854
1301:Src/mpu6050.c ****     else if (lpf >= 10)
 2899              		.loc 1 1301 14 is_stmt 0 view .LVU855
 2900 0056 0423     		movs	r3, #4
 2901 0058 DDE7     		b	.L211
 2902              	.L207:
1302:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
 2903              		.loc 1 1302 10 is_stmt 1 view .LVU856
1302:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
 2904              		.loc 1 1302 13 is_stmt 0 view .LVU857
 2905 005a 0928     		cmp	r0, #9
1303:Src/mpu6050.c ****     else
 2906              		.loc 1 1303 9 is_stmt 1 view .LVU858
1303:Src/mpu6050.c ****     else
 2907              		.loc 1 1303 14 is_stmt 0 view .LVU859
 2908 005c 8CBF     		ite	hi
 2909 005e 0523     		movhi	r3, #5
1305:Src/mpu6050.c **** 
 2910              		.loc 1 1305 9 is_stmt 1 view .LVU860
1305:Src/mpu6050.c **** 
 2911              		.loc 1 1305 14 is_stmt 0 view .LVU861
 2912 0060 0623     		movls	r3, #6
 2913 0062 D8E7     		b	.L211
 2914              	.L210:
1308:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
 2915              		.loc 1 1308 16 view .LVU862
 2916 0064 0020     		movs	r0, #0
 2917              	.LVL183:
1308:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
 2918              		.loc 1 1308 16 view .LVU863
 2919 0066 D1E7     		b	.L200
 2920              	.L213:
 2921              		.align	2
 2922              	.L212:
 2923 0068 00000000 		.word	.LANCHOR0
 2924              		.cfi_endproc
 2925              	.LFE79:
 2927              		.section	.text.mpu_get_sample_rate,"ax",%progbits
 2928              		.align	1
 2929              		.global	mpu_get_sample_rate
 2930              		.syntax unified
 2931              		.thumb
 2932              		.thumb_func
 2933              		.fpu softvfp
ARM GAS  /tmp/ccC60hwS.s 			page 104


 2935              	mpu_get_sample_rate:
 2936              	.LVL184:
 2937              	.LFB80:
1321:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
 2938              		.loc 1 1321 1 is_stmt 1 view -0
 2939              		.cfi_startproc
 2940              		@ args = 0, pretend = 0, frame = 0
 2941              		@ frame_needed = 0, uses_anonymous_args = 0
 2942              		@ link register save eliminated.
1322:Src/mpu6050.c ****         return -1;
 2943              		.loc 1 1322 5 view .LVU865
1322:Src/mpu6050.c ****         return -1;
 2944              		.loc 1 1322 20 is_stmt 0 view .LVU866
 2945 0000 054A     		ldr	r2, .L217
1321:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
 2946              		.loc 1 1321 1 view .LVU867
 2947 0002 0346     		mov	r3, r0
1322:Src/mpu6050.c ****         return -1;
 2948              		.loc 1 1322 8 view .LVU868
 2949 0004 92F82400 		ldrb	r0, [r2, #36]	@ zero_extendqisi2
 2950              	.LVL185:
1322:Src/mpu6050.c ****         return -1;
 2951              		.loc 1 1322 8 view .LVU869
 2952 0008 10B9     		cbnz	r0, .L216
1325:Src/mpu6050.c ****     return 0;
 2953              		.loc 1 1325 9 is_stmt 1 view .LVU870
1325:Src/mpu6050.c ****     return 0;
 2954              		.loc 1 1325 30 is_stmt 0 view .LVU871
 2955 000a D289     		ldrh	r2, [r2, #14]
1325:Src/mpu6050.c ****     return 0;
 2956              		.loc 1 1325 17 view .LVU872
 2957 000c 1A80     		strh	r2, [r3]	@ movhi
1326:Src/mpu6050.c **** }
 2958              		.loc 1 1326 5 is_stmt 1 view .LVU873
1326:Src/mpu6050.c **** }
 2959              		.loc 1 1326 12 is_stmt 0 view .LVU874
 2960 000e 7047     		bx	lr
 2961              	.L216:
1323:Src/mpu6050.c ****     else
 2962              		.loc 1 1323 16 view .LVU875
 2963 0010 4FF0FF30 		mov	r0, #-1
1327:Src/mpu6050.c **** 
 2964              		.loc 1 1327 1 view .LVU876
 2965 0014 7047     		bx	lr
 2966              	.L218:
 2967 0016 00BF     		.align	2
 2968              	.L217:
 2969 0018 00000000 		.word	.LANCHOR0
 2970              		.cfi_endproc
 2971              	.LFE80:
 2973              		.section	.text.mpu_get_compass_sample_rate,"ax",%progbits
 2974              		.align	1
 2975              		.global	mpu_get_compass_sample_rate
 2976              		.syntax unified
 2977              		.thumb
 2978              		.thumb_func
 2979              		.fpu softvfp
ARM GAS  /tmp/ccC60hwS.s 			page 105


 2981              	mpu_get_compass_sample_rate:
 2982              	.LVL186:
 2983              	.LFB82:
1383:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 2984              		.loc 1 1383 1 is_stmt 1 view -0
 2985              		.cfi_startproc
 2986              		@ args = 0, pretend = 0, frame = 0
 2987              		@ frame_needed = 0, uses_anonymous_args = 0
 2988              		@ link register save eliminated.
1388:Src/mpu6050.c ****     return -1;
 2989              		.loc 1 1388 5 view .LVU878
1388:Src/mpu6050.c ****     return -1;
 2990              		.loc 1 1388 13 is_stmt 0 view .LVU879
 2991 0000 0023     		movs	r3, #0
 2992 0002 0380     		strh	r3, [r0]	@ movhi
1389:Src/mpu6050.c **** #endif
 2993              		.loc 1 1389 5 is_stmt 1 view .LVU880
1391:Src/mpu6050.c **** 
 2994              		.loc 1 1391 1 is_stmt 0 view .LVU881
 2995 0004 4FF0FF30 		mov	r0, #-1
 2996              	.LVL187:
1391:Src/mpu6050.c **** 
 2997              		.loc 1 1391 1 view .LVU882
 2998 0008 7047     		bx	lr
 2999              		.cfi_endproc
 3000              	.LFE82:
 3002              		.section	.text.mpu_set_compass_sample_rate,"ax",%progbits
 3003              		.align	1
 3004              		.global	mpu_set_compass_sample_rate
 3005              		.syntax unified
 3006              		.thumb
 3007              		.thumb_func
 3008              		.fpu softvfp
 3010              	mpu_set_compass_sample_rate:
 3011              	.LVL188:
 3012              	.LFB83:
1405:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 3013              		.loc 1 1405 1 is_stmt 1 view -0
 3014              		.cfi_startproc
 3015              		@ args = 0, pretend = 0, frame = 0
 3016              		@ frame_needed = 0, uses_anonymous_args = 0
 3017              		@ link register save eliminated.
1417:Src/mpu6050.c **** #endif
 3018              		.loc 1 1417 5 view .LVU884
1419:Src/mpu6050.c **** 
 3019              		.loc 1 1419 1 is_stmt 0 view .LVU885
 3020 0000 4FF0FF30 		mov	r0, #-1
 3021              	.LVL189:
1419:Src/mpu6050.c **** 
 3022              		.loc 1 1419 1 view .LVU886
 3023 0004 7047     		bx	lr
 3024              		.cfi_endproc
 3025              	.LFE83:
 3027              		.section	.text.mpu_get_gyro_sens,"ax",%progbits
 3028              		.align	1
 3029              		.global	mpu_get_gyro_sens
 3030              		.syntax unified
ARM GAS  /tmp/ccC60hwS.s 			page 106


 3031              		.thumb
 3032              		.thumb_func
 3033              		.fpu softvfp
 3035              	mpu_get_gyro_sens:
 3036              	.LVL190:
 3037              	.LFB84:
1427:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
 3038              		.loc 1 1427 1 is_stmt 1 view -0
 3039              		.cfi_startproc
 3040              		@ args = 0, pretend = 0, frame = 0
 3041              		@ frame_needed = 0, uses_anonymous_args = 0
 3042              		@ link register save eliminated.
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3043              		.loc 1 1428 5 view .LVU888
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3044              		.loc 1 1428 24 is_stmt 0 view .LVU889
 3045 0000 0A4B     		ldr	r3, .L230
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3046              		.loc 1 1428 5 view .LVU890
 3047 0002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3048 0004 032B     		cmp	r3, #3
 3049 0006 0DD8     		bhi	.L228
 3050 0008 DFE803F0 		tbb	[pc, r3]
 3051              	.L224:
 3052 000c 02       		.byte	(.L227-.L224)/2
 3053 000d 06       		.byte	(.L226-.L224)/2
 3054 000e 08       		.byte	(.L225-.L224)/2
 3055 000f 0A       		.byte	(.L223-.L224)/2
 3056              		.p2align 1
 3057              	.L227:
1430:Src/mpu6050.c ****         break;
 3058              		.loc 1 1430 9 is_stmt 1 view .LVU891
1430:Src/mpu6050.c ****         break;
 3059              		.loc 1 1430 17 is_stmt 0 view .LVU892
 3060 0010 074B     		ldr	r3, .L230+4
 3061              	.L229:
1433:Src/mpu6050.c ****         break;
 3062              		.loc 1 1433 17 view .LVU893
 3063 0012 0360     		str	r3, [r0]	@ float
1434:Src/mpu6050.c ****     case INV_FSR_1000DPS:
 3064              		.loc 1 1434 9 is_stmt 1 view .LVU894
1444:Src/mpu6050.c **** }
 3065              		.loc 1 1444 12 is_stmt 0 view .LVU895
 3066 0014 0020     		movs	r0, #0
 3067              	.LVL191:
1434:Src/mpu6050.c ****     case INV_FSR_1000DPS:
 3068              		.loc 1 1434 9 view .LVU896
 3069 0016 7047     		bx	lr
 3070              	.LVL192:
 3071              	.L226:
1433:Src/mpu6050.c ****         break;
 3072              		.loc 1 1433 9 is_stmt 1 view .LVU897
1433:Src/mpu6050.c ****         break;
 3073              		.loc 1 1433 17 is_stmt 0 view .LVU898
 3074 0018 064B     		ldr	r3, .L230+8
 3075 001a FAE7     		b	.L229
 3076              	.L225:
ARM GAS  /tmp/ccC60hwS.s 			page 107


1436:Src/mpu6050.c ****         break;
 3077              		.loc 1 1436 9 is_stmt 1 view .LVU899
1436:Src/mpu6050.c ****         break;
 3078              		.loc 1 1436 17 is_stmt 0 view .LVU900
 3079 001c 064B     		ldr	r3, .L230+12
 3080 001e F8E7     		b	.L229
 3081              	.L223:
1439:Src/mpu6050.c ****         break;
 3082              		.loc 1 1439 9 is_stmt 1 view .LVU901
1439:Src/mpu6050.c ****         break;
 3083              		.loc 1 1439 17 is_stmt 0 view .LVU902
 3084 0020 064B     		ldr	r3, .L230+16
 3085 0022 F6E7     		b	.L229
 3086              	.L228:
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3087              		.loc 1 1428 5 view .LVU903
 3088 0024 4FF0FF30 		mov	r0, #-1
 3089              	.LVL193:
1445:Src/mpu6050.c **** 
 3090              		.loc 1 1445 1 view .LVU904
 3091 0028 7047     		bx	lr
 3092              	.L231:
 3093 002a 00BF     		.align	2
 3094              	.L230:
 3095 002c 00000000 		.word	.LANCHOR0
 3096 0030 00000343 		.word	1124270080
 3097 0034 00008342 		.word	1115881472
 3098 0038 33330342 		.word	1107505971
 3099 003c 33338341 		.word	1099117363
 3100              		.cfi_endproc
 3101              	.LFE84:
 3103              		.section	.text.mpu_get_accel_sens,"ax",%progbits
 3104              		.align	1
 3105              		.global	mpu_get_accel_sens
 3106              		.syntax unified
 3107              		.thumb
 3108              		.thumb_func
 3109              		.fpu softvfp
 3111              	mpu_get_accel_sens:
 3112              	.LVL194:
 3113              	.LFB85:
1453:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
 3114              		.loc 1 1453 1 is_stmt 1 view -0
 3115              		.cfi_startproc
 3116              		@ args = 0, pretend = 0, frame = 0
 3117              		@ frame_needed = 0, uses_anonymous_args = 0
 3118              		@ link register save eliminated.
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3119              		.loc 1 1454 5 view .LVU906
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3120              		.loc 1 1454 24 is_stmt 0 view .LVU907
 3121 0000 0E4B     		ldr	r3, .L244
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3122              		.loc 1 1454 5 view .LVU908
 3123 0002 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 3124 0004 032A     		cmp	r2, #3
 3125 0006 16D8     		bhi	.L240
ARM GAS  /tmp/ccC60hwS.s 			page 108


 3126 0008 DFE802F0 		tbb	[pc, r2]
 3127              	.L235:
 3128 000c 02       		.byte	(.L238-.L235)/2
 3129 000d 0C       		.byte	(.L237-.L235)/2
 3130 000e 0F       		.byte	(.L236-.L235)/2
 3131 000f 12       		.byte	(.L234-.L235)/2
 3132              		.p2align 1
 3133              	.L238:
1456:Src/mpu6050.c ****         break;
 3134              		.loc 1 1456 9 is_stmt 1 view .LVU909
1456:Src/mpu6050.c ****         break;
 3135              		.loc 1 1456 17 is_stmt 0 view .LVU910
 3136 0010 4FF48042 		mov	r2, #16384
 3137              	.L242:
1465:Src/mpu6050.c ****         break;
 3138              		.loc 1 1465 17 view .LVU911
 3139 0014 0280     		strh	r2, [r0]	@ movhi
1466:Src/mpu6050.c ****     default:
 3140              		.loc 1 1466 9 is_stmt 1 view .LVU912
1470:Src/mpu6050.c ****         sens[0] >>= 1;
 3141              		.loc 1 1470 5 view .LVU913
1470:Src/mpu6050.c ****         sens[0] >>= 1;
 3142              		.loc 1 1470 8 is_stmt 0 view .LVU914
 3143 0016 DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 3144 0018 13B1     		cbz	r3, .L243
1471:Src/mpu6050.c ****     return 0;
 3145              		.loc 1 1471 9 is_stmt 1 view .LVU915
1471:Src/mpu6050.c ****     return 0;
 3146              		.loc 1 1471 17 is_stmt 0 view .LVU916
 3147 001a 0388     		ldrh	r3, [r0]
 3148 001c 5B08     		lsrs	r3, r3, #1
 3149 001e 0380     		strh	r3, [r0]	@ movhi
 3150              	.L243:
1472:Src/mpu6050.c **** }
 3151              		.loc 1 1472 12 view .LVU917
 3152 0020 0020     		movs	r0, #0
 3153              	.LVL195:
1472:Src/mpu6050.c **** }
 3154              		.loc 1 1472 12 view .LVU918
 3155 0022 7047     		bx	lr
 3156              	.LVL196:
 3157              	.L237:
1459:Src/mpu6050.c ****         break;
 3158              		.loc 1 1459 9 is_stmt 1 view .LVU919
1459:Src/mpu6050.c ****         break;
 3159              		.loc 1 1459 17 is_stmt 0 view .LVU920
 3160 0024 4FF40052 		mov	r2, #8192
 3161 0028 F4E7     		b	.L242
 3162              	.L236:
1462:Src/mpu6050.c ****         break;
 3163              		.loc 1 1462 9 is_stmt 1 view .LVU921
1462:Src/mpu6050.c ****         break;
 3164              		.loc 1 1462 17 is_stmt 0 view .LVU922
 3165 002a 4FF48052 		mov	r2, #4096
 3166 002e F1E7     		b	.L242
 3167              	.L234:
1465:Src/mpu6050.c ****         break;
ARM GAS  /tmp/ccC60hwS.s 			page 109


 3168              		.loc 1 1465 9 is_stmt 1 view .LVU923
1465:Src/mpu6050.c ****         break;
 3169              		.loc 1 1465 17 is_stmt 0 view .LVU924
 3170 0030 4FF40062 		mov	r2, #2048
 3171 0034 EEE7     		b	.L242
 3172              	.L240:
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3173              		.loc 1 1454 5 view .LVU925
 3174 0036 4FF0FF30 		mov	r0, #-1
 3175              	.LVL197:
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3176              		.loc 1 1454 5 view .LVU926
 3177 003a 7047     		bx	lr
 3178              	.L245:
 3179              		.align	2
 3180              	.L244:
 3181 003c 00000000 		.word	.LANCHOR0
 3182              		.cfi_endproc
 3183              	.LFE85:
 3185              		.section	.text.mpu_get_fifo_config,"ax",%progbits
 3186              		.align	1
 3187              		.global	mpu_get_fifo_config
 3188              		.syntax unified
 3189              		.thumb
 3190              		.thumb_func
 3191              		.fpu softvfp
 3193              	mpu_get_fifo_config:
 3194              	.LVL198:
 3195              	.LFB86:
1485:Src/mpu6050.c ****     sensors[0] = st.chip_cfg.fifo_enable;
 3196              		.loc 1 1485 1 is_stmt 1 view -0
 3197              		.cfi_startproc
 3198              		@ args = 0, pretend = 0, frame = 0
 3199              		@ frame_needed = 0, uses_anonymous_args = 0
 3200              		@ link register save eliminated.
1486:Src/mpu6050.c ****     return 0;
 3201              		.loc 1 1486 5 view .LVU928
1486:Src/mpu6050.c ****     return 0;
 3202              		.loc 1 1486 29 is_stmt 0 view .LVU929
 3203 0000 024B     		ldr	r3, .L247
 3204 0002 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
1486:Src/mpu6050.c ****     return 0;
 3205              		.loc 1 1486 16 view .LVU930
 3206 0004 0370     		strb	r3, [r0]
1487:Src/mpu6050.c **** }
 3207              		.loc 1 1487 5 is_stmt 1 view .LVU931
1488:Src/mpu6050.c **** 
 3208              		.loc 1 1488 1 is_stmt 0 view .LVU932
 3209 0006 0020     		movs	r0, #0
 3210              	.LVL199:
1488:Src/mpu6050.c **** 
 3211              		.loc 1 1488 1 view .LVU933
 3212 0008 7047     		bx	lr
 3213              	.L248:
 3214 000a 00BF     		.align	2
 3215              	.L247:
 3216 000c 00000000 		.word	.LANCHOR0
ARM GAS  /tmp/ccC60hwS.s 			page 110


 3217              		.cfi_endproc
 3218              	.LFE86:
 3220              		.section	.text.mpu_configure_fifo,"ax",%progbits
 3221              		.align	1
 3222              		.global	mpu_configure_fifo
 3223              		.syntax unified
 3224              		.thumb
 3225              		.thumb_func
 3226              		.fpu softvfp
 3228              	mpu_configure_fifo:
 3229              	.LVL200:
 3230              	.LFB87:
1500:Src/mpu6050.c ****     unsigned char prev;
 3231              		.loc 1 1500 1 is_stmt 1 view -0
 3232              		.cfi_startproc
 3233              		@ args = 0, pretend = 0, frame = 0
 3234              		@ frame_needed = 0, uses_anonymous_args = 0
1501:Src/mpu6050.c ****     int result = 0;
 3235              		.loc 1 1501 5 view .LVU935
1502:Src/mpu6050.c **** 
 3236              		.loc 1 1502 5 view .LVU936
1505:Src/mpu6050.c **** 
 3237              		.loc 1 1505 5 view .LVU937
1507:Src/mpu6050.c ****         return 0;
 3238              		.loc 1 1507 5 view .LVU938
1500:Src/mpu6050.c ****     unsigned char prev;
 3239              		.loc 1 1500 1 is_stmt 0 view .LVU939
 3240 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3241              	.LCFI51:
 3242              		.cfi_def_cfa_offset 24
 3243              		.cfi_offset 3, -24
 3244              		.cfi_offset 4, -20
 3245              		.cfi_offset 5, -16
 3246              		.cfi_offset 6, -12
 3247              		.cfi_offset 7, -8
 3248              		.cfi_offset 14, -4
1507:Src/mpu6050.c ****         return 0;
 3249              		.loc 1 1507 20 view .LVU940
 3250 0002 114E     		ldr	r6, .L258
1507:Src/mpu6050.c ****         return 0;
 3251              		.loc 1 1507 8 view .LVU941
 3252 0004 96F82430 		ldrb	r3, [r6, #36]	@ zero_extendqisi2
 3253 0008 E3B9     		cbnz	r3, .L253
1510:Src/mpu6050.c ****             return -1;
 3254              		.loc 1 1510 9 is_stmt 1 view .LVU942
1510:Src/mpu6050.c ****             return -1;
 3255              		.loc 1 1510 26 is_stmt 0 view .LVU943
 3256 000a B47A     		ldrb	r4, [r6, #10]	@ zero_extendqisi2
1510:Src/mpu6050.c ****             return -1;
 3257              		.loc 1 1510 12 view .LVU944
 3258 000c 9CB1     		cbz	r4, .L254
1505:Src/mpu6050.c **** 
 3259              		.loc 1 1505 13 view .LVU945
 3260 000e 00F0FE05 		and	r5, r0, #254
1512:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
 3261              		.loc 1 1512 9 is_stmt 1 view .LVU946
1513:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
ARM GAS  /tmp/ccC60hwS.s 			page 111


 3262              		.loc 1 1513 33 is_stmt 0 view .LVU947
 3263 0012 2C40     		ands	r4, r4, r5
1521:Src/mpu6050.c ****             set_int_enable(1);
 3264              		.loc 1 1521 21 view .LVU948
 3265 0014 307D     		ldrb	r0, [r6, #20]	@ zero_extendqisi2
 3266              	.LVL201:
1512:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
 3267              		.loc 1 1512 14 view .LVU949
 3268 0016 377C     		ldrb	r7, [r6, #16]	@ zero_extendqisi2
 3269              	.LVL202:
1513:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3270              		.loc 1 1513 9 is_stmt 1 view .LVU950
1513:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3271              		.loc 1 1513 33 is_stmt 0 view .LVU951
 3272 0018 3474     		strb	r4, [r6, #16]
1514:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
 3273              		.loc 1 1514 9 is_stmt 1 view .LVU952
1514:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
 3274              		.loc 1 1514 12 is_stmt 0 view .LVU953
 3275 001a 641B     		subs	r4, r4, r5
 3276 001c 18BF     		it	ne
 3277 001e 4FF0FF34 		movne	r4, #-1
 3278              	.LVL203:
1521:Src/mpu6050.c ****             set_int_enable(1);
 3279              		.loc 1 1521 9 is_stmt 1 view .LVU954
1521:Src/mpu6050.c ****             set_int_enable(1);
 3280              		.loc 1 1521 21 is_stmt 0 view .LVU955
 3281 0022 2843     		orrs	r0, r0, r5
 3282 0024 0AD0     		beq	.L251
1522:Src/mpu6050.c ****         else
 3283              		.loc 1 1522 13 is_stmt 1 view .LVU956
 3284 0026 0120     		movs	r0, #1
 3285 0028 FFF7FEFF 		bl	set_int_enable.isra.0
 3286              	.LVL204:
1525:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3287              		.loc 1 1525 9 view .LVU957
1525:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3288              		.loc 1 1525 12 is_stmt 0 view .LVU958
 3289 002c 45B1     		cbz	r5, .L249
1526:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3290              		.loc 1 1526 13 is_stmt 1 view .LVU959
1526:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3291              		.loc 1 1526 17 is_stmt 0 view .LVU960
 3292 002e FFF7FEFF 		bl	mpu_reset_fifo
 3293              	.LVL205:
1526:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3294              		.loc 1 1526 16 view .LVU961
 3295 0032 28B1     		cbz	r0, .L249
1527:Src/mpu6050.c ****                 return -1;
 3296              		.loc 1 1527 17 is_stmt 1 view .LVU962
1527:Src/mpu6050.c ****                 return -1;
 3297              		.loc 1 1527 41 is_stmt 0 view .LVU963
 3298 0034 3774     		strb	r7, [r6, #16]
1528:Src/mpu6050.c ****             }
 3299              		.loc 1 1528 17 is_stmt 1 view .LVU964
 3300              	.LVL206:
 3301              	.L254:
ARM GAS  /tmp/ccC60hwS.s 			page 112


1511:Src/mpu6050.c ****         prev = st.chip_cfg.fifo_enable;
 3302              		.loc 1 1511 20 is_stmt 0 view .LVU965
 3303 0036 4FF0FF34 		mov	r4, #-1
 3304 003a 01E0     		b	.L249
 3305              	.LVL207:
 3306              	.L251:
1524:Src/mpu6050.c ****         if (sensors) {
 3307              		.loc 1 1524 13 is_stmt 1 view .LVU966
 3308 003c FFF7FEFF 		bl	set_int_enable.isra.0
 3309              	.LVL208:
1525:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3310              		.loc 1 1525 9 view .LVU967
 3311              	.L249:
1534:Src/mpu6050.c **** 
 3312              		.loc 1 1534 1 is_stmt 0 view .LVU968
 3313 0040 2046     		mov	r0, r4
 3314 0042 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3315              	.LVL209:
 3316              	.L253:
1508:Src/mpu6050.c ****     else {
 3317              		.loc 1 1508 16 view .LVU969
 3318 0044 0024     		movs	r4, #0
 3319 0046 FBE7     		b	.L249
 3320              	.L259:
 3321              		.align	2
 3322              	.L258:
 3323 0048 00000000 		.word	.LANCHOR0
 3324              		.cfi_endproc
 3325              	.LFE87:
 3327              		.section	.text.mpu_get_power_state,"ax",%progbits
 3328              		.align	1
 3329              		.global	mpu_get_power_state
 3330              		.syntax unified
 3331              		.thumb
 3332              		.thumb_func
 3333              		.fpu softvfp
 3335              	mpu_get_power_state:
 3336              	.LVL210:
 3337              	.LFB88:
1542:Src/mpu6050.c ****     if (st.chip_cfg.sensors)
 3338              		.loc 1 1542 1 is_stmt 1 view -0
 3339              		.cfi_startproc
 3340              		@ args = 0, pretend = 0, frame = 0
 3341              		@ frame_needed = 0, uses_anonymous_args = 0
 3342              		@ link register save eliminated.
1543:Src/mpu6050.c ****         power_on[0] = 1;
 3343              		.loc 1 1543 5 view .LVU971
1543:Src/mpu6050.c ****         power_on[0] = 1;
 3344              		.loc 1 1543 20 is_stmt 0 view .LVU972
 3345 0000 034B     		ldr	r3, .L261
1543:Src/mpu6050.c ****         power_on[0] = 1;
 3346              		.loc 1 1543 8 view .LVU973
 3347 0002 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 3348 0004 003B     		subs	r3, r3, #0
 3349 0006 18BF     		it	ne
 3350 0008 0123     		movne	r3, #1
 3351 000a 0370     		strb	r3, [r0]
ARM GAS  /tmp/ccC60hwS.s 			page 113


1547:Src/mpu6050.c **** }
 3352              		.loc 1 1547 5 is_stmt 1 view .LVU974
1548:Src/mpu6050.c **** 
 3353              		.loc 1 1548 1 is_stmt 0 view .LVU975
 3354 000c 0020     		movs	r0, #0
 3355              	.LVL211:
1548:Src/mpu6050.c **** 
 3356              		.loc 1 1548 1 view .LVU976
 3357 000e 7047     		bx	lr
 3358              	.L262:
 3359              		.align	2
 3360              	.L261:
 3361 0010 00000000 		.word	.LANCHOR0
 3362              		.cfi_endproc
 3363              	.LFE88:
 3365              		.section	.text.mpu_get_int_status,"ax",%progbits
 3366              		.align	1
 3367              		.global	mpu_get_int_status
 3368              		.syntax unified
 3369              		.thumb
 3370              		.thumb_func
 3371              		.fpu softvfp
 3373              	mpu_get_int_status:
 3374              	.LVL212:
 3375              	.LFB90:
1638:Src/mpu6050.c ****     unsigned char tmp[2];
 3376              		.loc 1 1638 1 is_stmt 1 view -0
 3377              		.cfi_startproc
 3378              		@ args = 0, pretend = 0, frame = 8
 3379              		@ frame_needed = 0, uses_anonymous_args = 0
1639:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3380              		.loc 1 1639 5 view .LVU978
1640:Src/mpu6050.c ****         return -1;
 3381              		.loc 1 1640 5 view .LVU979
1638:Src/mpu6050.c ****     unsigned char tmp[2];
 3382              		.loc 1 1638 1 is_stmt 0 view .LVU980
 3383 0000 13B5     		push	{r0, r1, r4, lr}
 3384              	.LCFI52:
 3385              		.cfi_def_cfa_offset 16
 3386              		.cfi_offset 4, -8
 3387              		.cfi_offset 14, -4
1640:Src/mpu6050.c ****         return -1;
 3388              		.loc 1 1640 21 view .LVU981
 3389 0002 0B4B     		ldr	r3, .L267
1638:Src/mpu6050.c ****     unsigned char tmp[2];
 3390              		.loc 1 1638 1 view .LVU982
 3391 0004 0446     		mov	r4, r0
1640:Src/mpu6050.c ****         return -1;
 3392              		.loc 1 1640 8 view .LVU983
 3393 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 3394 0008 1AB9     		cbnz	r2, .L264
 3395              	.LVL213:
 3396              	.L266:
1641:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
 3397              		.loc 1 1641 16 view .LVU984
 3398 000a 4FF0FF30 		mov	r0, #-1
 3399              	.L263:
ARM GAS  /tmp/ccC60hwS.s 			page 114


1646:Src/mpu6050.c **** 
 3400              		.loc 1 1646 1 view .LVU985
 3401 000e 02B0     		add	sp, sp, #8
 3402              	.LCFI53:
 3403              		.cfi_remember_state
 3404              		.cfi_def_cfa_offset 8
 3405              		@ sp needed
 3406 0010 10BD     		pop	{r4, pc}
 3407              	.LVL214:
 3408              	.L264:
 3409              	.LCFI54:
 3410              		.cfi_restore_state
1642:Src/mpu6050.c ****         return -1;
 3411              		.loc 1 1642 5 is_stmt 1 view .LVU986
1642:Src/mpu6050.c ****         return -1;
 3412              		.loc 1 1642 9 is_stmt 0 view .LVU987
 3413 0012 D3E90010 		ldrd	r1, r0, [r3]
 3414              	.LVL215:
1642:Src/mpu6050.c ****         return -1;
 3415              		.loc 1 1642 9 view .LVU988
 3416 0016 0222     		movs	r2, #2
 3417 0018 897C     		ldrb	r1, [r1, #18]	@ zero_extendqisi2
 3418 001a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3419 001c 01AB     		add	r3, sp, #4
 3420 001e FFF7FEFF 		bl	i2c_readBytes
 3421              	.LVL216:
1642:Src/mpu6050.c ****         return -1;
 3422              		.loc 1 1642 8 view .LVU989
 3423 0022 0028     		cmp	r0, #0
 3424 0024 F1D1     		bne	.L266
1644:Src/mpu6050.c ****     return 0;
 3425              		.loc 1 1644 5 is_stmt 1 view .LVU990
1644:Src/mpu6050.c ****     return 0;
 3426              		.loc 1 1644 15 is_stmt 0 view .LVU991
 3427 0026 BDF80430 		ldrh	r3, [sp, #4]
 3428 002a 5BBA     		rev16	r3, r3
 3429 002c 2380     		strh	r3, [r4]	@ movhi
1645:Src/mpu6050.c **** }
 3430              		.loc 1 1645 5 is_stmt 1 view .LVU992
1645:Src/mpu6050.c **** }
 3431              		.loc 1 1645 12 is_stmt 0 view .LVU993
 3432 002e EEE7     		b	.L263
 3433              	.L268:
 3434              		.align	2
 3435              	.L267:
 3436 0030 00000000 		.word	.LANCHOR0
 3437              		.cfi_endproc
 3438              	.LFE90:
 3440              		.section	.text.mpu_read_fifo,"ax",%progbits
 3441              		.align	1
 3442              		.global	mpu_read_fifo
 3443              		.syntax unified
 3444              		.thumb
 3445              		.thumb_func
 3446              		.fpu softvfp
 3448              	mpu_read_fifo:
 3449              	.LVL217:
ARM GAS  /tmp/ccC60hwS.s 			page 115


 3450              	.LFB91:
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3451              		.loc 1 1668 1 is_stmt 1 view -0
 3452              		.cfi_startproc
 3453              		@ args = 4, pretend = 0, frame = 16
 3454              		@ frame_needed = 0, uses_anonymous_args = 0
1670:Src/mpu6050.c ****     unsigned char packet_size = 0;
 3455              		.loc 1 1670 5 view .LVU995
1671:Src/mpu6050.c ****     unsigned short fifo_count, index = 0;
 3456              		.loc 1 1671 5 view .LVU996
1672:Src/mpu6050.c **** 
 3457              		.loc 1 1672 5 view .LVU997
1674:Src/mpu6050.c ****         return -1;
 3458              		.loc 1 1674 5 view .LVU998
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3459              		.loc 1 1668 1 is_stmt 0 view .LVU999
 3460 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3461              	.LCFI55:
 3462              		.cfi_def_cfa_offset 36
 3463              		.cfi_offset 4, -36
 3464              		.cfi_offset 5, -32
 3465              		.cfi_offset 6, -28
 3466              		.cfi_offset 7, -24
 3467              		.cfi_offset 8, -20
 3468              		.cfi_offset 9, -16
 3469              		.cfi_offset 10, -12
 3470              		.cfi_offset 11, -8
 3471              		.cfi_offset 14, -4
1674:Src/mpu6050.c ****         return -1;
 3472              		.loc 1 1674 20 view .LVU1000
 3473 0004 654D     		ldr	r5, .L320
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3474              		.loc 1 1668 1 view .LVU1001
 3475 0006 1E46     		mov	r6, r3
1674:Src/mpu6050.c ****         return -1;
 3476              		.loc 1 1674 8 view .LVU1002
 3477 0008 95F82430 		ldrb	r3, [r5, #36]	@ zero_extendqisi2
 3478              	.LVL218:
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3479              		.loc 1 1668 1 view .LVU1003
 3480 000c 0746     		mov	r7, r0
 3481 000e 8946     		mov	r9, r1
 3482 0010 9246     		mov	r10, r2
 3483 0012 85B0     		sub	sp, sp, #20
 3484              	.LCFI56:
 3485              		.cfi_def_cfa_offset 56
1674:Src/mpu6050.c ****         return -1;
 3486              		.loc 1 1674 8 view .LVU1004
 3487 0014 23B1     		cbz	r3, .L270
 3488              	.LVL219:
 3489              	.L272:
1675:Src/mpu6050.c **** 
 3490              		.loc 1 1675 16 view .LVU1005
 3491 0016 4FF0FF30 		mov	r0, #-1
 3492              	.LVL220:
 3493              	.L269:
1740:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 116


 3494              		.loc 1 1740 1 view .LVU1006
 3495 001a 05B0     		add	sp, sp, #20
 3496              	.LCFI57:
 3497              		.cfi_remember_state
 3498              		.cfi_def_cfa_offset 36
 3499              		@ sp needed
 3500 001c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3501              	.LVL221:
 3502              	.L270:
 3503              	.LCFI58:
 3504              		.cfi_restore_state
1677:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3505              		.loc 1 1677 5 is_stmt 1 view .LVU1007
1677:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3506              		.loc 1 1677 16 is_stmt 0 view .LVU1008
 3507 0020 3370     		strb	r3, [r6]
1678:Src/mpu6050.c ****         return -1;
 3508              		.loc 1 1678 5 is_stmt 1 view .LVU1009
1678:Src/mpu6050.c ****         return -1;
 3509              		.loc 1 1678 8 is_stmt 0 view .LVU1010
 3510 0022 AB7A     		ldrb	r3, [r5, #10]	@ zero_extendqisi2
 3511 0024 002B     		cmp	r3, #0
 3512 0026 F6D0     		beq	.L272
1680:Src/mpu6050.c ****         return -1;
 3513              		.loc 1 1680 5 is_stmt 1 view .LVU1011
1680:Src/mpu6050.c ****         return -1;
 3514              		.loc 1 1680 21 is_stmt 0 view .LVU1012
 3515 0028 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
1680:Src/mpu6050.c ****         return -1;
 3516              		.loc 1 1680 8 view .LVU1013
 3517 002a 002B     		cmp	r3, #0
 3518 002c F3D0     		beq	.L272
1683:Src/mpu6050.c ****         packet_size += 2;
 3519              		.loc 1 1683 5 is_stmt 1 view .LVU1014
1684:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
 3520              		.loc 1 1684 21 is_stmt 0 view .LVU1015
 3521 002e 13F04004 		ands	r4, r3, #64
 3522 0032 18BF     		it	ne
 3523 0034 0224     		movne	r4, #2
 3524              	.LVL222:
1685:Src/mpu6050.c ****         packet_size += 2;
 3525              		.loc 1 1685 5 is_stmt 1 view .LVU1016
1685:Src/mpu6050.c ****         packet_size += 2;
 3526              		.loc 1 1685 8 is_stmt 0 view .LVU1017
 3527 0036 9806     		lsls	r0, r3, #26
 3528              	.LVL223:
1686:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
 3529              		.loc 1 1686 9 is_stmt 1 view .LVU1018
1686:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
 3530              		.loc 1 1686 21 is_stmt 0 view .LVU1019
 3531 0038 48BF     		it	mi
 3532 003a 0234     		addmi	r4, r4, #2
 3533              	.LVL224:
1687:Src/mpu6050.c ****         packet_size += 2;
 3534              		.loc 1 1687 5 is_stmt 1 view .LVU1020
1687:Src/mpu6050.c ****         packet_size += 2;
 3535              		.loc 1 1687 8 is_stmt 0 view .LVU1021
ARM GAS  /tmp/ccC60hwS.s 			page 117


 3536 003c D906     		lsls	r1, r3, #27
 3537              	.LVL225:
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3538              		.loc 1 1688 9 is_stmt 1 view .LVU1022
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3539              		.loc 1 1688 21 is_stmt 0 view .LVU1023
 3540 003e 44BF     		itt	mi
 3541 0040 0234     		addmi	r4, r4, #2
 3542              	.LVL226:
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3543              		.loc 1 1688 21 view .LVU1024
 3544 0042 E4B2     		uxtbmi	r4, r4
 3545              	.LVL227:
1689:Src/mpu6050.c ****         packet_size += 6;
 3546              		.loc 1 1689 5 is_stmt 1 view .LVU1025
1689:Src/mpu6050.c ****         packet_size += 6;
 3547              		.loc 1 1689 8 is_stmt 0 view .LVU1026
 3548 0044 1A07     		lsls	r2, r3, #28
 3549              	.LVL228:
1690:Src/mpu6050.c **** 
 3550              		.loc 1 1690 9 is_stmt 1 view .LVU1027
1690:Src/mpu6050.c **** 
 3551              		.loc 1 1690 21 is_stmt 0 view .LVU1028
 3552 0046 48BF     		it	mi
 3553 0048 0634     		addmi	r4, r4, #6
 3554              	.LVL229:
1692:Src/mpu6050.c ****         return -1;
 3555              		.loc 1 1692 9 view .LVU1029
 3556 004a D5E90010 		ldrd	r1, r0, [r5]
 3557 004e 4FF00202 		mov	r2, #2
 3558 0052 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 3559 0054 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3560 0056 01AB     		add	r3, sp, #4
 3561              	.LVL230:
1690:Src/mpu6050.c **** 
 3562              		.loc 1 1690 21 view .LVU1030
 3563 0058 48BF     		it	mi
 3564 005a E4B2     		uxtbmi	r4, r4
 3565              	.LVL231:
1692:Src/mpu6050.c ****         return -1;
 3566              		.loc 1 1692 5 is_stmt 1 view .LVU1031
1692:Src/mpu6050.c ****         return -1;
 3567              		.loc 1 1692 9 is_stmt 0 view .LVU1032
 3568 005c FFF7FEFF 		bl	i2c_readBytes
 3569              	.LVL232:
1692:Src/mpu6050.c ****         return -1;
 3570              		.loc 1 1692 8 view .LVU1033
 3571 0060 0028     		cmp	r0, #0
 3572 0062 D8D1     		bne	.L272
1694:Src/mpu6050.c ****     if (fifo_count < packet_size)
 3573              		.loc 1 1694 5 is_stmt 1 view .LVU1034
 3574 0064 BDF80430 		ldrh	r3, [sp, #4]
1695:Src/mpu6050.c ****         return 0;
 3575              		.loc 1 1695 20 is_stmt 0 view .LVU1035
 3576 0068 1FFA84F8 		uxth	r8, r4
 3577 006c 5BBA     		rev16	r3, r3
 3578 006e 1FFA83FB 		uxth	fp, r3
ARM GAS  /tmp/ccC60hwS.s 			page 118


 3579              	.LVL233:
1695:Src/mpu6050.c ****         return 0;
 3580              		.loc 1 1695 5 is_stmt 1 view .LVU1036
1695:Src/mpu6050.c ****         return 0;
 3581              		.loc 1 1695 8 is_stmt 0 view .LVU1037
 3582 0072 D845     		cmp	r8, fp
 3583 0074 01D9     		bls	.L277
 3584              	.LVL234:
 3585              	.L319:
1736:Src/mpu6050.c ****     }
 3586              		.loc 1 1736 9 is_stmt 1 view .LVU1038
1739:Src/mpu6050.c **** }
 3587              		.loc 1 1739 12 is_stmt 0 view .LVU1039
 3588 0076 0020     		movs	r0, #0
1739:Src/mpu6050.c **** }
 3589              		.loc 1 1739 12 view .LVU1040
 3590 0078 CFE7     		b	.L269
 3591              	.LVL235:
 3592              	.L277:
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3593              		.loc 1 1700 5 is_stmt 1 view .LVU1041
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3594              		.loc 1 1700 25 is_stmt 0 view .LVU1042
 3595 007a 6868     		ldr	r0, [r5, #4]
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3596              		.loc 1 1700 20 view .LVU1043
 3597 007c 4388     		ldrh	r3, [r0, #2]
 3598              	.LVL236:
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3599              		.loc 1 1700 8 view .LVU1044
 3600 007e BBEB530F 		cmp	fp, r3, lsr #1
 3601 0082 11D9     		bls	.L278
1702:Src/mpu6050.c ****             return -1;
 3602              		.loc 1 1702 9 is_stmt 1 view .LVU1045
1702:Src/mpu6050.c ****             return -1;
 3603              		.loc 1 1702 13 is_stmt 0 view .LVU1046
 3604 0084 2968     		ldr	r1, [r5]
 3605 0086 0122     		movs	r2, #1
 3606 0088 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 3607 008a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3608 008c 01AB     		add	r3, sp, #4
 3609 008e FFF7FEFF 		bl	i2c_readBytes
 3610              	.LVL237:
1702:Src/mpu6050.c ****             return -1;
 3611              		.loc 1 1702 12 view .LVU1047
 3612 0092 0028     		cmp	r0, #0
 3613 0094 BFD1     		bne	.L272
1704:Src/mpu6050.c ****             mpu_reset_fifo();
 3614              		.loc 1 1704 9 is_stmt 1 view .LVU1048
1704:Src/mpu6050.c ****             mpu_reset_fifo();
 3615              		.loc 1 1704 12 is_stmt 0 view .LVU1049
 3616 0096 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3617 009a DB06     		lsls	r3, r3, #27
 3618 009c 04D5     		bpl	.L278
1705:Src/mpu6050.c ****             return -2;
 3619              		.loc 1 1705 13 is_stmt 1 view .LVU1050
 3620 009e FFF7FEFF 		bl	mpu_reset_fifo
ARM GAS  /tmp/ccC60hwS.s 			page 119


 3621              	.LVL238:
1706:Src/mpu6050.c ****         }
 3622              		.loc 1 1706 13 view .LVU1051
1706:Src/mpu6050.c ****         }
 3623              		.loc 1 1706 20 is_stmt 0 view .LVU1052
 3624 00a2 6FF00100 		mvn	r0, #1
 3625 00a6 B8E7     		b	.L269
 3626              	.L278:
1709:Src/mpu6050.c **** 
 3627              		.loc 1 1709 5 is_stmt 1 view .LVU1053
 3628 00a8 5046     		mov	r0, r10
 3629 00aa FFF7FEFF 		bl	get_tick_count_ms
 3630              	.LVL239:
1711:Src/mpu6050.c ****         return -1;
 3631              		.loc 1 1711 5 view .LVU1054
1711:Src/mpu6050.c ****         return -1;
 3632              		.loc 1 1711 9 is_stmt 0 view .LVU1055
 3633 00ae D5E90010 		ldrd	r1, r0, [r5]
 3634 00b2 2246     		mov	r2, r4
 3635 00b4 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 3636 00b6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3637 00b8 01AB     		add	r3, sp, #4
 3638 00ba FFF7FEFF 		bl	i2c_readBytes
 3639              	.LVL240:
1711:Src/mpu6050.c ****         return -1;
 3640              		.loc 1 1711 8 view .LVU1056
 3641 00be 0028     		cmp	r0, #0
 3642 00c0 A9D1     		bne	.L272
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3643              		.loc 1 1713 5 is_stmt 1 view .LVU1057
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3644              		.loc 1 1713 26 is_stmt 0 view .LVU1058
 3645 00c2 BBFBF4F3 		udiv	r3, fp, r4
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3646              		.loc 1 1713 13 view .LVU1059
 3647 00c6 0E9A     		ldr	r2, [sp, #56]
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3648              		.loc 1 1713 40 view .LVU1060
 3649 00c8 013B     		subs	r3, r3, #1
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3650              		.loc 1 1713 13 view .LVU1061
 3651 00ca 1370     		strb	r3, [r2]
1714:Src/mpu6050.c **** 
 3652              		.loc 1 1714 5 is_stmt 1 view .LVU1062
1714:Src/mpu6050.c **** 
 3653              		.loc 1 1714 16 is_stmt 0 view .LVU1063
 3654 00cc 3070     		strb	r0, [r6]
1716:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3655              		.loc 1 1716 5 is_stmt 1 view .LVU1064
1716:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3656              		.loc 1 1716 8 is_stmt 0 view .LVU1065
 3657 00ce 002C     		cmp	r4, #0
 3658 00d0 D1D0     		beq	.L319
1716:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3659              		.loc 1 1716 32 discriminator 1 view .LVU1066
 3660 00d2 2A7C     		ldrb	r2, [r5, #16]	@ zero_extendqisi2
 3661 00d4 12F00802 		ands	r2, r2, #8
ARM GAS  /tmp/ccC60hwS.s 			page 120


 3662 00d8 16D0     		beq	.L280
1717:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3663              		.loc 1 1717 9 is_stmt 1 view .LVU1067
1717:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3664              		.loc 1 1717 18 is_stmt 0 view .LVU1068
 3665 00da BDF80430 		ldrh	r3, [sp, #4]
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3666              		.loc 1 1723 8 view .LVU1069
 3667 00de B8F1060F 		cmp	r8, #6
1717:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3668              		.loc 1 1717 18 view .LVU1070
 3669 00e2 5BBA     		rev16	r3, r3
 3670 00e4 A9F80030 		strh	r3, [r9]	@ movhi
1718:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
 3671              		.loc 1 1718 9 is_stmt 1 view .LVU1071
1718:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
 3672              		.loc 1 1718 18 is_stmt 0 view .LVU1072
 3673 00e8 BDF80630 		ldrh	r3, [sp, #6]
 3674 00ec 5BBA     		rev16	r3, r3
 3675 00ee A9F80230 		strh	r3, [r9, #2]	@ movhi
1719:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
 3676              		.loc 1 1719 9 is_stmt 1 view .LVU1073
1719:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
 3677              		.loc 1 1719 18 is_stmt 0 view .LVU1074
 3678 00f2 BDF80830 		ldrh	r3, [sp, #8]
 3679 00f6 5BBA     		rev16	r3, r3
 3680 00f8 A9F80430 		strh	r3, [r9, #4]	@ movhi
1720:Src/mpu6050.c ****         index += 6;
 3681              		.loc 1 1720 9 is_stmt 1 view .LVU1075
1720:Src/mpu6050.c ****         index += 6;
 3682              		.loc 1 1720 20 is_stmt 0 view .LVU1076
 3683 00fc 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3684 00fe 43F00803 		orr	r3, r3, #8
 3685 0102 3370     		strb	r3, [r6]
1721:Src/mpu6050.c ****     }
 3686              		.loc 1 1721 9 is_stmt 1 view .LVU1077
 3687              	.LVL241:
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3688              		.loc 1 1723 5 view .LVU1078
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3689              		.loc 1 1723 8 is_stmt 0 view .LVU1079
 3690 0104 B7D0     		beq	.L319
1721:Src/mpu6050.c ****     }
 3691              		.loc 1 1721 15 view .LVU1080
 3692 0106 0622     		movs	r2, #6
 3693              	.LVL242:
 3694              	.L280:
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3695              		.loc 1 1723 32 discriminator 1 view .LVU1081
 3696 0108 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3697 010a 5806     		lsls	r0, r3, #25
 3698 010c 15D5     		bpl	.L281
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3699              		.loc 1 1724 9 is_stmt 1 view .LVU1082
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3700              		.loc 1 1724 24 is_stmt 0 view .LVU1083
 3701 010e 02F11003 		add	r3, r2, #16
ARM GAS  /tmp/ccC60hwS.s 			page 121


 3702 0112 6B44     		add	r3, sp, r3
 3703 0114 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3704              		.loc 1 1724 52 view .LVU1084
 3705 0118 531C     		adds	r3, r2, #1
 3706 011a 9BB2     		uxth	r3, r3
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3707              		.loc 1 1724 46 view .LVU1085
 3708 011c 1033     		adds	r3, r3, #16
 3709 011e 6B44     		add	r3, sp, r3
 3710 0120 13F80C3C 		ldrb	r3, [r3, #-12]	@ zero_extendqisi2
1726:Src/mpu6050.c ****     }
 3711              		.loc 1 1726 15 view .LVU1086
 3712 0124 0232     		adds	r2, r2, #2
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3713              		.loc 1 1724 40 view .LVU1087
 3714 0126 43EA0123 		orr	r3, r3, r1, lsl #8
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3715              		.loc 1 1724 17 view .LVU1088
 3716 012a 3B80     		strh	r3, [r7]	@ movhi
1725:Src/mpu6050.c ****         index += 2;
 3717              		.loc 1 1725 9 is_stmt 1 view .LVU1089
1725:Src/mpu6050.c ****         index += 2;
 3718              		.loc 1 1725 20 is_stmt 0 view .LVU1090
 3719 012c 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
1726:Src/mpu6050.c ****     }
 3720              		.loc 1 1726 15 view .LVU1091
 3721 012e 92B2     		uxth	r2, r2
1725:Src/mpu6050.c ****         index += 2;
 3722              		.loc 1 1725 20 view .LVU1092
 3723 0130 43F04003 		orr	r3, r3, #64
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3724              		.loc 1 1728 8 view .LVU1093
 3725 0134 9045     		cmp	r8, r2
1725:Src/mpu6050.c ****         index += 2;
 3726              		.loc 1 1725 20 view .LVU1094
 3727 0136 3370     		strb	r3, [r6]
1726:Src/mpu6050.c ****     }
 3728              		.loc 1 1726 9 is_stmt 1 view .LVU1095
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3729              		.loc 1 1728 5 view .LVU1096
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3730              		.loc 1 1728 8 is_stmt 0 view .LVU1097
 3731 0138 9DD0     		beq	.L319
 3732              	.L281:
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3733              		.loc 1 1728 32 discriminator 1 view .LVU1098
 3734 013a 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3735 013c 9906     		lsls	r1, r3, #26
 3736 013e 15D5     		bpl	.L282
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3737              		.loc 1 1729 9 is_stmt 1 view .LVU1099
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3738              		.loc 1 1729 24 is_stmt 0 view .LVU1100
 3739 0140 02F11003 		add	r3, r2, #16
 3740 0144 6B44     		add	r3, sp, r3
 3741 0146 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 122


1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3742              		.loc 1 1729 52 view .LVU1101
 3743 014a 531C     		adds	r3, r2, #1
 3744 014c 9BB2     		uxth	r3, r3
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3745              		.loc 1 1729 46 view .LVU1102
 3746 014e 1033     		adds	r3, r3, #16
 3747 0150 6B44     		add	r3, sp, r3
 3748 0152 13F80C3C 		ldrb	r3, [r3, #-12]	@ zero_extendqisi2
1731:Src/mpu6050.c ****     }
 3749              		.loc 1 1731 15 view .LVU1103
 3750 0156 0232     		adds	r2, r2, #2
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3751              		.loc 1 1729 40 view .LVU1104
 3752 0158 43EA0123 		orr	r3, r3, r1, lsl #8
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3753              		.loc 1 1729 17 view .LVU1105
 3754 015c 7B80     		strh	r3, [r7, #2]	@ movhi
1730:Src/mpu6050.c ****         index += 2;
 3755              		.loc 1 1730 9 is_stmt 1 view .LVU1106
1730:Src/mpu6050.c ****         index += 2;
 3756              		.loc 1 1730 20 is_stmt 0 view .LVU1107
 3757 015e 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
1731:Src/mpu6050.c ****     }
 3758              		.loc 1 1731 15 view .LVU1108
 3759 0160 92B2     		uxth	r2, r2
1730:Src/mpu6050.c ****         index += 2;
 3760              		.loc 1 1730 20 view .LVU1109
 3761 0162 43F02003 		orr	r3, r3, #32
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3762              		.loc 1 1733 8 view .LVU1110
 3763 0166 9045     		cmp	r8, r2
1730:Src/mpu6050.c ****         index += 2;
 3764              		.loc 1 1730 20 view .LVU1111
 3765 0168 3370     		strb	r3, [r6]
1731:Src/mpu6050.c ****     }
 3766              		.loc 1 1731 9 is_stmt 1 view .LVU1112
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3767              		.loc 1 1733 5 view .LVU1113
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3768              		.loc 1 1733 8 is_stmt 0 view .LVU1114
 3769 016a 84D0     		beq	.L319
 3770              	.L282:
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3771              		.loc 1 1733 32 discriminator 1 view .LVU1115
 3772 016c 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3773 016e DB06     		lsls	r3, r3, #27
 3774 0170 81D5     		bpl	.L319
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3775              		.loc 1 1734 9 is_stmt 1 view .LVU1116
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3776              		.loc 1 1734 24 is_stmt 0 view .LVU1117
 3777 0172 02F11003 		add	r3, r2, #16
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3778              		.loc 1 1734 52 view .LVU1118
 3779 0176 0132     		adds	r2, r2, #1
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
ARM GAS  /tmp/ccC60hwS.s 			page 123


 3780              		.loc 1 1734 24 view .LVU1119
 3781 0178 6B44     		add	r3, sp, r3
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3782              		.loc 1 1734 52 view .LVU1120
 3783 017a 92B2     		uxth	r2, r2
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3784              		.loc 1 1734 24 view .LVU1121
 3785 017c 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3786              		.loc 1 1734 46 view .LVU1122
 3787 0180 02F11003 		add	r3, r2, #16
 3788 0184 0DEB0302 		add	r2, sp, r3
 3789 0188 12F80C3C 		ldrb	r3, [r2, #-12]	@ zero_extendqisi2
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3790              		.loc 1 1734 40 view .LVU1123
 3791 018c 43EA0123 		orr	r3, r3, r1, lsl #8
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3792              		.loc 1 1734 17 view .LVU1124
 3793 0190 BB80     		strh	r3, [r7, #4]	@ movhi
1735:Src/mpu6050.c ****         index += 2;
 3794              		.loc 1 1735 9 is_stmt 1 view .LVU1125
1735:Src/mpu6050.c ****         index += 2;
 3795              		.loc 1 1735 20 is_stmt 0 view .LVU1126
 3796 0192 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3797 0194 43F01003 		orr	r3, r3, #16
 3798 0198 3370     		strb	r3, [r6]
 3799 019a 6CE7     		b	.L319
 3800              	.L321:
 3801              		.align	2
 3802              	.L320:
 3803 019c 00000000 		.word	.LANCHOR0
 3804              		.cfi_endproc
 3805              	.LFE91:
 3807              		.section	.text.mpu_read_fifo_stream,"ax",%progbits
 3808              		.align	1
 3809              		.global	mpu_read_fifo_stream
 3810              		.syntax unified
 3811              		.thumb
 3812              		.thumb_func
 3813              		.fpu softvfp
 3815              	mpu_read_fifo_stream:
 3816              	.LVL243:
 3817              	.LFB92:
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 3818              		.loc 1 1751 1 is_stmt 1 view -0
 3819              		.cfi_startproc
 3820              		@ args = 0, pretend = 0, frame = 8
 3821              		@ frame_needed = 0, uses_anonymous_args = 0
1752:Src/mpu6050.c ****     unsigned short fifo_count;
 3822              		.loc 1 1752 5 view .LVU1128
1753:Src/mpu6050.c ****     if (!st.chip_cfg.dmp_on)
 3823              		.loc 1 1753 5 view .LVU1129
1754:Src/mpu6050.c ****         return -1;
 3824              		.loc 1 1754 5 view .LVU1130
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 3825              		.loc 1 1751 1 is_stmt 0 view .LVU1131
 3826 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
ARM GAS  /tmp/ccC60hwS.s 			page 124


 3827              	.LCFI59:
 3828              		.cfi_def_cfa_offset 32
 3829              		.cfi_offset 4, -24
 3830              		.cfi_offset 5, -20
 3831              		.cfi_offset 6, -16
 3832              		.cfi_offset 7, -12
 3833              		.cfi_offset 8, -8
 3834              		.cfi_offset 14, -4
1754:Src/mpu6050.c ****         return -1;
 3835              		.loc 1 1754 21 view .LVU1132
 3836 0004 234F     		ldr	r7, .L335
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 3837              		.loc 1 1751 1 view .LVU1133
 3838 0006 0646     		mov	r6, r0
1754:Src/mpu6050.c ****         return -1;
 3839              		.loc 1 1754 8 view .LVU1134
 3840 0008 97F82430 		ldrb	r3, [r7, #36]	@ zero_extendqisi2
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 3841              		.loc 1 1751 1 view .LVU1135
 3842 000c 8846     		mov	r8, r1
 3843 000e 1546     		mov	r5, r2
1754:Src/mpu6050.c ****         return -1;
 3844              		.loc 1 1754 8 view .LVU1136
 3845 0010 23B9     		cbnz	r3, .L323
 3846              	.LVL244:
 3847              	.L334:
1764:Src/mpu6050.c ****     }
 3848              		.loc 1 1764 9 is_stmt 1 view .LVU1137
1764:Src/mpu6050.c ****     }
 3849              		.loc 1 1764 16 is_stmt 0 view .LVU1138
 3850 0012 4FF0FF30 		mov	r0, #-1
 3851              	.L322:
1780:Src/mpu6050.c **** 
 3852              		.loc 1 1780 1 view .LVU1139
 3853 0016 02B0     		add	sp, sp, #8
 3854              	.LCFI60:
 3855              		.cfi_remember_state
 3856              		.cfi_def_cfa_offset 24
 3857              		@ sp needed
 3858 0018 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3859              	.LVL245:
 3860              	.L323:
 3861              	.LCFI61:
 3862              		.cfi_restore_state
1756:Src/mpu6050.c ****         return -1;
 3863              		.loc 1 1756 5 is_stmt 1 view .LVU1140
1756:Src/mpu6050.c ****         return -1;
 3864              		.loc 1 1756 8 is_stmt 0 view .LVU1141
 3865 001c BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 3866 001e 002B     		cmp	r3, #0
 3867 0020 F7D0     		beq	.L334
1759:Src/mpu6050.c ****         return -1;
 3868              		.loc 1 1759 5 is_stmt 1 view .LVU1142
1759:Src/mpu6050.c ****         return -1;
 3869              		.loc 1 1759 9 is_stmt 0 view .LVU1143
 3870 0022 D7E90010 		ldrd	r1, r0, [r7]
 3871              	.LVL246:
ARM GAS  /tmp/ccC60hwS.s 			page 125


1759:Src/mpu6050.c ****         return -1;
 3872              		.loc 1 1759 9 view .LVU1144
 3873 0026 0222     		movs	r2, #2
 3874              	.LVL247:
1759:Src/mpu6050.c ****         return -1;
 3875              		.loc 1 1759 9 view .LVU1145
 3876 0028 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 3877 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3878 002c 01AB     		add	r3, sp, #4
 3879 002e FFF7FEFF 		bl	i2c_readBytes
 3880              	.LVL248:
1759:Src/mpu6050.c ****         return -1;
 3881              		.loc 1 1759 8 view .LVU1146
 3882 0032 0028     		cmp	r0, #0
 3883 0034 EDD1     		bne	.L334
1761:Src/mpu6050.c ****     if (fifo_count < length) {
 3884              		.loc 1 1761 5 is_stmt 1 view .LVU1147
 3885 0036 BDF80440 		ldrh	r4, [sp, #4]
 3886 003a 62BA     		rev16	r2, r4
 3887 003c 94B2     		uxth	r4, r2
 3888              	.LVL249:
1762:Src/mpu6050.c ****         more[0] = 0;
 3889              		.loc 1 1762 5 view .LVU1148
1762:Src/mpu6050.c ****         more[0] = 0;
 3890              		.loc 1 1762 8 is_stmt 0 view .LVU1149
 3891 003e A642     		cmp	r6, r4
 3892 0040 01D9     		bls	.L326
1763:Src/mpu6050.c ****         return -1;
 3893              		.loc 1 1763 9 is_stmt 1 view .LVU1150
1763:Src/mpu6050.c ****         return -1;
 3894              		.loc 1 1763 17 is_stmt 0 view .LVU1151
 3895 0042 2870     		strb	r0, [r5]
 3896 0044 E5E7     		b	.L334
 3897              	.L326:
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3898              		.loc 1 1766 5 is_stmt 1 view .LVU1152
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3899              		.loc 1 1766 25 is_stmt 0 view .LVU1153
 3900 0046 7868     		ldr	r0, [r7, #4]
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3901              		.loc 1 1766 20 view .LVU1154
 3902 0048 4388     		ldrh	r3, [r0, #2]
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3903              		.loc 1 1766 8 view .LVU1155
 3904 004a B4EB530F 		cmp	r4, r3, lsr #1
 3905 004e 11D9     		bls	.L327
1768:Src/mpu6050.c ****             return -1;
 3906              		.loc 1 1768 9 is_stmt 1 view .LVU1156
1768:Src/mpu6050.c ****             return -1;
 3907              		.loc 1 1768 13 is_stmt 0 view .LVU1157
 3908 0050 3968     		ldr	r1, [r7]
 3909 0052 0122     		movs	r2, #1
 3910              	.LVL250:
1768:Src/mpu6050.c ****             return -1;
 3911              		.loc 1 1768 13 view .LVU1158
 3912 0054 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 3913 0056 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 126


 3914 0058 01AB     		add	r3, sp, #4
 3915 005a FFF7FEFF 		bl	i2c_readBytes
 3916              	.LVL251:
1768:Src/mpu6050.c ****             return -1;
 3917              		.loc 1 1768 12 view .LVU1159
 3918 005e 0028     		cmp	r0, #0
 3919 0060 D7D1     		bne	.L334
1770:Src/mpu6050.c ****             mpu_reset_fifo();
 3920              		.loc 1 1770 9 is_stmt 1 view .LVU1160
1770:Src/mpu6050.c ****             mpu_reset_fifo();
 3921              		.loc 1 1770 12 is_stmt 0 view .LVU1161
 3922 0062 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3923 0066 DB06     		lsls	r3, r3, #27
 3924 0068 04D5     		bpl	.L327
1771:Src/mpu6050.c ****             return -2;
 3925              		.loc 1 1771 13 is_stmt 1 view .LVU1162
 3926 006a FFF7FEFF 		bl	mpu_reset_fifo
 3927              	.LVL252:
1772:Src/mpu6050.c ****         }
 3928              		.loc 1 1772 13 view .LVU1163
1772:Src/mpu6050.c ****         }
 3929              		.loc 1 1772 20 is_stmt 0 view .LVU1164
 3930 006e 6FF00100 		mvn	r0, #1
 3931 0072 D0E7     		b	.L322
 3932              	.L327:
1776:Src/mpu6050.c ****         return -1;
 3933              		.loc 1 1776 5 is_stmt 1 view .LVU1165
1776:Src/mpu6050.c ****         return -1;
 3934              		.loc 1 1776 9 is_stmt 0 view .LVU1166
 3935 0074 D7E90010 		ldrd	r1, r0, [r7]
 3936 0078 4346     		mov	r3, r8
 3937 007a 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 3938 007c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3939 007e F2B2     		uxtb	r2, r6
 3940 0080 FFF7FEFF 		bl	i2c_readBytes
 3941              	.LVL253:
1776:Src/mpu6050.c ****         return -1;
 3942              		.loc 1 1776 8 view .LVU1167
 3943 0084 0028     		cmp	r0, #0
 3944 0086 C4D1     		bne	.L334
1778:Src/mpu6050.c ****     return 0;
 3945              		.loc 1 1778 5 is_stmt 1 view .LVU1168
1778:Src/mpu6050.c ****     return 0;
 3946              		.loc 1 1778 35 is_stmt 0 view .LVU1169
 3947 0088 B4FBF6F4 		udiv	r4, r4, r6
 3948              	.LVL254:
1778:Src/mpu6050.c ****     return 0;
 3949              		.loc 1 1778 35 view .LVU1170
 3950 008c 013C     		subs	r4, r4, #1
1778:Src/mpu6050.c ****     return 0;
 3951              		.loc 1 1778 13 view .LVU1171
 3952 008e 2C70     		strb	r4, [r5]
1779:Src/mpu6050.c **** }
 3953              		.loc 1 1779 5 is_stmt 1 view .LVU1172
1779:Src/mpu6050.c **** }
 3954              		.loc 1 1779 12 is_stmt 0 view .LVU1173
 3955 0090 C1E7     		b	.L322
ARM GAS  /tmp/ccC60hwS.s 			page 127


 3956              	.L336:
 3957 0092 00BF     		.align	2
 3958              	.L335:
 3959 0094 00000000 		.word	.LANCHOR0
 3960              		.cfi_endproc
 3961              	.LFE92:
 3963              		.section	.text.mpu_set_bypass,"ax",%progbits
 3964              		.align	1
 3965              		.global	mpu_set_bypass
 3966              		.syntax unified
 3967              		.thumb
 3968              		.thumb_func
 3969              		.fpu softvfp
 3971              	mpu_set_bypass:
 3972              	.LVL255:
 3973              	.LFB93:
1788:Src/mpu6050.c ****     unsigned char tmp;
 3974              		.loc 1 1788 1 is_stmt 1 view -0
 3975              		.cfi_startproc
 3976              		@ args = 0, pretend = 0, frame = 8
 3977              		@ frame_needed = 0, uses_anonymous_args = 0
1789:Src/mpu6050.c **** 
 3978              		.loc 1 1789 5 view .LVU1175
1791:Src/mpu6050.c ****         return 0;
 3979              		.loc 1 1791 5 view .LVU1176
1788:Src/mpu6050.c ****     unsigned char tmp;
 3980              		.loc 1 1788 1 is_stmt 0 view .LVU1177
 3981 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 3982              	.LCFI62:
 3983              		.cfi_def_cfa_offset 24
 3984              		.cfi_offset 4, -12
 3985              		.cfi_offset 5, -8
 3986              		.cfi_offset 14, -4
1791:Src/mpu6050.c ****         return 0;
 3987              		.loc 1 1791 20 view .LVU1178
 3988 0002 384C     		ldr	r4, .L361
1788:Src/mpu6050.c ****     unsigned char tmp;
 3989              		.loc 1 1788 1 view .LVU1179
 3990 0004 0546     		mov	r5, r0
1791:Src/mpu6050.c ****         return 0;
 3991              		.loc 1 1791 8 view .LVU1180
 3992 0006 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 3993 0008 8342     		cmp	r3, r0
 3994 000a 69D0     		beq	.L349
1794:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 3995              		.loc 1 1794 5 is_stmt 1 view .LVU1181
1795:Src/mpu6050.c ****             return -1;
 3996              		.loc 1 1795 13 is_stmt 0 view .LVU1182
 3997 000c 6368     		ldr	r3, [r4, #4]
 3998 000e 0122     		movs	r2, #1
 3999 0010 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 4000              	.LVL256:
1795:Src/mpu6050.c ****             return -1;
 4001              		.loc 1 1795 13 view .LVU1183
 4002 0012 2368     		ldr	r3, [r4]
 4003 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 4004 0016 0DF10703 		add	r3, sp, #7
ARM GAS  /tmp/ccC60hwS.s 			page 128


1794:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4005              		.loc 1 1794 8 view .LVU1184
 4006 001a 6DB3     		cbz	r5, .L339
1795:Src/mpu6050.c ****             return -1;
 4007              		.loc 1 1795 9 is_stmt 1 view .LVU1185
1795:Src/mpu6050.c ****             return -1;
 4008              		.loc 1 1795 13 is_stmt 0 view .LVU1186
 4009 001c FFF7FEFF 		bl	i2c_readBytes
 4010              	.LVL257:
1795:Src/mpu6050.c ****             return -1;
 4011              		.loc 1 1795 12 view .LVU1187
 4012 0020 18B1     		cbz	r0, .L340
 4013              	.L341:
1796:Src/mpu6050.c ****         tmp &= ~BIT_AUX_IF_EN;
 4014              		.loc 1 1796 20 view .LVU1188
 4015 0022 4FF0FF30 		mov	r0, #-1
 4016              	.L337:
1830:Src/mpu6050.c **** 
 4017              		.loc 1 1830 1 view .LVU1189
 4018 0026 03B0     		add	sp, sp, #12
 4019              	.LCFI63:
 4020              		.cfi_remember_state
 4021              		.cfi_def_cfa_offset 12
 4022              		@ sp needed
 4023 0028 30BD     		pop	{r4, r5, pc}
 4024              	.L340:
 4025              	.LCFI64:
 4026              		.cfi_restore_state
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4027              		.loc 1 1797 9 is_stmt 1 view .LVU1190
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4028              		.loc 1 1797 13 is_stmt 0 view .LVU1191
 4029 002a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1798:Src/mpu6050.c ****             return -1;
 4030              		.loc 1 1798 13 view .LVU1192
 4031 002e D4E90010 		ldrd	r1, r0, [r4]
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4032              		.loc 1 1797 13 view .LVU1193
 4033 0032 23F02003 		bic	r3, r3, #32
 4034 0036 8DF80730 		strb	r3, [sp, #7]
1798:Src/mpu6050.c ****             return -1;
 4035              		.loc 1 1798 9 is_stmt 1 view .LVU1194
1798:Src/mpu6050.c ****             return -1;
 4036              		.loc 1 1798 13 is_stmt 0 view .LVU1195
 4037 003a 0122     		movs	r2, #1
 4038 003c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 4039 003e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4040 0040 0DF10703 		add	r3, sp, #7
 4041 0044 FFF7FEFF 		bl	i2c_writeBytes
 4042              	.LVL258:
1798:Src/mpu6050.c ****             return -1;
 4043              		.loc 1 1798 12 view .LVU1196
 4044 0048 0028     		cmp	r0, #0
 4045 004a EAD1     		bne	.L341
1800:Src/mpu6050.c ****         tmp = BIT_BYPASS_EN;
 4046              		.loc 1 1800 9 is_stmt 1 view .LVU1197
 4047 004c 0320     		movs	r0, #3
ARM GAS  /tmp/ccC60hwS.s 			page 129


 4048 004e FFF7FEFF 		bl	delay_1ms
 4049              	.LVL259:
1801:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4050              		.loc 1 1801 9 view .LVU1198
1801:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4051              		.loc 1 1801 13 is_stmt 0 view .LVU1199
 4052 0052 0223     		movs	r3, #2
 4053 0054 8DF80730 		strb	r3, [sp, #7]
1802:Src/mpu6050.c ****             tmp |= BIT_ACTL;
 4054              		.loc 1 1802 9 is_stmt 1 view .LVU1200
1802:Src/mpu6050.c ****             tmp |= BIT_ACTL;
 4055              		.loc 1 1802 12 is_stmt 0 view .LVU1201
 4056 0058 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 4057 005c 13B1     		cbz	r3, .L342
1803:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
 4058              		.loc 1 1803 13 is_stmt 1 view .LVU1202
1803:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
 4059              		.loc 1 1803 17 is_stmt 0 view .LVU1203
 4060 005e 8223     		movs	r3, #130
 4061 0060 8DF80730 		strb	r3, [sp, #7]
 4062              	.L342:
1804:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4063              		.loc 1 1804 9 is_stmt 1 view .LVU1204
1804:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4064              		.loc 1 1804 12 is_stmt 0 view .LVU1205
 4065 0064 94F82330 		ldrb	r3, [r4, #35]	@ zero_extendqisi2
 4066 0068 73B3     		cbz	r3, .L347
1805:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4067              		.loc 1 1805 13 is_stmt 1 view .LVU1206
1805:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4068              		.loc 1 1805 17 is_stmt 0 view .LVU1207
 4069 006a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4070              	.L360:
1824:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4071              		.loc 1 1824 13 is_stmt 1 view .LVU1208
1824:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4072              		.loc 1 1824 17 is_stmt 0 view .LVU1209
 4073 006e 43F03003 		orr	r3, r3, #48
 4074 0072 8DF80730 		strb	r3, [sp, #7]
 4075 0076 27E0     		b	.L347
 4076              	.L339:
1810:Src/mpu6050.c ****             return -1;
 4077              		.loc 1 1810 9 is_stmt 1 view .LVU1210
1810:Src/mpu6050.c ****             return -1;
 4078              		.loc 1 1810 13 is_stmt 0 view .LVU1211
 4079 0078 FFF7FEFF 		bl	i2c_readBytes
 4080              	.LVL260:
1810:Src/mpu6050.c ****             return -1;
 4081              		.loc 1 1810 12 view .LVU1212
 4082 007c 0028     		cmp	r0, #0
 4083 007e D0D1     		bne	.L341
1812:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4084              		.loc 1 1812 9 is_stmt 1 view .LVU1213
1816:Src/mpu6050.c ****             return -1;
 4085              		.loc 1 1816 13 is_stmt 0 view .LVU1214
 4086 0080 D4E90010 		ldrd	r1, r0, [r4]
1812:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
ARM GAS  /tmp/ccC60hwS.s 			page 130


 4087              		.loc 1 1812 12 view .LVU1215
 4088 0084 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4089              		.loc 1 1797 13 view .LVU1216
 4090 0086 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1812:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4091              		.loc 1 1812 12 view .LVU1217
 4092 008a D207     		lsls	r2, r2, #31
1813:Src/mpu6050.c ****         else
 4093              		.loc 1 1813 13 is_stmt 1 view .LVU1218
1813:Src/mpu6050.c ****         else
 4094              		.loc 1 1813 17 is_stmt 0 view .LVU1219
 4095 008c 4CBF     		ite	mi
 4096 008e 43F02003 		orrmi	r3, r3, #32
1815:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4097              		.loc 1 1815 13 is_stmt 1 view .LVU1220
1815:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4098              		.loc 1 1815 17 is_stmt 0 view .LVU1221
 4099 0092 03F0DF03 		andpl	r3, r3, #223
 4100 0096 8DF80730 		strb	r3, [sp, #7]
1816:Src/mpu6050.c ****             return -1;
 4101              		.loc 1 1816 9 is_stmt 1 view .LVU1222
1816:Src/mpu6050.c ****             return -1;
 4102              		.loc 1 1816 13 is_stmt 0 view .LVU1223
 4103 009a 0122     		movs	r2, #1
 4104 009c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 4105 009e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4106 00a0 0DF10703 		add	r3, sp, #7
 4107 00a4 FFF7FEFF 		bl	i2c_writeBytes
 4108              	.LVL261:
1816:Src/mpu6050.c ****             return -1;
 4109              		.loc 1 1816 12 view .LVU1224
 4110 00a8 0028     		cmp	r0, #0
 4111 00aa BAD1     		bne	.L341
1818:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4112              		.loc 1 1818 9 is_stmt 1 view .LVU1225
 4113 00ac 0320     		movs	r0, #3
 4114 00ae FFF7FEFF 		bl	delay_1ms
 4115              	.LVL262:
1819:Src/mpu6050.c ****             tmp = BIT_ACTL;
 4116              		.loc 1 1819 9 view .LVU1226
1819:Src/mpu6050.c ****             tmp = BIT_ACTL;
 4117              		.loc 1 1819 24 is_stmt 0 view .LVU1227
 4118 00b2 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
1823:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4119              		.loc 1 1823 12 view .LVU1228
 4120 00b6 94F82320 		ldrb	r2, [r4, #35]	@ zero_extendqisi2
1820:Src/mpu6050.c ****         else
 4121              		.loc 1 1820 17 view .LVU1229
 4122 00ba 002B     		cmp	r3, #0
 4123 00bc 18BF     		it	ne
 4124 00be 8023     		movne	r3, #128
 4125 00c0 8DF80730 		strb	r3, [sp, #7]
1823:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4126              		.loc 1 1823 9 is_stmt 1 view .LVU1230
1823:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4127              		.loc 1 1823 12 is_stmt 0 view .LVU1231
ARM GAS  /tmp/ccC60hwS.s 			page 131


 4128 00c4 002A     		cmp	r2, #0
 4129 00c6 D2D1     		bne	.L360
 4130              	.L347:
1825:Src/mpu6050.c ****             return -1;
 4131              		.loc 1 1825 9 is_stmt 1 view .LVU1232
1825:Src/mpu6050.c ****             return -1;
 4132              		.loc 1 1825 13 is_stmt 0 view .LVU1233
 4133 00c8 D4E90010 		ldrd	r1, r0, [r4]
 4134 00cc 0122     		movs	r2, #1
 4135 00ce C97D     		ldrb	r1, [r1, #23]	@ zero_extendqisi2
 4136 00d0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4137 00d2 0DF10703 		add	r3, sp, #7
 4138 00d6 FFF7FEFF 		bl	i2c_writeBytes
 4139              	.LVL263:
1825:Src/mpu6050.c ****             return -1;
 4140              		.loc 1 1825 12 view .LVU1234
 4141 00da 0028     		cmp	r0, #0
 4142 00dc A1D1     		bne	.L341
1828:Src/mpu6050.c ****     return 0;
 4143              		.loc 1 1828 5 is_stmt 1 view .LVU1235
1828:Src/mpu6050.c ****     return 0;
 4144              		.loc 1 1828 29 is_stmt 0 view .LVU1236
 4145 00de A574     		strb	r5, [r4, #18]
1829:Src/mpu6050.c **** }
 4146              		.loc 1 1829 5 is_stmt 1 view .LVU1237
 4147              	.L349:
1792:Src/mpu6050.c **** 
 4148              		.loc 1 1792 16 is_stmt 0 view .LVU1238
 4149 00e0 0020     		movs	r0, #0
 4150 00e2 A0E7     		b	.L337
 4151              	.L362:
 4152              		.align	2
 4153              	.L361:
 4154 00e4 00000000 		.word	.LANCHOR0
 4155              		.cfi_endproc
 4156              	.LFE93:
 4158              		.section	.text.mpu_set_int_level,"ax",%progbits
 4159              		.align	1
 4160              		.global	mpu_set_int_level
 4161              		.syntax unified
 4162              		.thumb
 4163              		.thumb_func
 4164              		.fpu softvfp
 4166              	mpu_set_int_level:
 4167              	.LVL264:
 4168              	.LFB94:
1838:Src/mpu6050.c ****     st.chip_cfg.active_low_int = active_low;
 4169              		.loc 1 1838 1 is_stmt 1 view -0
 4170              		.cfi_startproc
 4171              		@ args = 0, pretend = 0, frame = 0
 4172              		@ frame_needed = 0, uses_anonymous_args = 0
 4173              		@ link register save eliminated.
1839:Src/mpu6050.c ****     return 0;
 4174              		.loc 1 1839 5 view .LVU1240
1839:Src/mpu6050.c ****     return 0;
 4175              		.loc 1 1839 32 is_stmt 0 view .LVU1241
 4176 0000 024B     		ldr	r3, .L364
ARM GAS  /tmp/ccC60hwS.s 			page 132


 4177 0002 83F82200 		strb	r0, [r3, #34]
1840:Src/mpu6050.c **** }
 4178              		.loc 1 1840 5 is_stmt 1 view .LVU1242
1841:Src/mpu6050.c **** 
 4179              		.loc 1 1841 1 is_stmt 0 view .LVU1243
 4180 0006 0020     		movs	r0, #0
 4181              	.LVL265:
1841:Src/mpu6050.c **** 
 4182              		.loc 1 1841 1 view .LVU1244
 4183 0008 7047     		bx	lr
 4184              	.L365:
 4185 000a 00BF     		.align	2
 4186              	.L364:
 4187 000c 00000000 		.word	.LANCHOR0
 4188              		.cfi_endproc
 4189              	.LFE94:
 4191              		.section	.text.mpu_set_int_latched,"ax",%progbits
 4192              		.align	1
 4193              		.global	mpu_set_int_latched
 4194              		.syntax unified
 4195              		.thumb
 4196              		.thumb_func
 4197              		.fpu softvfp
 4199              	mpu_set_int_latched:
 4200              	.LVL266:
 4201              	.LFB95:
1850:Src/mpu6050.c ****     unsigned char tmp;
 4202              		.loc 1 1850 1 is_stmt 1 view -0
 4203              		.cfi_startproc
 4204              		@ args = 0, pretend = 0, frame = 8
 4205              		@ frame_needed = 0, uses_anonymous_args = 0
1851:Src/mpu6050.c ****     if (st.chip_cfg.latched_int == enable)
 4206              		.loc 1 1851 5 view .LVU1246
1852:Src/mpu6050.c ****         return 0;
 4207              		.loc 1 1852 5 view .LVU1247
1850:Src/mpu6050.c ****     unsigned char tmp;
 4208              		.loc 1 1850 1 is_stmt 0 view .LVU1248
 4209 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4210              	.LCFI65:
 4211              		.cfi_def_cfa_offset 24
 4212              		.cfi_offset 4, -12
 4213              		.cfi_offset 5, -8
 4214              		.cfi_offset 14, -4
1852:Src/mpu6050.c ****         return 0;
 4215              		.loc 1 1852 20 view .LVU1249
 4216 0002 174C     		ldr	r4, .L380
1850:Src/mpu6050.c ****     unsigned char tmp;
 4217              		.loc 1 1850 1 view .LVU1250
 4218 0004 0546     		mov	r5, r0
1852:Src/mpu6050.c ****         return 0;
 4219              		.loc 1 1852 8 view .LVU1251
 4220 0006 94F82330 		ldrb	r3, [r4, #35]	@ zero_extendqisi2
 4221 000a 8342     		cmp	r3, r0
 4222 000c 22D0     		beq	.L371
1855:Src/mpu6050.c ****         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4223              		.loc 1 1855 5 is_stmt 1 view .LVU1252
1856:Src/mpu6050.c ****     else
ARM GAS  /tmp/ccC60hwS.s 			page 133


 4224              		.loc 1 1856 13 is_stmt 0 view .LVU1253
 4225 000e 0028     		cmp	r0, #0
 4226 0010 0CBF     		ite	eq
 4227 0012 0023     		moveq	r3, #0
 4228 0014 3023     		movne	r3, #48
1859:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4229              		.loc 1 1859 8 view .LVU1254
 4230 0016 A27C     		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 4231 0018 8DF80730 		strb	r3, [sp, #7]
1859:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4232              		.loc 1 1859 5 is_stmt 1 view .LVU1255
1859:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4233              		.loc 1 1859 8 is_stmt 0 view .LVU1256
 4234 001c 1AB1     		cbz	r2, .L369
1860:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
 4235              		.loc 1 1860 9 is_stmt 1 view .LVU1257
1860:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
 4236              		.loc 1 1860 13 is_stmt 0 view .LVU1258
 4237 001e 43F00203 		orr	r3, r3, #2
 4238 0022 8DF80730 		strb	r3, [sp, #7]
 4239              	.L369:
1861:Src/mpu6050.c ****         tmp |= BIT_ACTL;
 4240              		.loc 1 1861 5 is_stmt 1 view .LVU1259
1861:Src/mpu6050.c ****         tmp |= BIT_ACTL;
 4241              		.loc 1 1861 8 is_stmt 0 view .LVU1260
 4242 0026 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 4243 002a 2BB1     		cbz	r3, .L370
1862:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4244              		.loc 1 1862 9 is_stmt 1 view .LVU1261
1862:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4245              		.loc 1 1862 13 is_stmt 0 view .LVU1262
 4246 002c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4247 0030 63F07F03 		orn	r3, r3, #127
 4248 0034 8DF80730 		strb	r3, [sp, #7]
 4249              	.L370:
1863:Src/mpu6050.c ****         return -1;
 4250              		.loc 1 1863 5 is_stmt 1 view .LVU1263
1863:Src/mpu6050.c ****         return -1;
 4251              		.loc 1 1863 9 is_stmt 0 view .LVU1264
 4252 0038 D4E90010 		ldrd	r1, r0, [r4]
 4253              	.LVL267:
1863:Src/mpu6050.c ****         return -1;
 4254              		.loc 1 1863 9 view .LVU1265
 4255 003c 0122     		movs	r2, #1
 4256 003e C97D     		ldrb	r1, [r1, #23]	@ zero_extendqisi2
 4257 0040 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4258 0042 0DF10703 		add	r3, sp, #7
 4259 0046 FFF7FEFF 		bl	i2c_writeBytes
 4260              	.LVL268:
1863:Src/mpu6050.c ****         return -1;
 4261              		.loc 1 1863 8 view .LVU1266
 4262 004a 28B9     		cbnz	r0, .L373
1865:Src/mpu6050.c ****     return 0;
 4263              		.loc 1 1865 5 is_stmt 1 view .LVU1267
1865:Src/mpu6050.c ****     return 0;
 4264              		.loc 1 1865 29 is_stmt 0 view .LVU1268
 4265 004c 84F82350 		strb	r5, [r4, #35]
ARM GAS  /tmp/ccC60hwS.s 			page 134


1866:Src/mpu6050.c **** }
 4266              		.loc 1 1866 5 is_stmt 1 view .LVU1269
 4267              	.L366:
1867:Src/mpu6050.c **** 
 4268              		.loc 1 1867 1 is_stmt 0 view .LVU1270
 4269 0050 03B0     		add	sp, sp, #12
 4270              	.LCFI66:
 4271              		.cfi_remember_state
 4272              		.cfi_def_cfa_offset 12
 4273              		@ sp needed
 4274 0052 30BD     		pop	{r4, r5, pc}
 4275              	.LVL269:
 4276              	.L371:
 4277              	.LCFI67:
 4278              		.cfi_restore_state
1853:Src/mpu6050.c **** 
 4279              		.loc 1 1853 16 view .LVU1271
 4280 0054 0020     		movs	r0, #0
 4281              	.LVL270:
1853:Src/mpu6050.c **** 
 4282              		.loc 1 1853 16 view .LVU1272
 4283 0056 FBE7     		b	.L366
 4284              	.L373:
1864:Src/mpu6050.c ****     st.chip_cfg.latched_int = enable;
 4285              		.loc 1 1864 16 view .LVU1273
 4286 0058 4FF0FF30 		mov	r0, #-1
 4287 005c F8E7     		b	.L366
 4288              	.L381:
 4289 005e 00BF     		.align	2
 4290              	.L380:
 4291 0060 00000000 		.word	.LANCHOR0
 4292              		.cfi_endproc
 4293              	.LFE95:
 4295              		.section	.text.mpu_lp_accel_mode,"ax",%progbits
 4296              		.align	1
 4297              		.global	mpu_lp_accel_mode
 4298              		.syntax unified
 4299              		.thumb
 4300              		.thumb_func
 4301              		.fpu softvfp
 4303              	mpu_lp_accel_mode:
 4304              	.LVL271:
 4305              	.LFB63:
 745:Src/mpu6050.c ****     unsigned char tmp[2];
 4306              		.loc 1 745 1 is_stmt 1 view -0
 4307              		.cfi_startproc
 4308              		@ args = 0, pretend = 0, frame = 8
 4309              		@ frame_needed = 0, uses_anonymous_args = 0
 746:Src/mpu6050.c **** 
 4310              		.loc 1 746 5 view .LVU1275
 748:Src/mpu6050.c ****         return -1;
 4311              		.loc 1 748 5 view .LVU1276
 748:Src/mpu6050.c ****         return -1;
 4312              		.loc 1 748 8 is_stmt 0 view .LVU1277
 4313 0000 2828     		cmp	r0, #40
 745:Src/mpu6050.c ****     unsigned char tmp[2];
 4314              		.loc 1 745 1 view .LVU1278
ARM GAS  /tmp/ccC60hwS.s 			page 135


 4315 0002 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4316              	.LCFI68:
 4317              		.cfi_def_cfa_offset 24
 4318              		.cfi_offset 4, -12
 4319              		.cfi_offset 5, -8
 4320              		.cfi_offset 14, -4
 745:Src/mpu6050.c ****     unsigned char tmp[2];
 4321              		.loc 1 745 1 view .LVU1279
 4322 0004 0446     		mov	r4, r0
 748:Src/mpu6050.c ****         return -1;
 4323              		.loc 1 748 8 view .LVU1280
 4324 0006 03D9     		bls	.L383
 4325              	.LVL272:
 4326              	.L386:
 749:Src/mpu6050.c **** 
 4327              		.loc 1 749 16 view .LVU1281
 4328 0008 4FF0FF30 		mov	r0, #-1
 4329              	.L382:
 820:Src/mpu6050.c **** 
 4330              		.loc 1 820 1 view .LVU1282
 4331 000c 03B0     		add	sp, sp, #12
 4332              	.LCFI69:
 4333              		.cfi_remember_state
 4334              		.cfi_def_cfa_offset 12
 4335              		@ sp needed
 4336 000e 30BD     		pop	{r4, r5, pc}
 4337              	.LVL273:
 4338              	.L383:
 4339              	.LCFI70:
 4340              		.cfi_restore_state
 751:Src/mpu6050.c ****         mpu_set_int_latched(0);
 4341              		.loc 1 751 5 is_stmt 1 view .LVU1283
 4342 0010 264D     		ldr	r5, .L393
 751:Src/mpu6050.c ****         mpu_set_int_latched(0);
 4343              		.loc 1 751 8 is_stmt 0 view .LVU1284
 4344 0012 90B9     		cbnz	r0, .L385
 752:Src/mpu6050.c ****         tmp[0] = 0;
 4345              		.loc 1 752 9 is_stmt 1 view .LVU1285
 4346 0014 FFF7FEFF 		bl	mpu_set_int_latched
 4347              	.LVL274:
 753:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 4348              		.loc 1 753 9 view .LVU1286
 755:Src/mpu6050.c ****             return -1;
 4349              		.loc 1 755 13 is_stmt 0 view .LVU1287
 4350 0018 D5E90010 		ldrd	r1, r0, [r5]
 754:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4351              		.loc 1 754 16 view .LVU1288
 4352 001c 0723     		movs	r3, #7
 753:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 4353              		.loc 1 753 16 view .LVU1289
 4354 001e 8DF80440 		strb	r4, [sp, #4]
 754:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4355              		.loc 1 754 9 is_stmt 1 view .LVU1290
 754:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4356              		.loc 1 754 16 is_stmt 0 view .LVU1291
 4357 0022 8DF80530 		strb	r3, [sp, #5]
 755:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 136


 4358              		.loc 1 755 9 is_stmt 1 view .LVU1292
 755:Src/mpu6050.c ****             return -1;
 4359              		.loc 1 755 13 is_stmt 0 view .LVU1293
 4360 0026 0222     		movs	r2, #2
 4361 0028 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4362 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4363 002c 01AB     		add	r3, sp, #4
 4364 002e FFF7FEFF 		bl	i2c_writeBytes
 4365              	.LVL275:
 755:Src/mpu6050.c ****             return -1;
 4366              		.loc 1 755 12 view .LVU1294
 4367 0032 0028     		cmp	r0, #0
 4368 0034 E8D1     		bne	.L386
 757:Src/mpu6050.c ****         return 0;
 4369              		.loc 1 757 9 is_stmt 1 view .LVU1295
 757:Src/mpu6050.c ****         return 0;
 4370              		.loc 1 757 35 is_stmt 0 view .LVU1296
 4371 0036 2875     		strb	r0, [r5, #20]
 758:Src/mpu6050.c ****     }
 4372              		.loc 1 758 9 is_stmt 1 view .LVU1297
 758:Src/mpu6050.c ****     }
 4373              		.loc 1 758 16 is_stmt 0 view .LVU1298
 4374 0038 E8E7     		b	.L382
 4375              	.LVL276:
 4376              	.L385:
 767:Src/mpu6050.c **** #if defined MPU6050
 4377              		.loc 1 767 5 is_stmt 1 view .LVU1299
 4378 003a 0120     		movs	r0, #1
 4379              	.LVL277:
 767:Src/mpu6050.c **** #if defined MPU6050
 4380              		.loc 1 767 5 is_stmt 0 view .LVU1300
 4381 003c FFF7FEFF 		bl	mpu_set_int_latched
 4382              	.LVL278:
 769:Src/mpu6050.c ****     if (rate == 1) {
 4383              		.loc 1 769 5 is_stmt 1 view .LVU1301
 769:Src/mpu6050.c ****     if (rate == 1) {
 4384              		.loc 1 769 12 is_stmt 0 view .LVU1302
 4385 0040 2023     		movs	r3, #32
 770:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4386              		.loc 1 770 8 view .LVU1303
 4387 0042 012C     		cmp	r4, #1
 769:Src/mpu6050.c ****     if (rate == 1) {
 4388              		.loc 1 769 12 view .LVU1304
 4389 0044 8DF80430 		strb	r3, [sp, #4]
 770:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4390              		.loc 1 770 5 is_stmt 1 view .LVU1305
 770:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4391              		.loc 1 770 8 is_stmt 0 view .LVU1306
 4392 0048 20D1     		bne	.L387
 771:Src/mpu6050.c ****         mpu_set_lpf(5);
 4393              		.loc 1 771 9 is_stmt 1 view .LVU1307
 771:Src/mpu6050.c ****         mpu_set_lpf(5);
 4394              		.loc 1 771 16 is_stmt 0 view .LVU1308
 4395 004a 0023     		movs	r3, #0
 4396              	.L392:
 775:Src/mpu6050.c ****     } else if (rate <= 20) {
 4397              		.loc 1 775 9 view .LVU1309
ARM GAS  /tmp/ccC60hwS.s 			page 137


 4398 004c 0520     		movs	r0, #5
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 4399              		.loc 1 774 16 view .LVU1310
 4400 004e 8DF80530 		strb	r3, [sp, #5]
 775:Src/mpu6050.c ****     } else if (rate <= 20) {
 4401              		.loc 1 775 9 is_stmt 1 view .LVU1311
 4402              	.L391:
 781:Src/mpu6050.c ****     }
 4403              		.loc 1 781 9 is_stmt 0 view .LVU1312
 4404 0052 FFF7FEFF 		bl	mpu_set_lpf
 4405              	.LVL279:
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4406              		.loc 1 783 5 is_stmt 1 view .LVU1313
 784:Src/mpu6050.c ****         return -1;
 4407              		.loc 1 784 9 is_stmt 0 view .LVU1314
 4408 0056 D5E90010 		ldrd	r1, r0, [r5]
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4409              		.loc 1 783 18 view .LVU1315
 4410 005a 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 784:Src/mpu6050.c ****         return -1;
 4411              		.loc 1 784 9 view .LVU1316
 4412 005e 0222     		movs	r2, #2
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4413              		.loc 1 783 22 view .LVU1317
 4414 0060 9B01     		lsls	r3, r3, #6
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4415              		.loc 1 783 28 view .LVU1318
 4416 0062 43F00703 		orr	r3, r3, #7
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4417              		.loc 1 783 12 view .LVU1319
 4418 0066 8DF80530 		strb	r3, [sp, #5]
 784:Src/mpu6050.c ****         return -1;
 4419              		.loc 1 784 5 is_stmt 1 view .LVU1320
 784:Src/mpu6050.c ****         return -1;
 4420              		.loc 1 784 9 is_stmt 0 view .LVU1321
 4421 006a 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4422 006c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4423 006e 01AB     		add	r3, sp, #4
 4424 0070 FFF7FEFF 		bl	i2c_writeBytes
 4425              	.LVL280:
 784:Src/mpu6050.c ****         return -1;
 4426              		.loc 1 784 8 view .LVU1322
 4427 0074 0446     		mov	r4, r0
 4428 0076 0028     		cmp	r0, #0
 4429 0078 C6D1     		bne	.L386
 814:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 4430              		.loc 1 814 5 is_stmt 1 view .LVU1323
 814:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 4431              		.loc 1 814 25 is_stmt 0 view .LVU1324
 4432 007a 0823     		movs	r3, #8
 4433 007c AB72     		strb	r3, [r5, #10]
 815:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 4434              		.loc 1 815 5 is_stmt 1 view .LVU1325
 816:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4435              		.loc 1 816 31 is_stmt 0 view .LVU1326
 4436 007e 0123     		movs	r3, #1
 815:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
ARM GAS  /tmp/ccC60hwS.s 			page 138


 4437              		.loc 1 815 25 view .LVU1327
 4438 0080 2873     		strb	r0, [r5, #12]
 816:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4439              		.loc 1 816 5 is_stmt 1 view .LVU1328
 816:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4440              		.loc 1 816 31 is_stmt 0 view .LVU1329
 4441 0082 2B75     		strb	r3, [r5, #20]
 817:Src/mpu6050.c **** 
 4442              		.loc 1 817 5 is_stmt 1 view .LVU1330
 4443 0084 FFF7FEFF 		bl	mpu_configure_fifo
 4444              	.LVL281:
 819:Src/mpu6050.c **** }
 4445              		.loc 1 819 5 view .LVU1331
 819:Src/mpu6050.c **** }
 4446              		.loc 1 819 12 is_stmt 0 view .LVU1332
 4447 0088 2046     		mov	r0, r4
 4448 008a BFE7     		b	.L382
 4449              	.L387:
 773:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 4450              		.loc 1 773 12 is_stmt 1 view .LVU1333
 773:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 4451              		.loc 1 773 15 is_stmt 0 view .LVU1334
 4452 008c 052C     		cmp	r4, #5
 4453 008e 01D8     		bhi	.L389
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 4454              		.loc 1 774 9 is_stmt 1 view .LVU1335
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 4455              		.loc 1 774 16 is_stmt 0 view .LVU1336
 4456 0090 0123     		movs	r3, #1
 4457 0092 DBE7     		b	.L392
 4458              	.L389:
 776:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 4459              		.loc 1 776 12 is_stmt 1 view .LVU1337
 776:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 4460              		.loc 1 776 15 is_stmt 0 view .LVU1338
 4461 0094 142C     		cmp	r4, #20
 777:Src/mpu6050.c ****         mpu_set_lpf(10);
 4462              		.loc 1 777 9 is_stmt 1 view .LVU1339
 777:Src/mpu6050.c ****         mpu_set_lpf(10);
 4463              		.loc 1 777 16 is_stmt 0 view .LVU1340
 4464 0096 95BF     		itete	ls
 4465 0098 0223     		movls	r3, #2
 780:Src/mpu6050.c ****         mpu_set_lpf(20);
 4466              		.loc 1 780 16 view .LVU1341
 4467 009a 0323     		movhi	r3, #3
 778:Src/mpu6050.c ****     } else {
 4468              		.loc 1 778 9 view .LVU1342
 4469 009c 0A20     		movls	r0, #10
 781:Src/mpu6050.c ****     }
 4470              		.loc 1 781 9 view .LVU1343
 4471 009e 1420     		movhi	r0, #20
 777:Src/mpu6050.c ****         mpu_set_lpf(10);
 4472              		.loc 1 777 16 view .LVU1344
 4473 00a0 94BF     		ite	ls
 4474 00a2 8DF80530 		strbls	r3, [sp, #5]
 778:Src/mpu6050.c ****     } else {
 4475              		.loc 1 778 9 is_stmt 1 view .LVU1345
ARM GAS  /tmp/ccC60hwS.s 			page 139


 780:Src/mpu6050.c ****         mpu_set_lpf(20);
 4476              		.loc 1 780 9 view .LVU1346
 780:Src/mpu6050.c ****         mpu_set_lpf(20);
 4477              		.loc 1 780 16 is_stmt 0 view .LVU1347
 4478 00a6 8DF80530 		strbhi	r3, [sp, #5]
 781:Src/mpu6050.c ****     }
 4479              		.loc 1 781 9 is_stmt 1 view .LVU1348
 4480 00aa D2E7     		b	.L391
 4481              	.L394:
 4482              		.align	2
 4483              	.L393:
 4484 00ac 00000000 		.word	.LANCHOR0
 4485              		.cfi_endproc
 4486              	.LFE63:
 4488              		.section	.text.mpu_set_sample_rate,"ax",%progbits
 4489              		.align	1
 4490              		.global	mpu_set_sample_rate
 4491              		.syntax unified
 4492              		.thumb
 4493              		.thumb_func
 4494              		.fpu softvfp
 4496              	mpu_set_sample_rate:
 4497              	.LVL282:
 4498              	.LFB81:
1336:Src/mpu6050.c ****     unsigned char data;
 4499              		.loc 1 1336 1 view -0
 4500              		.cfi_startproc
 4501              		@ args = 0, pretend = 0, frame = 8
 4502              		@ frame_needed = 0, uses_anonymous_args = 0
1337:Src/mpu6050.c **** 
 4503              		.loc 1 1337 5 view .LVU1350
1339:Src/mpu6050.c ****         return -1;
 4504              		.loc 1 1339 5 view .LVU1351
1336:Src/mpu6050.c ****     unsigned char data;
 4505              		.loc 1 1336 1 is_stmt 0 view .LVU1352
 4506 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 4507              	.LCFI71:
 4508              		.cfi_def_cfa_offset 32
 4509              		.cfi_offset 4, -20
 4510              		.cfi_offset 5, -16
 4511              		.cfi_offset 6, -12
 4512              		.cfi_offset 7, -8
 4513              		.cfi_offset 14, -4
1339:Src/mpu6050.c ****         return -1;
 4514              		.loc 1 1339 22 view .LVU1353
 4515 0002 1E4E     		ldr	r6, .L405
1336:Src/mpu6050.c ****     unsigned char data;
 4516              		.loc 1 1336 1 view .LVU1354
 4517 0004 0546     		mov	r5, r0
1339:Src/mpu6050.c ****         return -1;
 4518              		.loc 1 1339 8 view .LVU1355
 4519 0006 B37A     		ldrb	r3, [r6, #10]	@ zero_extendqisi2
 4520 0008 1BB9     		cbnz	r3, .L396
 4521              	.LVL283:
 4522              	.L398:
1340:Src/mpu6050.c **** 
 4523              		.loc 1 1340 16 view .LVU1356
ARM GAS  /tmp/ccC60hwS.s 			page 140


 4524 000a 4FF0FF30 		mov	r0, #-1
 4525              	.L395:
1375:Src/mpu6050.c **** 
 4526              		.loc 1 1375 1 view .LVU1357
 4527 000e 03B0     		add	sp, sp, #12
 4528              	.LCFI72:
 4529              		.cfi_remember_state
 4530              		.cfi_def_cfa_offset 20
 4531              		@ sp needed
 4532 0010 F0BD     		pop	{r4, r5, r6, r7, pc}
 4533              	.LVL284:
 4534              	.L396:
 4535              	.LCFI73:
 4536              		.cfi_restore_state
1342:Src/mpu6050.c ****         return -1;
 4537              		.loc 1 1342 5 is_stmt 1 view .LVU1358
1342:Src/mpu6050.c ****         return -1;
 4538              		.loc 1 1342 8 is_stmt 0 view .LVU1359
 4539 0012 96F82440 		ldrb	r4, [r6, #36]	@ zero_extendqisi2
 4540 0016 002C     		cmp	r4, #0
 4541 0018 F7D1     		bne	.L398
1345:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
 4542              		.loc 1 1345 9 is_stmt 1 view .LVU1360
1345:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
 4543              		.loc 1 1345 12 is_stmt 0 view .LVU1361
 4544 001a 337D     		ldrb	r3, [r6, #20]	@ zero_extendqisi2
 4545 001c 4BB1     		cbz	r3, .L399
1346:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
 4546              		.loc 1 1346 13 is_stmt 1 view .LVU1362
1346:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
 4547              		.loc 1 1346 16 is_stmt 0 view .LVU1363
 4548 001e 431E     		subs	r3, r0, #1
 4549 0020 272B     		cmp	r3, #39
 4550 0022 03D8     		bhi	.L400
1348:Src/mpu6050.c ****                 return 0;
 4551              		.loc 1 1348 17 is_stmt 1 view .LVU1364
 4552 0024 FFF7FEFF 		bl	mpu_lp_accel_mode
 4553              	.LVL285:
1349:Src/mpu6050.c ****             }
 4554              		.loc 1 1349 17 view .LVU1365
 4555              	.L404:
1373:Src/mpu6050.c ****     }
 4556              		.loc 1 1373 9 view .LVU1366
1373:Src/mpu6050.c ****     }
 4557              		.loc 1 1373 16 is_stmt 0 view .LVU1367
 4558 0028 2046     		mov	r0, r4
 4559 002a F0E7     		b	.L395
 4560              	.LVL286:
 4561              	.L400:
1354:Src/mpu6050.c ****         }
 4562              		.loc 1 1354 13 is_stmt 1 view .LVU1368
 4563 002c 2046     		mov	r0, r4
 4564              	.LVL287:
1354:Src/mpu6050.c ****         }
 4565              		.loc 1 1354 13 is_stmt 0 view .LVU1369
 4566 002e FFF7FEFF 		bl	mpu_lp_accel_mode
 4567              	.LVL288:
ARM GAS  /tmp/ccC60hwS.s 			page 141


 4568              	.L399:
1356:Src/mpu6050.c ****             rate = 4;
 4569              		.loc 1 1356 9 is_stmt 1 view .LVU1370
1362:Src/mpu6050.c ****             return -1;
 4570              		.loc 1 1362 13 is_stmt 0 view .LVU1371
 4571 0032 D6E90010 		ldrd	r1, r0, [r6]
 4572 0036 B5F57A7F 		cmp	r5, #1000
 4573 003a 28BF     		it	cs
 4574 003c 4FF47A75 		movcs	r5, #1000
 4575              	.LVL289:
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4576              		.loc 1 1361 9 is_stmt 1 view .LVU1372
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4577              		.loc 1 1361 21 is_stmt 0 view .LVU1373
 4578 0040 042D     		cmp	r5, #4
 4579 0042 38BF     		it	cc
 4580 0044 0425     		movcc	r5, #4
 4581              	.LVL290:
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4582              		.loc 1 1361 21 view .LVU1374
 4583 0046 4FF47A77 		mov	r7, #1000
 4584 004a B7FBF5F5 		udiv	r5, r7, r5
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4585              		.loc 1 1361 28 view .LVU1375
 4586 004e 013D     		subs	r5, r5, #1
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4587              		.loc 1 1361 14 view .LVU1376
 4588 0050 8DF80750 		strb	r5, [sp, #7]
1362:Src/mpu6050.c ****             return -1;
 4589              		.loc 1 1362 9 is_stmt 1 view .LVU1377
1362:Src/mpu6050.c ****             return -1;
 4590              		.loc 1 1362 13 is_stmt 0 view .LVU1378
 4591 0054 0122     		movs	r2, #1
 4592 0056 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4593 0058 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4594 005a 0DF10703 		add	r3, sp, #7
 4595 005e FFF7FEFF 		bl	i2c_writeBytes
 4596              	.LVL291:
1362:Src/mpu6050.c ****             return -1;
 4597              		.loc 1 1362 12 view .LVU1379
 4598 0062 0446     		mov	r4, r0
 4599 0064 0028     		cmp	r0, #0
 4600 0066 D0D1     		bne	.L398
1365:Src/mpu6050.c **** 
 4601              		.loc 1 1365 9 is_stmt 1 view .LVU1380
1365:Src/mpu6050.c **** 
 4602              		.loc 1 1365 45 is_stmt 0 view .LVU1381
 4603 0068 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 4604 006c 0130     		adds	r0, r0, #1
1365:Src/mpu6050.c **** 
 4605              		.loc 1 1365 33 view .LVU1382
 4606 006e B7FBF0F0 		udiv	r0, r7, r0
 4607 0072 F081     		strh	r0, [r6, #14]	@ movhi
1372:Src/mpu6050.c ****         return 0;
 4608              		.loc 1 1372 9 is_stmt 1 view .LVU1383
 4609 0074 4008     		lsrs	r0, r0, #1
 4610 0076 FFF7FEFF 		bl	mpu_set_lpf
ARM GAS  /tmp/ccC60hwS.s 			page 142


 4611              	.LVL292:
 4612 007a D5E7     		b	.L404
 4613              	.L406:
 4614              		.align	2
 4615              	.L405:
 4616 007c 00000000 		.word	.LANCHOR0
 4617              		.cfi_endproc
 4618              	.LFE81:
 4620              		.section	.text.mpu_set_sensors,"ax",%progbits
 4621              		.align	1
 4622              		.global	mpu_set_sensors
 4623              		.syntax unified
 4624              		.thumb
 4625              		.thumb_func
 4626              		.fpu softvfp
 4628              	mpu_set_sensors:
 4629              	.LVL293:
 4630              	.LFB89:
1561:Src/mpu6050.c ****     unsigned char data;
 4631              		.loc 1 1561 1 view -0
 4632              		.cfi_startproc
 4633              		@ args = 0, pretend = 0, frame = 8
 4634              		@ frame_needed = 0, uses_anonymous_args = 0
1562:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4635              		.loc 1 1562 5 view .LVU1385
1567:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4636              		.loc 1 1567 5 view .LVU1386
1567:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4637              		.loc 1 1567 8 is_stmt 0 view .LVU1387
 4638 0000 10F07003 		ands	r3, r0, #112
1561:Src/mpu6050.c ****     unsigned char data;
 4639              		.loc 1 1561 1 view .LVU1388
 4640 0004 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4641              	.LCFI74:
 4642              		.cfi_def_cfa_offset 24
 4643              		.cfi_offset 4, -12
 4644              		.cfi_offset 5, -8
 4645              		.cfi_offset 14, -4
1561:Src/mpu6050.c ****     unsigned char data;
 4646              		.loc 1 1561 1 view .LVU1389
 4647 0006 0446     		mov	r4, r0
1567:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4648              		.loc 1 1567 8 view .LVU1390
 4649 0008 13D0     		beq	.L408
1568:Src/mpu6050.c ****     else if (sensors)
 4650              		.loc 1 1568 9 is_stmt 1 view .LVU1391
1568:Src/mpu6050.c ****     else if (sensors)
 4651              		.loc 1 1568 14 is_stmt 0 view .LVU1392
 4652 000a 0123     		movs	r3, #1
 4653              	.L423:
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4654              		.loc 1 1573 34 view .LVU1393
 4655 000c 2B4D     		ldr	r5, .L424
1572:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4656              		.loc 1 1572 14 view .LVU1394
 4657 000e 8DF80730 		strb	r3, [sp, #7]
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
ARM GAS  /tmp/ccC60hwS.s 			page 143


 4658              		.loc 1 1573 5 is_stmt 1 view .LVU1395
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4659              		.loc 1 1573 9 is_stmt 0 view .LVU1396
 4660 0012 D5E90010 		ldrd	r1, r0, [r5]
 4661              	.LVL294:
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4662              		.loc 1 1573 9 view .LVU1397
 4663 0016 0122     		movs	r2, #1
 4664 0018 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4665 001a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4666 001c 0DF10703 		add	r3, sp, #7
 4667 0020 FFF7FEFF 		bl	i2c_writeBytes
 4668              	.LVL295:
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4669              		.loc 1 1573 8 view .LVU1398
 4670 0024 48B1     		cbz	r0, .L411
 4671              	.L418:
1574:Src/mpu6050.c ****         return -1;
 4672              		.loc 1 1574 9 is_stmt 1 view .LVU1399
1574:Src/mpu6050.c ****         return -1;
 4673              		.loc 1 1574 29 is_stmt 0 view .LVU1400
 4674 0026 0023     		movs	r3, #0
1575:Src/mpu6050.c ****     }
 4675              		.loc 1 1575 16 view .LVU1401
 4676 0028 4FF0FF30 		mov	r0, #-1
1574:Src/mpu6050.c ****         return -1;
 4677              		.loc 1 1574 29 view .LVU1402
 4678 002c AB72     		strb	r3, [r5, #10]
1575:Src/mpu6050.c ****     }
 4679              		.loc 1 1575 9 is_stmt 1 view .LVU1403
 4680              	.L407:
1630:Src/mpu6050.c **** 
 4681              		.loc 1 1630 1 is_stmt 0 view .LVU1404
 4682 002e 03B0     		add	sp, sp, #12
 4683              	.LCFI75:
 4684              		.cfi_remember_state
 4685              		.cfi_def_cfa_offset 12
 4686              		@ sp needed
 4687 0030 30BD     		pop	{r4, r5, pc}
 4688              	.LVL296:
 4689              	.L408:
 4690              	.LCFI76:
 4691              		.cfi_restore_state
1569:Src/mpu6050.c ****         data = 0;
 4692              		.loc 1 1569 10 is_stmt 1 view .LVU1405
1569:Src/mpu6050.c ****         data = 0;
 4693              		.loc 1 1569 13 is_stmt 0 view .LVU1406
 4694 0032 0028     		cmp	r0, #0
 4695 0034 EAD1     		bne	.L423
1572:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4696              		.loc 1 1572 9 is_stmt 1 view .LVU1407
1572:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4697              		.loc 1 1572 14 is_stmt 0 view .LVU1408
 4698 0036 4023     		movs	r3, #64
 4699 0038 E8E7     		b	.L423
 4700              	.LVL297:
 4701              	.L411:
ARM GAS  /tmp/ccC60hwS.s 			page 144


1577:Src/mpu6050.c **** 
 4702              		.loc 1 1577 5 is_stmt 1 view .LVU1409
1577:Src/mpu6050.c **** 
 4703              		.loc 1 1577 32 is_stmt 0 view .LVU1410
 4704 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4705 003e 23F04003 		bic	r3, r3, #64
1577:Src/mpu6050.c **** 
 4706              		.loc 1 1577 25 view .LVU1411
 4707 0042 2B73     		strb	r3, [r5, #12]
1579:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
 4708              		.loc 1 1579 5 is_stmt 1 view .LVU1412
1580:Src/mpu6050.c ****         data |= BIT_STBY_XG;
 4709              		.loc 1 1580 5 view .LVU1413
1580:Src/mpu6050.c ****         data |= BIT_STBY_XG;
 4710              		.loc 1 1580 8 is_stmt 0 view .LVU1414
 4711 0044 6306     		lsls	r3, r4, #25
1581:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4712              		.loc 1 1581 14 view .LVU1415
 4713 0046 56BF     		itet	pl
 4714 0048 0423     		movpl	r3, #4
1579:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
 4715              		.loc 1 1579 10 view .LVU1416
 4716 004a 8DF80700 		strbmi	r0, [sp, #7]
1581:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4717              		.loc 1 1581 9 is_stmt 1 view .LVU1417
1581:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4718              		.loc 1 1581 14 is_stmt 0 view .LVU1418
 4719 004e 8DF80730 		strbpl	r3, [sp, #7]
1582:Src/mpu6050.c ****         data |= BIT_STBY_YG;
 4720              		.loc 1 1582 5 is_stmt 1 view .LVU1419
1582:Src/mpu6050.c ****         data |= BIT_STBY_YG;
 4721              		.loc 1 1582 8 is_stmt 0 view .LVU1420
 4722 0052 A106     		lsls	r1, r4, #26
1583:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4723              		.loc 1 1583 9 is_stmt 1 view .LVU1421
1583:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4724              		.loc 1 1583 14 is_stmt 0 view .LVU1422
 4725 0054 58BF     		it	pl
 4726 0056 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4727              		.loc 1 1588 9 view .LVU1423
 4728 005a D5E90010 		ldrd	r1, r0, [r5]
1583:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4729              		.loc 1 1583 14 view .LVU1424
 4730 005e 5CBF     		itt	pl
 4731 0060 43F00203 		orrpl	r3, r3, #2
 4732 0064 8DF80730 		strbpl	r3, [sp, #7]
1584:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
 4733              		.loc 1 1584 5 is_stmt 1 view .LVU1425
1584:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
 4734              		.loc 1 1584 8 is_stmt 0 view .LVU1426
 4735 0068 E206     		lsls	r2, r4, #27
1585:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4736              		.loc 1 1585 9 is_stmt 1 view .LVU1427
1585:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4737              		.loc 1 1585 14 is_stmt 0 view .LVU1428
 4738 006a 58BF     		it	pl
ARM GAS  /tmp/ccC60hwS.s 			page 145


 4739 006c 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4740              		.loc 1 1588 9 view .LVU1429
 4741 0070 4FF00102 		mov	r2, #1
1585:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4742              		.loc 1 1585 14 view .LVU1430
 4743 0074 5CBF     		itt	pl
 4744 0076 43F00103 		orrpl	r3, r3, #1
 4745 007a 8DF80730 		strbpl	r3, [sp, #7]
1586:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
 4746              		.loc 1 1586 5 is_stmt 1 view .LVU1431
1586:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
 4747              		.loc 1 1586 8 is_stmt 0 view .LVU1432
 4748 007e 2307     		lsls	r3, r4, #28
1587:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4749              		.loc 1 1587 9 is_stmt 1 view .LVU1433
1587:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4750              		.loc 1 1587 14 is_stmt 0 view .LVU1434
 4751 0080 58BF     		it	pl
 4752 0082 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4753              		.loc 1 1588 9 view .LVU1435
 4754 0086 897D     		ldrb	r1, [r1, #22]	@ zero_extendqisi2
1587:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4755              		.loc 1 1587 14 view .LVU1436
 4756 0088 5CBF     		itt	pl
 4757 008a 43F03803 		orrpl	r3, r3, #56
 4758 008e 8DF80730 		strbpl	r3, [sp, #7]
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4759              		.loc 1 1588 5 is_stmt 1 view .LVU1437
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4760              		.loc 1 1588 9 is_stmt 0 view .LVU1438
 4761 0092 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4762 0094 0DF10703 		add	r3, sp, #7
 4763 0098 FFF7FEFF 		bl	i2c_writeBytes
 4764              	.LVL298:
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4765              		.loc 1 1588 8 view .LVU1439
 4766 009c 0028     		cmp	r0, #0
 4767 009e C2D1     		bne	.L418
1593:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
 4768              		.loc 1 1593 5 is_stmt 1 view .LVU1440
1593:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
 4769              		.loc 1 1593 8 is_stmt 0 view .LVU1441
 4770 00a0 14F0F70F 		tst	r4, #247
 4771 00a4 01D0     		beq	.L419
1595:Src/mpu6050.c **** 
 4772              		.loc 1 1595 9 is_stmt 1 view .LVU1442
 4773 00a6 FFF7FEFF 		bl	mpu_set_int_latched
 4774              	.LVL299:
 4775              	.L419:
1626:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4776              		.loc 1 1626 5 view .LVU1443
1626:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4777              		.loc 1 1626 25 is_stmt 0 view .LVU1444
 4778 00aa AC72     		strb	r4, [r5, #10]
1627:Src/mpu6050.c ****     delay_ms(50);
ARM GAS  /tmp/ccC60hwS.s 			page 146


 4779              		.loc 1 1627 5 is_stmt 1 view .LVU1445
1627:Src/mpu6050.c ****     delay_ms(50);
 4780              		.loc 1 1627 31 is_stmt 0 view .LVU1446
 4781 00ac 0024     		movs	r4, #0
1628:Src/mpu6050.c ****     return 0;
 4782              		.loc 1 1628 5 view .LVU1447
 4783 00ae 3220     		movs	r0, #50
1627:Src/mpu6050.c ****     delay_ms(50);
 4784              		.loc 1 1627 31 view .LVU1448
 4785 00b0 2C75     		strb	r4, [r5, #20]
1628:Src/mpu6050.c ****     return 0;
 4786              		.loc 1 1628 5 is_stmt 1 view .LVU1449
 4787 00b2 FFF7FEFF 		bl	delay_1ms
 4788              	.LVL300:
1629:Src/mpu6050.c **** }
 4789              		.loc 1 1629 5 view .LVU1450
1629:Src/mpu6050.c **** }
 4790              		.loc 1 1629 12 is_stmt 0 view .LVU1451
 4791 00b6 2046     		mov	r0, r4
 4792 00b8 B9E7     		b	.L407
 4793              	.L425:
 4794 00ba 00BF     		.align	2
 4795              	.L424:
 4796 00bc 00000000 		.word	.LANCHOR0
 4797              		.cfi_endproc
 4798              	.LFE89:
 4800              		.section	.text.mpu_init,"ax",%progbits
 4801              		.align	1
 4802              		.global	mpu_init
 4803              		.syntax unified
 4804              		.thumb
 4805              		.thumb_func
 4806              		.fpu softvfp
 4808              	mpu_init:
 4809              	.LFB62:
 656:Src/mpu6050.c ****     unsigned char data[6];
 4810              		.loc 1 656 1 is_stmt 1 view -0
 4811              		.cfi_startproc
 4812              		@ args = 0, pretend = 0, frame = 8
 4813              		@ frame_needed = 0, uses_anonymous_args = 0
 657:Src/mpu6050.c **** 
 4814              		.loc 1 657 5 view .LVU1453
 660:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4815              		.loc 1 660 5 view .LVU1454
 660:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4816              		.loc 1 660 13 is_stmt 0 view .LVU1455
 4817 0000 8023     		movs	r3, #128
 656:Src/mpu6050.c ****     unsigned char data[6];
 4818              		.loc 1 656 1 view .LVU1456
 4819 0002 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4820              	.LCFI77:
 4821              		.cfi_def_cfa_offset 24
 4822              		.cfi_offset 4, -12
 4823              		.cfi_offset 5, -8
 4824              		.cfi_offset 14, -4
 661:Src/mpu6050.c ****         return -1;
 4825              		.loc 1 661 34 view .LVU1457
ARM GAS  /tmp/ccC60hwS.s 			page 147


 4826 0004 2A4C     		ldr	r4, .L430
 660:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4827              		.loc 1 660 13 view .LVU1458
 4828 0006 8DF80030 		strb	r3, [sp]
 661:Src/mpu6050.c ****         return -1;
 4829              		.loc 1 661 5 is_stmt 1 view .LVU1459
 661:Src/mpu6050.c ****         return -1;
 4830              		.loc 1 661 9 is_stmt 0 view .LVU1460
 4831 000a D4E90010 		ldrd	r1, r0, [r4]
 4832 000e 6B46     		mov	r3, sp
 4833 0010 0122     		movs	r2, #1
 4834 0012 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4835 0014 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4836 0016 FFF7FEFF 		bl	i2c_writeBytes
 4837              	.LVL301:
 661:Src/mpu6050.c ****         return -1;
 4838              		.loc 1 661 8 view .LVU1461
 4839 001a 0546     		mov	r5, r0
 4840 001c 20B1     		cbz	r0, .L427
 4841              	.L429:
 662:Src/mpu6050.c ****     delay_ms(100);
 4842              		.loc 1 662 16 view .LVU1462
 4843 001e 4FF0FF34 		mov	r4, #-1
 4844              	.L426:
 727:Src/mpu6050.c **** 
 4845              		.loc 1 727 1 view .LVU1463
 4846 0022 2046     		mov	r0, r4
 4847 0024 03B0     		add	sp, sp, #12
 4848              	.LCFI78:
 4849              		.cfi_remember_state
 4850              		.cfi_def_cfa_offset 12
 4851              		@ sp needed
 4852 0026 30BD     		pop	{r4, r5, pc}
 4853              	.L427:
 4854              	.LCFI79:
 4855              		.cfi_restore_state
 663:Src/mpu6050.c **** 
 4856              		.loc 1 663 5 is_stmt 1 view .LVU1464
 4857 0028 6420     		movs	r0, #100
 4858 002a FFF7FEFF 		bl	delay_1ms
 4859              	.LVL302:
 666:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4860              		.loc 1 666 5 view .LVU1465
 667:Src/mpu6050.c ****         return -1;
 4861              		.loc 1 667 9 is_stmt 0 view .LVU1466
 4862 002e D4E90010 		ldrd	r1, r0, [r4]
 666:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4863              		.loc 1 666 13 view .LVU1467
 4864 0032 8DF80050 		strb	r5, [sp]
 667:Src/mpu6050.c ****         return -1;
 4865              		.loc 1 667 5 is_stmt 1 view .LVU1468
 667:Src/mpu6050.c ****         return -1;
 4866              		.loc 1 667 9 is_stmt 0 view .LVU1469
 4867 0036 6B46     		mov	r3, sp
 4868 0038 0122     		movs	r2, #1
 4869 003a 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4870 003c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 148


 4871 003e FFF7FEFF 		bl	i2c_writeBytes
 4872              	.LVL303:
 667:Src/mpu6050.c ****         return -1;
 4873              		.loc 1 667 8 view .LVU1470
 4874 0042 0028     		cmp	r0, #0
 4875 0044 EBD1     		bne	.L429
 670:Src/mpu6050.c **** 
 4876              		.loc 1 670 4 is_stmt 1 view .LVU1471
 682:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 4877              		.loc 1 682 5 view .LVU1472
 683:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 4878              		.loc 1 683 5 view .LVU1473
 684:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 4879              		.loc 1 684 5 view .LVU1474
 685:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 4880              		.loc 1 685 5 view .LVU1475
 686:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 4881              		.loc 1 686 5 view .LVU1476
 686:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 4882              		.loc 1 686 29 is_stmt 0 view .LVU1477
 4883 0046 4FF6FF73 		movw	r3, #65535
 4884 004a E381     		strh	r3, [r4, #14]	@ movhi
 687:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 4885              		.loc 1 687 5 is_stmt 1 view .LVU1478
 687:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 4886              		.loc 1 687 29 is_stmt 0 view .LVU1479
 4887 004c 2374     		strb	r3, [r4, #16]
 688:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4888              		.loc 1 688 5 is_stmt 1 view .LVU1480
 693:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 4889              		.loc 1 693 5 view .LVU1481
 683:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 4890              		.loc 1 683 26 is_stmt 0 view .LVU1482
 4891 004e 4FF0FF33 		mov	r3, #-1
 688:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4892              		.loc 1 688 29 view .LVU1483
 4893 0052 FF22     		movs	r2, #255
 683:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 4894              		.loc 1 683 26 view .LVU1484
 4895 0054 A360     		str	r3, [r4, #8]
 693:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 4896              		.loc 1 693 25 view .LVU1485
 4897 0056 0123     		movs	r3, #1
 698:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 4898              		.loc 1 698 31 view .LVU1486
 4899 0058 A082     		strh	r0, [r4, #20]	@ movhi
 699:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 4900              		.loc 1 699 5 view .LVU1487
 4901 005a C4F81600 		str	r0, [r4, #22]	@ unaligned
 4902 005e C4F81A00 		str	r0, [r4, #26]	@ unaligned
 4903 0062 C4F81E00 		str	r0, [r4, #30]	@ unaligned
 700:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 4904              		.loc 1 700 24 view .LVU1488
 4905 0066 6062     		str	r0, [r4, #36]
 688:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4906              		.loc 1 688 29 view .LVU1489
 4907 0068 6282     		strh	r2, [r4, #18]	@ movhi
ARM GAS  /tmp/ccC60hwS.s 			page 149


 704:Src/mpu6050.c ****         return -1;
 4908              		.loc 1 704 9 view .LVU1490
 4909 006a 4FF4FA60 		mov	r0, #2000
 695:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 4910              		.loc 1 695 32 view .LVU1491
 4911 006e 6384     		strh	r3, [r4, #34]	@ movhi
 693:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 4912              		.loc 1 693 25 view .LVU1492
 4913 0070 2373     		strb	r3, [r4, #12]
 695:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 4914              		.loc 1 695 5 is_stmt 1 view .LVU1493
 696:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 4915              		.loc 1 696 5 view .LVU1494
 697:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4916              		.loc 1 697 5 view .LVU1495
 698:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 4917              		.loc 1 698 5 view .LVU1496
 699:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 4918              		.loc 1 699 5 view .LVU1497
 700:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 4919              		.loc 1 700 5 view .LVU1498
 701:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = 0;
 4920              		.loc 1 701 5 view .LVU1499
 702:Src/mpu6050.c **** 
 4921              		.loc 1 702 5 view .LVU1500
 704:Src/mpu6050.c ****         return -1;
 4922              		.loc 1 704 5 view .LVU1501
 704:Src/mpu6050.c ****         return -1;
 4923              		.loc 1 704 9 is_stmt 0 view .LVU1502
 4924 0072 FFF7FEFF 		bl	mpu_set_gyro_fsr
 4925              	.LVL304:
 704:Src/mpu6050.c ****         return -1;
 4926              		.loc 1 704 8 view .LVU1503
 4927 0076 0028     		cmp	r0, #0
 4928 0078 D1D1     		bne	.L429
 706:Src/mpu6050.c ****         return -1;
 4929              		.loc 1 706 5 is_stmt 1 view .LVU1504
 706:Src/mpu6050.c ****         return -1;
 4930              		.loc 1 706 9 is_stmt 0 view .LVU1505
 4931 007a 0220     		movs	r0, #2
 4932 007c FFF7FEFF 		bl	mpu_set_accel_fsr
 4933              	.LVL305:
 706:Src/mpu6050.c ****         return -1;
 4934              		.loc 1 706 8 view .LVU1506
 4935 0080 0028     		cmp	r0, #0
 4936 0082 CCD1     		bne	.L429
 708:Src/mpu6050.c ****         return -1;
 4937              		.loc 1 708 5 is_stmt 1 view .LVU1507
 708:Src/mpu6050.c ****         return -1;
 4938              		.loc 1 708 9 is_stmt 0 view .LVU1508
 4939 0084 2A20     		movs	r0, #42
 4940 0086 FFF7FEFF 		bl	mpu_set_lpf
 4941              	.LVL306:
 708:Src/mpu6050.c ****         return -1;
 4942              		.loc 1 708 8 view .LVU1509
 4943 008a 0028     		cmp	r0, #0
 4944 008c C7D1     		bne	.L429
ARM GAS  /tmp/ccC60hwS.s 			page 150


 710:Src/mpu6050.c ****         return -1;
 4945              		.loc 1 710 5 is_stmt 1 view .LVU1510
 710:Src/mpu6050.c ****         return -1;
 4946              		.loc 1 710 9 is_stmt 0 view .LVU1511
 4947 008e 3220     		movs	r0, #50
 4948 0090 FFF7FEFF 		bl	mpu_set_sample_rate
 4949              	.LVL307:
 710:Src/mpu6050.c ****         return -1;
 4950              		.loc 1 710 8 view .LVU1512
 4951 0094 0028     		cmp	r0, #0
 4952 0096 C2D1     		bne	.L429
 712:Src/mpu6050.c ****         return -1;
 4953              		.loc 1 712 5 is_stmt 1 view .LVU1513
 712:Src/mpu6050.c ****         return -1;
 4954              		.loc 1 712 9 is_stmt 0 view .LVU1514
 4955 0098 FFF7FEFF 		bl	mpu_configure_fifo
 4956              	.LVL308:
 712:Src/mpu6050.c ****         return -1;
 4957              		.loc 1 712 8 view .LVU1515
 4958 009c 0028     		cmp	r0, #0
 4959 009e BED1     		bne	.L429
 721:Src/mpu6050.c ****         return -1;
 4960              		.loc 1 721 5 is_stmt 1 view .LVU1516
 721:Src/mpu6050.c ****         return -1;
 4961              		.loc 1 721 9 is_stmt 0 view .LVU1517
 4962 00a0 FFF7FEFF 		bl	mpu_set_bypass
 4963              	.LVL309:
 721:Src/mpu6050.c ****         return -1;
 4964              		.loc 1 721 8 view .LVU1518
 4965 00a4 0446     		mov	r4, r0
 4966 00a6 0028     		cmp	r0, #0
 4967 00a8 B9D1     		bne	.L429
 725:Src/mpu6050.c ****     return 0;
 4968              		.loc 1 725 5 is_stmt 1 view .LVU1519
 4969 00aa FFF7FEFF 		bl	mpu_set_sensors
 4970              	.LVL310:
 726:Src/mpu6050.c **** }
 4971              		.loc 1 726 5 view .LVU1520
 726:Src/mpu6050.c **** }
 4972              		.loc 1 726 12 is_stmt 0 view .LVU1521
 4973 00ae B8E7     		b	.L426
 4974              	.L431:
 4975              		.align	2
 4976              	.L430:
 4977 00b0 00000000 		.word	.LANCHOR0
 4978              		.cfi_endproc
 4979              	.LFE62:
 4981              		.section	.text.mpu_write_mem,"ax",%progbits
 4982              		.align	1
 4983              		.global	mpu_write_mem
 4984              		.syntax unified
 4985              		.thumb
 4986              		.thumb_func
 4987              		.fpu softvfp
 4989              	mpu_write_mem:
 4990              	.LVL311:
 4991              	.LFB101:
ARM GAS  /tmp/ccC60hwS.s 			page 151


2129:Src/mpu6050.c **** 
2130:Src/mpu6050.c **** #ifdef MPU6500
2131:Src/mpu6050.c **** #define REG_6500_XG_ST_DATA     0x0
2132:Src/mpu6050.c **** #define REG_6500_XA_ST_DATA     0xD
2133:Src/mpu6050.c **** static const unsigned short mpu_6500_st_tb[256] = {
2134:Src/mpu6050.c ****     2620,2646,2672,2699,2726,2753,2781,2808, //7
2135:Src/mpu6050.c ****     2837,2865,2894,2923,2952,2981,3011,3041, //15
2136:Src/mpu6050.c ****     3072,3102,3133,3165,3196,3228,3261,3293, //23
2137:Src/mpu6050.c ****     3326,3359,3393,3427,3461,3496,3531,3566, //31
2138:Src/mpu6050.c ****     3602,3638,3674,3711,3748,3786,3823,3862, //39
2139:Src/mpu6050.c ****     3900,3939,3979,4019,4059,4099,4140,4182, //47
2140:Src/mpu6050.c ****     4224,4266,4308,4352,4395,4439,4483,4528, //55
2141:Src/mpu6050.c ****     4574,4619,4665,4712,4759,4807,4855,4903, //63
2142:Src/mpu6050.c ****     4953,5002,5052,5103,5154,5205,5257,5310, //71
2143:Src/mpu6050.c ****     5363,5417,5471,5525,5581,5636,5693,5750, //79
2144:Src/mpu6050.c ****     5807,5865,5924,5983,6043,6104,6165,6226, //87
2145:Src/mpu6050.c ****     6289,6351,6415,6479,6544,6609,6675,6742, //95
2146:Src/mpu6050.c ****     6810,6878,6946,7016,7086,7157,7229,7301, //103
2147:Src/mpu6050.c ****     7374,7448,7522,7597,7673,7750,7828,7906, //111
2148:Src/mpu6050.c ****     7985,8065,8145,8227,8309,8392,8476,8561, //119
2149:Src/mpu6050.c ****     8647,8733,8820,8909,8998,9088,9178,9270,
2150:Src/mpu6050.c ****     9363,9457,9551,9647,9743,9841,9939,10038,
2151:Src/mpu6050.c ****     10139,10240,10343,10446,10550,10656,10763,10870,
2152:Src/mpu6050.c ****     10979,11089,11200,11312,11425,11539,11654,11771,
2153:Src/mpu6050.c ****     11889,12008,12128,12249,12371,12495,12620,12746,
2154:Src/mpu6050.c ****     12874,13002,13132,13264,13396,13530,13666,13802,
2155:Src/mpu6050.c ****     13940,14080,14221,14363,14506,14652,14798,14946,
2156:Src/mpu6050.c ****     15096,15247,15399,15553,15709,15866,16024,16184,
2157:Src/mpu6050.c ****     16346,16510,16675,16842,17010,17180,17352,17526,
2158:Src/mpu6050.c ****     17701,17878,18057,18237,18420,18604,18790,18978,
2159:Src/mpu6050.c ****     19167,19359,19553,19748,19946,20145,20347,20550,
2160:Src/mpu6050.c ****     20756,20963,21173,21385,21598,21814,22033,22253,
2161:Src/mpu6050.c ****     22475,22700,22927,23156,23388,23622,23858,24097,
2162:Src/mpu6050.c ****     24338,24581,24827,25075,25326,25579,25835,26093,
2163:Src/mpu6050.c ****     26354,26618,26884,27153,27424,27699,27976,28255,
2164:Src/mpu6050.c ****     28538,28823,29112,29403,29697,29994,30294,30597,
2165:Src/mpu6050.c ****     30903,31212,31524,31839,32157,32479,32804,33132
2166:Src/mpu6050.c **** };
2167:Src/mpu6050.c **** static int accel_6500_self_test(long *bias_regular, long *bias_st, int debug)
2168:Src/mpu6050.c **** {
2169:Src/mpu6050.c ****     int i, result = 0, otp_value_zero = 0;
2170:Src/mpu6050.c ****     float accel_st_al_min, accel_st_al_max;
2171:Src/mpu6050.c ****     float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], accel_offset_max;
2172:Src/mpu6050.c ****     unsigned char regs[3];
2173:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, REG_6500_XA_ST_DATA, 3, regs)) {
2174:Src/mpu6050.c ****         if(debug)
2175:Src/mpu6050.c ****             log_i("Reading OTP Register Error\r\n");
2176:Src/mpu6050.c ****         return 0x07;
2177:Src/mpu6050.c ****     }
2178:Src/mpu6050.c ****     if(debug)
2179:Src/mpu6050.c ****         log_i("Accel OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
2180:Src/mpu6050.c ****     for (i = 0; i < 3; i++) {
2181:Src/mpu6050.c ****         if (regs[i] != 0) {
2182:Src/mpu6050.c ****             ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
2183:Src/mpu6050.c ****             ct_shift_prod[i] *= 65536.f;
2184:Src/mpu6050.c ****             ct_shift_prod[i] /= test.accel_sens;
2185:Src/mpu6050.c ****         }
ARM GAS  /tmp/ccC60hwS.s 			page 152


2186:Src/mpu6050.c ****         else {
2187:Src/mpu6050.c ****             ct_shift_prod[i] = 0;
2188:Src/mpu6050.c ****             otp_value_zero = 1;
2189:Src/mpu6050.c ****         }
2190:Src/mpu6050.c ****     }
2191:Src/mpu6050.c ****     if(otp_value_zero == 0) {
2192:Src/mpu6050.c ****         if(debug)
2193:Src/mpu6050.c ****             log_i("ACCEL:CRITERIA A\r\n");
2194:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2195:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2196:Src/mpu6050.c ****             if(debug) {
2197:Src/mpu6050.c ****                 log_i("Bias_Shift=%ld, Bias_Reg=%ld, Bias_HWST=%ld\r\n",
2198:Src/mpu6050.c ****                         (long)st_shift_cust[i], bias_regular[i],
2199:Src/mpu6050.c ****                         bias_st[i]);
2200:Src/mpu6050.c ****                 log_i("OTP value: %ld\r\n", (long)ct_shift_prod[i]);
2201:Src/mpu6050.c ****             }
2202:Src/mpu6050.c **** 
2203:Src/mpu6050.c ****             st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i] - 1.f;
2204:Src/mpu6050.c **** 
2205:Src/mpu6050.c ****             if(debug)
2206:Src/mpu6050.c ****                 log_i("ratio=%ld, threshold=%ld\r\n", (long)st_shift_ratio[i],
2207:Src/mpu6050.c ****                             (long)test.max_accel_var);
2208:Src/mpu6050.c **** 
2209:Src/mpu6050.c ****             if (fabs(st_shift_ratio[i]) > test.max_accel_var) {
2210:Src/mpu6050.c ****                 if(debug)
2211:Src/mpu6050.c ****                     log_i("ACCEL Fail Axis = %d\r\n", i);
2212:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2213:Src/mpu6050.c ****             }
2214:Src/mpu6050.c ****         }
2215:Src/mpu6050.c ****     }
2216:Src/mpu6050.c ****     else {
2217:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria B */
2218:Src/mpu6050.c ****         accel_st_al_min = test.min_g * 65536.f;
2219:Src/mpu6050.c ****         accel_st_al_max = test.max_g * 65536.f;
2220:Src/mpu6050.c **** 
2221:Src/mpu6050.c ****         if(debug) {
2222:Src/mpu6050.c ****             log_i("ACCEL:CRITERIA B\r\n");
2223:Src/mpu6050.c ****             log_i("Min MG: %ld\r\n", (long)accel_st_al_min);
2224:Src/mpu6050.c ****             log_i("Max MG: %ld\r\n", (long)accel_st_al_max);
2225:Src/mpu6050.c ****         }
2226:Src/mpu6050.c **** 
2227:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2228:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2229:Src/mpu6050.c **** 
2230:Src/mpu6050.c ****             if(debug)
2231:Src/mpu6050.c ****                 log_i("Bias_shift=%ld, st=%ld, reg=%ld\r\n", (long)st_shift_cust[i], bias_st[i], bi
2232:Src/mpu6050.c ****             if(st_shift_cust[i] < accel_st_al_min || st_shift_cust[i] > accel_st_al_max) {
2233:Src/mpu6050.c ****                 if(debug)
2234:Src/mpu6050.c ****                     log_i("Accel FAIL axis:%d <= 225mg or >= 675mg\r\n", i);
2235:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2236:Src/mpu6050.c ****             }
2237:Src/mpu6050.c ****         }
2238:Src/mpu6050.c ****     }
2239:Src/mpu6050.c **** 
2240:Src/mpu6050.c ****     if(result == 0) {
2241:Src/mpu6050.c ****     /* Self Test Pass/Fail Criteria C */
2242:Src/mpu6050.c ****         accel_offset_max = test.max_g_offset * 65536.f;
ARM GAS  /tmp/ccC60hwS.s 			page 153


2243:Src/mpu6050.c ****         if(debug)
2244:Src/mpu6050.c ****             log_i("Accel:CRITERIA C: bias less than %ld\n", (long)accel_offset_max);
2245:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2246:Src/mpu6050.c ****             if(fabs(bias_regular[i]) > accel_offset_max) {
2247:Src/mpu6050.c ****                 if(debug)
2248:Src/mpu6050.c ****                     log_i("FAILED: Accel axis:%d = %ld > 500mg\n", i, bias_regular[i]);
2249:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2250:Src/mpu6050.c ****             }
2251:Src/mpu6050.c ****         }
2252:Src/mpu6050.c ****     }
2253:Src/mpu6050.c **** 
2254:Src/mpu6050.c ****     return result;
2255:Src/mpu6050.c **** }
2256:Src/mpu6050.c **** 
2257:Src/mpu6050.c **** static int gyro_6500_self_test(long *bias_regular, long *bias_st, int debug)
2258:Src/mpu6050.c **** {
2259:Src/mpu6050.c ****     int i, result = 0, otp_value_zero = 0;
2260:Src/mpu6050.c ****     float gyro_st_al_max;
2261:Src/mpu6050.c ****     float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], gyro_offset_max;
2262:Src/mpu6050.c ****     unsigned char regs[3];
2263:Src/mpu6050.c **** 
2264:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, REG_6500_XG_ST_DATA, 3, regs)) {
2265:Src/mpu6050.c ****         if(debug)
2266:Src/mpu6050.c ****             log_i("Reading OTP Register Error.\n");
2267:Src/mpu6050.c ****         return 0x07;
2268:Src/mpu6050.c ****     }
2269:Src/mpu6050.c **** 
2270:Src/mpu6050.c ****     if(debug)
2271:Src/mpu6050.c ****         log_i("Gyro OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
2272:Src/mpu6050.c **** 
2273:Src/mpu6050.c ****     for (i = 0; i < 3; i++) {
2274:Src/mpu6050.c ****         if (regs[i] != 0) {
2275:Src/mpu6050.c ****             ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
2276:Src/mpu6050.c ****             ct_shift_prod[i] *= 65536.f;
2277:Src/mpu6050.c ****             ct_shift_prod[i] /= test.gyro_sens;
2278:Src/mpu6050.c ****         }
2279:Src/mpu6050.c ****         else {
2280:Src/mpu6050.c ****             ct_shift_prod[i] = 0;
2281:Src/mpu6050.c ****             otp_value_zero = 1;
2282:Src/mpu6050.c ****         }
2283:Src/mpu6050.c ****     }
2284:Src/mpu6050.c **** 
2285:Src/mpu6050.c ****     if(otp_value_zero == 0) {
2286:Src/mpu6050.c ****         if(debug)
2287:Src/mpu6050.c ****             log_i("GYRO:CRITERIA A\n");
2288:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria A */
2289:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2290:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2291:Src/mpu6050.c **** 
2292:Src/mpu6050.c ****             if(debug) {
2293:Src/mpu6050.c ****                 log_i("Bias_Shift=%ld, Bias_Reg=%ld, Bias_HWST=%ld\r\n",
2294:Src/mpu6050.c ****                         (long)st_shift_cust[i], bias_regular[i],
2295:Src/mpu6050.c ****                         bias_st[i]);
2296:Src/mpu6050.c ****                 log_i("OTP value: %ld\r\n", (long)ct_shift_prod[i]);
2297:Src/mpu6050.c ****             }
2298:Src/mpu6050.c **** 
2299:Src/mpu6050.c ****             st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i];
ARM GAS  /tmp/ccC60hwS.s 			page 154


2300:Src/mpu6050.c **** 
2301:Src/mpu6050.c ****             if(debug)
2302:Src/mpu6050.c ****                 log_i("ratio=%ld, threshold=%ld\r\n", (long)st_shift_ratio[i],
2303:Src/mpu6050.c ****                             (long)test.max_gyro_var);
2304:Src/mpu6050.c **** 
2305:Src/mpu6050.c ****             if (fabs(st_shift_ratio[i]) < test.max_gyro_var) {
2306:Src/mpu6050.c ****                 if(debug)
2307:Src/mpu6050.c ****                     log_i("Gyro Fail Axis = %d\n", i);
2308:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2309:Src/mpu6050.c ****             }
2310:Src/mpu6050.c ****         }
2311:Src/mpu6050.c ****     }
2312:Src/mpu6050.c ****     else {
2313:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria B */
2314:Src/mpu6050.c ****         gyro_st_al_max = test.max_dps * 65536.f;
2315:Src/mpu6050.c **** 
2316:Src/mpu6050.c ****         if(debug) {
2317:Src/mpu6050.c ****             log_i("GYRO:CRITERIA B\r\n");
2318:Src/mpu6050.c ****             log_i("Max DPS: %ld\r\n", (long)gyro_st_al_max);
2319:Src/mpu6050.c ****         }
2320:Src/mpu6050.c **** 
2321:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2322:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2323:Src/mpu6050.c **** 
2324:Src/mpu6050.c ****             if(debug)
2325:Src/mpu6050.c ****                 log_i("Bias_shift=%ld, st=%ld, reg=%ld\r\n", (long)st_shift_cust[i], bias_st[i], bi
2326:Src/mpu6050.c ****             if(st_shift_cust[i] < gyro_st_al_max) {
2327:Src/mpu6050.c ****                 if(debug)
2328:Src/mpu6050.c ****                     log_i("GYRO FAIL axis:%d greater than 60dps\r\n", i);
2329:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2330:Src/mpu6050.c ****             }
2331:Src/mpu6050.c ****         }
2332:Src/mpu6050.c ****     }
2333:Src/mpu6050.c **** 
2334:Src/mpu6050.c ****     if(result == 0) {
2335:Src/mpu6050.c ****     /* Self Test Pass/Fail Criteria C */
2336:Src/mpu6050.c ****         gyro_offset_max = test.min_dps * 65536.f;
2337:Src/mpu6050.c ****         if(debug)
2338:Src/mpu6050.c ****             log_i("Gyro:CRITERIA C: bias less than %ld\r\n", (long)gyro_offset_max);
2339:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2340:Src/mpu6050.c ****             if(fabs(bias_regular[i]) > gyro_offset_max) {
2341:Src/mpu6050.c ****                 if(debug)
2342:Src/mpu6050.c ****                     log_i("FAILED: Gyro axis:%d = %ld > 20dps\r\n", i, bias_regular[i]);
2343:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2344:Src/mpu6050.c ****             }
2345:Src/mpu6050.c ****         }
2346:Src/mpu6050.c ****     }
2347:Src/mpu6050.c ****     return result;
2348:Src/mpu6050.c **** }
2349:Src/mpu6050.c **** 
2350:Src/mpu6050.c **** static int get_st_6500_biases(long *gyro, long *accel, unsigned char hw_test, int debug)
2351:Src/mpu6050.c **** {
2352:Src/mpu6050.c ****     unsigned char data[HWST_MAX_PACKET_LENGTH];
2353:Src/mpu6050.c ****     unsigned char packet_count, ii;
2354:Src/mpu6050.c ****     unsigned short fifo_count;
2355:Src/mpu6050.c ****     int s = 0, read_size = 0, ind;
2356:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 155


2357:Src/mpu6050.c ****     data[0] = 0x01;
2358:Src/mpu6050.c ****     data[1] = 0;
2359:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
2360:Src/mpu6050.c ****         return -1;
2361:Src/mpu6050.c ****     delay_ms(200);
2362:Src/mpu6050.c ****     data[0] = 0;
2363:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
2364:Src/mpu6050.c ****         return -1;
2365:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2366:Src/mpu6050.c ****         return -1;
2367:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
2368:Src/mpu6050.c ****         return -1;
2369:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2370:Src/mpu6050.c ****         return -1;
2371:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2372:Src/mpu6050.c ****         return -1;
2373:Src/mpu6050.c ****     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
2374:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2375:Src/mpu6050.c ****         return -1;
2376:Src/mpu6050.c ****     delay_ms(15);
2377:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
2378:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
2379:Src/mpu6050.c ****         return -1;
2380:Src/mpu6050.c ****     data[0] = st.test->reg_rate_div;
2381:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
2382:Src/mpu6050.c ****         return -1;
2383:Src/mpu6050.c ****     if (hw_test)
2384:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
2385:Src/mpu6050.c ****     else
2386:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr;
2387:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
2388:Src/mpu6050.c ****         return -1;
2389:Src/mpu6050.c **** 
2390:Src/mpu6050.c ****     if (hw_test)
2391:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
2392:Src/mpu6050.c ****     else
2393:Src/mpu6050.c ****         data[0] = test.reg_accel_fsr;
2394:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
2395:Src/mpu6050.c ****         return -1;
2396:Src/mpu6050.c **** 
2397:Src/mpu6050.c ****     delay_ms(test.wait_ms);  //wait 200ms for sensors to stabilize
2398:Src/mpu6050.c **** 
2399:Src/mpu6050.c ****     /* Enable FIFO */
2400:Src/mpu6050.c ****     data[0] = BIT_FIFO_EN;
2401:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2402:Src/mpu6050.c ****         return -1;
2403:Src/mpu6050.c ****     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2404:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2405:Src/mpu6050.c ****         return -1;
2406:Src/mpu6050.c **** 
2407:Src/mpu6050.c ****     //initialize the bias return values
2408:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
2409:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
2410:Src/mpu6050.c **** 
2411:Src/mpu6050.c ****     if(debug)
2412:Src/mpu6050.c ****         log_i("Starting Bias Loop Reads\r\n");
2413:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 156


2414:Src/mpu6050.c ****     //start reading samples
2415:Src/mpu6050.c ****     while (s < test.packet_thresh) {
2416:Src/mpu6050.c ****         delay_ms(test.sample_wait_ms); //wait 10ms to fill FIFO
2417:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
2418:Src/mpu6050.c ****             return -1;
2419:Src/mpu6050.c ****         fifo_count = (data[0] << 8) | data[1];
2420:Src/mpu6050.c ****         packet_count = fifo_count / MAX_PACKET_LENGTH;
2421:Src/mpu6050.c ****         if ((test.packet_thresh - s) < packet_count)
2422:Src/mpu6050.c ****                     packet_count = test.packet_thresh - s;
2423:Src/mpu6050.c ****         read_size = packet_count * MAX_PACKET_LENGTH;
2424:Src/mpu6050.c **** 
2425:Src/mpu6050.c ****         //burst read from FIFO
2426:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, read_size, data))
2427:Src/mpu6050.c ****                         return -1;
2428:Src/mpu6050.c ****         ind = 0;
2429:Src/mpu6050.c ****         for (ii = 0; ii < packet_count; ii++) {
2430:Src/mpu6050.c ****             short accel_cur[3], gyro_cur[3];
2431:Src/mpu6050.c ****             accel_cur[0] = ((short)data[ind + 0] << 8) | data[ind + 1];
2432:Src/mpu6050.c ****             accel_cur[1] = ((short)data[ind + 2] << 8) | data[ind + 3];
2433:Src/mpu6050.c ****             accel_cur[2] = ((short)data[ind + 4] << 8) | data[ind + 5];
2434:Src/mpu6050.c ****             accel[0] += (long)accel_cur[0];
2435:Src/mpu6050.c ****             accel[1] += (long)accel_cur[1];
2436:Src/mpu6050.c ****             accel[2] += (long)accel_cur[2];
2437:Src/mpu6050.c ****             gyro_cur[0] = (((short)data[ind + 6] << 8) | data[ind + 7]);
2438:Src/mpu6050.c ****             gyro_cur[1] = (((short)data[ind + 8] << 8) | data[ind + 9]);
2439:Src/mpu6050.c ****             gyro_cur[2] = (((short)data[ind + 10] << 8) | data[ind + 11]);
2440:Src/mpu6050.c ****             gyro[0] += (long)gyro_cur[0];
2441:Src/mpu6050.c ****             gyro[1] += (long)gyro_cur[1];
2442:Src/mpu6050.c ****             gyro[2] += (long)gyro_cur[2];
2443:Src/mpu6050.c ****             ind += MAX_PACKET_LENGTH;
2444:Src/mpu6050.c ****         }
2445:Src/mpu6050.c ****         s += packet_count;
2446:Src/mpu6050.c ****     }
2447:Src/mpu6050.c **** 
2448:Src/mpu6050.c ****     if(debug)
2449:Src/mpu6050.c ****         log_i("Samples: %d\r\n", s);
2450:Src/mpu6050.c **** 
2451:Src/mpu6050.c ****     //stop FIFO
2452:Src/mpu6050.c ****     data[0] = 0;
2453:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2454:Src/mpu6050.c ****         return -1;
2455:Src/mpu6050.c **** 
2456:Src/mpu6050.c ****     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / s);
2457:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / s);
2458:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / s);
2459:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens / s);
2460:Src/mpu6050.c ****     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens / s);
2461:Src/mpu6050.c ****     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens / s);
2462:Src/mpu6050.c ****     /* remove gravity from bias calculation */
2463:Src/mpu6050.c ****     if (accel[2] > 0L)
2464:Src/mpu6050.c ****         accel[2] -= 65536L;
2465:Src/mpu6050.c ****     else
2466:Src/mpu6050.c ****         accel[2] += 65536L;
2467:Src/mpu6050.c **** 
2468:Src/mpu6050.c **** 
2469:Src/mpu6050.c ****     if(debug) {
2470:Src/mpu6050.c ****         log_i("Accel offset data HWST bit=%d: %ld %ld %ld\r\n", hw_test, accel[0], accel[1], accel[
ARM GAS  /tmp/ccC60hwS.s 			page 157


2471:Src/mpu6050.c ****         log_i("Gyro offset data HWST bit=%d: %ld %ld %ld\r\n", hw_test, gyro[0], gyro[1], gyro[2]);
2472:Src/mpu6050.c ****     }
2473:Src/mpu6050.c **** 
2474:Src/mpu6050.c ****     return 0;
2475:Src/mpu6050.c **** }
2476:Src/mpu6050.c **** /**
2477:Src/mpu6050.c ****  *  @brief      Trigger gyro/accel/compass self-test for MPU6500/MPU9250
2478:Src/mpu6050.c ****  *  On success/error, the self-test returns a mask representing the sensor(s)
2479:Src/mpu6050.c ****  *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
2480:Src/mpu6050.c ****  *  a zero (0) indicates a failure.
2481:Src/mpu6050.c ****  *
2482:Src/mpu6050.c ****  *  \n The mask is defined as follows:
2483:Src/mpu6050.c ****  *  \n Bit 0:   Gyro.
2484:Src/mpu6050.c ****  *  \n Bit 1:   Accel.
2485:Src/mpu6050.c ****  *  \n Bit 2:   Compass.
2486:Src/mpu6050.c ****  *
2487:Src/mpu6050.c ****  *  @param[out] gyro        Gyro biases in q16 format.
2488:Src/mpu6050.c ****  *  @param[out] accel       Accel biases (if applicable) in q16 format.
2489:Src/mpu6050.c ****  *  @param[in]  debug       Debug flag used to print out more detailed logs. Must first set up logg
2490:Src/mpu6050.c ****  *  @return     Result mask (see above).
2491:Src/mpu6050.c ****  */
2492:Src/mpu6050.c **** int mpu_run_6500_self_test(long *gyro, long *accel, unsigned char debug)
2493:Src/mpu6050.c **** {
2494:Src/mpu6050.c ****     const unsigned char tries = 2;
2495:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
2496:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
2497:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2498:Src/mpu6050.c ****     unsigned char compass_result;
2499:Src/mpu6050.c **** #endif
2500:Src/mpu6050.c ****     int ii;
2501:Src/mpu6050.c **** 
2502:Src/mpu6050.c ****     int result;
2503:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
2504:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
2505:Src/mpu6050.c ****     unsigned char dmp_was_on;
2506:Src/mpu6050.c **** 
2507:Src/mpu6050.c **** 
2508:Src/mpu6050.c **** 
2509:Src/mpu6050.c ****     if(debug)
2510:Src/mpu6050.c ****         log_i("Starting MPU6500 HWST!\r\n");
2511:Src/mpu6050.c **** 
2512:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
2513:Src/mpu6050.c ****         mpu_set_dmp_state(0);
2514:Src/mpu6050.c ****         dmp_was_on = 1;
2515:Src/mpu6050.c ****     } else
2516:Src/mpu6050.c ****         dmp_was_on = 0;
2517:Src/mpu6050.c **** 
2518:Src/mpu6050.c ****     /* Get initial settings. */
2519:Src/mpu6050.c ****     mpu_get_gyro_fsr(&gyro_fsr);
2520:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
2521:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
2522:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
2523:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
2524:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
2525:Src/mpu6050.c **** 
2526:Src/mpu6050.c ****     if(debug)
2527:Src/mpu6050.c ****         log_i("Retrieving Biases\r\n");
ARM GAS  /tmp/ccC60hwS.s 			page 158


2528:Src/mpu6050.c **** 
2529:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2530:Src/mpu6050.c ****         if (!get_st_6500_biases(gyro, accel, 0, debug))
2531:Src/mpu6050.c ****             break;
2532:Src/mpu6050.c ****     if (ii == tries) {
2533:Src/mpu6050.c ****         /* If we reach this point, we most likely encountered an I2C error.
2534:Src/mpu6050.c ****          * We'll just report an error for all three sensors.
2535:Src/mpu6050.c ****          */
2536:Src/mpu6050.c ****         if(debug)
2537:Src/mpu6050.c ****             log_i("Retrieving Biases Error - possible I2C error\r\n");
2538:Src/mpu6050.c **** 
2539:Src/mpu6050.c ****         result = 0;
2540:Src/mpu6050.c ****         goto restore;
2541:Src/mpu6050.c ****     }
2542:Src/mpu6050.c **** 
2543:Src/mpu6050.c ****     if(debug)
2544:Src/mpu6050.c ****         log_i("Retrieving ST Biases\r\n");
2545:Src/mpu6050.c **** 
2546:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2547:Src/mpu6050.c ****         if (!get_st_6500_biases(gyro_st, accel_st, 1, debug))
2548:Src/mpu6050.c ****             break;
2549:Src/mpu6050.c ****     if (ii == tries) {
2550:Src/mpu6050.c **** 
2551:Src/mpu6050.c ****         if(debug)
2552:Src/mpu6050.c ****             log_i("Retrieving ST Biases Error - possible I2C error\r\n");
2553:Src/mpu6050.c **** 
2554:Src/mpu6050.c ****         /* Again, probably an I2C error. */
2555:Src/mpu6050.c ****         result = 0;
2556:Src/mpu6050.c ****         goto restore;
2557:Src/mpu6050.c ****     }
2558:Src/mpu6050.c **** 
2559:Src/mpu6050.c ****     accel_result = accel_6500_self_test(accel, accel_st, debug);
2560:Src/mpu6050.c ****     if(debug)
2561:Src/mpu6050.c ****         log_i("Accel Self Test Results: %d\r\n", accel_result);
2562:Src/mpu6050.c **** 
2563:Src/mpu6050.c ****     gyro_result = gyro_6500_self_test(gyro, gyro_st, debug);
2564:Src/mpu6050.c ****     if(debug)
2565:Src/mpu6050.c ****         log_i("Gyro Self Test Results: %d\r\n", gyro_result);
2566:Src/mpu6050.c **** 
2567:Src/mpu6050.c ****     result = 0;
2568:Src/mpu6050.c ****     if (!gyro_result)
2569:Src/mpu6050.c ****         result |= 0x01;
2570:Src/mpu6050.c ****     if (!accel_result)
2571:Src/mpu6050.c ****         result |= 0x02;
2572:Src/mpu6050.c **** 
2573:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2574:Src/mpu6050.c ****     compass_result = compass_self_test();
2575:Src/mpu6050.c ****     if(debug)
2576:Src/mpu6050.c ****         log_i("Compass Self Test Results: %d\r\n", compass_result);
2577:Src/mpu6050.c ****     if (!compass_result)
2578:Src/mpu6050.c ****         result |= 0x04;
2579:Src/mpu6050.c **** #else
2580:Src/mpu6050.c ****     result |= 0x04;
2581:Src/mpu6050.c **** #endif
2582:Src/mpu6050.c **** restore:
2583:Src/mpu6050.c ****     if(debug)
2584:Src/mpu6050.c ****         log_i("Exiting HWST\r\n");
ARM GAS  /tmp/ccC60hwS.s 			page 159


2585:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
2586:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
2587:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
2588:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
2589:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
2590:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
2591:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
2592:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
2593:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
2594:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
2595:Src/mpu6050.c ****     mpu_set_lpf(lpf);
2596:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
2597:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
2598:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
2599:Src/mpu6050.c **** 
2600:Src/mpu6050.c ****     if (dmp_was_on)
2601:Src/mpu6050.c ****         mpu_set_dmp_state(1);
2602:Src/mpu6050.c **** 
2603:Src/mpu6050.c ****     return result;
2604:Src/mpu6050.c **** }
2605:Src/mpu6050.c **** #endif
2606:Src/mpu6050.c ****  /*
2607:Src/mpu6050.c ****  *  \n This function must be called with the device either face-up or face-down
2608:Src/mpu6050.c ****  *  (z-axis is parallel to gravity).
2609:Src/mpu6050.c ****  *  @param[out] gyro        Gyro biases in q16 format.
2610:Src/mpu6050.c ****  *  @param[out] accel       Accel biases (if applicable) in q16 format.
2611:Src/mpu6050.c ****  *  @return     Result mask (see above).
2612:Src/mpu6050.c ****  */
2613:Src/mpu6050.c **** int mpu_run_self_test(long *gyro, long *accel)
2614:Src/mpu6050.c **** {
2615:Src/mpu6050.c **** #ifdef MPU6050
2616:Src/mpu6050.c ****     const unsigned char tries = 2;
2617:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
2618:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
2619:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2620:Src/mpu6050.c ****     unsigned char compass_result;
2621:Src/mpu6050.c **** #endif
2622:Src/mpu6050.c ****     int ii;
2623:Src/mpu6050.c **** #endif
2624:Src/mpu6050.c ****     int result;
2625:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
2626:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
2627:Src/mpu6050.c ****     unsigned char dmp_was_on;
2628:Src/mpu6050.c **** 
2629:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
2630:Src/mpu6050.c ****         mpu_set_dmp_state(0);
2631:Src/mpu6050.c ****         dmp_was_on = 1;
2632:Src/mpu6050.c ****     } else
2633:Src/mpu6050.c ****         dmp_was_on = 0;
2634:Src/mpu6050.c **** 
2635:Src/mpu6050.c ****     /* Get initial settings. */
2636:Src/mpu6050.c ****     mpu_get_gyro_fsr(&gyro_fsr);
2637:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
2638:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
2639:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
2640:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
2641:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
ARM GAS  /tmp/ccC60hwS.s 			page 160


2642:Src/mpu6050.c **** 
2643:Src/mpu6050.c ****     /* For older chips, the self-test will be different. */
2644:Src/mpu6050.c **** #if defined MPU6050
2645:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2646:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
2647:Src/mpu6050.c ****             break;
2648:Src/mpu6050.c ****     if (ii == tries) {
2649:Src/mpu6050.c ****         /* If we reach this point, we most likely encountered an I2C error.
2650:Src/mpu6050.c ****          * We'll just report an error for all three sensors.
2651:Src/mpu6050.c ****          */
2652:Src/mpu6050.c ****         result = 0;
2653:Src/mpu6050.c ****         goto restore;
2654:Src/mpu6050.c ****     }
2655:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2656:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
2657:Src/mpu6050.c ****             break;
2658:Src/mpu6050.c ****     if (ii == tries) {
2659:Src/mpu6050.c ****         /* Again, probably an I2C error. */
2660:Src/mpu6050.c ****         result = 0;
2661:Src/mpu6050.c ****         goto restore;
2662:Src/mpu6050.c ****     }
2663:Src/mpu6050.c ****     accel_result = accel_self_test(accel, accel_st);
2664:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
2665:Src/mpu6050.c **** 
2666:Src/mpu6050.c ****     result = 0;
2667:Src/mpu6050.c ****     if (!gyro_result)
2668:Src/mpu6050.c ****         result |= 0x01;
2669:Src/mpu6050.c ****     if (!accel_result)
2670:Src/mpu6050.c ****         result |= 0x02;
2671:Src/mpu6050.c **** 
2672:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2673:Src/mpu6050.c ****     compass_result = compass_self_test();
2674:Src/mpu6050.c ****     if (!compass_result)
2675:Src/mpu6050.c ****         result |= 0x04;
2676:Src/mpu6050.c **** #else
2677:Src/mpu6050.c ****         result |= 0x04;
2678:Src/mpu6050.c **** #endif
2679:Src/mpu6050.c **** restore:
2680:Src/mpu6050.c **** #elif defined MPU6500
2681:Src/mpu6050.c ****     /* For now, this function will return a "pass" result for all three sensors
2682:Src/mpu6050.c ****      * for compatibility with current test applications.
2683:Src/mpu6050.c ****      */
2684:Src/mpu6050.c ****     get_st_biases(gyro, accel, 0);
2685:Src/mpu6050.c ****     result = 0x7;
2686:Src/mpu6050.c **** #endif
2687:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
2688:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
2689:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
2690:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
2691:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
2692:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
2693:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
2694:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
2695:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
2696:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
2697:Src/mpu6050.c ****     mpu_set_lpf(lpf);
2698:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
ARM GAS  /tmp/ccC60hwS.s 			page 161


2699:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
2700:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
2701:Src/mpu6050.c **** 
2702:Src/mpu6050.c ****     if (dmp_was_on)
2703:Src/mpu6050.c ****         mpu_set_dmp_state(1);
2704:Src/mpu6050.c **** 
2705:Src/mpu6050.c ****     return result;
2706:Src/mpu6050.c **** }
2707:Src/mpu6050.c **** 
2708:Src/mpu6050.c **** /**
2709:Src/mpu6050.c ****  *  @brief      Write to the DMP memory.
2710:Src/mpu6050.c ****  *  This function prevents I2C writes past the bank boundaries. The DMP memory
2711:Src/mpu6050.c ****  *  is only accessible when the chip is awake.
2712:Src/mpu6050.c ****  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2713:Src/mpu6050.c ****  *  @param[in]  length      Number of bytes to write.
2714:Src/mpu6050.c ****  *  @param[in]  data        Bytes to write to memory.
2715:Src/mpu6050.c ****  *  @return     0 if successful.
2716:Src/mpu6050.c ****  */
2717:Src/mpu6050.c **** int mpu_write_mem(unsigned short mem_addr, unsigned short length,
2718:Src/mpu6050.c ****         unsigned char *data)
2719:Src/mpu6050.c **** {
 4992              		.loc 1 2719 1 is_stmt 1 view -0
 4993              		.cfi_startproc
 4994              		@ args = 0, pretend = 0, frame = 8
 4995              		@ frame_needed = 0, uses_anonymous_args = 0
2720:Src/mpu6050.c ****     unsigned char tmp[2];
 4996              		.loc 1 2720 5 view .LVU1523
2721:Src/mpu6050.c **** 
2722:Src/mpu6050.c ****     if (!data)
 4997              		.loc 1 2722 5 view .LVU1524
2719:Src/mpu6050.c ****     unsigned char tmp[2];
 4998              		.loc 1 2719 1 is_stmt 0 view .LVU1525
 4999 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 5000              	.LCFI80:
 5001              		.cfi_def_cfa_offset 32
 5002              		.cfi_offset 4, -20
 5003              		.cfi_offset 5, -16
 5004              		.cfi_offset 6, -12
 5005              		.cfi_offset 7, -8
 5006              		.cfi_offset 14, -4
2719:Src/mpu6050.c ****     unsigned char tmp[2];
 5007              		.loc 1 2719 1 view .LVU1526
 5008 0002 0D46     		mov	r5, r1
 5009              		.loc 1 2722 8 view .LVU1527
 5010 0004 1646     		mov	r6, r2
 5011 0006 1AB9     		cbnz	r2, .L433
 5012              	.LVL312:
 5013              	.L435:
2723:Src/mpu6050.c ****         return -1;
 5014              		.loc 1 2723 16 view .LVU1528
 5015 0008 4FF0FF30 		mov	r0, #-1
 5016              	.L432:
2724:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
2725:Src/mpu6050.c ****         return -1;
2726:Src/mpu6050.c **** 
2727:Src/mpu6050.c ****     tmp[0] = (unsigned char)(mem_addr >> 8);
2728:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
ARM GAS  /tmp/ccC60hwS.s 			page 162


2729:Src/mpu6050.c **** 
2730:Src/mpu6050.c ****     /* Check bank boundaries. */
2731:Src/mpu6050.c ****     if (tmp[1] + length > st.hw->bank_size)
2732:Src/mpu6050.c ****         return -1;
2733:Src/mpu6050.c **** 
2734:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2735:Src/mpu6050.c ****         return -1;
2736:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
2737:Src/mpu6050.c ****         return -1;
2738:Src/mpu6050.c ****     return 0;
2739:Src/mpu6050.c **** }
 5017              		.loc 1 2739 1 view .LVU1529
 5018 000c 03B0     		add	sp, sp, #12
 5019              	.LCFI81:
 5020              		.cfi_remember_state
 5021              		.cfi_def_cfa_offset 20
 5022              		@ sp needed
 5023 000e F0BD     		pop	{r4, r5, r6, r7, pc}
 5024              	.LVL313:
 5025              	.L433:
 5026              	.LCFI82:
 5027              		.cfi_restore_state
2724:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5028              		.loc 1 2724 5 is_stmt 1 view .LVU1530
2724:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5029              		.loc 1 2724 21 is_stmt 0 view .LVU1531
 5030 0010 124C     		ldr	r4, .L439
2724:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5031              		.loc 1 2724 8 view .LVU1532
 5032 0012 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 5033 0014 002B     		cmp	r3, #0
 5034 0016 F7D0     		beq	.L435
2727:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5035              		.loc 1 2727 5 is_stmt 1 view .LVU1533
2731:Src/mpu6050.c ****         return -1;
 5036              		.loc 1 2731 29 is_stmt 0 view .LVU1534
 5037 0018 6768     		ldr	r7, [r4, #4]
2727:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5038              		.loc 1 2727 14 view .LVU1535
 5039 001a 030A     		lsrs	r3, r0, #8
 5040 001c 8DF80430 		strb	r3, [sp, #4]
2728:Src/mpu6050.c **** 
 5041              		.loc 1 2728 5 is_stmt 1 view .LVU1536
2728:Src/mpu6050.c **** 
 5042              		.loc 1 2728 14 is_stmt 0 view .LVU1537
 5043 0020 C0B2     		uxtb	r0, r0
 5044              	.LVL314:
2731:Src/mpu6050.c ****         return -1;
 5045              		.loc 1 2731 32 view .LVU1538
 5046 0022 7B89     		ldrh	r3, [r7, #10]
2728:Src/mpu6050.c **** 
 5047              		.loc 1 2728 12 view .LVU1539
 5048 0024 8DF80500 		strb	r0, [sp, #5]
2731:Src/mpu6050.c ****         return -1;
 5049              		.loc 1 2731 5 is_stmt 1 view .LVU1540
2731:Src/mpu6050.c ****         return -1;
 5050              		.loc 1 2731 16 is_stmt 0 view .LVU1541
ARM GAS  /tmp/ccC60hwS.s 			page 163


 5051 0028 0844     		add	r0, r0, r1
2731:Src/mpu6050.c ****         return -1;
 5052              		.loc 1 2731 8 view .LVU1542
 5053 002a 9842     		cmp	r0, r3
 5054 002c ECDC     		bgt	.L435
2734:Src/mpu6050.c ****         return -1;
 5055              		.loc 1 2734 5 is_stmt 1 view .LVU1543
2734:Src/mpu6050.c ****         return -1;
 5056              		.loc 1 2734 9 is_stmt 0 view .LVU1544
 5057 002e 2168     		ldr	r1, [r4]
 5058              	.LVL315:
2734:Src/mpu6050.c ****         return -1;
 5059              		.loc 1 2734 9 view .LVU1545
 5060 0030 0222     		movs	r2, #2
 5061              	.LVL316:
2734:Src/mpu6050.c ****         return -1;
 5062              		.loc 1 2734 9 view .LVU1546
 5063 0032 C97E     		ldrb	r1, [r1, #27]	@ zero_extendqisi2
 5064 0034 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5065 0036 01AB     		add	r3, sp, #4
 5066 0038 FFF7FEFF 		bl	i2c_writeBytes
 5067              	.LVL317:
2734:Src/mpu6050.c ****         return -1;
 5068              		.loc 1 2734 8 view .LVU1547
 5069 003c 0028     		cmp	r0, #0
 5070 003e E3D1     		bne	.L435
2736:Src/mpu6050.c ****         return -1;
 5071              		.loc 1 2736 5 is_stmt 1 view .LVU1548
2736:Src/mpu6050.c ****         return -1;
 5072              		.loc 1 2736 9 is_stmt 0 view .LVU1549
 5073 0040 D4E90010 		ldrd	r1, r0, [r4]
 5074 0044 3346     		mov	r3, r6
 5075 0046 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 5076 0048 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5077 004a EAB2     		uxtb	r2, r5
 5078 004c FFF7FEFF 		bl	i2c_writeBytes
 5079              	.LVL318:
2736:Src/mpu6050.c ****         return -1;
 5080              		.loc 1 2736 8 view .LVU1550
 5081 0050 0038     		subs	r0, r0, #0
 5082 0052 18BF     		it	ne
 5083 0054 0120     		movne	r0, #1
 5084 0056 4042     		rsbs	r0, r0, #0
 5085 0058 D8E7     		b	.L432
 5086              	.L440:
 5087 005a 00BF     		.align	2
 5088              	.L439:
 5089 005c 00000000 		.word	.LANCHOR0
 5090              		.cfi_endproc
 5091              	.LFE101:
 5093              		.section	.text.mpu_read_mem,"ax",%progbits
 5094              		.align	1
 5095              		.global	mpu_read_mem
 5096              		.syntax unified
 5097              		.thumb
 5098              		.thumb_func
 5099              		.fpu softvfp
ARM GAS  /tmp/ccC60hwS.s 			page 164


 5101              	mpu_read_mem:
 5102              	.LVL319:
 5103              	.LFB102:
2740:Src/mpu6050.c **** 
2741:Src/mpu6050.c **** /**
2742:Src/mpu6050.c ****  *  @brief      Read from the DMP memory.
2743:Src/mpu6050.c ****  *  This function prevents I2C reads past the bank boundaries. The DMP memory
2744:Src/mpu6050.c ****  *  is only accessible when the chip is awake.
2745:Src/mpu6050.c ****  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2746:Src/mpu6050.c ****  *  @param[in]  length      Number of bytes to read.
2747:Src/mpu6050.c ****  *  @param[out] data        Bytes read from memory.
2748:Src/mpu6050.c ****  *  @return     0 if successful.
2749:Src/mpu6050.c ****  */
2750:Src/mpu6050.c **** int mpu_read_mem(unsigned short mem_addr, unsigned short length,
2751:Src/mpu6050.c ****         unsigned char *data)
2752:Src/mpu6050.c **** {
 5104              		.loc 1 2752 1 is_stmt 1 view -0
 5105              		.cfi_startproc
 5106              		@ args = 0, pretend = 0, frame = 8
 5107              		@ frame_needed = 0, uses_anonymous_args = 0
2753:Src/mpu6050.c ****     unsigned char tmp[2];
 5108              		.loc 1 2753 5 view .LVU1552
2754:Src/mpu6050.c **** 
2755:Src/mpu6050.c ****     if (!data)
 5109              		.loc 1 2755 5 view .LVU1553
2752:Src/mpu6050.c ****     unsigned char tmp[2];
 5110              		.loc 1 2752 1 is_stmt 0 view .LVU1554
 5111 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 5112              	.LCFI83:
 5113              		.cfi_def_cfa_offset 32
 5114              		.cfi_offset 4, -20
 5115              		.cfi_offset 5, -16
 5116              		.cfi_offset 6, -12
 5117              		.cfi_offset 7, -8
 5118              		.cfi_offset 14, -4
2752:Src/mpu6050.c ****     unsigned char tmp[2];
 5119              		.loc 1 2752 1 view .LVU1555
 5120 0002 0D46     		mov	r5, r1
 5121              		.loc 1 2755 8 view .LVU1556
 5122 0004 1646     		mov	r6, r2
 5123 0006 1AB9     		cbnz	r2, .L442
 5124              	.LVL320:
 5125              	.L444:
2756:Src/mpu6050.c ****         return -1;
 5126              		.loc 1 2756 16 view .LVU1557
 5127 0008 4FF0FF30 		mov	r0, #-1
 5128              	.L441:
2757:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
2758:Src/mpu6050.c ****         return -1;
2759:Src/mpu6050.c **** 
2760:Src/mpu6050.c ****     tmp[0] = (unsigned char)(mem_addr >> 8);
2761:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
2762:Src/mpu6050.c **** 
2763:Src/mpu6050.c ****     /* Check bank boundaries. */
2764:Src/mpu6050.c ****     if (tmp[1] + length > st.hw->bank_size)
2765:Src/mpu6050.c ****         return -1;
2766:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 165


2767:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2768:Src/mpu6050.c ****         return -1;
2769:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
2770:Src/mpu6050.c ****         return -1;
2771:Src/mpu6050.c ****     return 0;
2772:Src/mpu6050.c **** }
 5129              		.loc 1 2772 1 view .LVU1558
 5130 000c 03B0     		add	sp, sp, #12
 5131              	.LCFI84:
 5132              		.cfi_remember_state
 5133              		.cfi_def_cfa_offset 20
 5134              		@ sp needed
 5135 000e F0BD     		pop	{r4, r5, r6, r7, pc}
 5136              	.LVL321:
 5137              	.L442:
 5138              	.LCFI85:
 5139              		.cfi_restore_state
2757:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5140              		.loc 1 2757 5 is_stmt 1 view .LVU1559
2757:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5141              		.loc 1 2757 21 is_stmt 0 view .LVU1560
 5142 0010 124C     		ldr	r4, .L448
2757:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5143              		.loc 1 2757 8 view .LVU1561
 5144 0012 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 5145 0014 002B     		cmp	r3, #0
 5146 0016 F7D0     		beq	.L444
2760:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5147              		.loc 1 2760 5 is_stmt 1 view .LVU1562
2764:Src/mpu6050.c ****         return -1;
 5148              		.loc 1 2764 29 is_stmt 0 view .LVU1563
 5149 0018 6768     		ldr	r7, [r4, #4]
2760:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5150              		.loc 1 2760 14 view .LVU1564
 5151 001a 030A     		lsrs	r3, r0, #8
 5152 001c 8DF80430 		strb	r3, [sp, #4]
2761:Src/mpu6050.c **** 
 5153              		.loc 1 2761 5 is_stmt 1 view .LVU1565
2761:Src/mpu6050.c **** 
 5154              		.loc 1 2761 14 is_stmt 0 view .LVU1566
 5155 0020 C0B2     		uxtb	r0, r0
 5156              	.LVL322:
2764:Src/mpu6050.c ****         return -1;
 5157              		.loc 1 2764 32 view .LVU1567
 5158 0022 7B89     		ldrh	r3, [r7, #10]
2761:Src/mpu6050.c **** 
 5159              		.loc 1 2761 12 view .LVU1568
 5160 0024 8DF80500 		strb	r0, [sp, #5]
2764:Src/mpu6050.c ****         return -1;
 5161              		.loc 1 2764 5 is_stmt 1 view .LVU1569
2764:Src/mpu6050.c ****         return -1;
 5162              		.loc 1 2764 16 is_stmt 0 view .LVU1570
 5163 0028 0844     		add	r0, r0, r1
2764:Src/mpu6050.c ****         return -1;
 5164              		.loc 1 2764 8 view .LVU1571
 5165 002a 9842     		cmp	r0, r3
 5166 002c ECDC     		bgt	.L444
ARM GAS  /tmp/ccC60hwS.s 			page 166


2767:Src/mpu6050.c ****         return -1;
 5167              		.loc 1 2767 5 is_stmt 1 view .LVU1572
2767:Src/mpu6050.c ****         return -1;
 5168              		.loc 1 2767 9 is_stmt 0 view .LVU1573
 5169 002e 2168     		ldr	r1, [r4]
 5170              	.LVL323:
2767:Src/mpu6050.c ****         return -1;
 5171              		.loc 1 2767 9 view .LVU1574
 5172 0030 0222     		movs	r2, #2
 5173              	.LVL324:
2767:Src/mpu6050.c ****         return -1;
 5174              		.loc 1 2767 9 view .LVU1575
 5175 0032 C97E     		ldrb	r1, [r1, #27]	@ zero_extendqisi2
 5176 0034 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5177 0036 01AB     		add	r3, sp, #4
 5178 0038 FFF7FEFF 		bl	i2c_writeBytes
 5179              	.LVL325:
2767:Src/mpu6050.c ****         return -1;
 5180              		.loc 1 2767 8 view .LVU1576
 5181 003c 0028     		cmp	r0, #0
 5182 003e E3D1     		bne	.L444
2769:Src/mpu6050.c ****         return -1;
 5183              		.loc 1 2769 5 is_stmt 1 view .LVU1577
2769:Src/mpu6050.c ****         return -1;
 5184              		.loc 1 2769 9 is_stmt 0 view .LVU1578
 5185 0040 D4E90010 		ldrd	r1, r0, [r4]
 5186 0044 3346     		mov	r3, r6
 5187 0046 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 5188 0048 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5189 004a EAB2     		uxtb	r2, r5
 5190 004c FFF7FEFF 		bl	i2c_readBytes
 5191              	.LVL326:
2769:Src/mpu6050.c ****         return -1;
 5192              		.loc 1 2769 8 view .LVU1579
 5193 0050 0038     		subs	r0, r0, #0
 5194 0052 18BF     		it	ne
 5195 0054 0120     		movne	r0, #1
 5196 0056 4042     		rsbs	r0, r0, #0
 5197 0058 D8E7     		b	.L441
 5198              	.L449:
 5199 005a 00BF     		.align	2
 5200              	.L448:
 5201 005c 00000000 		.word	.LANCHOR0
 5202              		.cfi_endproc
 5203              	.LFE102:
 5205              		.section	.text.mpu_load_firmware,"ax",%progbits
 5206              		.align	1
 5207              		.global	mpu_load_firmware
 5208              		.syntax unified
 5209              		.thumb
 5210              		.thumb_func
 5211              		.fpu softvfp
 5213              	mpu_load_firmware:
 5214              	.LVL327:
 5215              	.LFB103:
2773:Src/mpu6050.c **** 
2774:Src/mpu6050.c **** /**
ARM GAS  /tmp/ccC60hwS.s 			page 167


2775:Src/mpu6050.c ****  *  @brief      Load and verify DMP image.
2776:Src/mpu6050.c ****  *  @param[in]  length      Length of DMP image.
2777:Src/mpu6050.c ****  *  @param[in]  firmware    DMP code.
2778:Src/mpu6050.c ****  *  @param[in]  start_addr  Starting address of DMP code memory.
2779:Src/mpu6050.c ****  *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
2780:Src/mpu6050.c ****  *  @return     0 if successful.
2781:Src/mpu6050.c ****  */
2782:Src/mpu6050.c **** int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
2783:Src/mpu6050.c ****     unsigned short start_addr, unsigned short sample_rate)
2784:Src/mpu6050.c **** {
 5216              		.loc 1 2784 1 is_stmt 1 view -0
 5217              		.cfi_startproc
 5218              		@ args = 0, pretend = 0, frame = 32
 5219              		@ frame_needed = 0, uses_anonymous_args = 0
2785:Src/mpu6050.c ****     unsigned short ii;
 5220              		.loc 1 2785 5 view .LVU1581
2786:Src/mpu6050.c ****     unsigned short this_write;
 5221              		.loc 1 2786 5 view .LVU1582
2787:Src/mpu6050.c ****     /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
2788:Src/mpu6050.c **** #define LOAD_CHUNK  (16)
2789:Src/mpu6050.c ****     unsigned char cur[LOAD_CHUNK], tmp[2];
 5222              		.loc 1 2789 5 view .LVU1583
2790:Src/mpu6050.c **** 
2791:Src/mpu6050.c ****     if (st.chip_cfg.dmp_loaded)
 5223              		.loc 1 2791 5 view .LVU1584
2784:Src/mpu6050.c ****     unsigned short ii;
 5224              		.loc 1 2784 1 is_stmt 0 view .LVU1585
 5225 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5226              	.LCFI86:
 5227              		.cfi_def_cfa_offset 36
 5228              		.cfi_offset 4, -36
 5229              		.cfi_offset 5, -32
 5230              		.cfi_offset 6, -28
 5231              		.cfi_offset 7, -24
 5232              		.cfi_offset 8, -20
 5233              		.cfi_offset 9, -16
 5234              		.cfi_offset 10, -12
 5235              		.cfi_offset 11, -8
 5236              		.cfi_offset 14, -4
 5237              		.loc 1 2791 20 view .LVU1586
 5238 0004 254D     		ldr	r5, .L460
2784:Src/mpu6050.c ****     unsigned short ii;
 5239              		.loc 1 2784 1 view .LVU1587
 5240 0006 89B0     		sub	sp, sp, #36
 5241              	.LCFI87:
 5242              		.cfi_def_cfa_offset 72
 5243              		.loc 1 2791 8 view .LVU1588
 5244 0008 95F82540 		ldrb	r4, [r5, #37]	@ zero_extendqisi2
2784:Src/mpu6050.c ****     unsigned short ii;
 5245              		.loc 1 2784 1 view .LVU1589
 5246 000c 8146     		mov	r9, r0
 5247 000e 8A46     		mov	r10, r1
 5248 0010 1746     		mov	r7, r2
 5249 0012 0193     		str	r3, [sp, #4]
 5250              		.loc 1 2791 8 view .LVU1590
 5251 0014 24B1     		cbz	r4, .L451
 5252              	.LVL328:
ARM GAS  /tmp/ccC60hwS.s 			page 168


 5253              	.L453:
2792:Src/mpu6050.c ****         /* DMP should only be loaded once. */
2793:Src/mpu6050.c ****         return -1;
 5254              		.loc 1 2793 16 view .LVU1591
 5255 0016 4FF0FF30 		mov	r0, #-1
 5256              	.L450:
2794:Src/mpu6050.c **** 
2795:Src/mpu6050.c ****     if (!firmware)
2796:Src/mpu6050.c ****         return -1;
2797:Src/mpu6050.c ****     for (ii = 0; ii < length; ii += this_write) {
2798:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
2799:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
2800:Src/mpu6050.c ****             return -1;
2801:Src/mpu6050.c ****         if (mpu_read_mem(ii, this_write, cur))
2802:Src/mpu6050.c ****             return -1;
2803:Src/mpu6050.c ****         if (memcmp(firmware+ii, cur, this_write))
2804:Src/mpu6050.c ****             return -2;
2805:Src/mpu6050.c ****     }
2806:Src/mpu6050.c **** 
2807:Src/mpu6050.c ****     /* Set program start address. */
2808:Src/mpu6050.c ****     tmp[0] = start_addr >> 8;
2809:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
2810:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
2811:Src/mpu6050.c ****         return -1;
2812:Src/mpu6050.c **** 
2813:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 1;
2814:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
2815:Src/mpu6050.c ****     return 0;
2816:Src/mpu6050.c **** }
 5257              		.loc 1 2816 1 view .LVU1592
 5258 001a 09B0     		add	sp, sp, #36
 5259              	.LCFI88:
 5260              		.cfi_remember_state
 5261              		.cfi_def_cfa_offset 36
 5262              		@ sp needed
 5263 001c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5264              	.LVL329:
 5265              	.L451:
 5266              	.LCFI89:
 5267              		.cfi_restore_state
2795:Src/mpu6050.c ****         return -1;
 5268              		.loc 1 2795 5 is_stmt 1 view .LVU1593
2795:Src/mpu6050.c ****         return -1;
 5269              		.loc 1 2795 8 is_stmt 0 view .LVU1594
 5270 0020 0029     		cmp	r1, #0
 5271 0022 F8D0     		beq	.L453
 5272              	.LVL330:
 5273              	.L454:
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5274              		.loc 1 2797 18 is_stmt 1 discriminator 1 view .LVU1595
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5275              		.loc 1 2797 5 is_stmt 0 discriminator 1 view .LVU1596
 5276 0024 4C45     		cmp	r4, r9
 5277 0026 14D3     		bcc	.L455
2808:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
 5278              		.loc 1 2808 5 is_stmt 1 view .LVU1597
2808:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
ARM GAS  /tmp/ccC60hwS.s 			page 169


 5279              		.loc 1 2808 12 is_stmt 0 view .LVU1598
 5280 0028 3B0A     		lsrs	r3, r7, #8
 5281 002a 8DF80C30 		strb	r3, [sp, #12]
2809:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
 5282              		.loc 1 2809 5 is_stmt 1 view .LVU1599
2809:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
 5283              		.loc 1 2809 12 is_stmt 0 view .LVU1600
 5284 002e 8DF80D70 		strb	r7, [sp, #13]
2810:Src/mpu6050.c ****         return -1;
 5285              		.loc 1 2810 5 is_stmt 1 view .LVU1601
2810:Src/mpu6050.c ****         return -1;
 5286              		.loc 1 2810 9 is_stmt 0 view .LVU1602
 5287 0032 D5E90010 		ldrd	r1, r0, [r5]
 5288 0036 0222     		movs	r2, #2
 5289 0038 497F     		ldrb	r1, [r1, #29]	@ zero_extendqisi2
 5290 003a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5291 003c 03AB     		add	r3, sp, #12
 5292 003e FFF7FEFF 		bl	i2c_writeBytes
 5293              	.LVL331:
2810:Src/mpu6050.c ****         return -1;
 5294              		.loc 1 2810 8 view .LVU1603
 5295 0042 0028     		cmp	r0, #0
 5296 0044 E7D1     		bne	.L453
2813:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
 5297              		.loc 1 2813 5 is_stmt 1 view .LVU1604
2813:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
 5298              		.loc 1 2813 28 is_stmt 0 view .LVU1605
 5299 0046 0123     		movs	r3, #1
 5300 0048 85F82530 		strb	r3, [r5, #37]
2814:Src/mpu6050.c ****     return 0;
 5301              		.loc 1 2814 5 is_stmt 1 view .LVU1606
2814:Src/mpu6050.c ****     return 0;
 5302              		.loc 1 2814 33 is_stmt 0 view .LVU1607
 5303 004c 019B     		ldr	r3, [sp, #4]
 5304 004e EB84     		strh	r3, [r5, #38]	@ movhi
2815:Src/mpu6050.c **** }
 5305              		.loc 1 2815 5 is_stmt 1 view .LVU1608
2815:Src/mpu6050.c **** }
 5306              		.loc 1 2815 12 is_stmt 0 view .LVU1609
 5307 0050 E3E7     		b	.L450
 5308              	.L455:
2798:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5309              		.loc 1 2798 9 is_stmt 1 view .LVU1610
2798:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5310              		.loc 1 2798 22 is_stmt 0 view .LVU1611
 5311 0052 A9EB040B 		sub	fp, r9, r4
 5312 0056 BBF1100F 		cmp	fp, #16
 5313 005a A8BF     		it	ge
 5314 005c 4FF0100B 		movge	fp, #16
2799:Src/mpu6050.c ****             return -1;
 5315              		.loc 1 2799 59 view .LVU1612
 5316 0060 0AEB0408 		add	r8, r10, r4
2798:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5317              		.loc 1 2798 20 view .LVU1613
 5318 0064 1FFA8BF6 		uxth	r6, fp
 5319              	.LVL332:
2799:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 170


 5320              		.loc 1 2799 9 is_stmt 1 view .LVU1614
2799:Src/mpu6050.c ****             return -1;
 5321              		.loc 1 2799 13 is_stmt 0 view .LVU1615
 5322 0068 4246     		mov	r2, r8
 5323 006a 3146     		mov	r1, r6
 5324 006c 2046     		mov	r0, r4
 5325 006e FFF7FEFF 		bl	mpu_write_mem
 5326              	.LVL333:
2799:Src/mpu6050.c ****             return -1;
 5327              		.loc 1 2799 12 view .LVU1616
 5328 0072 0028     		cmp	r0, #0
 5329 0074 CFD1     		bne	.L453
2801:Src/mpu6050.c ****             return -1;
 5330              		.loc 1 2801 9 is_stmt 1 view .LVU1617
2801:Src/mpu6050.c ****             return -1;
 5331              		.loc 1 2801 13 is_stmt 0 view .LVU1618
 5332 0076 3146     		mov	r1, r6
 5333 0078 2046     		mov	r0, r4
 5334 007a 04AA     		add	r2, sp, #16
 5335 007c FFF7FEFF 		bl	mpu_read_mem
 5336              	.LVL334:
2801:Src/mpu6050.c ****             return -1;
 5337              		.loc 1 2801 12 view .LVU1619
 5338 0080 0028     		cmp	r0, #0
 5339 0082 C8D1     		bne	.L453
2803:Src/mpu6050.c ****             return -2;
 5340              		.loc 1 2803 9 is_stmt 1 view .LVU1620
2803:Src/mpu6050.c ****             return -2;
 5341              		.loc 1 2803 13 is_stmt 0 view .LVU1621
 5342 0084 3246     		mov	r2, r6
 5343 0086 4046     		mov	r0, r8
 5344 0088 04A9     		add	r1, sp, #16
 5345 008a FFF7FEFF 		bl	memcmp
 5346              	.LVL335:
2803:Src/mpu6050.c ****             return -2;
 5347              		.loc 1 2803 12 view .LVU1622
 5348 008e 10B9     		cbnz	r0, .L456
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5349              		.loc 1 2797 31 is_stmt 1 discriminator 2 view .LVU1623
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5350              		.loc 1 2797 34 is_stmt 0 discriminator 2 view .LVU1624
 5351 0090 3444     		add	r4, r4, r6
 5352              	.LVL336:
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5353              		.loc 1 2797 34 discriminator 2 view .LVU1625
 5354 0092 A4B2     		uxth	r4, r4
 5355              	.LVL337:
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5356              		.loc 1 2797 34 discriminator 2 view .LVU1626
 5357 0094 C6E7     		b	.L454
 5358              	.L456:
2804:Src/mpu6050.c ****     }
 5359              		.loc 1 2804 20 view .LVU1627
 5360 0096 6FF00100 		mvn	r0, #1
 5361 009a BEE7     		b	.L450
 5362              	.L461:
 5363              		.align	2
ARM GAS  /tmp/ccC60hwS.s 			page 171


 5364              	.L460:
 5365 009c 00000000 		.word	.LANCHOR0
 5366              		.cfi_endproc
 5367              	.LFE103:
 5369              		.section	.text.mpu_set_dmp_state,"ax",%progbits
 5370              		.align	1
 5371              		.global	mpu_set_dmp_state
 5372              		.syntax unified
 5373              		.thumb
 5374              		.thumb_func
 5375              		.fpu softvfp
 5377              	mpu_set_dmp_state:
 5378              	.LVL338:
 5379              	.LFB104:
2817:Src/mpu6050.c **** 
2818:Src/mpu6050.c **** /**
2819:Src/mpu6050.c ****  *  @brief      Enable/disable DMP support.
2820:Src/mpu6050.c ****  *  @param[in]  enable  1 to turn on the DMP.
2821:Src/mpu6050.c ****  *  @return     0 if successful.
2822:Src/mpu6050.c ****  */
2823:Src/mpu6050.c **** int mpu_set_dmp_state(unsigned char enable)
2824:Src/mpu6050.c **** {
 5380              		.loc 1 2824 1 is_stmt 1 view -0
 5381              		.cfi_startproc
 5382              		@ args = 0, pretend = 0, frame = 8
 5383              		@ frame_needed = 0, uses_anonymous_args = 0
2825:Src/mpu6050.c ****     unsigned char tmp;
 5384              		.loc 1 2825 5 view .LVU1629
2826:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on == enable)
 5385              		.loc 1 2826 5 view .LVU1630
2824:Src/mpu6050.c ****     unsigned char tmp;
 5386              		.loc 1 2824 1 is_stmt 0 view .LVU1631
 5387 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 5388              	.LCFI90:
 5389              		.cfi_def_cfa_offset 24
 5390              		.cfi_offset 4, -12
 5391              		.cfi_offset 5, -8
 5392              		.cfi_offset 14, -4
 5393              		.loc 1 2826 20 view .LVU1632
 5394 0002 1D4D     		ldr	r5, .L468
2824:Src/mpu6050.c ****     unsigned char tmp;
 5395              		.loc 1 2824 1 view .LVU1633
 5396 0004 0446     		mov	r4, r0
 5397              		.loc 1 2826 8 view .LVU1634
 5398 0006 95F82430 		ldrb	r3, [r5, #36]	@ zero_extendqisi2
 5399 000a 8342     		cmp	r3, r0
 5400 000c 1ED0     		beq	.L465
2827:Src/mpu6050.c ****         return 0;
2828:Src/mpu6050.c **** 
2829:Src/mpu6050.c ****     if (enable) {
 5401              		.loc 1 2829 5 is_stmt 1 view .LVU1635
 5402              		.loc 1 2829 8 is_stmt 0 view .LVU1636
 5403 000e 00B3     		cbz	r0, .L464
2830:Src/mpu6050.c ****         if (!st.chip_cfg.dmp_loaded)
 5404              		.loc 1 2830 9 is_stmt 1 view .LVU1637
 5405              		.loc 1 2830 12 is_stmt 0 view .LVU1638
 5406 0010 95F82530 		ldrb	r3, [r5, #37]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 172


 5407 0014 6BB3     		cbz	r3, .L466
 5408              	.LBB10:
 5409              	.LBI10:
2823:Src/mpu6050.c **** {
 5410              		.loc 1 2823 5 is_stmt 1 view .LVU1639
 5411              	.LVL339:
 5412              	.LBB11:
2831:Src/mpu6050.c ****             return -1;
2832:Src/mpu6050.c ****         /* Disable data ready interrupt. */
2833:Src/mpu6050.c ****         set_int_enable(0);
 5413              		.loc 1 2833 9 view .LVU1640
2834:Src/mpu6050.c ****         /* Disable bypass mode. */
2835:Src/mpu6050.c ****         mpu_set_bypass(0);
2836:Src/mpu6050.c ****         /* Keep constant sample rate, FIFO rate controlled by DMP. */
2837:Src/mpu6050.c ****         mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
2838:Src/mpu6050.c ****         /* Remove FIFO elements. */
2839:Src/mpu6050.c ****         tmp = 0;
 5414              		.loc 1 2839 13 is_stmt 0 view .LVU1641
 5415 0016 0024     		movs	r4, #0
2833:Src/mpu6050.c ****         /* Disable bypass mode. */
 5416              		.loc 1 2833 9 view .LVU1642
 5417 0018 0020     		movs	r0, #0
 5418              	.LVL340:
2833:Src/mpu6050.c ****         /* Disable bypass mode. */
 5419              		.loc 1 2833 9 view .LVU1643
 5420 001a FFF7FEFF 		bl	set_int_enable.isra.0
 5421              	.LVL341:
2835:Src/mpu6050.c ****         /* Keep constant sample rate, FIFO rate controlled by DMP. */
 5422              		.loc 1 2835 9 is_stmt 1 view .LVU1644
 5423 001e 0020     		movs	r0, #0
 5424 0020 FFF7FEFF 		bl	mpu_set_bypass
 5425              	.LVL342:
2837:Src/mpu6050.c ****         /* Remove FIFO elements. */
 5426              		.loc 1 2837 9 view .LVU1645
 5427 0024 E88C     		ldrh	r0, [r5, #38]
 5428 0026 FFF7FEFF 		bl	mpu_set_sample_rate
 5429              	.LVL343:
 5430              		.loc 1 2839 9 view .LVU1646
2840:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5431              		.loc 1 2840 9 is_stmt 0 view .LVU1647
 5432 002a 6868     		ldr	r0, [r5, #4]
2839:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5433              		.loc 1 2839 13 view .LVU1648
 5434 002c 8DF80740 		strb	r4, [sp, #7]
 5435              		.loc 1 2840 9 is_stmt 1 view .LVU1649
 5436 0030 0122     		movs	r2, #1
 5437 0032 2321     		movs	r1, #35
 5438 0034 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5439 0036 0DF10703 		add	r3, sp, #7
 5440 003a FFF7FEFF 		bl	i2c_writeBytes
 5441              	.LVL344:
2841:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 1;
 5442              		.loc 1 2841 9 view .LVU1650
 5443              		.loc 1 2841 28 is_stmt 0 view .LVU1651
 5444 003e 0120     		movs	r0, #1
 5445 0040 85F82400 		strb	r0, [r5, #36]
2842:Src/mpu6050.c ****         /* Enable DMP interrupt. */
ARM GAS  /tmp/ccC60hwS.s 			page 173


2843:Src/mpu6050.c ****         set_int_enable(1);
 5446              		.loc 1 2843 9 is_stmt 1 view .LVU1652
 5447 0044 FFF7FEFF 		bl	set_int_enable.isra.0
 5448              	.LVL345:
2844:Src/mpu6050.c ****         mpu_reset_fifo();
 5449              		.loc 1 2844 9 view .LVU1653
 5450              	.L467:
 5451              		.loc 1 2844 9 is_stmt 0 view .LVU1654
 5452              	.LBE11:
 5453              	.LBE10:
2845:Src/mpu6050.c ****     } else {
2846:Src/mpu6050.c ****         /* Disable DMP interrupt. */
2847:Src/mpu6050.c ****         set_int_enable(0);
2848:Src/mpu6050.c ****         /* Restore FIFO settings. */
2849:Src/mpu6050.c ****         tmp = st.chip_cfg.fifo_enable;
2850:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
2851:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
2852:Src/mpu6050.c ****         mpu_reset_fifo();
 5454              		.loc 1 2852 9 is_stmt 1 view .LVU1655
 5455 0048 FFF7FEFF 		bl	mpu_reset_fifo
 5456              	.LVL346:
 5457              	.L465:
2827:Src/mpu6050.c **** 
 5458              		.loc 1 2827 16 is_stmt 0 view .LVU1656
 5459 004c 0020     		movs	r0, #0
 5460              	.L462:
2853:Src/mpu6050.c ****     }
2854:Src/mpu6050.c ****     return 0;
2855:Src/mpu6050.c **** }
 5461              		.loc 1 2855 1 view .LVU1657
 5462 004e 03B0     		add	sp, sp, #12
 5463              	.LCFI91:
 5464              		.cfi_remember_state
 5465              		.cfi_def_cfa_offset 12
 5466              		@ sp needed
 5467 0050 30BD     		pop	{r4, r5, pc}
 5468              	.LVL347:
 5469              	.L464:
 5470              	.LCFI92:
 5471              		.cfi_restore_state
2847:Src/mpu6050.c ****         /* Restore FIFO settings. */
 5472              		.loc 1 2847 9 is_stmt 1 view .LVU1658
 5473 0052 FFF7FEFF 		bl	set_int_enable.isra.0
 5474              	.LVL348:
2849:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5475              		.loc 1 2849 9 view .LVU1659
2849:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5476              		.loc 1 2849 13 is_stmt 0 view .LVU1660
 5477 0056 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
2850:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
 5478              		.loc 1 2850 9 view .LVU1661
 5479 0058 6868     		ldr	r0, [r5, #4]
2849:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5480              		.loc 1 2849 13 view .LVU1662
 5481 005a 8DF80730 		strb	r3, [sp, #7]
2850:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
 5482              		.loc 1 2850 9 is_stmt 1 view .LVU1663
ARM GAS  /tmp/ccC60hwS.s 			page 174


 5483 005e 0122     		movs	r2, #1
 5484 0060 2321     		movs	r1, #35
 5485 0062 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5486 0064 0DF10703 		add	r3, sp, #7
 5487 0068 FFF7FEFF 		bl	i2c_writeBytes
 5488              	.LVL349:
2851:Src/mpu6050.c ****         mpu_reset_fifo();
 5489              		.loc 1 2851 9 view .LVU1664
2851:Src/mpu6050.c ****         mpu_reset_fifo();
 5490              		.loc 1 2851 28 is_stmt 0 view .LVU1665
 5491 006c 85F82440 		strb	r4, [r5, #36]
 5492 0070 EAE7     		b	.L467
 5493              	.LVL350:
 5494              	.L466:
2831:Src/mpu6050.c ****         /* Disable data ready interrupt. */
 5495              		.loc 1 2831 20 view .LVU1666
 5496 0072 4FF0FF30 		mov	r0, #-1
 5497              	.LVL351:
2831:Src/mpu6050.c ****         /* Disable data ready interrupt. */
 5498              		.loc 1 2831 20 view .LVU1667
 5499 0076 EAE7     		b	.L462
 5500              	.L469:
 5501              		.align	2
 5502              	.L468:
 5503 0078 00000000 		.word	.LANCHOR0
 5504              		.cfi_endproc
 5505              	.LFE104:
 5507              		.global	__aeabi_fcmpeq
 5508              		.global	__aeabi_fcmpgt
 5509              		.global	__aeabi_fcmplt
 5510              		.section	.text.mpu_run_self_test,"ax",%progbits
 5511              		.align	1
 5512              		.global	mpu_run_self_test
 5513              		.syntax unified
 5514              		.thumb
 5515              		.thumb_func
 5516              		.fpu softvfp
 5518              	mpu_run_self_test:
 5519              	.LVL352:
 5520              	.LFB100:
2614:Src/mpu6050.c **** #ifdef MPU6050
 5521              		.loc 1 2614 1 is_stmt 1 view -0
 5522              		.cfi_startproc
 5523              		@ args = 0, pretend = 0, frame = 80
 5524              		@ frame_needed = 0, uses_anonymous_args = 0
2616:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
 5525              		.loc 1 2616 5 view .LVU1669
2617:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
 5526              		.loc 1 2617 5 view .LVU1670
2618:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 5527              		.loc 1 2618 5 view .LVU1671
2622:Src/mpu6050.c **** #endif
 5528              		.loc 1 2622 5 view .LVU1672
2624:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
 5529              		.loc 1 2624 5 view .LVU1673
2625:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
 5530              		.loc 1 2625 5 view .LVU1674
ARM GAS  /tmp/ccC60hwS.s 			page 175


2626:Src/mpu6050.c ****     unsigned char dmp_was_on;
 5531              		.loc 1 2626 5 view .LVU1675
2627:Src/mpu6050.c **** 
 5532              		.loc 1 2627 5 view .LVU1676
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5533              		.loc 1 2629 5 view .LVU1677
2614:Src/mpu6050.c **** #ifdef MPU6050
 5534              		.loc 1 2614 1 is_stmt 0 view .LVU1678
 5535 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5536              	.LCFI93:
 5537              		.cfi_def_cfa_offset 36
 5538              		.cfi_offset 4, -36
 5539              		.cfi_offset 5, -32
 5540              		.cfi_offset 6, -28
 5541              		.cfi_offset 7, -24
 5542              		.cfi_offset 8, -20
 5543              		.cfi_offset 9, -16
 5544              		.cfi_offset 10, -12
 5545              		.cfi_offset 11, -8
 5546              		.cfi_offset 14, -4
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5547              		.loc 1 2629 20 view .LVU1679
 5548 0004 B94C     		ldr	r4, .L534
2614:Src/mpu6050.c **** #ifdef MPU6050
 5549              		.loc 1 2614 1 view .LVU1680
 5550 0006 95B0     		sub	sp, sp, #84
 5551              	.LCFI94:
 5552              		.cfi_def_cfa_offset 120
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5553              		.loc 1 2629 20 view .LVU1681
 5554 0008 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
2614:Src/mpu6050.c **** #ifdef MPU6050
 5555              		.loc 1 2614 1 view .LVU1682
 5556 000c 0746     		mov	r7, r0
 5557 000e 8846     		mov	r8, r1
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5558              		.loc 1 2629 20 view .LVU1683
 5559 0010 0093     		str	r3, [sp]
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5560              		.loc 1 2629 8 view .LVU1684
 5561 0012 23B1     		cbz	r3, .L471
2630:Src/mpu6050.c ****         dmp_was_on = 1;
 5562              		.loc 1 2630 9 is_stmt 1 view .LVU1685
 5563 0014 0020     		movs	r0, #0
 5564              	.LVL353:
2630:Src/mpu6050.c ****         dmp_was_on = 1;
 5565              		.loc 1 2630 9 is_stmt 0 view .LVU1686
 5566 0016 FFF7FEFF 		bl	mpu_set_dmp_state
 5567              	.LVL354:
2631:Src/mpu6050.c ****     } else
 5568              		.loc 1 2631 9 is_stmt 1 view .LVU1687
2631:Src/mpu6050.c ****     } else
 5569              		.loc 1 2631 20 is_stmt 0 view .LVU1688
 5570 001a 0123     		movs	r3, #1
 5571 001c 0093     		str	r3, [sp]
 5572              	.LVL355:
 5573              	.L471:
ARM GAS  /tmp/ccC60hwS.s 			page 176


2636:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
 5574              		.loc 1 2636 5 is_stmt 1 view .LVU1689
 5575 001e 0DF11E00 		add	r0, sp, #30
 5576 0022 FFF7FEFF 		bl	mpu_get_gyro_fsr
 5577              	.LVL356:
2637:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
 5578              		.loc 1 2637 5 view .LVU1690
 5579 0026 0DF11D00 		add	r0, sp, #29
 5580 002a FFF7FEFF 		bl	mpu_get_accel_fsr
 5581              	.LVL357:
2638:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
 5582              		.loc 1 2638 5 view .LVU1691
 5583 002e 0DF12200 		add	r0, sp, #34
 5584 0032 FFF7FEFF 		bl	mpu_get_lpf
 5585              	.LVL358:
2639:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
 5586              		.loc 1 2639 5 view .LVU1692
 5587 0036 08A8     		add	r0, sp, #32
 5588 0038 FFF7FEFF 		bl	mpu_get_sample_rate
 5589              	.LVL359:
2640:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5590              		.loc 1 2640 5 view .LVU1693
2640:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5591              		.loc 1 2640 16 is_stmt 0 view .LVU1694
 5592 003c A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
2646:Src/mpu6050.c ****             break;
 5593              		.loc 1 2646 14 view .LVU1695
 5594 003e 0022     		movs	r2, #0
2640:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5595              		.loc 1 2640 16 view .LVU1696
 5596 0040 0393     		str	r3, [sp, #12]
 5597              	.LVL360:
2641:Src/mpu6050.c **** 
 5598              		.loc 1 2641 5 is_stmt 1 view .LVU1697
 5599              	.LBB20:
 5600              	.LBI20:
1484:Src/mpu6050.c **** {
 5601              		.loc 1 1484 5 view .LVU1698
 5602              	.LBB21:
1486:Src/mpu6050.c ****     return 0;
 5603              		.loc 1 1486 5 view .LVU1699
1486:Src/mpu6050.c ****     return 0;
 5604              		.loc 1 1486 29 is_stmt 0 view .LVU1700
 5605 0042 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 5606              	.LBE21:
 5607              	.LBE20:
2646:Src/mpu6050.c ****             break;
 5608              		.loc 1 2646 14 view .LVU1701
 5609 0044 4146     		mov	r1, r8
 5610 0046 3846     		mov	r0, r7
 5611              	.LBB23:
 5612              	.LBB22:
1486:Src/mpu6050.c ****     return 0;
 5613              		.loc 1 1486 29 view .LVU1702
 5614 0048 0493     		str	r3, [sp, #16]
 5615              	.LVL361:
1487:Src/mpu6050.c **** }
ARM GAS  /tmp/ccC60hwS.s 			page 177


 5616              		.loc 1 1487 5 is_stmt 1 view .LVU1703
1487:Src/mpu6050.c **** }
 5617              		.loc 1 1487 5 is_stmt 0 view .LVU1704
 5618              	.LBE22:
 5619              	.LBE23:
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5620              		.loc 1 2645 5 is_stmt 1 view .LVU1705
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5621              		.loc 1 2645 18 view .LVU1706
2646:Src/mpu6050.c ****             break;
 5622              		.loc 1 2646 9 view .LVU1707
2646:Src/mpu6050.c ****             break;
 5623              		.loc 1 2646 14 is_stmt 0 view .LVU1708
 5624 004a FFF7FEFF 		bl	get_st_biases
 5625              	.LVL362:
2646:Src/mpu6050.c ****             break;
 5626              		.loc 1 2646 12 view .LVU1709
 5627 004e 0028     		cmp	r0, #0
 5628 0050 40F08B80 		bne	.L472
 5629              	.LVL363:
 5630              	.L475:
2655:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5631              		.loc 1 2655 18 is_stmt 1 view .LVU1710
2656:Src/mpu6050.c ****             break;
 5632              		.loc 1 2656 9 view .LVU1711
2656:Src/mpu6050.c ****             break;
 5633              		.loc 1 2656 14 is_stmt 0 view .LVU1712
 5634 0054 0122     		movs	r2, #1
 5635 0056 0EA9     		add	r1, sp, #56
 5636 0058 0BA8     		add	r0, sp, #44
 5637 005a FFF7FEFF 		bl	get_st_biases
 5638              	.LVL364:
2656:Src/mpu6050.c ****             break;
 5639              		.loc 1 2656 12 view .LVU1713
 5640 005e 0028     		cmp	r0, #0
 5641 0060 40F0B480 		bne	.L526
 5642              	.LVL365:
 5643              	.L473:
2663:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5644              		.loc 1 2663 5 is_stmt 1 view .LVU1714
 5645              	.LBB24:
 5646              	.LBI24:
1895:Src/mpu6050.c **** {
 5647              		.loc 1 1895 12 view .LVU1715
 5648              	.LBB25:
1897:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
 5649              		.loc 1 1897 5 view .LVU1716
1898:Src/mpu6050.c **** 
 5650              		.loc 1 1898 5 view .LVU1717
1900:Src/mpu6050.c ****     for(jj = 0; jj < 3; jj++) {
 5651              		.loc 1 1900 5 view .LVU1718
 5652              	.LBB26:
 5653              	.LBI26:
1870:Src/mpu6050.c **** {
 5654              		.loc 1 1870 12 view .LVU1719
 5655              	.LBB27:
1872:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 178


 5656              		.loc 1 1872 5 view .LVU1720
1874:Src/mpu6050.c ****         return 0x07;
 5657              		.loc 1 1874 5 view .LVU1721
1874:Src/mpu6050.c ****         return 0x07;
 5658              		.loc 1 1874 9 is_stmt 0 view .LVU1722
 5659 0064 6068     		ldr	r0, [r4, #4]
 5660 0066 0422     		movs	r2, #4
 5661 0068 0D21     		movs	r1, #13
 5662 006a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5663 006c 0AAB     		add	r3, sp, #40
 5664 006e FFF7FEFF 		bl	i2c_readBytes
 5665              	.LVL366:
1874:Src/mpu6050.c ****         return 0x07;
 5666              		.loc 1 1874 8 view .LVU1723
 5667 0072 0546     		mov	r5, r0
 5668 0074 0028     		cmp	r0, #0
 5669 0076 00F0B180 		beq	.L527
 5670              	.L477:
 5671              	.LVL367:
1874:Src/mpu6050.c ****         return 0x07;
 5672              		.loc 1 1874 8 view .LVU1724
 5673              	.LBE27:
 5674              	.LBE26:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5675              		.loc 1 1901 17 is_stmt 1 view .LVU1725
1897:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
 5676              		.loc 1 1897 13 is_stmt 0 view .LVU1726
 5677 007a 0026     		movs	r6, #0
1909:Src/mpu6050.c ****     }
 5678              		.loc 1 1909 25 view .LVU1727
 5679 007c 4FF00109 		mov	r9, #1
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5680              		.loc 1 1901 12 view .LVU1728
 5681 0080 3546     		mov	r5, r6
 5682 0082 0EAB     		add	r3, sp, #56
 5683              	.LVL368:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5684              		.loc 1 1901 12 view .LVU1729
 5685 0084 0293     		str	r3, [sp, #8]
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5686              		.loc 1 1905 16 view .LVU1730
 5687 0086 DFF868B2 		ldr	fp, .L534+4
 5688 008a 11AB     		add	r3, sp, #68
 5689              	.LVL369:
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5690              		.loc 1 1905 16 view .LVU1731
 5691 008c 0193     		str	r3, [sp, #4]
 5692              	.LVL370:
 5693              	.L480:
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5694              		.loc 1 1902 9 is_stmt 1 view .LVU1732
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5695              		.loc 1 1902 56 is_stmt 0 view .LVU1733
 5696 008e 029A     		ldr	r2, [sp, #8]
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5697              		.loc 1 1902 47 view .LVU1734
 5698 0090 58F82500 		ldr	r0, [r8, r5, lsl #2]
ARM GAS  /tmp/ccC60hwS.s 			page 179


1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5699              		.loc 1 1902 56 view .LVU1735
 5700 0094 52F8043B 		ldr	r3, [r2], #4
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5701              		.loc 1 1902 47 view .LVU1736
 5702 0098 C01A     		subs	r0, r0, r3
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5703              		.loc 1 1902 62 view .LVU1737
 5704 009a 0028     		cmp	r0, #0
 5705 009c B8BF     		it	lt
 5706 009e 4042     		rsblt	r0, r0, #0
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5707              		.loc 1 1902 56 view .LVU1738
 5708 00a0 0292     		str	r2, [sp, #8]
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5709              		.loc 1 1902 62 view .LVU1739
 5710 00a2 FFF7FEFF 		bl	__aeabi_i2f
 5711              	.LVL371:
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5712              		.loc 1 1902 23 view .LVU1740
 5713 00a6 4FF05E51 		mov	r1, #931135488
 5714 00aa FFF7FEFF 		bl	__aeabi_fmul
 5715              	.LVL372:
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5716              		.loc 1 1903 21 view .LVU1741
 5717 00ae 019B     		ldr	r3, [sp, #4]
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5718              		.loc 1 1902 23 view .LVU1742
 5719 00b0 8246     		mov	r10, r0
 5720              	.LVL373:
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5721              		.loc 1 1903 9 is_stmt 1 view .LVU1743
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5722              		.loc 1 1903 21 is_stmt 0 view .LVU1744
 5723 00b2 53F8042B 		ldr	r2, [r3], #4	@ float
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5724              		.loc 1 1903 12 view .LVU1745
 5725 00b6 0021     		movs	r1, #0
 5726 00b8 1046     		mov	r0, r2
 5727              	.LVL374:
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5728              		.loc 1 1903 21 view .LVU1746
 5729 00ba 0193     		str	r3, [sp, #4]
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5730              		.loc 1 1903 12 view .LVU1747
 5731 00bc 0592     		str	r2, [sp, #20]
 5732 00be FFF7FEFF 		bl	__aeabi_fcmpeq
 5733              	.LVL375:
 5734 00c2 0028     		cmp	r0, #0
 5735 00c4 40F0D280 		bne	.L528
1904:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5736              		.loc 1 1904 13 is_stmt 1 view .LVU1748
 5737              	.LVL376:
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5738              		.loc 1 1905 13 view .LVU1749
1904:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5739              		.loc 1 1904 42 is_stmt 0 view .LVU1750
ARM GAS  /tmp/ccC60hwS.s 			page 180


 5740 00c8 059A     		ldr	r2, [sp, #20]
 5741 00ca 5046     		mov	r0, r10
 5742 00cc 1146     		mov	r1, r2
 5743 00ce FFF7FEFF 		bl	__aeabi_fdiv
 5744              	.LVL377:
1904:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5745              		.loc 1 1904 26 view .LVU1751
 5746 00d2 4FF07E51 		mov	r1, #1065353216
 5747 00d6 FFF7FEFF 		bl	__aeabi_fsub
 5748              	.LVL378:
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5749              		.loc 1 1905 16 view .LVU1752
 5750 00da 5946     		mov	r1, fp
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5751              		.loc 1 1905 17 view .LVU1753
 5752 00dc 20F00040 		bic	r0, r0, #-2147483648
 5753              	.LVL379:
 5754              	.L531:
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 5755              		.loc 1 1907 49 view .LVU1754
 5756 00e0 FFF7FEFF 		bl	__aeabi_fcmpgt
 5757              	.LVL380:
 5758 00e4 10B1     		cbz	r0, .L488
 5759              	.L490:
1909:Src/mpu6050.c ****     }
 5760              		.loc 1 1909 13 is_stmt 1 view .LVU1755
1909:Src/mpu6050.c ****     }
 5761              		.loc 1 1909 25 is_stmt 0 view .LVU1756
 5762 00e6 09FA05F3 		lsl	r3, r9, r5
1909:Src/mpu6050.c ****     }
 5763              		.loc 1 1909 20 view .LVU1757
 5764 00ea 1E43     		orrs	r6, r6, r3
 5765              	.LVL381:
 5766              	.L488:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5767              		.loc 1 1901 25 is_stmt 1 view .LVU1758
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5768              		.loc 1 1901 27 is_stmt 0 view .LVU1759
 5769 00ec 0135     		adds	r5, r5, #1
 5770              	.LVL382:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5771              		.loc 1 1901 17 is_stmt 1 view .LVU1760
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5772              		.loc 1 1901 5 is_stmt 0 view .LVU1761
 5773 00ee 032D     		cmp	r5, #3
 5774 00f0 CDD1     		bne	.L480
1912:Src/mpu6050.c **** }
 5775              		.loc 1 1912 5 is_stmt 1 view .LVU1762
 5776              	.LVL383:
1912:Src/mpu6050.c **** }
 5777              		.loc 1 1912 5 is_stmt 0 view .LVU1763
 5778              	.LBE25:
 5779              	.LBE24:
 5780              	.LBB31:
 5781              	.LBB32:
1921:Src/mpu6050.c ****         return 0x07;
 5782              		.loc 1 1921 9 view .LVU1764
ARM GAS  /tmp/ccC60hwS.s 			page 181


 5783 00f2 6068     		ldr	r0, [r4, #4]
 5784              	.LBE32:
 5785              	.LBE31:
2663:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5786              		.loc 1 2663 18 view .LVU1765
 5787 00f4 F3B2     		uxtb	r3, r6
 5788              	.LBB37:
 5789              	.LBB33:
1921:Src/mpu6050.c ****         return 0x07;
 5790              		.loc 1 1921 9 view .LVU1766
 5791 00f6 2A46     		mov	r2, r5
 5792              	.LBE33:
 5793              	.LBE37:
2663:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5794              		.loc 1 2663 18 view .LVU1767
 5795 00f8 0193     		str	r3, [sp, #4]
 5796              	.LVL384:
2664:Src/mpu6050.c **** 
 5797              		.loc 1 2664 5 is_stmt 1 view .LVU1768
 5798              	.LBB38:
 5799              	.LBI31:
1915:Src/mpu6050.c **** {
 5800              		.loc 1 1915 12 view .LVU1769
 5801              	.LBB34:
1917:Src/mpu6050.c ****     unsigned char tmp[3];
 5802              		.loc 1 1917 5 view .LVU1770
1918:Src/mpu6050.c ****     float st_shift, st_shift_cust, st_shift_var;
 5803              		.loc 1 1918 5 view .LVU1771
1919:Src/mpu6050.c **** 
 5804              		.loc 1 1919 5 view .LVU1772
1921:Src/mpu6050.c ****         return 0x07;
 5805              		.loc 1 1921 5 view .LVU1773
1921:Src/mpu6050.c ****         return 0x07;
 5806              		.loc 1 1921 9 is_stmt 0 view .LVU1774
 5807 00fa 0D21     		movs	r1, #13
 5808 00fc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5809 00fe 11AB     		add	r3, sp, #68
 5810 0100 FFF7FEFF 		bl	i2c_readBytes
 5811              	.LVL385:
1921:Src/mpu6050.c ****         return 0x07;
 5812              		.loc 1 1921 8 view .LVU1775
 5813 0104 0546     		mov	r5, r0
 5814 0106 0028     		cmp	r0, #0
 5815 0108 40F0ED80 		bne	.L503
1924:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5816              		.loc 1 1924 5 is_stmt 1 view .LVU1776
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5817              		.loc 1 1928 13 is_stmt 0 view .LVU1777
 5818 010c 0646     		mov	r6, r0
1939:Src/mpu6050.c ****     }
 5819              		.loc 1 1939 25 view .LVU1778
 5820 010e 4FF00109 		mov	r9, #1
1924:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5821              		.loc 1 1924 12 view .LVU1779
 5822 0112 9DF84430 		ldrb	r3, [sp, #68]	@ zero_extendqisi2
 5823 0116 0DF12C0A 		add	r10, sp, #44
 5824              	.LVL386:
ARM GAS  /tmp/ccC60hwS.s 			page 182


1924:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5825              		.loc 1 1924 12 view .LVU1780
 5826 011a 03F01F03 		and	r3, r3, #31
 5827 011e 8DF84430 		strb	r3, [sp, #68]
1925:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5828              		.loc 1 1925 5 is_stmt 1 view .LVU1781
1925:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5829              		.loc 1 1925 12 is_stmt 0 view .LVU1782
 5830 0122 9DF84530 		ldrb	r3, [sp, #69]	@ zero_extendqisi2
 5831 0126 0DF14408 		add	r8, sp, #68
 5832              	.LVL387:
1925:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5833              		.loc 1 1925 12 view .LVU1783
 5834 012a 03F01F03 		and	r3, r3, #31
 5835 012e 8DF84530 		strb	r3, [sp, #69]
1926:Src/mpu6050.c **** 
 5836              		.loc 1 1926 5 is_stmt 1 view .LVU1784
1926:Src/mpu6050.c **** 
 5837              		.loc 1 1926 12 is_stmt 0 view .LVU1785
 5838 0132 9DF84630 		ldrb	r3, [sp, #70]	@ zero_extendqisi2
 5839 0136 03F01F03 		and	r3, r3, #31
 5840 013a 8DF84630 		strb	r3, [sp, #70]
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5841              		.loc 1 1928 5 is_stmt 1 view .LVU1786
 5842              	.LVL388:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5843              		.loc 1 1928 18 view .LVU1787
 5844              	.L500:
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 5845              		.loc 1 1929 9 view .LVU1788
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 5846              		.loc 1 1929 56 is_stmt 0 view .LVU1789
 5847 013e 5AF8043B 		ldr	r3, [r10], #4
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 5848              		.loc 1 1929 47 view .LVU1790
 5849 0142 57F82600 		ldr	r0, [r7, r6, lsl #2]
 5850 0146 C01A     		subs	r0, r0, r3
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 5851              		.loc 1 1929 62 view .LVU1791
 5852 0148 0028     		cmp	r0, #0
 5853 014a B8BF     		it	lt
 5854 014c 4042     		rsblt	r0, r0, #0
 5855 014e FFF7FEFF 		bl	__aeabi_i2f
 5856              	.LVL389:
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 5857              		.loc 1 1929 23 view .LVU1792
 5858 0152 4FF05E51 		mov	r1, #931135488
 5859 0156 FFF7FEFF 		bl	__aeabi_fmul
 5860              	.LVL390:
1930:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 5861              		.loc 1 1930 16 view .LVU1793
 5862 015a 18F8013B 		ldrb	r3, [r8], #1	@ zero_extendqisi2
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 5863              		.loc 1 1929 23 view .LVU1794
 5864 015e 8346     		mov	fp, r0
 5865              	.LVL391:
1930:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
ARM GAS  /tmp/ccC60hwS.s 			page 183


 5866              		.loc 1 1930 9 is_stmt 1 view .LVU1795
1930:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 5867              		.loc 1 1930 12 is_stmt 0 view .LVU1796
 5868 0160 002B     		cmp	r3, #0
 5869 0162 00F0B880 		beq	.L529
1931:Src/mpu6050.c ****             while (--tmp[jj])
 5870              		.loc 1 1931 22 view .LVU1797
 5871 0166 6348     		ldr	r0, .L534+8
 5872              	.LVL392:
1931:Src/mpu6050.c ****             while (--tmp[jj])
 5873              		.loc 1 1931 22 view .LVU1798
 5874 0168 8FE0     		b	.L493
 5875              	.LVL393:
 5876              	.L472:
1931:Src/mpu6050.c ****             while (--tmp[jj])
 5877              		.loc 1 1931 22 view .LVU1799
 5878              	.LBE34:
 5879              	.LBE38:
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5880              		.loc 1 2645 30 is_stmt 1 view .LVU1800
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5881              		.loc 1 2645 18 view .LVU1801
2646:Src/mpu6050.c ****             break;
 5882              		.loc 1 2646 9 view .LVU1802
2646:Src/mpu6050.c ****             break;
 5883              		.loc 1 2646 14 is_stmt 0 view .LVU1803
 5884 016a 0022     		movs	r2, #0
 5885 016c 4146     		mov	r1, r8
 5886 016e 3846     		mov	r0, r7
 5887 0170 FFF7FEFF 		bl	get_st_biases
 5888              	.LVL394:
2646:Src/mpu6050.c ****             break;
 5889              		.loc 1 2646 12 view .LVU1804
 5890 0174 0028     		cmp	r0, #0
 5891 0176 3FF46DAF 		beq	.L475
 5892              	.L479:
2652:Src/mpu6050.c ****         goto restore;
 5893              		.loc 1 2652 16 view .LVU1805
 5894 017a 0025     		movs	r5, #0
 5895              	.LVL395:
 5896              	.L476:
2688:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5897              		.loc 1 2688 5 is_stmt 1 view .LVU1806
2689:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 5898              		.loc 1 2689 5 view .LVU1807
2690:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 5899              		.loc 1 2690 5 view .LVU1808
2691:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 5900              		.loc 1 2691 5 view .LVU1809
2691:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 5901              		.loc 1 2691 29 is_stmt 0 view .LVU1810
 5902 017c 4FF6FF73 		movw	r3, #65535
2694:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 5903              		.loc 1 2694 25 view .LVU1811
 5904 0180 0126     		movs	r6, #1
2691:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 5905              		.loc 1 2691 29 view .LVU1812
ARM GAS  /tmp/ccC60hwS.s 			page 184


 5906 0182 E381     		strh	r3, [r4, #14]	@ movhi
2692:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 5907              		.loc 1 2692 5 is_stmt 1 view .LVU1813
2693:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 5908              		.loc 1 2693 5 view .LVU1814
2693:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 5909              		.loc 1 2693 29 is_stmt 0 view .LVU1815
 5910 0184 2374     		strb	r3, [r4, #16]
2694:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 5911              		.loc 1 2694 5 is_stmt 1 view .LVU1816
2688:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5912              		.loc 1 2688 26 is_stmt 0 view .LVU1817
 5913 0186 4FF0FF33 		mov	r3, #-1
2695:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
 5914              		.loc 1 2695 5 view .LVU1818
 5915 018a BDF81E00 		ldrh	r0, [sp, #30]
2688:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5916              		.loc 1 2688 26 view .LVU1819
 5917 018e A360     		str	r3, [r4, #8]
2694:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 5918              		.loc 1 2694 25 view .LVU1820
 5919 0190 2673     		strb	r6, [r4, #12]
2695:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
 5920              		.loc 1 2695 5 is_stmt 1 view .LVU1821
 5921 0192 FFF7FEFF 		bl	mpu_set_gyro_fsr
 5922              	.LVL396:
2696:Src/mpu6050.c ****     mpu_set_lpf(lpf);
 5923              		.loc 1 2696 5 view .LVU1822
 5924 0196 9DF81D00 		ldrb	r0, [sp, #29]	@ zero_extendqisi2
 5925 019a FFF7FEFF 		bl	mpu_set_accel_fsr
 5926              	.LVL397:
2697:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
 5927              		.loc 1 2697 5 view .LVU1823
 5928 019e BDF82200 		ldrh	r0, [sp, #34]
 5929 01a2 FFF7FEFF 		bl	mpu_set_lpf
 5930              	.LVL398:
2698:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
 5931              		.loc 1 2698 5 view .LVU1824
 5932 01a6 BDF82000 		ldrh	r0, [sp, #32]
 5933 01aa FFF7FEFF 		bl	mpu_set_sample_rate
 5934              	.LVL399:
2699:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
 5935              		.loc 1 2699 5 view .LVU1825
 5936 01ae 0398     		ldr	r0, [sp, #12]
 5937 01b0 FFF7FEFF 		bl	mpu_set_sensors
 5938              	.LVL400:
2700:Src/mpu6050.c **** 
 5939              		.loc 1 2700 5 view .LVU1826
 5940 01b4 0498     		ldr	r0, [sp, #16]
 5941 01b6 FFF7FEFF 		bl	mpu_configure_fifo
 5942              	.LVL401:
2702:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 5943              		.loc 1 2702 5 view .LVU1827
2702:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 5944              		.loc 1 2702 8 is_stmt 0 view .LVU1828
 5945 01ba 009B     		ldr	r3, [sp]
 5946 01bc 13B1     		cbz	r3, .L470
ARM GAS  /tmp/ccC60hwS.s 			page 185


2703:Src/mpu6050.c **** 
 5947              		.loc 1 2703 9 is_stmt 1 view .LVU1829
 5948 01be 3046     		mov	r0, r6
 5949 01c0 FFF7FEFF 		bl	mpu_set_dmp_state
 5950              	.LVL402:
2705:Src/mpu6050.c **** }
 5951              		.loc 1 2705 5 view .LVU1830
 5952              	.L470:
2706:Src/mpu6050.c **** 
 5953              		.loc 1 2706 1 is_stmt 0 view .LVU1831
 5954 01c4 2846     		mov	r0, r5
 5955 01c6 15B0     		add	sp, sp, #84
 5956              	.LCFI95:
 5957              		.cfi_remember_state
 5958              		.cfi_def_cfa_offset 36
 5959              	.LVL403:
2706:Src/mpu6050.c **** 
 5960              		.loc 1 2706 1 view .LVU1832
 5961              		@ sp needed
 5962 01c8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5963              	.LVL404:
 5964              	.L526:
 5965              	.LCFI96:
 5966              		.cfi_restore_state
2655:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5967              		.loc 1 2655 30 is_stmt 1 view .LVU1833
2655:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5968              		.loc 1 2655 18 view .LVU1834
2656:Src/mpu6050.c ****             break;
 5969              		.loc 1 2656 9 view .LVU1835
2656:Src/mpu6050.c ****             break;
 5970              		.loc 1 2656 14 is_stmt 0 view .LVU1836
 5971 01cc 0122     		movs	r2, #1
 5972 01ce 0EA9     		add	r1, sp, #56
 5973 01d0 0BA8     		add	r0, sp, #44
 5974 01d2 FFF7FEFF 		bl	get_st_biases
 5975              	.LVL405:
2656:Src/mpu6050.c ****             break;
 5976              		.loc 1 2656 12 view .LVU1837
 5977 01d6 0028     		cmp	r0, #0
 5978 01d8 CFD1     		bne	.L479
 5979 01da 43E7     		b	.L473
 5980              	.LVL406:
 5981              	.L527:
 5982              	.LBB39:
 5983              	.LBB30:
 5984              	.LBB29:
 5985              	.LBB28:
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5986              		.loc 1 1877 5 is_stmt 1 view .LVU1838
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5987              		.loc 1 1877 38 is_stmt 0 view .LVU1839
 5988 01dc 9DF82830 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5989              		.loc 1 1877 51 view .LVU1840
 5990 01e0 9DF82B10 		ldrb	r1, [sp, #43]	@ zero_extendqisi2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
ARM GAS  /tmp/ccC60hwS.s 			page 186


 5991              		.loc 1 1877 38 view .LVU1841
 5992 01e4 DB10     		asrs	r3, r3, #3
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5993              		.loc 1 1877 63 view .LVU1842
 5994 01e6 C1F30112 		ubfx	r2, r1, #4, #2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5995              		.loc 1 1877 38 view .LVU1843
 5996 01ea 03F01C03 		and	r3, r3, #28
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5997              		.loc 1 1877 44 view .LVU1844
 5998 01ee 1343     		orrs	r3, r3, r2
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 5999              		.loc 1 1878 38 view .LVU1845
 6000 01f0 9DF82920 		ldrb	r2, [sp, #41]	@ zero_extendqisi2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6001              		.loc 1 1877 19 view .LVU1846
 6002 01f4 8DF82430 		strb	r3, [sp, #36]
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6003              		.loc 1 1878 5 is_stmt 1 view .LVU1847
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6004              		.loc 1 1878 38 is_stmt 0 view .LVU1848
 6005 01f8 D210     		asrs	r2, r2, #3
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6006              		.loc 1 1878 63 view .LVU1849
 6007 01fa C1F38103 		ubfx	r3, r1, #2, #2
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6008              		.loc 1 1878 38 view .LVU1850
 6009 01fe 02F01C02 		and	r2, r2, #28
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6010              		.loc 1 1878 44 view .LVU1851
 6011 0202 1A43     		orrs	r2, r2, r3
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6012              		.loc 1 1879 38 view .LVU1852
 6013 0204 9DF82A30 		ldrb	r3, [sp, #42]	@ zero_extendqisi2
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6014              		.loc 1 1879 54 view .LVU1853
 6015 0208 01F00301 		and	r1, r1, #3
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6016              		.loc 1 1879 38 view .LVU1854
 6017 020c DB10     		asrs	r3, r3, #3
 6018 020e 03F01C03 		and	r3, r3, #28
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6019              		.loc 1 1879 44 view .LVU1855
 6020 0212 0B43     		orrs	r3, r3, r1
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6021              		.loc 1 1879 19 view .LVU1856
 6022 0214 8DF82630 		strb	r3, [sp, #38]
1882:Src/mpu6050.c ****             continue;
 6023              		.loc 1 1882 26 view .LVU1857
 6024 0218 0023     		movs	r3, #0
1888:Src/mpu6050.c ****         while (--shift_code[ii])
 6025              		.loc 1 1888 22 view .LVU1858
 6026 021a DFF8DCB0 		ldr	fp, .L534+12
1890:Src/mpu6050.c ****     }
 6027              		.loc 1 1890 26 view .LVU1859
 6028 021e 3749     		ldr	r1, .L534+16
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
ARM GAS  /tmp/ccC60hwS.s 			page 187


 6029              		.loc 1 1878 19 view .LVU1860
 6030 0220 8DF82520 		strb	r2, [sp, #37]
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6031              		.loc 1 1879 5 is_stmt 1 view .LVU1861
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6032              		.loc 1 1880 5 view .LVU1862
 6033              	.LVL407:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6034              		.loc 1 1880 18 view .LVU1863
 6035 0224 0DF1240A 		add	r10, sp, #36
 6036 0228 0DF14409 		add	r9, sp, #68
 6037              	.LVL408:
 6038              	.L485:
1881:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6039              		.loc 1 1881 9 view .LVU1864
1881:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6040              		.loc 1 1881 24 is_stmt 0 view .LVU1865
 6041 022c 1AF8016B 		ldrb	r6, [r10], #1	@ zero_extendqisi2
1881:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6042              		.loc 1 1881 12 view .LVU1866
 6043 0230 46B9     		cbnz	r6, .L481
1882:Src/mpu6050.c ****             continue;
 6044              		.loc 1 1882 13 is_stmt 1 view .LVU1867
1882:Src/mpu6050.c ****             continue;
 6045              		.loc 1 1882 26 is_stmt 0 view .LVU1868
 6046 0232 C9F80030 		str	r3, [r9]	@ float
1883:Src/mpu6050.c ****         }
 6047              		.loc 1 1883 13 is_stmt 1 view .LVU1869
 6048              	.L482:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6049              		.loc 1 1880 26 view .LVU1870
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6050              		.loc 1 1880 28 is_stmt 0 view .LVU1871
 6051 0236 0135     		adds	r5, r5, #1
 6052              	.LVL409:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6053              		.loc 1 1880 28 view .LVU1872
 6054 0238 EDB2     		uxtb	r5, r5
 6055              	.LVL410:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6056              		.loc 1 1880 18 is_stmt 1 view .LVU1873
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6057              		.loc 1 1880 5 is_stmt 0 view .LVU1874
 6058 023a 032D     		cmp	r5, #3
 6059 023c 09F10409 		add	r9, r9, #4
 6060 0240 F4D1     		bne	.L485
 6061 0242 1AE7     		b	.L477
 6062              	.L481:
1888:Src/mpu6050.c ****         while (--shift_code[ii])
 6063              		.loc 1 1888 9 is_stmt 1 view .LVU1875
1888:Src/mpu6050.c ****         while (--shift_code[ii])
 6064              		.loc 1 1888 22 is_stmt 0 view .LVU1876
 6065 0244 C9F800B0 		str	fp, [r9]	@ float
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6066              		.loc 1 1889 9 is_stmt 1 view .LVU1877
 6067              	.L483:
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
ARM GAS  /tmp/ccC60hwS.s 			page 188


 6068              		.loc 1 1889 15 view .LVU1878
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6069              		.loc 1 1889 16 is_stmt 0 view .LVU1879
 6070 0248 013E     		subs	r6, r6, #1
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6071              		.loc 1 1889 15 view .LVU1880
 6072 024a 16F0FF06 		ands	r6, r6, #255
 6073 024e 02D1     		bne	.L484
 6074 0250 0AF8016C 		strb	r6, [r10, #-1]
 6075 0254 EFE7     		b	.L482
 6076              	.L484:
1890:Src/mpu6050.c ****     }
 6077              		.loc 1 1890 26 view .LVU1881
 6078 0256 D9F80000 		ldr	r0, [r9]	@ float
 6079 025a CDE90113 		strd	r1, r3, [sp, #4]
 6080 025e FFF7FEFF 		bl	__aeabi_fmul
 6081              	.LVL411:
 6082 0262 DDE90113 		ldrd	r1, r3, [sp, #4]
 6083 0266 C9F80000 		str	r0, [r9]	@ float
 6084 026a EDE7     		b	.L483
 6085              	.LVL412:
 6086              	.L528:
1890:Src/mpu6050.c ****     }
 6087              		.loc 1 1890 26 view .LVU1882
 6088              	.LBE28:
 6089              	.LBE29:
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6090              		.loc 1 1907 16 is_stmt 1 view .LVU1883
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6091              		.loc 1 1907 19 is_stmt 0 view .LVU1884
 6092 026c 5046     		mov	r0, r10
 6093 026e 2449     		ldr	r1, .L534+20
 6094 0270 FFF7FEFF 		bl	__aeabi_fcmplt
 6095              	.LVL413:
 6096 0274 0028     		cmp	r0, #0
 6097 0276 7FF436AF 		bne	.L490
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6098              		.loc 1 1907 49 view .LVU1885
 6099 027a 5046     		mov	r0, r10
 6100 027c 2149     		ldr	r1, .L534+24
 6101 027e 2FE7     		b	.L531
 6102              	.LVL414:
 6103              	.L495:
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6104              		.loc 1 1907 49 view .LVU1886
 6105              	.LBE30:
 6106              	.LBE39:
 6107              	.LBB40:
 6108              	.LBB35:
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6109              		.loc 1 1933 26 view .LVU1887
 6110 0280 2149     		ldr	r1, .L534+28
 6111 0282 0293     		str	r3, [sp, #8]
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6112              		.loc 1 1933 17 is_stmt 1 view .LVU1888
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6113              		.loc 1 1933 26 is_stmt 0 view .LVU1889
ARM GAS  /tmp/ccC60hwS.s 			page 189


 6114 0284 FFF7FEFF 		bl	__aeabi_fmul
 6115              	.LVL415:
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6116              		.loc 1 1933 26 view .LVU1890
 6117 0288 029B     		ldr	r3, [sp, #8]
 6118              	.LVL416:
 6119              	.L493:
1932:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6120              		.loc 1 1932 19 is_stmt 1 view .LVU1891
1932:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6121              		.loc 1 1932 20 is_stmt 0 view .LVU1892
 6122 028a 013B     		subs	r3, r3, #1
1932:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6123              		.loc 1 1932 19 view .LVU1893
 6124 028c 13F0FF03 		ands	r3, r3, #255
 6125 0290 F6D1     		bne	.L495
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6126              		.loc 1 1934 42 view .LVU1894
 6127 0292 0146     		mov	r1, r0
 6128 0294 08F8013C 		strb	r3, [r8, #-1]
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6129              		.loc 1 1934 13 is_stmt 1 view .LVU1895
 6130              	.LVL417:
1935:Src/mpu6050.c ****                 result |= 1 << jj;
 6131              		.loc 1 1935 13 view .LVU1896
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6132              		.loc 1 1934 42 is_stmt 0 view .LVU1897
 6133 0298 5846     		mov	r0, fp
 6134              	.LVL418:
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6135              		.loc 1 1934 42 view .LVU1898
 6136 029a FFF7FEFF 		bl	__aeabi_fdiv
 6137              	.LVL419:
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6138              		.loc 1 1934 26 view .LVU1899
 6139 029e 4FF07E51 		mov	r1, #1065353216
 6140 02a2 FFF7FEFF 		bl	__aeabi_fsub
 6141              	.LVL420:
1935:Src/mpu6050.c ****                 result |= 1 << jj;
 6142              		.loc 1 1935 16 view .LVU1900
 6143 02a6 1249     		ldr	r1, .L534+4
1935:Src/mpu6050.c ****                 result |= 1 << jj;
 6144              		.loc 1 1935 17 view .LVU1901
 6145 02a8 20F00040 		bic	r0, r0, #-2147483648
 6146              	.L533:
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6147              		.loc 1 1937 51 view .LVU1902
 6148 02ac FFF7FEFF 		bl	__aeabi_fcmpgt
 6149              	.LVL421:
 6150 02b0 10B1     		cbz	r0, .L496
 6151              	.L498:
1939:Src/mpu6050.c ****     }
 6152              		.loc 1 1939 13 is_stmt 1 view .LVU1903
1939:Src/mpu6050.c ****     }
 6153              		.loc 1 1939 25 is_stmt 0 view .LVU1904
 6154 02b2 09FA06F3 		lsl	r3, r9, r6
1939:Src/mpu6050.c ****     }
ARM GAS  /tmp/ccC60hwS.s 			page 190


 6155              		.loc 1 1939 20 view .LVU1905
 6156 02b6 1D43     		orrs	r5, r5, r3
 6157              	.LVL422:
 6158              	.L496:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6159              		.loc 1 1928 26 is_stmt 1 view .LVU1906
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6160              		.loc 1 1928 28 is_stmt 0 view .LVU1907
 6161 02b8 0136     		adds	r6, r6, #1
 6162              	.LVL423:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6163              		.loc 1 1928 18 is_stmt 1 view .LVU1908
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6164              		.loc 1 1928 5 is_stmt 0 view .LVU1909
 6165 02ba 032E     		cmp	r6, #3
 6166 02bc 7FF43FAF 		bne	.L500
 6167              	.LVL424:
 6168              	.L492:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6169              		.loc 1 1928 5 view .LVU1910
 6170              	.LBE35:
 6171              	.LBE40:
2666:Src/mpu6050.c ****     if (!gyro_result)
 6172              		.loc 1 2666 5 is_stmt 1 view .LVU1911
2667:Src/mpu6050.c ****         result |= 0x01;
 6173              		.loc 1 2667 5 view .LVU1912
2667:Src/mpu6050.c ****         result |= 0x01;
 6174              		.loc 1 2667 8 is_stmt 0 view .LVU1913
 6175 02c0 EDB2     		uxtb	r5, r5
2667:Src/mpu6050.c ****         result |= 0x01;
 6176              		.loc 1 2667 8 view .LVU1914
 6177 02c2 B5FA85F5 		clz	r5, r5
 6178              	.LVL425:
2669:Src/mpu6050.c ****         result |= 0x02;
 6179              		.loc 1 2669 8 view .LVU1915
 6180 02c6 019B     		ldr	r3, [sp, #4]
2667:Src/mpu6050.c ****         result |= 0x01;
 6181              		.loc 1 2667 8 view .LVU1916
 6182 02c8 6D09     		lsrs	r5, r5, #5
 6183              	.LVL426:
2669:Src/mpu6050.c ****         result |= 0x02;
 6184              		.loc 1 2669 5 is_stmt 1 view .LVU1917
2669:Src/mpu6050.c ****         result |= 0x02;
 6185              		.loc 1 2669 8 is_stmt 0 view .LVU1918
 6186 02ca 0BB9     		cbnz	r3, .L501
2670:Src/mpu6050.c **** 
 6187              		.loc 1 2670 9 is_stmt 1 view .LVU1919
2670:Src/mpu6050.c **** 
 6188              		.loc 1 2670 16 is_stmt 0 view .LVU1920
 6189 02cc 45F00205 		orr	r5, r5, #2
 6190              	.LVL427:
 6191              	.L501:
2677:Src/mpu6050.c **** #endif
 6192              		.loc 1 2677 9 is_stmt 1 view .LVU1921
2677:Src/mpu6050.c **** #endif
 6193              		.loc 1 2677 16 is_stmt 0 view .LVU1922
 6194 02d0 45F00405 		orr	r5, r5, #4
ARM GAS  /tmp/ccC60hwS.s 			page 191


 6195              	.LVL428:
2677:Src/mpu6050.c **** #endif
 6196              		.loc 1 2677 16 view .LVU1923
 6197 02d4 52E7     		b	.L476
 6198              	.LVL429:
 6199              	.L529:
 6200              	.LBB41:
 6201              	.LBB36:
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6202              		.loc 1 1937 16 is_stmt 1 view .LVU1924
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6203              		.loc 1 1937 19 is_stmt 0 view .LVU1925
 6204 02d6 0D49     		ldr	r1, .L534+32
 6205 02d8 FFF7FEFF 		bl	__aeabi_fcmplt
 6206              	.LVL430:
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6207              		.loc 1 1937 19 view .LVU1926
 6208 02dc 0028     		cmp	r0, #0
 6209 02de E8D1     		bne	.L498
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6210              		.loc 1 1937 51 view .LVU1927
 6211 02e0 5846     		mov	r0, fp
 6212 02e2 0B49     		ldr	r1, .L534+36
 6213 02e4 E2E7     		b	.L533
 6214              	.LVL431:
 6215              	.L503:
1922:Src/mpu6050.c **** 
 6216              		.loc 1 1922 16 view .LVU1928
 6217 02e6 0725     		movs	r5, #7
 6218 02e8 EAE7     		b	.L492
 6219              	.L535:
 6220 02ea 00BF     		.align	2
 6221              	.L534:
 6222 02ec 00000000 		.word	.LANCHOR0
 6223 02f0 295C0F3E 		.word	1041194025
 6224 02f4 0000C841 		.word	1103626240
 6225 02f8 7B14AE3E 		.word	1051595899
 6226 02fc 1D5A843F 		.word	1065638429
 6227 0300 9A99993E 		.word	1050253722
 6228 0304 3333733F 		.word	1064514355
 6229 0308 54E3853F 		.word	1065739092
 6230 030c 00002041 		.word	1092616192
 6231 0310 0000D242 		.word	1121058816
 6232              	.LBE36:
 6233              	.LBE41:
 6234              		.cfi_endproc
 6235              	.LFE100:
 6237              		.section	.text.mpu_get_dmp_state,"ax",%progbits
 6238              		.align	1
 6239              		.global	mpu_get_dmp_state
 6240              		.syntax unified
 6241              		.thumb
 6242              		.thumb_func
 6243              		.fpu softvfp
 6245              	mpu_get_dmp_state:
 6246              	.LVL432:
 6247              	.LFB105:
ARM GAS  /tmp/ccC60hwS.s 			page 192


2856:Src/mpu6050.c **** 
2857:Src/mpu6050.c **** /**
2858:Src/mpu6050.c ****  *  @brief      Get DMP state.
2859:Src/mpu6050.c ****  *  @param[out] enabled 1 if enabled.
2860:Src/mpu6050.c ****  *  @return     0 if successful.
2861:Src/mpu6050.c ****  */
2862:Src/mpu6050.c **** int mpu_get_dmp_state(unsigned char *enabled)
2863:Src/mpu6050.c **** {
 6248              		.loc 1 2863 1 is_stmt 1 view -0
 6249              		.cfi_startproc
 6250              		@ args = 0, pretend = 0, frame = 0
 6251              		@ frame_needed = 0, uses_anonymous_args = 0
 6252              		@ link register save eliminated.
2864:Src/mpu6050.c ****     enabled[0] = st.chip_cfg.dmp_on;
 6253              		.loc 1 2864 5 view .LVU1930
 6254              		.loc 1 2864 29 is_stmt 0 view .LVU1931
 6255 0000 024B     		ldr	r3, .L537
 6256 0002 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 6257              		.loc 1 2864 16 view .LVU1932
 6258 0006 0370     		strb	r3, [r0]
2865:Src/mpu6050.c ****     return 0;
 6259              		.loc 1 2865 5 is_stmt 1 view .LVU1933
2866:Src/mpu6050.c **** }
 6260              		.loc 1 2866 1 is_stmt 0 view .LVU1934
 6261 0008 0020     		movs	r0, #0
 6262              	.LVL433:
 6263              		.loc 1 2866 1 view .LVU1935
 6264 000a 7047     		bx	lr
 6265              	.L538:
 6266              		.align	2
 6267              	.L537:
 6268 000c 00000000 		.word	.LANCHOR0
 6269              		.cfi_endproc
 6270              	.LFE105:
 6272              		.section	.text.mpu_get_compass_reg,"ax",%progbits
 6273              		.align	1
 6274              		.global	mpu_get_compass_reg
 6275              		.syntax unified
 6276              		.thumb
 6277              		.thumb_func
 6278              		.fpu softvfp
 6280              	mpu_get_compass_reg:
 6281              	.LVL434:
 6282              	.LFB106:
2867:Src/mpu6050.c **** 
2868:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2869:Src/mpu6050.c **** /* This initialization is similar to the one in ak8975.c. */
2870:Src/mpu6050.c **** static int setup_compass(void)
2871:Src/mpu6050.c **** {
2872:Src/mpu6050.c ****     unsigned char data[4], akm_addr;
2873:Src/mpu6050.c **** 
2874:Src/mpu6050.c ****     mpu_set_bypass(1);
2875:Src/mpu6050.c **** 
2876:Src/mpu6050.c ****     /* Find compass. Possible addresses range from 0x0C to 0x0F. */
2877:Src/mpu6050.c ****     for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
2878:Src/mpu6050.c ****         int result;
2879:Src/mpu6050.c ****         result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
ARM GAS  /tmp/ccC60hwS.s 			page 193


2880:Src/mpu6050.c ****         if (!result && (data[0] == AKM_WHOAMI))
2881:Src/mpu6050.c ****             break;
2882:Src/mpu6050.c ****     }
2883:Src/mpu6050.c **** 
2884:Src/mpu6050.c ****     if (akm_addr > 0x0F) {
2885:Src/mpu6050.c ****         /* TODO: Handle this case in all compass-related functions. */
2886:Src/mpu6050.c ****         #ifdef SERIAL_DEBUG
2887:Src/mpu6050.c ****             log_i("Compass not found\r\n");
2888:Src/mpu6050.c ****         #endif
2889:Src/mpu6050.c ****         return -1;
2890:Src/mpu6050.c ****     }
2891:Src/mpu6050.c **** 
2892:Src/mpu6050.c ****     st.chip_cfg.compass_addr = akm_addr;
2893:Src/mpu6050.c **** 
2894:Src/mpu6050.c ****     data[0] = AKM_POWER_DOWN;
2895:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2896:Src/mpu6050.c ****         return -1;
2897:Src/mpu6050.c ****     delay_ms(1);
2898:Src/mpu6050.c **** 
2899:Src/mpu6050.c ****     data[0] = AKM_FUSE_ROM_ACCESS;
2900:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2901:Src/mpu6050.c ****         return -1;
2902:Src/mpu6050.c ****     delay_ms(1);
2903:Src/mpu6050.c **** 
2904:Src/mpu6050.c ****     /* Get sensitivity adjustment data from fuse ROM. */
2905:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
2906:Src/mpu6050.c ****         return -1;
2907:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
2908:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
2909:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
2910:Src/mpu6050.c **** 
2911:Src/mpu6050.c ****     data[0] = AKM_POWER_DOWN;
2912:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2913:Src/mpu6050.c ****         return -1;
2914:Src/mpu6050.c ****     delay_ms(1);
2915:Src/mpu6050.c **** 
2916:Src/mpu6050.c ****     mpu_set_bypass(0);
2917:Src/mpu6050.c **** 
2918:Src/mpu6050.c ****     /* Set up master mode, master clock, and ES bit. */
2919:Src/mpu6050.c ****     data[0] = 0x40;
2920:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2921:Src/mpu6050.c ****         return -1;
2922:Src/mpu6050.c **** 
2923:Src/mpu6050.c ****     /* Slave 0 reads from AKM data registers. */
2924:Src/mpu6050.c ****     data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
2925:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
2926:Src/mpu6050.c ****         return -1;
2927:Src/mpu6050.c **** 
2928:Src/mpu6050.c ****     /* Compass reads start at this register. */
2929:Src/mpu6050.c ****     data[0] = AKM_REG_ST1;
2930:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
2931:Src/mpu6050.c ****         return -1;
2932:Src/mpu6050.c **** 
2933:Src/mpu6050.c ****     /* Enable slave 0, 8-byte reads. */
2934:Src/mpu6050.c ****     data[0] = BIT_SLAVE_EN | 8;
2935:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
2936:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccC60hwS.s 			page 194


2937:Src/mpu6050.c **** 
2938:Src/mpu6050.c ****     /* Slave 1 changes AKM measurement mode. */
2939:Src/mpu6050.c ****     data[0] = st.chip_cfg.compass_addr;
2940:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
2941:Src/mpu6050.c ****         return -1;
2942:Src/mpu6050.c **** 
2943:Src/mpu6050.c ****     /* AKM measurement mode register. */
2944:Src/mpu6050.c ****     data[0] = AKM_REG_CNTL;
2945:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
2946:Src/mpu6050.c ****         return -1;
2947:Src/mpu6050.c **** 
2948:Src/mpu6050.c ****     /* Enable slave 1, 1-byte writes. */
2949:Src/mpu6050.c ****     data[0] = BIT_SLAVE_EN | 1;
2950:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
2951:Src/mpu6050.c ****         return -1;
2952:Src/mpu6050.c **** 
2953:Src/mpu6050.c ****     /* Set slave 1 data. */
2954:Src/mpu6050.c ****     data[0] = AKM_SINGLE_MEASUREMENT;
2955:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
2956:Src/mpu6050.c ****         return -1;
2957:Src/mpu6050.c **** 
2958:Src/mpu6050.c ****     /* Trigger slave 0 and slave 1 actions at each sample. */
2959:Src/mpu6050.c ****     data[0] = 0x03;
2960:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
2961:Src/mpu6050.c ****         return -1;
2962:Src/mpu6050.c **** 
2963:Src/mpu6050.c **** #ifdef MPU9150
2964:Src/mpu6050.c ****     /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
2965:Src/mpu6050.c ****     data[0] = BIT_I2C_MST_VDDIO;
2966:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
2967:Src/mpu6050.c ****         return -1;
2968:Src/mpu6050.c **** #endif
2969:Src/mpu6050.c **** 
2970:Src/mpu6050.c ****     return 0;
2971:Src/mpu6050.c **** }
2972:Src/mpu6050.c **** #endif
2973:Src/mpu6050.c **** 
2974:Src/mpu6050.c **** /**
2975:Src/mpu6050.c ****  *  @brief      Read raw compass data.
2976:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
2977:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
2978:Src/mpu6050.c ****  *  @return     0 if successful.
2979:Src/mpu6050.c ****  */
2980:Src/mpu6050.c **** int mpu_get_compass_reg(short *data, unsigned long *timestamp)
2981:Src/mpu6050.c **** {
 6283              		.loc 1 2981 1 is_stmt 1 view -0
 6284              		.cfi_startproc
 6285              		@ args = 0, pretend = 0, frame = 0
 6286              		@ frame_needed = 0, uses_anonymous_args = 0
 6287              		@ link register save eliminated.
2982:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2983:Src/mpu6050.c ****     unsigned char tmp[9];
2984:Src/mpu6050.c **** 
2985:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
2986:Src/mpu6050.c ****         return -1;
2987:Src/mpu6050.c **** 
2988:Src/mpu6050.c **** #ifdef AK89xx_BYPASS
ARM GAS  /tmp/ccC60hwS.s 			page 195


2989:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
2990:Src/mpu6050.c ****         return -1;
2991:Src/mpu6050.c ****     tmp[8] = AKM_SINGLE_MEASUREMENT;
2992:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
2993:Src/mpu6050.c ****         return -1;
2994:Src/mpu6050.c **** #else
2995:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
2996:Src/mpu6050.c ****         return -1;
2997:Src/mpu6050.c **** #endif
2998:Src/mpu6050.c **** 
2999:Src/mpu6050.c **** #if defined AK8975_SECONDARY
3000:Src/mpu6050.c ****     /* AK8975 doesn't have the overrun error bit. */
3001:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY))
3002:Src/mpu6050.c ****         return -2;
3003:Src/mpu6050.c ****     if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
3004:Src/mpu6050.c ****         return -3;
3005:Src/mpu6050.c **** #elif defined AK8963_SECONDARY
3006:Src/mpu6050.c ****     /* AK8963 doesn't have the data read error bit. */
3007:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
3008:Src/mpu6050.c ****         return -2;
3009:Src/mpu6050.c ****     if (tmp[7] & AKM_OVERFLOW)
3010:Src/mpu6050.c ****         return -3;
3011:Src/mpu6050.c **** #endif
3012:Src/mpu6050.c ****     data[0] = (tmp[2] << 8) | tmp[1];
3013:Src/mpu6050.c ****     data[1] = (tmp[4] << 8) | tmp[3];
3014:Src/mpu6050.c ****     data[2] = (tmp[6] << 8) | tmp[5];
3015:Src/mpu6050.c **** 
3016:Src/mpu6050.c ****     data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
3017:Src/mpu6050.c ****     data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
3018:Src/mpu6050.c ****     data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
3019:Src/mpu6050.c **** 
3020:Src/mpu6050.c ****     if (timestamp)
3021:Src/mpu6050.c ****         get_ms(timestamp);
3022:Src/mpu6050.c ****     return 0;
3023:Src/mpu6050.c **** #else
3024:Src/mpu6050.c ****     return -1;
 6288              		.loc 1 3024 5 view .LVU1937
3025:Src/mpu6050.c **** #endif
3026:Src/mpu6050.c **** }
 6289              		.loc 1 3026 1 is_stmt 0 view .LVU1938
 6290 0000 4FF0FF30 		mov	r0, #-1
 6291              	.LVL435:
 6292              		.loc 1 3026 1 view .LVU1939
 6293 0004 7047     		bx	lr
 6294              		.cfi_endproc
 6295              	.LFE106:
 6297              		.section	.text.mpu_get_compass_fsr,"ax",%progbits
 6298              		.align	1
 6299              		.global	mpu_get_compass_fsr
 6300              		.syntax unified
 6301              		.thumb
 6302              		.thumb_func
 6303              		.fpu softvfp
 6305              	mpu_get_compass_fsr:
 6306              	.LVL436:
 6307              	.LFB107:
3027:Src/mpu6050.c **** 
ARM GAS  /tmp/ccC60hwS.s 			page 196


3028:Src/mpu6050.c **** /**
3029:Src/mpu6050.c ****  *  @brief      Get the compass full-scale range.
3030:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
3031:Src/mpu6050.c ****  *  @return     0 if successful.
3032:Src/mpu6050.c ****  */
3033:Src/mpu6050.c **** int mpu_get_compass_fsr(unsigned short *fsr)
3034:Src/mpu6050.c **** {
 6308              		.loc 1 3034 1 is_stmt 1 view -0
 6309              		.cfi_startproc
 6310              		@ args = 0, pretend = 0, frame = 0
 6311              		@ frame_needed = 0, uses_anonymous_args = 0
 6312              		@ link register save eliminated.
3035:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
3036:Src/mpu6050.c ****     fsr[0] = st.hw->compass_fsr;
3037:Src/mpu6050.c ****     return 0;
3038:Src/mpu6050.c **** #else
3039:Src/mpu6050.c ****     return -1;
 6313              		.loc 1 3039 5 view .LVU1941
3040:Src/mpu6050.c **** #endif
3041:Src/mpu6050.c **** }
 6314              		.loc 1 3041 1 is_stmt 0 view .LVU1942
 6315 0000 4FF0FF30 		mov	r0, #-1
 6316              	.LVL437:
 6317              		.loc 1 3041 1 view .LVU1943
 6318 0004 7047     		bx	lr
 6319              		.cfi_endproc
 6320              	.LFE107:
 6322              		.section	.text.mpu_lp_motion_interrupt,"ax",%progbits
 6323              		.align	1
 6324              		.global	mpu_lp_motion_interrupt
 6325              		.syntax unified
 6326              		.thumb
 6327              		.thumb_func
 6328              		.fpu softvfp
 6330              	mpu_lp_motion_interrupt:
 6331              	.LVL438:
 6332              	.LFB108:
3042:Src/mpu6050.c **** 
3043:Src/mpu6050.c **** /**
3044:Src/mpu6050.c ****  *  @brief      Enters LP accel motion interrupt mode.
3045:Src/mpu6050.c ****  *  The behaviour of this feature is very different between the MPU6050 and the
3046:Src/mpu6050.c ****  *  MPU6500. Each chip's version of this feature is explained below.
3047:Src/mpu6050.c ****  *
3048:Src/mpu6050.c ****  *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
3049:Src/mpu6050.c ****  *  increments.
3050:Src/mpu6050.c ****  *
3051:Src/mpu6050.c ****  *  \n Low-power accel mode supports the following frequencies:
3052:Src/mpu6050.c ****  *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
3053:Src/mpu6050.c ****  *
3054:Src/mpu6050.c ****  *  \n MPU6500:
3055:Src/mpu6050.c ****  *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
3056:Src/mpu6050.c ****  *  sample. The hardware monitors the accel data and detects any large change
3057:Src/mpu6050.c ****  *  over a short period of time.
3058:Src/mpu6050.c ****  *
3059:Src/mpu6050.c ****  *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
3060:Src/mpu6050.c ****  *  increments.
3061:Src/mpu6050.c ****  *
ARM GAS  /tmp/ccC60hwS.s 			page 197


3062:Src/mpu6050.c ****  *  \n MPU6500 Low-power accel mode supports the following frequencies:
3063:Src/mpu6050.c ****  *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
3064:Src/mpu6050.c ****  *
3065:Src/mpu6050.c ****  *  \n\n NOTES:
3066:Src/mpu6050.c ****  *  \n The driver will round down @e thresh to the nearest supported value if
3067:Src/mpu6050.c ****  *  an unsupported threshold is selected.
3068:Src/mpu6050.c ****  *  \n To select a fractional wake-up frequency, round down the value passed to
3069:Src/mpu6050.c ****  *  @e lpa_freq.
3070:Src/mpu6050.c ****  *  \n The MPU6500 does not support a delay parameter. If this function is used
3071:Src/mpu6050.c ****  *  for the MPU6500, the value passed to @e time will be ignored.
3072:Src/mpu6050.c ****  *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
3073:Src/mpu6050.c ****  *  the previous configuration.
3074:Src/mpu6050.c ****  *
3075:Src/mpu6050.c ****  *  @param[in]  thresh      Motion threshold in mg.
3076:Src/mpu6050.c ****  *  @param[in]  time        Duration in milliseconds that the accel data must
3077:Src/mpu6050.c ****  *                          exceed @e thresh before motion is reported.
3078:Src/mpu6050.c ****  *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
3079:Src/mpu6050.c ****  *  @return     0 if successful.
3080:Src/mpu6050.c ****  */
3081:Src/mpu6050.c **** int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time, unsigned short lpa_freq)
3082:Src/mpu6050.c **** {
 6333              		.loc 1 3082 1 is_stmt 1 view -0
 6334              		.cfi_startproc
 6335              		@ args = 0, pretend = 0, frame = 0
 6336              		@ frame_needed = 0, uses_anonymous_args = 0
3083:Src/mpu6050.c **** 
3084:Src/mpu6050.c **** #if defined MPU6500
3085:Src/mpu6050.c ****     unsigned char data[3];
3086:Src/mpu6050.c **** #endif
3087:Src/mpu6050.c ****     if (lpa_freq) {
 6337              		.loc 1 3087 5 view .LVU1945
3082:Src/mpu6050.c **** 
 6338              		.loc 1 3082 1 is_stmt 0 view .LVU1946
 6339 0000 38B5     		push	{r3, r4, r5, lr}
 6340              	.LCFI97:
 6341              		.cfi_def_cfa_offset 16
 6342              		.cfi_offset 3, -16
 6343              		.cfi_offset 4, -12
 6344              		.cfi_offset 5, -8
 6345              		.cfi_offset 14, -4
 6346              		.loc 1 3087 8 view .LVU1947
 6347 0002 002A     		cmp	r2, #0
 6348 0004 3FD0     		beq	.L542
3088:Src/mpu6050.c **** #if defined MPU6500
3089:Src/mpu6050.c ****         unsigned char thresh_hw;
3090:Src/mpu6050.c **** 
3091:Src/mpu6050.c ****         /* 1LSb = 4mg. */
3092:Src/mpu6050.c ****         if (thresh > 1020)
3093:Src/mpu6050.c ****             thresh_hw = 255;
3094:Src/mpu6050.c ****         else if (thresh < 4)
3095:Src/mpu6050.c ****             thresh_hw = 1;
3096:Src/mpu6050.c ****         else
3097:Src/mpu6050.c ****             thresh_hw = thresh >> 2;
3098:Src/mpu6050.c **** #endif
3099:Src/mpu6050.c **** 
3100:Src/mpu6050.c ****         if (!time)
 6349              		.loc 1 3100 9 is_stmt 1 view .LVU1948
ARM GAS  /tmp/ccC60hwS.s 			page 198


 6350              	.LVL439:
3101:Src/mpu6050.c ****             /* Minimum duration must be 1ms. */
3102:Src/mpu6050.c ****             time = 1;
3103:Src/mpu6050.c **** 
3104:Src/mpu6050.c **** #if defined MPU6500
3105:Src/mpu6050.c ****         if (lpa_freq > 640)
3106:Src/mpu6050.c ****             /* At this point, the chip has not been re-configured, so the
3107:Src/mpu6050.c ****              * function can safely exit.
3108:Src/mpu6050.c ****              */
3109:Src/mpu6050.c ****             return -1;
3110:Src/mpu6050.c **** #endif
3111:Src/mpu6050.c **** 
3112:Src/mpu6050.c ****         if (!st.chip_cfg.int_motion_only) {
 6351              		.loc 1 3112 9 view .LVU1949
 6352              		.loc 1 3112 25 is_stmt 0 view .LVU1950
 6353 0006 254C     		ldr	r4, .L553
 6354              		.loc 1 3112 12 view .LVU1951
 6355 0008 607D     		ldrb	r0, [r4, #21]	@ zero_extendqisi2
 6356              	.LVL440:
 6357              		.loc 1 3112 12 view .LVU1952
 6358 000a B8B9     		cbnz	r0, .L543
3113:Src/mpu6050.c ****             /* Store current settings for later. */
3114:Src/mpu6050.c ****             if (st.chip_cfg.dmp_on) {
 6359              		.loc 1 3114 13 is_stmt 1 view .LVU1953
 6360              		.loc 1 3114 16 is_stmt 0 view .LVU1954
 6361 000c 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 6362 0010 13B1     		cbz	r3, .L544
3115:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
 6363              		.loc 1 3115 17 is_stmt 1 view .LVU1955
 6364 0012 FFF7FEFF 		bl	mpu_set_dmp_state
 6365              	.LVL441:
3116:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 1;
 6366              		.loc 1 3116 17 view .LVU1956
 6367              		.loc 1 3116 42 is_stmt 0 view .LVU1957
 6368 0016 0123     		movs	r3, #1
 6369              	.L544:
3117:Src/mpu6050.c ****             } else
3118:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 0;
 6370              		.loc 1 3118 17 is_stmt 1 view .LVU1958
3119:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
 6371              		.loc 1 3119 13 is_stmt 0 view .LVU1959
 6372 0018 2148     		ldr	r0, .L553+4
3118:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
 6373              		.loc 1 3118 42 view .LVU1960
 6374 001a 84F82030 		strb	r3, [r4, #32]
 6375              		.loc 1 3119 13 is_stmt 1 view .LVU1961
 6376 001e FFF7FEFF 		bl	mpu_get_gyro_fsr
 6377              	.LVL442:
3120:Src/mpu6050.c ****             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
 6378              		.loc 1 3120 13 view .LVU1962
 6379 0022 2048     		ldr	r0, .L553+8
 6380 0024 FFF7FEFF 		bl	mpu_get_accel_fsr
 6381              	.LVL443:
3121:Src/mpu6050.c ****             mpu_get_lpf(&st.chip_cfg.cache.lpf);
 6382              		.loc 1 3121 13 view .LVU1963
 6383 0028 1F48     		ldr	r0, .L553+12
 6384 002a FFF7FEFF 		bl	mpu_get_lpf
ARM GAS  /tmp/ccC60hwS.s 			page 199


 6385              	.LVL444:
3122:Src/mpu6050.c ****             mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
 6386              		.loc 1 3122 13 view .LVU1964
 6387 002e 1F48     		ldr	r0, .L553+16
 6388 0030 FFF7FEFF 		bl	mpu_get_sample_rate
 6389              	.LVL445:
3123:Src/mpu6050.c ****             st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
 6390              		.loc 1 3123 13 view .LVU1965
 6391              		.loc 1 3123 42 is_stmt 0 view .LVU1966
 6392 0034 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 6393 0036 A377     		strb	r3, [r4, #30]
3124:Src/mpu6050.c ****             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
 6394              		.loc 1 3124 13 is_stmt 1 view .LVU1967
 6395              	.LVL446:
 6396              	.LBB42:
 6397              	.LBI42:
1484:Src/mpu6050.c **** {
 6398              		.loc 1 1484 5 view .LVU1968
 6399              	.LBB43:
1486:Src/mpu6050.c ****     return 0;
 6400              		.loc 1 1486 5 view .LVU1969
1486:Src/mpu6050.c ****     return 0;
 6401              		.loc 1 1486 16 is_stmt 0 view .LVU1970
 6402 0038 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 6403 003a E377     		strb	r3, [r4, #31]
1487:Src/mpu6050.c **** }
 6404              		.loc 1 1487 5 is_stmt 1 view .LVU1971
 6405              	.LVL447:
 6406              	.L543:
1487:Src/mpu6050.c **** }
 6407              		.loc 1 1487 5 is_stmt 0 view .LVU1972
 6408              	.LBE43:
 6409              	.LBE42:
3125:Src/mpu6050.c ****         }
3126:Src/mpu6050.c **** 
3127:Src/mpu6050.c **** #if defined MPU6500
3128:Src/mpu6050.c ****         /* Disable hardware interrupts. */
3129:Src/mpu6050.c ****         set_int_enable(0);
3130:Src/mpu6050.c **** 
3131:Src/mpu6050.c ****         /* Enter full-power accel-only mode, no FIFO/DMP. */
3132:Src/mpu6050.c ****         data[0] = 0;
3133:Src/mpu6050.c ****         data[1] = 0;
3134:Src/mpu6050.c ****         data[2] = BIT_STBY_XYZG;
3135:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
3136:Src/mpu6050.c ****             goto lp_int_restore;
3137:Src/mpu6050.c **** 
3138:Src/mpu6050.c ****         /* Set motion threshold. */
3139:Src/mpu6050.c ****         data[0] = thresh_hw;
3140:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
3141:Src/mpu6050.c ****             goto lp_int_restore;
3142:Src/mpu6050.c **** 
3143:Src/mpu6050.c ****         /* Set wake frequency. */
3144:Src/mpu6050.c ****         if (lpa_freq == 1)
3145:Src/mpu6050.c ****             data[0] = INV_LPA_1_25HZ;
3146:Src/mpu6050.c ****         else if (lpa_freq == 2)
3147:Src/mpu6050.c ****             data[0] = INV_LPA_2_5HZ;
3148:Src/mpu6050.c ****         else if (lpa_freq <= 5)
ARM GAS  /tmp/ccC60hwS.s 			page 200


3149:Src/mpu6050.c ****             data[0] = INV_LPA_5HZ;
3150:Src/mpu6050.c ****         else if (lpa_freq <= 10)
3151:Src/mpu6050.c ****             data[0] = INV_LPA_10HZ;
3152:Src/mpu6050.c ****         else if (lpa_freq <= 20)
3153:Src/mpu6050.c ****             data[0] = INV_LPA_20HZ;
3154:Src/mpu6050.c ****         else if (lpa_freq <= 40)
3155:Src/mpu6050.c ****             data[0] = INV_LPA_40HZ;
3156:Src/mpu6050.c ****         else if (lpa_freq <= 80)
3157:Src/mpu6050.c ****             data[0] = INV_LPA_80HZ;
3158:Src/mpu6050.c ****         else if (lpa_freq <= 160)
3159:Src/mpu6050.c ****             data[0] = INV_LPA_160HZ;
3160:Src/mpu6050.c ****         else if (lpa_freq <= 320)
3161:Src/mpu6050.c ****             data[0] = INV_LPA_320HZ;
3162:Src/mpu6050.c ****         else
3163:Src/mpu6050.c ****             data[0] = INV_LPA_640HZ;
3164:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
3165:Src/mpu6050.c ****             goto lp_int_restore;
3166:Src/mpu6050.c **** 
3167:Src/mpu6050.c ****         /* Enable motion interrupt (MPU6500 version). */
3168:Src/mpu6050.c ****         data[0] = BITS_WOM_EN;
3169:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
3170:Src/mpu6050.c ****             goto lp_int_restore;
3171:Src/mpu6050.c **** 
3172:Src/mpu6050.c ****         /* Enable cycle mode. */
3173:Src/mpu6050.c ****         data[0] = BIT_LPA_CYCLE;
3174:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
3175:Src/mpu6050.c ****             goto lp_int_restore;
3176:Src/mpu6050.c **** 
3177:Src/mpu6050.c ****         /* Enable interrupt. */
3178:Src/mpu6050.c ****         data[0] = BIT_MOT_INT_EN;
3179:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
3180:Src/mpu6050.c ****             goto lp_int_restore;
3181:Src/mpu6050.c **** 
3182:Src/mpu6050.c ****         st.chip_cfg.int_motion_only = 1;
3183:Src/mpu6050.c ****         return 0;
3184:Src/mpu6050.c **** #endif
3185:Src/mpu6050.c ****     } else {
3186:Src/mpu6050.c ****         /* Don't "restore" the previous state if no state has been saved. */
3187:Src/mpu6050.c ****         unsigned int ii;
3188:Src/mpu6050.c ****         char *cache_ptr = (char*)&st.chip_cfg.cache;
3189:Src/mpu6050.c ****         for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
3190:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
3191:Src/mpu6050.c ****                 goto lp_int_restore;
3192:Src/mpu6050.c ****         }
3193:Src/mpu6050.c ****         /* If we reach this point, motion interrupt mode hasn't been used yet. */
3194:Src/mpu6050.c ****         return -1;
3195:Src/mpu6050.c ****     }
3196:Src/mpu6050.c **** lp_int_restore:
3197:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
3198:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 6410              		.loc 1 3198 5 is_stmt 1 view .LVU1973
3199:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6411              		.loc 1 3199 5 view .LVU1974
3200:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 6412              		.loc 1 3200 5 view .LVU1975
3201:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 6413              		.loc 1 3201 5 view .LVU1976
ARM GAS  /tmp/ccC60hwS.s 			page 201


 6414              		.loc 1 3201 29 is_stmt 0 view .LVU1977
 6415 003c 4FF6FF73 		movw	r3, #65535
 6416 0040 164C     		ldr	r4, .L553
3202:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
3203:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
3204:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6417              		.loc 1 3204 25 view .LVU1978
 6418 0042 0125     		movs	r5, #1
3201:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 6419              		.loc 1 3201 29 view .LVU1979
 6420 0044 E381     		strh	r3, [r4, #14]	@ movhi
3202:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6421              		.loc 1 3202 5 is_stmt 1 view .LVU1980
3203:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6422              		.loc 1 3203 5 view .LVU1981
3203:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6423              		.loc 1 3203 29 is_stmt 0 view .LVU1982
 6424 0046 2374     		strb	r3, [r4, #16]
 6425              		.loc 1 3204 5 is_stmt 1 view .LVU1983
3198:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6426              		.loc 1 3198 26 is_stmt 0 view .LVU1984
 6427 0048 4FF0FF33 		mov	r3, #-1
3205:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6428              		.loc 1 3205 5 view .LVU1985
 6429 004c A07F     		ldrb	r0, [r4, #30]	@ zero_extendqisi2
3198:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6430              		.loc 1 3198 26 view .LVU1986
 6431 004e A360     		str	r3, [r4, #8]
3204:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6432              		.loc 1 3204 25 view .LVU1987
 6433 0050 2573     		strb	r5, [r4, #12]
 6434              		.loc 1 3205 5 is_stmt 1 view .LVU1988
 6435 0052 FFF7FEFF 		bl	mpu_set_sensors
 6436              	.LVL448:
3206:Src/mpu6050.c ****     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
 6437              		.loc 1 3206 5 view .LVU1989
 6438 0056 E08A     		ldrh	r0, [r4, #22]
 6439 0058 FFF7FEFF 		bl	mpu_set_gyro_fsr
 6440              	.LVL449:
3207:Src/mpu6050.c ****     mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
 6441              		.loc 1 3207 5 view .LVU1990
 6442 005c 207E     		ldrb	r0, [r4, #24]	@ zero_extendqisi2
 6443 005e FFF7FEFF 		bl	mpu_set_accel_fsr
 6444              	.LVL450:
3208:Src/mpu6050.c ****     mpu_set_lpf(st.chip_cfg.cache.lpf);
 6445              		.loc 1 3208 5 view .LVU1991
 6446 0062 608B     		ldrh	r0, [r4, #26]
 6447 0064 FFF7FEFF 		bl	mpu_set_lpf
 6448              	.LVL451:
3209:Src/mpu6050.c ****     mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
 6449              		.loc 1 3209 5 view .LVU1992
 6450 0068 A08B     		ldrh	r0, [r4, #28]
 6451 006a FFF7FEFF 		bl	mpu_set_sample_rate
 6452              	.LVL452:
3210:Src/mpu6050.c ****     mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
 6453              		.loc 1 3210 5 view .LVU1993
 6454 006e E07F     		ldrb	r0, [r4, #31]	@ zero_extendqisi2
ARM GAS  /tmp/ccC60hwS.s 			page 202


 6455 0070 FFF7FEFF 		bl	mpu_configure_fifo
 6456              	.LVL453:
3211:Src/mpu6050.c **** 
3212:Src/mpu6050.c ****     if (st.chip_cfg.cache.dmp_on)
 6457              		.loc 1 3212 5 view .LVU1994
 6458              		.loc 1 3212 8 is_stmt 0 view .LVU1995
 6459 0074 94F82030 		ldrb	r3, [r4, #32]	@ zero_extendqisi2
 6460 0078 13B1     		cbz	r3, .L548
3213:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 6461              		.loc 1 3213 9 is_stmt 1 view .LVU1996
 6462 007a 2846     		mov	r0, r5
 6463 007c FFF7FEFF 		bl	mpu_set_dmp_state
 6464              	.LVL454:
 6465              	.L548:
3214:Src/mpu6050.c **** 
3215:Src/mpu6050.c **** #ifdef MPU6500
3216:Src/mpu6050.c ****     /* Disable motion interrupt (MPU6500 version). */
3217:Src/mpu6050.c ****     data[0] = 0;
3218:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
3219:Src/mpu6050.c ****         goto lp_int_restore;
3220:Src/mpu6050.c **** #endif
3221:Src/mpu6050.c **** 
3222:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 6466              		.loc 1 3222 5 view .LVU1997
 6467              		.loc 1 3222 33 is_stmt 0 view .LVU1998
 6468 0080 0020     		movs	r0, #0
 6469 0082 6075     		strb	r0, [r4, #21]
3223:Src/mpu6050.c ****     return 0;
 6470              		.loc 1 3223 5 is_stmt 1 view .LVU1999
 6471              		.loc 1 3223 12 is_stmt 0 view .LVU2000
 6472 0084 09E0     		b	.L541
 6473              	.LVL455:
 6474              	.L542:
 6475              		.loc 1 3223 12 view .LVU2001
 6476 0086 064B     		ldr	r3, .L553+4
 6477              	.LVL456:
 6478              	.L546:
 6479              	.LBB44:
3190:Src/mpu6050.c ****                 goto lp_int_restore;
 6480              		.loc 1 3190 13 is_stmt 1 view .LVU2002
3190:Src/mpu6050.c ****                 goto lp_int_restore;
 6481              		.loc 1 3190 26 is_stmt 0 view .LVU2003
 6482 0088 13F8011B 		ldrb	r1, [r3], #1	@ zero_extendqisi2
3190:Src/mpu6050.c ****                 goto lp_int_restore;
 6483              		.loc 1 3190 16 view .LVU2004
 6484 008c 0029     		cmp	r1, #0
 6485 008e D5D1     		bne	.L543
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6486              		.loc 1 3189 54 is_stmt 1 discriminator 2 view .LVU2005
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6487              		.loc 1 3189 56 is_stmt 0 discriminator 2 view .LVU2006
 6488 0090 0132     		adds	r2, r2, #1
 6489              	.LVL457:
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6490              		.loc 1 3189 22 is_stmt 1 discriminator 2 view .LVU2007
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6491              		.loc 1 3189 9 is_stmt 0 discriminator 2 view .LVU2008
ARM GAS  /tmp/ccC60hwS.s 			page 203


 6492 0092 0C2A     		cmp	r2, #12
 6493 0094 F8D1     		bne	.L546
3194:Src/mpu6050.c ****     }
 6494              		.loc 1 3194 16 view .LVU2009
 6495 0096 4FF0FF30 		mov	r0, #-1
 6496              	.LVL458:
 6497              	.L541:
3194:Src/mpu6050.c ****     }
 6498              		.loc 1 3194 16 view .LVU2010
 6499              	.LBE44:
3224:Src/mpu6050.c **** }
 6500              		.loc 1 3224 1 view .LVU2011
 6501 009a 38BD     		pop	{r3, r4, r5, pc}
 6502              	.L554:
 6503              		.align	2
 6504              	.L553:
 6505 009c 00000000 		.word	.LANCHOR0
 6506 00a0 16000000 		.word	.LANCHOR0+22
 6507 00a4 18000000 		.word	.LANCHOR0+24
 6508 00a8 1A000000 		.word	.LANCHOR0+26
 6509 00ac 1C000000 		.word	.LANCHOR0+28
 6510              		.cfi_endproc
 6511              	.LFE108:
 6513              		.section	.rodata.mpu_start_self_test.str1.1,"aMS",%progbits,1
 6514              	.LC1:
 6515 0000 50617373 		.ascii	"Passed!\015\012\000"
 6515      6564210D 
 6515      0A00
 6516              	.LC2:
 6517 000a 4779726F 		.ascii	"Gyro failed\015\012\000"
 6517      20666169 
 6517      6C65640D 
 6517      0A00
 6518              	.LC3:
 6519 0018 41636365 		.ascii	"Accel failed\015\012\000"
 6519      6C206661 
 6519      696C6564 
 6519      0D0A00
 6520              	.LC4:
 6521 0027 436F6D70 		.ascii	"Compass failed\015\012\000"
 6521      61737320 
 6521      6661696C 
 6521      65640D0A 
 6521      00
 6522              		.section	.text.mpu_start_self_test,"ax",%progbits
 6523              		.align	1
 6524              		.global	mpu_start_self_test
 6525              		.syntax unified
 6526              		.thumb
 6527              		.thumb_func
 6528              		.fpu softvfp
 6530              	mpu_start_self_test:
 6531              	.LFB109:
3225:Src/mpu6050.c **** 
3226:Src/mpu6050.c **** /*
3227:Src/mpu6050.c ****  *  This function must be called with the device either face-up or face-down
3228:Src/mpu6050.c ****  *  (z-axis is parallel to gravity).
ARM GAS  /tmp/ccC60hwS.s 			page 204


3229:Src/mpu6050.c ****  */
3230:Src/mpu6050.c **** void mpu_start_self_test(void)
3231:Src/mpu6050.c **** {
 6532              		.loc 1 3231 1 is_stmt 1 view -0
 6533              		.cfi_startproc
 6534              		@ args = 0, pretend = 0, frame = 24
 6535              		@ frame_needed = 0, uses_anonymous_args = 0
3232:Src/mpu6050.c ****     int result;
 6536              		.loc 1 3232 5 view .LVU2013
3233:Src/mpu6050.c ****     long gyro[3], accel[3];
 6537              		.loc 1 3233 5 view .LVU2014
3234:Src/mpu6050.c **** 
3235:Src/mpu6050.c **** #if defined (MPU6500) || defined (MPU9250)
3236:Src/mpu6050.c ****     result = mpu_run_6500_self_test(gyro, accel, 0);
3237:Src/mpu6050.c **** #elif defined (MPU6050) || defined (MPU9150)
3238:Src/mpu6050.c ****     result = mpu_run_self_test(gyro, accel);
 6538              		.loc 1 3238 5 view .LVU2015
3231:Src/mpu6050.c ****     int result;
 6539              		.loc 1 3231 1 is_stmt 0 view .LVU2016
 6540 0000 10B5     		push	{r4, lr}
 6541              	.LCFI98:
 6542              		.cfi_def_cfa_offset 8
 6543              		.cfi_offset 4, -8
 6544              		.cfi_offset 14, -4
 6545 0002 86B0     		sub	sp, sp, #24
 6546              	.LCFI99:
 6547              		.cfi_def_cfa_offset 32
 6548              		.loc 1 3238 14 view .LVU2017
 6549 0004 6846     		mov	r0, sp
 6550 0006 03A9     		add	r1, sp, #12
 6551 0008 FFF7FEFF 		bl	mpu_run_self_test
 6552              	.LVL459:
3239:Src/mpu6050.c **** #endif
3240:Src/mpu6050.c ****     #ifdef SERIAL_DEBUG
3241:Src/mpu6050.c ****         log_i("accel: %ld %ld %ld\r\n",
3242:Src/mpu6050.c ****                                 accel[0],
3243:Src/mpu6050.c ****                                 accel[1],
3244:Src/mpu6050.c ****                                 accel[2]);
3245:Src/mpu6050.c ****         log_i("gyro: %ld %ld %ld\r\n",
3246:Src/mpu6050.c ****                                 gyro[0],
3247:Src/mpu6050.c ****                                 gyro[1],
3248:Src/mpu6050.c ****                                 gyro[2]);
3249:Src/mpu6050.c ****     #endif
3250:Src/mpu6050.c ****     if (result == 0x7) {
 6553              		.loc 1 3250 8 view .LVU2018
 6554 000c 0728     		cmp	r0, #7
3238:Src/mpu6050.c **** #endif
 6555              		.loc 1 3238 14 view .LVU2019
 6556 000e 0446     		mov	r4, r0
 6557              	.LVL460:
 6558              		.loc 1 3250 5 is_stmt 1 view .LVU2020
 6559              		.loc 1 3250 8 is_stmt 0 view .LVU2021
 6560 0010 04D1     		bne	.L556
3251:Src/mpu6050.c ****         consoleLog("Passed!\r\n");
 6561              		.loc 1 3251 9 is_stmt 1 view .LVU2022
 6562 0012 0948     		ldr	r0, .L561
 6563              	.LVL461:
ARM GAS  /tmp/ccC60hwS.s 			page 205


 6564              	.L560:
3252:Src/mpu6050.c ****         /* Test passed. We can trust the gyro data here, so now we need to update calibrated data*/
3253:Src/mpu6050.c **** 
3254:Src/mpu6050.c **** #ifdef USE_CAL_HW_REGISTERS
3255:Src/mpu6050.c ****         /*
3256:Src/mpu6050.c ****          * This portion of the code uses the HW offset registers that are in the MPUxxxx devices
3257:Src/mpu6050.c ****          * instead of pushing the cal data to the MPL software library
3258:Src/mpu6050.c ****          */
3259:Src/mpu6050.c ****         unsigned char i = 0;
3260:Src/mpu6050.c **** 
3261:Src/mpu6050.c ****         for(i = 0; i<3; i++) {
3262:Src/mpu6050.c ****             gyro[i] = (long)(gyro[i] * 32.8f); //convert to +-1000dps
3263:Src/mpu6050.c ****             accel[i] *= 2048.f; //convert to +-16G
3264:Src/mpu6050.c ****             accel[i] = accel[i] >> 16;
3265:Src/mpu6050.c ****             gyro[i] = (long)(gyro[i] >> 16);
3266:Src/mpu6050.c ****         }
3267:Src/mpu6050.c **** 
3268:Src/mpu6050.c ****         mpu_set_gyro_bias_reg(gyro);
3269:Src/mpu6050.c **** 
3270:Src/mpu6050.c ****         #if defined (MPU6500) || defined (MPU9250)
3271:Src/mpu6050.c ****                 mpu_set_accel_bias_6500_reg(accel);
3272:Src/mpu6050.c ****         #elif defined (MPU6050) || defined (MPU9150)
3273:Src/mpu6050.c ****                 mpu_set_accel_bias_6050_reg(accel);
3274:Src/mpu6050.c ****         #endif
3275:Src/mpu6050.c **** #endif
3276:Src/mpu6050.c ****     }
3277:Src/mpu6050.c ****     else {
3278:Src/mpu6050.c ****         if (!(result & 0x1))
3279:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
3280:Src/mpu6050.c ****         if (!(result & 0x2))
3281:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
3282:Src/mpu6050.c ****         if (!(result & 0x4))
3283:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6565              		.loc 1 3283 13 is_stmt 0 view .LVU2023
 6566 0014 FFF7FEFF 		bl	consoleLog
 6567              	.LVL462:
 6568              	.L555:
3284:Src/mpu6050.c ****      }
3285:Src/mpu6050.c **** 
3286:Src/mpu6050.c **** }
 6569              		.loc 1 3286 1 view .LVU2024
 6570 0018 06B0     		add	sp, sp, #24
 6571              	.LCFI100:
 6572              		.cfi_remember_state
 6573              		.cfi_def_cfa_offset 8
 6574              		@ sp needed
 6575 001a 10BD     		pop	{r4, pc}
 6576              	.LVL463:
 6577              	.L556:
 6578              	.LCFI101:
 6579              		.cfi_restore_state
3278:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
 6580              		.loc 1 3278 9 is_stmt 1 view .LVU2025
3278:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
 6581              		.loc 1 3278 12 is_stmt 0 view .LVU2026
 6582 001c C107     		lsls	r1, r0, #31
 6583 001e 02D4     		bmi	.L558
ARM GAS  /tmp/ccC60hwS.s 			page 206


3279:Src/mpu6050.c ****         if (!(result & 0x2))
 6584              		.loc 1 3279 13 is_stmt 1 view .LVU2027
 6585 0020 0648     		ldr	r0, .L561+4
 6586              	.LVL464:
3279:Src/mpu6050.c ****         if (!(result & 0x2))
 6587              		.loc 1 3279 13 is_stmt 0 view .LVU2028
 6588 0022 FFF7FEFF 		bl	consoleLog
 6589              	.LVL465:
 6590              	.L558:
3280:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
 6591              		.loc 1 3280 9 is_stmt 1 view .LVU2029
3280:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
 6592              		.loc 1 3280 12 is_stmt 0 view .LVU2030
 6593 0026 A207     		lsls	r2, r4, #30
 6594 0028 02D4     		bmi	.L559
3281:Src/mpu6050.c ****         if (!(result & 0x4))
 6595              		.loc 1 3281 13 is_stmt 1 view .LVU2031
 6596 002a 0548     		ldr	r0, .L561+8
 6597 002c FFF7FEFF 		bl	consoleLog
 6598              	.LVL466:
 6599              	.L559:
3282:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6600              		.loc 1 3282 9 view .LVU2032
3282:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6601              		.loc 1 3282 12 is_stmt 0 view .LVU2033
 6602 0030 6307     		lsls	r3, r4, #29
 6603 0032 F1D4     		bmi	.L555
3283:Src/mpu6050.c ****      }
 6604              		.loc 1 3283 13 is_stmt 1 view .LVU2034
 6605 0034 0348     		ldr	r0, .L561+12
 6606 0036 EDE7     		b	.L560
 6607              	.L562:
 6608              		.align	2
 6609              	.L561:
 6610 0038 00000000 		.word	.LC1
 6611 003c 0A000000 		.word	.LC2
 6612 0040 18000000 		.word	.LC3
 6613 0044 27000000 		.word	.LC4
 6614              		.cfi_endproc
 6615              	.LFE109:
 6617              		.section	.rodata.mpu_setup_gyro.str1.1,"aMS",%progbits,1
 6618              	.LC5:
 6619 0000 41636365 		.ascii	"Accel ON\015\012\000"
 6619      6C204F4E 
 6619      0D0A00
 6620              	.LC6:
 6621 000b 41636365 		.ascii	"Accel OFF\015\012\000"
 6621      6C204F46 
 6621      460D0A00 
 6622              	.LC7:
 6623 0017 4779726F 		.ascii	"Gyro ON\015\012\000"
 6623      204F4E0D 
 6623      0A00
 6624              	.LC8:
 6625 0021 4779726F 		.ascii	"Gyro OFF\015\012\000"
 6625      204F4646 
 6625      0D0A00
ARM GAS  /tmp/ccC60hwS.s 			page 207


 6626              		.section	.text.mpu_setup_gyro,"ax",%progbits
 6627              		.align	1
 6628              		.global	mpu_setup_gyro
 6629              		.syntax unified
 6630              		.thumb
 6631              		.thumb_func
 6632              		.fpu softvfp
 6634              	mpu_setup_gyro:
 6635              	.LFB110:
3287:Src/mpu6050.c **** 
3288:Src/mpu6050.c **** 
3289:Src/mpu6050.c **** 
3290:Src/mpu6050.c **** //=========================================================================================
3291:Src/mpu6050.c **** struct hal_s {
3292:Src/mpu6050.c ****     unsigned char lp_accel_mode;
3293:Src/mpu6050.c ****     unsigned char sensors;
3294:Src/mpu6050.c ****     unsigned char dmp_on;
3295:Src/mpu6050.c ****     unsigned char wait_for_tap;
3296:Src/mpu6050.c ****     volatile unsigned char new_gyro;
3297:Src/mpu6050.c ****     unsigned long no_dmp_hz;
3298:Src/mpu6050.c ****     unsigned long next_pedo_ms;
3299:Src/mpu6050.c ****     unsigned long next_temp_ms;
3300:Src/mpu6050.c ****     unsigned int report;
3301:Src/mpu6050.c ****     unsigned short dmp_features;
3302:Src/mpu6050.c **** };
3303:Src/mpu6050.c **** static struct hal_s hal = {0};
3304:Src/mpu6050.c **** 
3305:Src/mpu6050.c **** 
3306:Src/mpu6050.c **** /* This fuction handle sensor on/off combinations. */
3307:Src/mpu6050.c **** void mpu_setup_gyro(void)
3308:Src/mpu6050.c **** {
 6636              		.loc 1 3308 1 view -0
 6637              		.cfi_startproc
 6638              		@ args = 0, pretend = 0, frame = 8
 6639              		@ frame_needed = 0, uses_anonymous_args = 0
3309:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
 6640              		.loc 1 3309 5 view .LVU2036
 6641              	.LVL467:
3310:Src/mpu6050.c ****     if (hal.sensors & ACCEL_ON) {
 6642              		.loc 1 3310 5 view .LVU2037
3308:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
 6643              		.loc 1 3308 1 is_stmt 0 view .LVU2038
 6644 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 6645              	.LCFI102:
 6646              		.cfi_def_cfa_offset 24
 6647              		.cfi_offset 4, -16
 6648              		.cfi_offset 5, -12
 6649              		.cfi_offset 6, -8
 6650              		.cfi_offset 14, -4
 6651              		.loc 1 3310 12 view .LVU2039
 6652 0002 134E     		ldr	r6, .L573
 6653 0004 7478     		ldrb	r4, [r6, #1]	@ zero_extendqisi2
 6654              		.loc 1 3310 8 view .LVU2040
 6655 0006 14F00104 		ands	r4, r4, #1
 6656 000a 1DD0     		beq	.L564
3311:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6657              		.loc 1 3311 9 is_stmt 1 view .LVU2041
ARM GAS  /tmp/ccC60hwS.s 			page 208


 6658              	.LVL468:
3312:Src/mpu6050.c ****         consoleLog("Accel ON\r\n");
 6659              		.loc 1 3312 9 view .LVU2042
 6660 000c 1148     		ldr	r0, .L573+4
 6661 000e FFF7FEFF 		bl	consoleLog
 6662              	.LVL469:
3311:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6663              		.loc 1 3311 14 is_stmt 0 view .LVU2043
 6664 0012 0824     		movs	r4, #8
 6665              	.LVL470:
 6666              	.L565:
3313:Src/mpu6050.c ****     } else {
3314:Src/mpu6050.c ****         consoleLog("Accel OFF\r\n");
3315:Src/mpu6050.c ****     }
3316:Src/mpu6050.c ****     if (hal.sensors & GYRO_ON) {
 6667              		.loc 1 3316 5 is_stmt 1 view .LVU2044
 6668 0014 7578     		ldrb	r5, [r6, #1]	@ zero_extendqisi2
 6669              		.loc 1 3316 8 is_stmt 0 view .LVU2045
 6670 0016 15F00205 		ands	r5, r5, #2
3317:Src/mpu6050.c ****         mask |= INV_XYZ_GYRO;
 6671              		.loc 1 3317 9 is_stmt 1 view .LVU2046
 6672              		.loc 1 3317 14 is_stmt 0 view .LVU2047
 6673 001a 1BBF     		ittet	ne
 6674 001c 44F07004 		orrne	r4, r4, #112
 6675              	.LVL471:
3318:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
 6676              		.loc 1 3318 9 is_stmt 1 view .LVU2048
3319:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6677              		.loc 1 3319 9 is_stmt 0 view .LVU2049
 6678 0020 0D48     		ldrne	r0, .L573+8
3320:Src/mpu6050.c ****     } else {
3321:Src/mpu6050.c ****         consoleLog("Gyro OFF\r\n");
 6679              		.loc 1 3321 9 view .LVU2050
 6680 0022 0E48     		ldreq	r0, .L573+12
3318:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6681              		.loc 1 3318 31 view .LVU2051
 6682 0024 3578     		ldrbne	r5, [r6]	@ zero_extendqisi2
 6683              	.LVL472:
3319:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6684              		.loc 1 3319 9 is_stmt 1 view .LVU2052
 6685              		.loc 1 3321 9 view .LVU2053
 6686 0026 FFF7FEFF 		bl	consoleLog
 6687              	.LVL473:
3322:Src/mpu6050.c ****     }
3323:Src/mpu6050.c **** #ifdef COMPASS_ENABLED
3324:Src/mpu6050.c ****     if (hal.sensors & COMPASS_ON) {
3325:Src/mpu6050.c ****         mask |= INV_XYZ_COMPASS;
3326:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
3327:Src/mpu6050.c ****     }
3328:Src/mpu6050.c **** #endif
3329:Src/mpu6050.c ****     /* If you need a power transition, this function should be called with a
3330:Src/mpu6050.c ****      * mask of the sensors still enabled. The driver turns off any sensors
3331:Src/mpu6050.c ****      * excluded from this mask.
3332:Src/mpu6050.c ****      */
3333:Src/mpu6050.c ****     mpu_set_sensors(mask);
 6688              		.loc 1 3333 5 view .LVU2054
 6689 002a 2046     		mov	r0, r4
ARM GAS  /tmp/ccC60hwS.s 			page 209


 6690 002c FFF7FEFF 		bl	mpu_set_sensors
 6691              	.LVL474:
3334:Src/mpu6050.c ****     mpu_configure_fifo(mask);
 6692              		.loc 1 3334 5 view .LVU2055
 6693 0030 2046     		mov	r0, r4
 6694 0032 FFF7FEFF 		bl	mpu_configure_fifo
 6695              	.LVL475:
3335:Src/mpu6050.c ****     if (lp_accel_was_on) {
 6696              		.loc 1 3335 5 view .LVU2056
 6697              		.loc 1 3335 8 is_stmt 0 view .LVU2057
 6698 0036 2DB1     		cbz	r5, .L563
 6699              	.LBB45:
3336:Src/mpu6050.c ****         unsigned short rate;
 6700              		.loc 1 3336 9 is_stmt 1 view .LVU2058
3337:Src/mpu6050.c ****         hal.lp_accel_mode = 0;
 6701              		.loc 1 3337 9 view .LVU2059
 6702              		.loc 1 3337 27 is_stmt 0 view .LVU2060
 6703 0038 0023     		movs	r3, #0
3338:Src/mpu6050.c ****         /* Switching out of LP accel, notify MPL of new accel sampling rate. */
3339:Src/mpu6050.c ****         mpu_get_sample_rate(&rate);
 6704              		.loc 1 3339 9 view .LVU2061
 6705 003a 0DF10600 		add	r0, sp, #6
3337:Src/mpu6050.c ****         hal.lp_accel_mode = 0;
 6706              		.loc 1 3337 27 view .LVU2062
 6707 003e 3370     		strb	r3, [r6]
 6708              		.loc 1 3339 9 is_stmt 1 view .LVU2063
 6709 0040 FFF7FEFF 		bl	mpu_get_sample_rate
 6710              	.LVL476:
 6711              	.L563:
 6712              	.LBE45:
3340:Src/mpu6050.c ****     }
3341:Src/mpu6050.c **** }
 6713              		.loc 1 3341 1 is_stmt 0 view .LVU2064
 6714 0044 02B0     		add	sp, sp, #8
 6715              	.LCFI103:
 6716              		.cfi_remember_state
 6717              		.cfi_def_cfa_offset 16
 6718              		@ sp needed
 6719 0046 70BD     		pop	{r4, r5, r6, pc}
 6720              	.LVL477:
 6721              	.L564:
 6722              	.LCFI104:
 6723              		.cfi_restore_state
3314:Src/mpu6050.c ****     }
 6724              		.loc 1 3314 9 is_stmt 1 view .LVU2065
 6725 0048 0548     		ldr	r0, .L573+16
 6726 004a FFF7FEFF 		bl	consoleLog
 6727              	.LVL478:
 6728 004e E1E7     		b	.L565
 6729              	.L574:
 6730              		.align	2
 6731              	.L573:
 6732 0050 00000000 		.word	.LANCHOR2
 6733 0054 00000000 		.word	.LC5
 6734 0058 17000000 		.word	.LC7
 6735 005c 21000000 		.word	.LC8
 6736 0060 0B000000 		.word	.LC6
ARM GAS  /tmp/ccC60hwS.s 			page 210


 6737              		.cfi_endproc
 6738              	.LFE110:
 6740              		.section	.text.inv_row_2_scale,"ax",%progbits
 6741              		.align	1
 6742              		.global	inv_row_2_scale
 6743              		.syntax unified
 6744              		.thumb
 6745              		.thumb_func
 6746              		.fpu softvfp
 6748              	inv_row_2_scale:
 6749              	.LVL479:
 6750              	.LFB111:
3342:Src/mpu6050.c **** 
3343:Src/mpu6050.c **** unsigned short inv_row_2_scale(const signed char *row)
3344:Src/mpu6050.c **** {
 6751              		.loc 1 3344 1 view -0
 6752              		.cfi_startproc
 6753              		@ args = 0, pretend = 0, frame = 0
 6754              		@ frame_needed = 0, uses_anonymous_args = 0
 6755              		@ link register save eliminated.
3345:Src/mpu6050.c ****     unsigned short b;
 6756              		.loc 1 3345 5 view .LVU2067
3346:Src/mpu6050.c **** 
3347:Src/mpu6050.c ****     if (row[0] > 0)
 6757              		.loc 1 3347 5 view .LVU2068
 6758              		.loc 1 3347 12 is_stmt 0 view .LVU2069
 6759 0000 90F90030 		ldrsb	r3, [r0]
 6760              		.loc 1 3347 8 view .LVU2070
 6761 0004 002B     		cmp	r3, #0
 6762 0006 0CDC     		bgt	.L577
3348:Src/mpu6050.c ****         b = 0;
3349:Src/mpu6050.c ****     else if (row[0] < 0)
 6763              		.loc 1 3349 10 is_stmt 1 view .LVU2071
 6764              		.loc 1 3349 13 is_stmt 0 view .LVU2072
 6765 0008 0DD1     		bne	.L578
3350:Src/mpu6050.c ****         b = 4;
3351:Src/mpu6050.c ****     else if (row[1] > 0)
 6766              		.loc 1 3351 10 is_stmt 1 view .LVU2073
 6767              		.loc 1 3351 17 is_stmt 0 view .LVU2074
 6768 000a 90F90130 		ldrsb	r3, [r0, #1]
 6769              		.loc 1 3351 13 view .LVU2075
 6770 000e 002B     		cmp	r3, #0
 6771 0010 0BDC     		bgt	.L579
3352:Src/mpu6050.c ****         b = 1;
3353:Src/mpu6050.c ****     else if (row[1] < 0)
 6772              		.loc 1 3353 10 is_stmt 1 view .LVU2076
 6773              		.loc 1 3353 13 is_stmt 0 view .LVU2077
 6774 0012 0CD1     		bne	.L580
 6775              	.LVL480:
 6776              	.LBB48:
 6777              	.LBI48:
3343:Src/mpu6050.c **** {
 6778              		.loc 1 3343 16 is_stmt 1 view .LVU2078
 6779              	.LBB49:
3354:Src/mpu6050.c ****         b = 5;
3355:Src/mpu6050.c ****     else if (row[2] > 0)
 6780              		.loc 1 3355 10 view .LVU2079
ARM GAS  /tmp/ccC60hwS.s 			page 211


 6781              		.loc 1 3355 17 is_stmt 0 view .LVU2080
 6782 0014 90F90230 		ldrsb	r3, [r0, #2]
 6783              		.loc 1 3355 13 view .LVU2081
 6784 0018 002B     		cmp	r3, #0
 6785 001a 0ADC     		bgt	.L581
3356:Src/mpu6050.c ****         b = 2;
3357:Src/mpu6050.c ****     else if (row[2] < 0)
 6786              		.loc 1 3357 10 is_stmt 1 view .LVU2082
 6787              		.loc 1 3357 13 is_stmt 0 view .LVU2083
 6788 001c 0BD1     		bne	.L582
3358:Src/mpu6050.c ****         b = 6;
3359:Src/mpu6050.c ****     else
3360:Src/mpu6050.c ****         b = 7;      // error
 6789              		.loc 1 3360 11 view .LVU2084
 6790 001e 0720     		movs	r0, #7
 6791              	.LVL481:
 6792              		.loc 1 3360 11 view .LVU2085
 6793 0020 7047     		bx	lr
 6794              	.LVL482:
 6795              	.L577:
 6796              		.loc 1 3360 11 view .LVU2086
 6797              	.LBE49:
 6798              	.LBE48:
3348:Src/mpu6050.c ****     else if (row[0] < 0)
 6799              		.loc 1 3348 11 view .LVU2087
 6800 0022 0020     		movs	r0, #0
 6801              	.LVL483:
3348:Src/mpu6050.c ****     else if (row[0] < 0)
 6802              		.loc 1 3348 11 view .LVU2088
 6803 0024 7047     		bx	lr
 6804              	.LVL484:
 6805              	.L578:
3350:Src/mpu6050.c ****     else if (row[1] > 0)
 6806              		.loc 1 3350 11 view .LVU2089
 6807 0026 0420     		movs	r0, #4
 6808              	.LVL485:
3350:Src/mpu6050.c ****     else if (row[1] > 0)
 6809              		.loc 1 3350 11 view .LVU2090
 6810 0028 7047     		bx	lr
 6811              	.LVL486:
 6812              	.L579:
3352:Src/mpu6050.c ****     else if (row[1] < 0)
 6813              		.loc 1 3352 11 view .LVU2091
 6814 002a 0120     		movs	r0, #1
 6815              	.LVL487:
3352:Src/mpu6050.c ****     else if (row[1] < 0)
 6816              		.loc 1 3352 11 view .LVU2092
 6817 002c 7047     		bx	lr
 6818              	.LVL488:
 6819              	.L580:
3354:Src/mpu6050.c ****     else if (row[2] > 0)
 6820              		.loc 1 3354 11 view .LVU2093
 6821 002e 0520     		movs	r0, #5
 6822              	.LVL489:
3354:Src/mpu6050.c ****     else if (row[2] > 0)
 6823              		.loc 1 3354 11 view .LVU2094
 6824 0030 7047     		bx	lr
ARM GAS  /tmp/ccC60hwS.s 			page 212


 6825              	.LVL490:
 6826              	.L581:
 6827              	.LBB51:
 6828              	.LBB50:
3356:Src/mpu6050.c ****     else if (row[2] < 0)
 6829              		.loc 1 3356 11 view .LVU2095
 6830 0032 0220     		movs	r0, #2
 6831              	.LVL491:
3356:Src/mpu6050.c ****     else if (row[2] < 0)
 6832              		.loc 1 3356 11 view .LVU2096
 6833 0034 7047     		bx	lr
 6834              	.LVL492:
 6835              	.L582:
3358:Src/mpu6050.c ****     else
 6836              		.loc 1 3358 11 view .LVU2097
 6837 0036 0620     		movs	r0, #6
 6838              	.LVL493:
3358:Src/mpu6050.c ****     else
 6839              		.loc 1 3358 11 view .LVU2098
 6840              	.LBE50:
 6841              	.LBE51:
3361:Src/mpu6050.c ****     return b;
 6842              		.loc 1 3361 5 is_stmt 1 view .LVU2099
3362:Src/mpu6050.c **** }
 6843              		.loc 1 3362 1 is_stmt 0 view .LVU2100
 6844 0038 7047     		bx	lr
 6845              		.cfi_endproc
 6846              	.LFE111:
 6848              		.section	.text.inv_orientation_matrix_to_scalar,"ax",%progbits
 6849              		.align	1
 6850              		.global	inv_orientation_matrix_to_scalar
 6851              		.syntax unified
 6852              		.thumb
 6853              		.thumb_func
 6854              		.fpu softvfp
 6856              	inv_orientation_matrix_to_scalar:
 6857              	.LVL494:
 6858              	.LFB112:
3363:Src/mpu6050.c **** 
3364:Src/mpu6050.c **** /*
3365:Src/mpu6050.c ****  *  This function converts the Sensor orientation matric to a scalar
3366:Src/mpu6050.c ****  */
3367:Src/mpu6050.c **** unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx)
3368:Src/mpu6050.c **** {
 6859              		.loc 1 3368 1 is_stmt 1 view -0
 6860              		.cfi_startproc
 6861              		@ args = 0, pretend = 0, frame = 0
 6862              		@ frame_needed = 0, uses_anonymous_args = 0
3369:Src/mpu6050.c ****     unsigned short scalar;
 6863              		.loc 1 3369 5 view .LVU2102
3370:Src/mpu6050.c ****     scalar  = inv_row_2_scale(mtx);
 6864              		.loc 1 3370 5 view .LVU2103
3368:Src/mpu6050.c ****     unsigned short scalar;
 6865              		.loc 1 3368 1 is_stmt 0 view .LVU2104
 6866 0000 10B5     		push	{r4, lr}
 6867              	.LCFI105:
 6868              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccC60hwS.s 			page 213


 6869              		.cfi_offset 4, -8
 6870              		.cfi_offset 14, -4
3368:Src/mpu6050.c ****     unsigned short scalar;
 6871              		.loc 1 3368 1 view .LVU2105
 6872 0002 0246     		mov	r2, r0
 6873              		.loc 1 3370 15 view .LVU2106
 6874 0004 FFF7FEFF 		bl	inv_row_2_scale
 6875              	.LVL495:
 6876              		.loc 1 3370 15 view .LVU2107
 6877 0008 0146     		mov	r1, r0
 6878              	.LVL496:
3371:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 3) << 3;
 6879              		.loc 1 3371 5 is_stmt 1 view .LVU2108
 6880              		.loc 1 3371 15 is_stmt 0 view .LVU2109
 6881 000a D01C     		adds	r0, r2, #3
 6882 000c FFF7FEFF 		bl	inv_row_2_scale
 6883              	.LVL497:
 6884 0010 0446     		mov	r4, r0
 6885              	.LVL498:
3372:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 6) << 6;
 6886              		.loc 1 3372 5 is_stmt 1 view .LVU2110
 6887              		.loc 1 3372 15 is_stmt 0 view .LVU2111
 6888 0012 901D     		adds	r0, r2, #6
 6889 0014 FFF7FEFF 		bl	inv_row_2_scale
 6890              	.LVL499:
 6891              		.loc 1 3372 40 view .LVU2112
 6892 0018 8301     		lsls	r3, r0, #6
 6893              		.loc 1 3372 12 view .LVU2113
 6894 001a 43EAC403 		orr	r3, r3, r4, lsl #3
 6895 001e 43EA0100 		orr	r0, r3, r1
 6896              	.LVL500:
3373:Src/mpu6050.c **** 
3374:Src/mpu6050.c ****     return scalar;
 6897              		.loc 1 3374 5 is_stmt 1 view .LVU2114
3375:Src/mpu6050.c **** }
 6898              		.loc 1 3375 1 is_stmt 0 view .LVU2115
 6899 0022 80B2     		uxth	r0, r0
 6900              		.loc 1 3375 1 view .LVU2116
 6901 0024 10BD     		pop	{r4, pc}
 6902              		.cfi_endproc
 6903              	.LFE112:
 6905              		.section	.rodata.mpu_config.str1.1,"aMS",%progbits,1
 6906              	.LC9:
 6907 0000 436F6E66 		.ascii	"Configuring MPU6050... \000"
 6907      69677572 
 6907      696E6720 
 6907      4D505536 
 6907      3035302E 
 6908              	.LC10:
 6909 0018 4641494C 		.ascii	"FAIL (MPU)\015\012\000"
 6909      20284D50 
 6909      55290D0A 
 6909      00
 6910              	.LC11:
 6911 0025 204F4B0D 		.ascii	" OK\015\012\000"
 6911      0A00
 6912              		.section	.text.mpu_config,"ax",%progbits
ARM GAS  /tmp/ccC60hwS.s 			page 214


 6913              		.align	1
 6914              		.global	mpu_config
 6915              		.syntax unified
 6916              		.thumb
 6917              		.thumb_func
 6918              		.fpu softvfp
 6920              	mpu_config:
 6921              	.LFB113:
3376:Src/mpu6050.c **** 
3377:Src/mpu6050.c **** 
3378:Src/mpu6050.c **** /**
3379:Src/mpu6050.c ****  *  @}
3380:Src/mpu6050.c ****  */
3381:Src/mpu6050.c **** 
3382:Src/mpu6050.c **** /* =========================== MPU-6050 Configuration =========================== */
3383:Src/mpu6050.c **** int mpu_config(void)
3384:Src/mpu6050.c **** {
 6922              		.loc 1 3384 1 is_stmt 1 view -0
 6923              		.cfi_startproc
 6924              		@ args = 0, pretend = 0, frame = 0
 6925              		@ frame_needed = 0, uses_anonymous_args = 0
3385:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
 6926              		.loc 1 3385 5 view .LVU2118
3384:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
 6927              		.loc 1 3384 1 is_stmt 0 view .LVU2119
 6928 0000 10B5     		push	{r4, lr}
 6929              	.LCFI106:
 6930              		.cfi_def_cfa_offset 8
 6931              		.cfi_offset 4, -8
 6932              		.cfi_offset 14, -4
 6933              		.loc 1 3385 5 view .LVU2120
 6934 0002 1148     		ldr	r0, .L587
 6935 0004 FFF7FEFF 		bl	consoleLog
 6936              	.LVL501:
3386:Src/mpu6050.c **** 
3387:Src/mpu6050.c ****     if(mpu_init()) {
 6937              		.loc 1 3387 5 is_stmt 1 view .LVU2121
 6938              		.loc 1 3387 8 is_stmt 0 view .LVU2122
 6939 0008 FFF7FEFF 		bl	mpu_init
 6940              	.LVL502:
 6941              		.loc 1 3387 7 view .LVU2123
 6942 000c 0446     		mov	r4, r0
 6943 000e 30B1     		cbz	r0, .L585
3388:Src/mpu6050.c ****         consoleLog("FAIL (MPU)\r\n");
 6944              		.loc 1 3388 9 is_stmt 1 view .LVU2124
 6945 0010 0E48     		ldr	r0, .L587+4
 6946 0012 FFF7FEFF 		bl	consoleLog
 6947              	.LVL503:
3389:Src/mpu6050.c ****         return -1;
 6948              		.loc 1 3389 9 view .LVU2125
 6949              		.loc 1 3389 16 is_stmt 0 view .LVU2126
 6950 0016 4FF0FF34 		mov	r4, #-1
 6951              	.L584:
3390:Src/mpu6050.c ****     }
3391:Src/mpu6050.c **** 
3392:Src/mpu6050.c ****     /* Get/set hardware configuration. Start gyro. */
3393:Src/mpu6050.c ****     /* Wake up all sensors. */
ARM GAS  /tmp/ccC60hwS.s 			page 215


3394:Src/mpu6050.c ****     mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL);
3395:Src/mpu6050.c **** 
3396:Src/mpu6050.c ****     /* Push both gyro and accel data into the FIFO. */
3397:Src/mpu6050.c ****     mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);
3398:Src/mpu6050.c ****     mpu_set_sample_rate(MPU_DEFAULT_HZ);
3399:Src/mpu6050.c **** 
3400:Src/mpu6050.c ****     /* Read back configuration in case it was set improperly. */
3401:Src/mpu6050.c ****     // mpu_get_sample_rate(&gyro_rate);
3402:Src/mpu6050.c ****     // mpu_get_gyro_fsr(&gyro_fsr);
3403:Src/mpu6050.c ****     // mpu_get_accel_fsr(&accel_fsr);
3404:Src/mpu6050.c **** 
3405:Src/mpu6050.c ****     /* Initialize HAL state variables. */
3406:Src/mpu6050.c ****     hal.sensors             = ACCEL_ON | GYRO_ON;
3407:Src/mpu6050.c ****     hal.dmp_on              = 0;
3408:Src/mpu6050.c ****     hal.report              = 0;
3409:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
3410:Src/mpu6050.c ****     hal.next_temp_ms        = 0;
3411:Src/mpu6050.c **** 
3412:Src/mpu6050.c **** #ifdef MPU_DMP_ENABLE
3413:Src/mpu6050.c ****     /* To initialize the DMP:
3414:Src/mpu6050.c ****      * 1. Call dmp_load_motion_driver_firmware(). This pushes the DMP image in
3415:Src/mpu6050.c ****      *    inv_mpu_dmp_motion_driver.h into the MPU memory.
3416:Src/mpu6050.c ****      * 2. Push the gyro and accel orientation matrix to the DMP.
3417:Src/mpu6050.c ****      * 3. Register gesture callbacks. Don't worry, these callbacks won't be
3418:Src/mpu6050.c ****      *    executed unless the corresponding feature is enabled.
3419:Src/mpu6050.c ****      * 4. Call dmp_enable_feature(mask) to enable different features.
3420:Src/mpu6050.c ****      * 5. Call dmp_set_fifo_rate(freq) to select a DMP output rate.
3421:Src/mpu6050.c ****      * 6. Call any feature-specific control functions.
3422:Src/mpu6050.c ****      *
3423:Src/mpu6050.c ****      * To enable the DMP, just call mpu_set_dmp_state(1). This function can
3424:Src/mpu6050.c ****      * be called repeatedly to enable and disable the DMP at runtime.
3425:Src/mpu6050.c ****      *
3426:Src/mpu6050.c ****      * The following is a short summary of the features supported in the DMP
3427:Src/mpu6050.c ****      * image provided in inv_mpu_dmp_motion_driver.c:
3428:Src/mpu6050.c ****      * DMP_FEATURE_LP_QUAT: Generate a gyro-only quaternion on the DMP at
3429:Src/mpu6050.c ****      * 200Hz. Integrating the gyro data at higher rates reduces numerical
3430:Src/mpu6050.c ****      * errors (compared to integration on the MCU at a lower sampling rate).
3431:Src/mpu6050.c ****      * DMP_FEATURE_6X_LP_QUAT: Generate a gyro/accel quaternion on the DMP at
3432:Src/mpu6050.c ****      * 200Hz. Cannot be used in combination with DMP_FEATURE_LP_QUAT.
3433:Src/mpu6050.c ****      * DMP_FEATURE_TAP: Detect taps along the X, Y, and Z axes.
3434:Src/mpu6050.c ****      * DMP_FEATURE_ANDROID_ORIENT: Google's screen rotation algorithm. Triggers
3435:Src/mpu6050.c ****      * an event at the four orientations where the screen should rotate.
3436:Src/mpu6050.c ****      * DMP_FEATURE_GYRO_CAL: Calibrates the gyro data after eight seconds of
3437:Src/mpu6050.c ****      * no motion.
3438:Src/mpu6050.c ****      * DMP_FEATURE_SEND_RAW_ACCEL: Add raw accelerometer data to the FIFO.
3439:Src/mpu6050.c ****      * DMP_FEATURE_SEND_RAW_GYRO: Add raw gyro data to the FIFO.
3440:Src/mpu6050.c ****      * DMP_FEATURE_SEND_CAL_GYRO: Add calibrated gyro data to the FIFO. Cannot
3441:Src/mpu6050.c ****      * be used in combination with DMP_FEATURE_SEND_RAW_GYRO.
3442:Src/mpu6050.c ****      */
3443:Src/mpu6050.c ****         consoleLog(" writing DMP... ");
3444:Src/mpu6050.c ****         if (dmp_load_motion_driver_firmware()) {
3445:Src/mpu6050.c ****             consoleLog(" FAIL (DMP)\r\n");
3446:Src/mpu6050.c ****             return -1;
3447:Src/mpu6050.c ****         }
3448:Src/mpu6050.c ****     dmp_set_orientation(inv_orientation_matrix_to_scalar(MPU_ORIENTATION));
3449:Src/mpu6050.c ****     dmp_register_tap_cb(mpu_tap_func);
3450:Src/mpu6050.c ****     dmp_register_android_orient_cb(mpu_android_orient_func);
ARM GAS  /tmp/ccC60hwS.s 			page 216


3451:Src/mpu6050.c ****     /*
3452:Src/mpu6050.c ****      * Known Bug -
3453:Src/mpu6050.c ****      * DMP when enabled will sample sensor data at 200Hz and output to FIFO at the rate
3454:Src/mpu6050.c ****      * specified in the dmp_set_fifo_rate API. The DMP will then sent an interrupt once
3455:Src/mpu6050.c ****      * a sample has been put into the FIFO. Therefore if the dmp_set_fifo_rate is at 25Hz
3456:Src/mpu6050.c ****      * there will be a 25Hz interrupt from the MPU device.
3457:Src/mpu6050.c ****      *
3458:Src/mpu6050.c ****      * There is a known issue in which if you do not enable DMP_FEATURE_TAP
3459:Src/mpu6050.c ****      * then the interrupts will be at 200Hz even if fifo rate
3460:Src/mpu6050.c ****      * is set at a different rate. To avoid this issue include the DMP_FEATURE_TAP
3461:Src/mpu6050.c ****      *
3462:Src/mpu6050.c ****      * DMP sensor fusion works only with gyro at +-2000dps and accel +-2G
3463:Src/mpu6050.c ****      */
3464:Src/mpu6050.c ****     hal.dmp_features = 	DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT |
3465:Src/mpu6050.c ****                         DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_C
3466:Src/mpu6050.c ****     dmp_enable_feature(hal.dmp_features);
3467:Src/mpu6050.c ****     dmp_set_fifo_rate(MPU_DEFAULT_HZ);
3468:Src/mpu6050.c ****     mpu_set_dmp_state(1);
3469:Src/mpu6050.c ****     hal.dmp_on = 1;
3470:Src/mpu6050.c **** #endif
3471:Src/mpu6050.c **** 
3472:Src/mpu6050.c ****     consoleLog(" OK\r\n");	
3473:Src/mpu6050.c ****     return 0;
3474:Src/mpu6050.c **** }
 6952              		.loc 1 3474 1 view .LVU2127
 6953 001a 2046     		mov	r0, r4
 6954 001c 10BD     		pop	{r4, pc}
 6955              	.L585:
3394:Src/mpu6050.c **** 
 6956              		.loc 1 3394 5 is_stmt 1 view .LVU2128
 6957 001e 7820     		movs	r0, #120
 6958 0020 FFF7FEFF 		bl	mpu_set_sensors
 6959              	.LVL504:
3397:Src/mpu6050.c ****     mpu_set_sample_rate(MPU_DEFAULT_HZ);
 6960              		.loc 1 3397 5 view .LVU2129
 6961 0024 7820     		movs	r0, #120
 6962 0026 FFF7FEFF 		bl	mpu_configure_fifo
 6963              	.LVL505:
3398:Src/mpu6050.c **** 
 6964              		.loc 1 3398 5 view .LVU2130
 6965 002a 1420     		movs	r0, #20
 6966 002c FFF7FEFF 		bl	mpu_set_sample_rate
 6967              	.LVL506:
3406:Src/mpu6050.c ****     hal.dmp_on              = 0;
 6968              		.loc 1 3406 5 view .LVU2131
3406:Src/mpu6050.c ****     hal.dmp_on              = 0;
 6969              		.loc 1 3406 29 is_stmt 0 view .LVU2132
 6970 0030 0322     		movs	r2, #3
 6971 0032 074B     		ldr	r3, .L587+8
3472:Src/mpu6050.c ****     return 0;
 6972              		.loc 1 3472 5 view .LVU2133
 6973 0034 0748     		ldr	r0, .L587+12
3410:Src/mpu6050.c **** 
 6974              		.loc 1 3410 29 view .LVU2134
 6975 0036 C3E90344 		strd	r4, r4, [r3, #12]
3406:Src/mpu6050.c ****     hal.dmp_on              = 0;
 6976              		.loc 1 3406 29 view .LVU2135
ARM GAS  /tmp/ccC60hwS.s 			page 217


 6977 003a 5A70     		strb	r2, [r3, #1]
3407:Src/mpu6050.c ****     hal.report              = 0;
 6978              		.loc 1 3407 5 is_stmt 1 view .LVU2136
3407:Src/mpu6050.c ****     hal.report              = 0;
 6979              		.loc 1 3407 29 is_stmt 0 view .LVU2137
 6980 003c 9C70     		strb	r4, [r3, #2]
3408:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
 6981              		.loc 1 3408 5 is_stmt 1 view .LVU2138
3408:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
 6982              		.loc 1 3408 29 is_stmt 0 view .LVU2139
 6983 003e 5C61     		str	r4, [r3, #20]
3409:Src/mpu6050.c ****     hal.next_temp_ms        = 0;
 6984              		.loc 1 3409 5 is_stmt 1 view .LVU2140
3472:Src/mpu6050.c ****     return 0;
 6985              		.loc 1 3472 5 view .LVU2141
 6986 0040 FFF7FEFF 		bl	consoleLog
 6987              	.LVL507:
3473:Src/mpu6050.c **** }
 6988              		.loc 1 3473 5 view .LVU2142
3473:Src/mpu6050.c **** }
 6989              		.loc 1 3473 12 is_stmt 0 view .LVU2143
 6990 0044 E9E7     		b	.L584
 6991              	.L588:
 6992 0046 00BF     		.align	2
 6993              	.L587:
 6994 0048 00000000 		.word	.LC9
 6995 004c 18000000 		.word	.LC10
 6996 0050 00000000 		.word	.LANCHOR2
 6997 0054 25000000 		.word	.LC11
 6998              		.cfi_endproc
 6999              	.LFE113:
 7001              		.section	.text.mpu_read_gyro_raw,"ax",%progbits
 7002              		.align	1
 7003              		.global	mpu_read_gyro_raw
 7004              		.syntax unified
 7005              		.thumb
 7006              		.thumb_func
 7007              		.fpu softvfp
 7009              	mpu_read_gyro_raw:
 7010              	.LFB115:
3475:Src/mpu6050.c **** 
3476:Src/mpu6050.c **** 
3477:Src/mpu6050.c **** /* =========================== MPU-6050 Get Packet Data =========================== */
3478:Src/mpu6050.c **** 
3479:Src/mpu6050.c **** void mpu_get_data(void)
3480:Src/mpu6050.c **** {
3481:Src/mpu6050.c ****     
3482:Src/mpu6050.c ****     unsigned long sensor_timestamp;
3483:Src/mpu6050.c ****     unsigned long timestamp;
3484:Src/mpu6050.c ****     unsigned char new_data = 0, new_temp = 0;
3485:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
3486:Src/mpu6050.c **** 
3487:Src/mpu6050.c ****     // check for DMP interrupt bit or Data Ready interrupt bit (in case DMP is disabled) -> this in
3488:Src/mpu6050.c ****     i2c_readByte(st.hw->addr, st.reg->int_status, &mpu_int_status);
3489:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
3490:Src/mpu6050.c ****             hal.new_gyro = 1;
3491:Src/mpu6050.c ****     }
ARM GAS  /tmp/ccC60hwS.s 			page 218


3492:Src/mpu6050.c **** 
3493:Src/mpu6050.c ****     get_tick_count_ms(&timestamp);
3494:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
3495:Src/mpu6050.c ****      * Let's make them timer-based.
3496:Src/mpu6050.c ****      */
3497:Src/mpu6050.c ****     if (timestamp > hal.next_temp_ms) {
3498:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
3499:Src/mpu6050.c ****         new_temp = 1;
3500:Src/mpu6050.c ****     }
3501:Src/mpu6050.c **** 
3502:Src/mpu6050.c **** 
3503:Src/mpu6050.c ****     if (hal.new_gyro && hal.dmp_on) {
3504:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
3505:Src/mpu6050.c ****         static long quat[4], temperature;
3506:Src/mpu6050.c ****         unsigned char more;
3507:Src/mpu6050.c ****         /* This function gets new data from the FIFO when the DMP is in
3508:Src/mpu6050.c ****             * use. The FIFO can contain any combination of gyro, accel,
3509:Src/mpu6050.c ****             * quaternion, and gesture data. The sensors parameter tells the
3510:Src/mpu6050.c ****             * caller which data fields were actually populated with new data.
3511:Src/mpu6050.c ****             * For example, if sensors == (INV_XYZ_GYRO | INV_WXYZ_QUAT), then
3512:Src/mpu6050.c ****             * the FIFO isn't being filled with accel data.
3513:Src/mpu6050.c ****             * The driver parses the gesture data to determine if a gesture
3514:Src/mpu6050.c ****             * event has occurred; on an event, the application will be notified
3515:Src/mpu6050.c ****             * via a callback (assuming that a callback function was properly
3516:Src/mpu6050.c ****             * registered). The more parameter is non-zero if there are
3517:Src/mpu6050.c ****             * leftover packets in the FIFO.
3518:Src/mpu6050.c ****             */
3519:Src/mpu6050.c ****         dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors, &more);
3520:Src/mpu6050.c ****         if (!more)
3521:Src/mpu6050.c ****             hal.new_gyro = 0;
3522:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
3523:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
3524:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
3525:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
3526:Src/mpu6050.c ****             new_data = 1;
3527:Src/mpu6050.c ****             if (new_temp) {
3528:Src/mpu6050.c ****                 new_temp = 0;
3529:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
3530:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
3531:Src/mpu6050.c ****             }
3532:Src/mpu6050.c ****         }
3533:Src/mpu6050.c ****         if (sensors & INV_XYZ_ACCEL) {
3534:Src/mpu6050.c ****             mpu.accel.x = accel[0];
3535:Src/mpu6050.c ****             mpu.accel.y = accel[1];
3536:Src/mpu6050.c ****             mpu.accel.z = accel[2];
3537:Src/mpu6050.c ****             new_data = 1;
3538:Src/mpu6050.c ****         }
3539:Src/mpu6050.c ****         if (sensors & INV_WXYZ_QUAT) {
3540:Src/mpu6050.c ****             mpu.quat.w = quat[0];
3541:Src/mpu6050.c ****             mpu.quat.x = quat[1];
3542:Src/mpu6050.c ****             mpu.quat.y = quat[2];
3543:Src/mpu6050.c ****             mpu.quat.z = quat[3];
3544:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
3545:Src/mpu6050.c ****             new_data = 1;
3546:Src/mpu6050.c ****         }
3547:Src/mpu6050.c ****     } else if (hal.new_gyro) {
3548:Src/mpu6050.c ****         short gyro[3], accel[3];
ARM GAS  /tmp/ccC60hwS.s 			page 219


3549:Src/mpu6050.c ****         long temperature;
3550:Src/mpu6050.c ****         unsigned char sensors, more;
3551:Src/mpu6050.c ****         /* This function gets new data from the FIFO. The FIFO can contain
3552:Src/mpu6050.c ****             * gyro, accel, both, or neither. The sensors parameter tells the
3553:Src/mpu6050.c ****             * caller which data fields were actually populated with new data.
3554:Src/mpu6050.c ****             * For example, if sensors == INV_XYZ_GYRO, then the FIFO isn't
3555:Src/mpu6050.c ****             * being filled with accel data. The more parameter is non-zero if
3556:Src/mpu6050.c ****             * there are leftover packets in the FIFO. The HAL can use this
3557:Src/mpu6050.c ****             * information to increase the frequency at which this function is
3558:Src/mpu6050.c ****             * called.
3559:Src/mpu6050.c ****             */
3560:Src/mpu6050.c ****         hal.new_gyro = 0;
3561:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
3562:Src/mpu6050.c ****         if (more)
3563:Src/mpu6050.c ****             hal.new_gyro = 1;
3564:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
3565:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
3566:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
3567:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
3568:Src/mpu6050.c ****             new_data = 1;
3569:Src/mpu6050.c ****             if (new_temp) {
3570:Src/mpu6050.c ****                 new_temp = 0;
3571:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
3572:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
3573:Src/mpu6050.c ****             }
3574:Src/mpu6050.c ****         }
3575:Src/mpu6050.c ****         if (sensors & INV_XYZ_ACCEL) {
3576:Src/mpu6050.c ****             mpu.accel.x = accel[0];
3577:Src/mpu6050.c ****             mpu.accel.y = accel[1];
3578:Src/mpu6050.c ****             mpu.accel.z = accel[2];
3579:Src/mpu6050.c ****             new_data = 1;
3580:Src/mpu6050.c ****         }
3581:Src/mpu6050.c ****     }
3582:Src/mpu6050.c **** 
3583:Src/mpu6050.c ****     if (new_data) {
3584:Src/mpu6050.c ****         // do something if needed
3585:Src/mpu6050.c ****     }
3586:Src/mpu6050.c ****         
3587:Src/mpu6050.c **** }
3588:Src/mpu6050.c **** 
3589:Src/mpu6050.c **** 
3590:Src/mpu6050.c **** /* =========================== MPU-6050 Post-processing Functions =========================== */
3591:Src/mpu6050.c **** 
3592:Src/mpu6050.c **** void mpu_read_gyro_raw(void)
3593:Src/mpu6050.c **** {
 7011              		.loc 1 3593 1 is_stmt 1 view -0
 7012              		.cfi_startproc
 7013              		@ args = 0, pretend = 0, frame = 8
 7014              		@ frame_needed = 0, uses_anonymous_args = 0
3594:Src/mpu6050.c ****     uint8_t buffer[6];
 7015              		.loc 1 3594 5 view .LVU2145
3595:Src/mpu6050.c **** 
3596:Src/mpu6050.c ****     // Read 6 BYTES of data starting from GYRO_XOUT_H register (the MPU-6050 automatically incremen
3597:Src/mpu6050.c ****     i2c_readBytes(st.hw->addr, st.reg->raw_accel, 6, buffer);
 7016              		.loc 1 3597 5 view .LVU2146
3593:Src/mpu6050.c ****     uint8_t buffer[6];
 7017              		.loc 1 3593 1 is_stmt 0 view .LVU2147
ARM GAS  /tmp/ccC60hwS.s 			page 220


 7018 0000 07B5     		push	{r0, r1, r2, lr}
 7019              	.LCFI107:
 7020              		.cfi_def_cfa_offset 16
 7021              		.cfi_offset 14, -4
 7022              		.loc 1 3597 34 view .LVU2148
 7023 0002 0C4B     		ldr	r3, .L590
 7024              		.loc 1 3597 5 view .LVU2149
 7025 0004 0622     		movs	r2, #6
 7026 0006 D3E90010 		ldrd	r1, r0, [r3]
 7027 000a 6B46     		mov	r3, sp
 7028 000c C97B     		ldrb	r1, [r1, #15]	@ zero_extendqisi2
 7029 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 7030 0010 FFF7FEFF 		bl	i2c_readBytes
 7031              	.LVL508:
3598:Src/mpu6050.c **** 
3599:Src/mpu6050.c ****     mpu.gyro.x = (int16_t)(buffer[0] << 8 | buffer[1]);
 7032              		.loc 1 3599 5 is_stmt 1 view .LVU2150
 7033              		.loc 1 3599 16 is_stmt 0 view .LVU2151
 7034 0014 BDF80020 		ldrh	r2, [sp]
 7035 0018 074B     		ldr	r3, .L590+4
 7036 001a 52BA     		rev16	r2, r2
 7037 001c 1A80     		strh	r2, [r3]	@ movhi
3600:Src/mpu6050.c ****     mpu.gyro.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7038              		.loc 1 3600 5 is_stmt 1 view .LVU2152
 7039              		.loc 1 3600 16 is_stmt 0 view .LVU2153
 7040 001e BDF80220 		ldrh	r2, [sp, #2]
 7041 0022 52BA     		rev16	r2, r2
 7042 0024 5A80     		strh	r2, [r3, #2]	@ movhi
3601:Src/mpu6050.c ****     mpu.gyro.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7043              		.loc 1 3601 5 is_stmt 1 view .LVU2154
 7044              		.loc 1 3601 16 is_stmt 0 view .LVU2155
 7045 0026 BDF80420 		ldrh	r2, [sp, #4]
 7046 002a 52BA     		rev16	r2, r2
 7047 002c 9A80     		strh	r2, [r3, #4]	@ movhi
3602:Src/mpu6050.c **** 
3603:Src/mpu6050.c ****     /*** convert the RAW hardware units values into dps (�/s)
3604:Src/mpu6050.c ****          we have to divide according to the Full scale value set in FS_SEL,
3605:Src/mpu6050.c ****          configured to 2000�/s (check MPU_GYRO_FSR). So we need to divide by 16.4 LSB/�/s
3606:Src/mpu6050.c ****          for more details check GYRO_CONFIG Register              ****/
3607:Src/mpu6050.c ****     //Gx = mpu.gyro.x / 16.4;
3608:Src/mpu6050.c ****     //Gy = mpu.gyro.y / 16.4;
3609:Src/mpu6050.c ****     //Gz = mpu.gyro.z / 16.4;
3610:Src/mpu6050.c **** }
 7048              		.loc 1 3610 1 view .LVU2156
 7049 002e 03B0     		add	sp, sp, #12
 7050              	.LCFI108:
 7051              		.cfi_def_cfa_offset 4
 7052              		@ sp needed
 7053 0030 5DF804FB 		ldr	pc, [sp], #4
 7054              	.L591:
 7055              		.align	2
 7056              	.L590:
 7057 0034 00000000 		.word	.LANCHOR0
 7058 0038 00000000 		.word	.LANCHOR3
 7059              		.cfi_endproc
 7060              	.LFE115:
 7062              		.section	.text.mpu_read_accel_raw,"ax",%progbits
ARM GAS  /tmp/ccC60hwS.s 			page 221


 7063              		.align	1
 7064              		.global	mpu_read_accel_raw
 7065              		.syntax unified
 7066              		.thumb
 7067              		.thumb_func
 7068              		.fpu softvfp
 7070              	mpu_read_accel_raw:
 7071              	.LFB116:
3611:Src/mpu6050.c **** 
3612:Src/mpu6050.c **** 
3613:Src/mpu6050.c **** void mpu_read_accel_raw(void)
3614:Src/mpu6050.c **** {
 7072              		.loc 1 3614 1 is_stmt 1 view -0
 7073              		.cfi_startproc
 7074              		@ args = 0, pretend = 0, frame = 8
 7075              		@ frame_needed = 0, uses_anonymous_args = 0
3615:Src/mpu6050.c ****     uint8_t buffer[6];
 7076              		.loc 1 3615 5 view .LVU2158
3616:Src/mpu6050.c **** 
3617:Src/mpu6050.c ****     // Read 6 BYTES of data starting from ACCEL_XOUT_H register (the MPU-6050 automatically increme
3618:Src/mpu6050.c ****     i2c_readBytes(st.hw->addr, st.reg->raw_gyro, 6, buffer);
 7077              		.loc 1 3618 5 view .LVU2159
3614:Src/mpu6050.c ****     uint8_t buffer[6];
 7078              		.loc 1 3614 1 is_stmt 0 view .LVU2160
 7079 0000 07B5     		push	{r0, r1, r2, lr}
 7080              	.LCFI109:
 7081              		.cfi_def_cfa_offset 16
 7082              		.cfi_offset 14, -4
 7083              		.loc 1 3618 34 view .LVU2161
 7084 0002 0C4B     		ldr	r3, .L593
 7085              		.loc 1 3618 5 view .LVU2162
 7086 0004 0622     		movs	r2, #6
 7087 0006 D3E90010 		ldrd	r1, r0, [r3]
 7088 000a 6B46     		mov	r3, sp
 7089 000c 897B     		ldrb	r1, [r1, #14]	@ zero_extendqisi2
 7090 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 7091 0010 FFF7FEFF 		bl	i2c_readBytes
 7092              	.LVL509:
3619:Src/mpu6050.c ****     
3620:Src/mpu6050.c ****     mpu.accel.x = (int16_t)(buffer[0] << 8 | buffer[1]);
 7093              		.loc 1 3620 5 is_stmt 1 view .LVU2163
 7094              		.loc 1 3620 17 is_stmt 0 view .LVU2164
 7095 0014 BDF80020 		ldrh	r2, [sp]
 7096 0018 074B     		ldr	r3, .L593+4
 7097 001a 52BA     		rev16	r2, r2
 7098 001c DA80     		strh	r2, [r3, #6]	@ movhi
3621:Src/mpu6050.c ****     mpu.accel.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7099              		.loc 1 3621 5 is_stmt 1 view .LVU2165
 7100              		.loc 1 3621 17 is_stmt 0 view .LVU2166
 7101 001e BDF80220 		ldrh	r2, [sp, #2]
 7102 0022 52BA     		rev16	r2, r2
 7103 0024 1A81     		strh	r2, [r3, #8]	@ movhi
3622:Src/mpu6050.c ****     mpu.accel.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7104              		.loc 1 3622 5 is_stmt 1 view .LVU2167
 7105              		.loc 1 3622 17 is_stmt 0 view .LVU2168
 7106 0026 BDF80420 		ldrh	r2, [sp, #4]
 7107 002a 52BA     		rev16	r2, r2
ARM GAS  /tmp/ccC60hwS.s 			page 222


 7108 002c 5A81     		strh	r2, [r3, #10]	@ movhi
3623:Src/mpu6050.c **** 
3624:Src/mpu6050.c **** 
3625:Src/mpu6050.c ****     /*** convert the RAW hardware units into acceleration in 'g'
3626:Src/mpu6050.c ****          we have to divide according to the Full scale value set in FS_SEL,
3627:Src/mpu6050.c ****          configured to 2g (check MPU_ACCEL_FSR). So we need to divide by 16384.0 LSB/g
3628:Src/mpu6050.c ****          for more details check ACCEL_CONFIG Register              ****/
3629:Src/mpu6050.c ****     //Ax = mpu.accel.x / 16384.0;
3630:Src/mpu6050.c ****     //Ay = mpu.accel.y / 16384.0;
3631:Src/mpu6050.c ****     //Az = mpu.accel.z / 16384.0;
3632:Src/mpu6050.c **** }
 7109              		.loc 1 3632 1 view .LVU2169
 7110 002e 03B0     		add	sp, sp, #12
 7111              	.LCFI110:
 7112              		.cfi_def_cfa_offset 4
 7113              		@ sp needed
 7114 0030 5DF804FB 		ldr	pc, [sp], #4
 7115              	.L594:
 7116              		.align	2
 7117              	.L593:
 7118 0034 00000000 		.word	.LANCHOR0
 7119 0038 00000000 		.word	.LANCHOR3
 7120              		.cfi_endproc
 7121              	.LFE116:
 7123              		.global	__aeabi_f2d
 7124              		.global	__aeabi_d2f
 7125              		.global	__aeabi_dmul
 7126              		.global	__aeabi_d2iz
 7127              		.section	.text.mpu_calc_euler_angles,"ax",%progbits
 7128              		.align	1
 7129              		.global	mpu_calc_euler_angles
 7130              		.syntax unified
 7131              		.thumb
 7132              		.thumb_func
 7133              		.fpu softvfp
 7135              	mpu_calc_euler_angles:
 7136              	.LFB117:
3633:Src/mpu6050.c **** 
3634:Src/mpu6050.c **** /*
3635:Src/mpu6050.c ****  * Calculate Euler Angles
3636:Src/mpu6050.c ****  * aerospace sequence, to obtain sensor attitude:
3637:Src/mpu6050.c ****  * 1. roll  (x-axis rotation)
3638:Src/mpu6050.c ****  * 2. pitch (y-axis rotation)
3639:Src/mpu6050.c ****  * 3. yaw   (z-axis rotation)
3640:Src/mpu6050.c ****  */
3641:Src/mpu6050.c **** void mpu_calc_euler_angles(void) {
 7137              		.loc 1 3641 34 is_stmt 1 view -0
 7138              		.cfi_startproc
 7139              		@ args = 0, pretend = 0, frame = 16
 7140              		@ frame_needed = 0, uses_anonymous_args = 0
3642:Src/mpu6050.c ****     
3643:Src/mpu6050.c ****     float w, x, y, z;
 7141              		.loc 1 3643 5 view .LVU2171
3644:Src/mpu6050.c ****     float yaw, pitch, roll;
 7142              		.loc 1 3644 5 view .LVU2172
3645:Src/mpu6050.c **** 
3646:Src/mpu6050.c ****     // Convert quaternions[q30] to quaternion[float]
ARM GAS  /tmp/ccC60hwS.s 			page 223


3647:Src/mpu6050.c ****     w = (float)mpu.quat.w / q30;        // q30 = 2^30
 7143              		.loc 1 3647 5 view .LVU2173
3641:Src/mpu6050.c ****     
 7144              		.loc 1 3641 34 is_stmt 0 view .LVU2174
 7145 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7146              	.LCFI111:
 7147              		.cfi_def_cfa_offset 36
 7148              		.cfi_offset 4, -36
 7149              		.cfi_offset 5, -32
 7150              		.cfi_offset 6, -28
 7151              		.cfi_offset 7, -24
 7152              		.cfi_offset 8, -20
 7153              		.cfi_offset 9, -16
 7154              		.cfi_offset 10, -12
 7155              		.cfi_offset 11, -8
 7156              		.cfi_offset 14, -4
 7157              		.loc 1 3647 24 view .LVU2175
 7158 0004 6A4C     		ldr	r4, .L596+8
3641:Src/mpu6050.c ****     
 7159              		.loc 1 3641 34 view .LVU2176
 7160 0006 85B0     		sub	sp, sp, #20
 7161              	.LCFI112:
 7162              		.cfi_def_cfa_offset 56
 7163              		.loc 1 3647 9 view .LVU2177
 7164 0008 E068     		ldr	r0, [r4, #12]
 7165 000a FFF7FEFF 		bl	__aeabi_i2f
 7166              	.LVL510:
 7167              		.loc 1 3647 7 view .LVU2178
 7168 000e 4FF04251 		mov	r1, #813694976
 7169 0012 FFF7FEFF 		bl	__aeabi_fmul
 7170              	.LVL511:
 7171 0016 8246     		mov	r10, r0
 7172              	.LVL512:
3648:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
 7173              		.loc 1 3648 5 is_stmt 1 view .LVU2179
 7174              		.loc 1 3648 9 is_stmt 0 view .LVU2180
 7175 0018 2069     		ldr	r0, [r4, #16]
 7176              	.LVL513:
 7177              		.loc 1 3648 9 view .LVU2181
 7178 001a FFF7FEFF 		bl	__aeabi_i2f
 7179              	.LVL514:
 7180              		.loc 1 3648 7 view .LVU2182
 7181 001e 4FF04251 		mov	r1, #813694976
 7182 0022 FFF7FEFF 		bl	__aeabi_fmul
 7183              	.LVL515:
 7184 0026 0546     		mov	r5, r0
 7185              	.LVL516:
3649:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
 7186              		.loc 1 3649 5 is_stmt 1 view .LVU2183
 7187              		.loc 1 3649 9 is_stmt 0 view .LVU2184
 7188 0028 6069     		ldr	r0, [r4, #20]
 7189              	.LVL517:
 7190              		.loc 1 3649 9 view .LVU2185
 7191 002a FFF7FEFF 		bl	__aeabi_i2f
 7192              	.LVL518:
 7193              		.loc 1 3649 7 view .LVU2186
 7194 002e 4FF04251 		mov	r1, #813694976
ARM GAS  /tmp/ccC60hwS.s 			page 224


 7195 0032 FFF7FEFF 		bl	__aeabi_fmul
 7196              	.LVL519:
 7197 0036 0646     		mov	r6, r0
 7198              	.LVL520:
3650:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7199              		.loc 1 3650 5 is_stmt 1 view .LVU2187
 7200              		.loc 1 3650 9 is_stmt 0 view .LVU2188
 7201 0038 A069     		ldr	r0, [r4, #24]
 7202              	.LVL521:
 7203              		.loc 1 3650 9 view .LVU2189
 7204 003a FFF7FEFF 		bl	__aeabi_i2f
 7205              	.LVL522:
 7206              		.loc 1 3650 7 view .LVU2190
 7207 003e 4FF04251 		mov	r1, #813694976
 7208 0042 FFF7FEFF 		bl	__aeabi_fmul
 7209              	.LVL523:
3651:Src/mpu6050.c **** 
3652:Src/mpu6050.c ****     // Calculate Euler angles: source <https://en.wikipedia.org/wiki/Conversion_between_quaternions
3653:Src/mpu6050.c ****     roll    = atan2(2*(w*x + y*z), 1 - 2*(x*x + y*y));      // roll  (x-axis rotation)
 7210              		.loc 1 3653 50 view .LVU2191
 7211 0046 3146     		mov	r1, r6
3650:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7212              		.loc 1 3650 7 view .LVU2192
 7213 0048 0746     		mov	r7, r0
 7214              	.LVL524:
 7215              		.loc 1 3653 5 is_stmt 1 view .LVU2193
 7216              		.loc 1 3653 50 is_stmt 0 view .LVU2194
 7217 004a 3046     		mov	r0, r6
 7218              	.LVL525:
 7219              		.loc 1 3653 50 view .LVU2195
 7220 004c FFF7FEFF 		bl	__aeabi_fmul
 7221              	.LVL526:
 7222 0050 8346     		mov	fp, r0
 7223              		.loc 1 3653 44 view .LVU2196
 7224 0052 2946     		mov	r1, r5
 7225 0054 2846     		mov	r0, r5
 7226 0056 FFF7FEFF 		bl	__aeabi_fmul
 7227              	.LVL527:
 7228              		.loc 1 3653 47 view .LVU2197
 7229 005a 5946     		mov	r1, fp
 7230 005c FFF7FEFF 		bl	__aeabi_fadd
 7231              	.LVL528:
 7232 0060 0146     		mov	r1, r0
 7233              		.loc 1 3653 41 view .LVU2198
 7234 0062 FFF7FEFF 		bl	__aeabi_fadd
 7235              	.LVL529:
 7236 0066 0146     		mov	r1, r0
 7237              		.loc 1 3653 38 view .LVU2199
 7238 0068 4FF07E50 		mov	r0, #1065353216
 7239 006c FFF7FEFF 		bl	__aeabi_fsub
 7240              	.LVL530:
 7241              		.loc 1 3653 15 view .LVU2200
 7242 0070 FFF7FEFF 		bl	__aeabi_f2d
 7243              	.LVL531:
 7244 0074 8046     		mov	r8, r0
 7245 0076 8946     		mov	r9, r1
 7246              		.loc 1 3653 25 view .LVU2201
ARM GAS  /tmp/ccC60hwS.s 			page 225


 7247 0078 5046     		mov	r0, r10
 7248 007a 2946     		mov	r1, r5
 7249 007c FFF7FEFF 		bl	__aeabi_fmul
 7250              	.LVL532:
 7251              		.loc 1 3653 31 view .LVU2202
 7252 0080 3946     		mov	r1, r7
 7253              		.loc 1 3653 25 view .LVU2203
 7254 0082 0090     		str	r0, [sp]
 7255              		.loc 1 3653 31 view .LVU2204
 7256 0084 3046     		mov	r0, r6
 7257 0086 FFF7FEFF 		bl	__aeabi_fmul
 7258              	.LVL533:
 7259              		.loc 1 3653 28 view .LVU2205
 7260 008a 009B     		ldr	r3, [sp]
 7261              		.loc 1 3653 31 view .LVU2206
 7262 008c 0146     		mov	r1, r0
 7263              		.loc 1 3653 28 view .LVU2207
 7264 008e 1846     		mov	r0, r3
 7265 0090 FFF7FEFF 		bl	__aeabi_fadd
 7266              	.LVL534:
 7267 0094 0146     		mov	r1, r0
 7268              		.loc 1 3653 22 view .LVU2208
 7269 0096 FFF7FEFF 		bl	__aeabi_fadd
 7270              	.LVL535:
 7271              		.loc 1 3653 15 view .LVU2209
 7272 009a FFF7FEFF 		bl	__aeabi_f2d
 7273              	.LVL536:
 7274 009e 4246     		mov	r2, r8
 7275 00a0 4B46     		mov	r3, r9
 7276 00a2 FFF7FEFF 		bl	atan2
 7277              	.LVL537:
 7278 00a6 8046     		mov	r8, r0
 7279 00a8 8946     		mov	r9, r1
 7280              	.LVL538:
3654:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7281              		.loc 1 3654 5 is_stmt 1 view .LVU2210
 7282              		.loc 1 3654 24 is_stmt 0 view .LVU2211
 7283 00aa 5046     		mov	r0, r10
 7284 00ac 3146     		mov	r1, r6
 7285 00ae FFF7FEFF 		bl	__aeabi_fmul
 7286              	.LVL539:
 7287              		.loc 1 3654 30 view .LVU2212
 7288 00b2 3946     		mov	r1, r7
 7289              		.loc 1 3654 24 view .LVU2213
 7290 00b4 0090     		str	r0, [sp]
 7291              		.loc 1 3654 30 view .LVU2214
 7292 00b6 2846     		mov	r0, r5
 7293 00b8 FFF7FEFF 		bl	__aeabi_fmul
 7294              	.LVL540:
 7295              		.loc 1 3654 27 view .LVU2215
 7296 00bc 009B     		ldr	r3, [sp]
 7297              		.loc 1 3654 30 view .LVU2216
 7298 00be 0146     		mov	r1, r0
 7299              		.loc 1 3654 27 view .LVU2217
 7300 00c0 1846     		mov	r0, r3
 7301 00c2 FFF7FEFF 		bl	__aeabi_fsub
 7302              	.LVL541:
ARM GAS  /tmp/ccC60hwS.s 			page 226


 7303 00c6 0146     		mov	r1, r0
 7304              		.loc 1 3654 21 view .LVU2218
 7305 00c8 FFF7FEFF 		bl	__aeabi_fadd
 7306              	.LVL542:
 7307              		.loc 1 3654 15 view .LVU2219
 7308 00cc FFF7FEFF 		bl	__aeabi_f2d
 7309              	.LVL543:
 7310 00d0 FFF7FEFF 		bl	asin
 7311              	.LVL544:
 7312 00d4 CDE90001 		strd	r0, [sp]
 7313              	.LVL545:
3655:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7314              		.loc 1 3655 5 is_stmt 1 view .LVU2220
 7315              		.loc 1 3655 50 is_stmt 0 view .LVU2221
 7316 00d8 3946     		mov	r1, r7
 7317 00da 3846     		mov	r0, r7
 7318              	.LVL546:
 7319              		.loc 1 3655 50 view .LVU2222
 7320 00dc FFF7FEFF 		bl	__aeabi_fmul
 7321              	.LVL547:
 7322              		.loc 1 3655 47 view .LVU2223
 7323 00e0 5946     		mov	r1, fp
 7324 00e2 FFF7FEFF 		bl	__aeabi_fadd
 7325              	.LVL548:
 7326 00e6 0146     		mov	r1, r0
 7327              		.loc 1 3655 41 view .LVU2224
 7328 00e8 FFF7FEFF 		bl	__aeabi_fadd
 7329              	.LVL549:
 7330 00ec 0146     		mov	r1, r0
 7331              		.loc 1 3655 38 view .LVU2225
 7332 00ee 4FF07E50 		mov	r0, #1065353216
 7333 00f2 FFF7FEFF 		bl	__aeabi_fsub
 7334              	.LVL550:
 7335              		.loc 1 3655 15 view .LVU2226
 7336 00f6 FFF7FEFF 		bl	__aeabi_f2d
 7337              	.LVL551:
 7338 00fa 0246     		mov	r2, r0
 7339 00fc 0B46     		mov	r3, r1
 7340              		.loc 1 3655 25 view .LVU2227
 7341 00fe 5046     		mov	r0, r10
 7342 0100 3946     		mov	r1, r7
 7343              		.loc 1 3655 15 view .LVU2228
 7344 0102 CDE90223 		strd	r2, [sp, #8]
 7345              		.loc 1 3655 25 view .LVU2229
 7346 0106 FFF7FEFF 		bl	__aeabi_fmul
 7347              	.LVL552:
 7348              		.loc 1 3655 31 view .LVU2230
 7349 010a 3146     		mov	r1, r6
 7350              		.loc 1 3655 25 view .LVU2231
 7351 010c 0746     		mov	r7, r0
 7352              	.LVL553:
 7353              		.loc 1 3655 31 view .LVU2232
 7354 010e 2846     		mov	r0, r5
 7355 0110 FFF7FEFF 		bl	__aeabi_fmul
 7356              	.LVL554:
 7357 0114 0146     		mov	r1, r0
 7358              		.loc 1 3655 28 view .LVU2233
ARM GAS  /tmp/ccC60hwS.s 			page 227


 7359 0116 3846     		mov	r0, r7
 7360 0118 FFF7FEFF 		bl	__aeabi_fadd
 7361              	.LVL555:
 7362 011c 0146     		mov	r1, r0
 7363              		.loc 1 3655 22 view .LVU2234
 7364 011e FFF7FEFF 		bl	__aeabi_fadd
 7365              	.LVL556:
 7366              		.loc 1 3655 15 view .LVU2235
 7367 0122 FFF7FEFF 		bl	__aeabi_f2d
 7368              	.LVL557:
 7369 0126 DDE90223 		ldrd	r2, [sp, #8]
 7370 012a FFF7FEFF 		bl	atan2
 7371              	.LVL558:
 7372 012e 0646     		mov	r6, r0
 7373              	.LVL559:
 7374              		.loc 1 3655 15 view .LVU2236
 7375 0130 0F46     		mov	r7, r1
 7376              	.LVL560:
3656:Src/mpu6050.c **** 
3657:Src/mpu6050.c ****     // Convert [rad] to [deg*100]
3658:Src/mpu6050.c ****     mpu.euler.roll  = (int16_t)(roll  * RAD2DEG * 100);
 7377              		.loc 1 3658 5 is_stmt 1 view .LVU2237
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7378              		.loc 1 3653 13 is_stmt 0 view .LVU2238
 7379 0132 4046     		mov	r0, r8
 7380 0134 4946     		mov	r1, r9
 7381 0136 FFF7FEFF 		bl	__aeabi_d2f
 7382              	.LVL561:
 7383              		.loc 1 3658 39 view .LVU2239
 7384 013a FFF7FEFF 		bl	__aeabi_f2d
 7385              	.LVL562:
 7386 013e 1AA3     		adr	r3, .L596
 7387 0140 D3E90023 		ldrd	r2, [r3]
 7388 0144 FFF7FEFF 		bl	__aeabi_dmul
 7389              	.LVL563:
 7390              		.loc 1 3658 49 view .LVU2240
 7391 0148 0022     		movs	r2, #0
 7392 014a 1A4B     		ldr	r3, .L596+12
 7393 014c FFF7FEFF 		bl	__aeabi_dmul
 7394              	.LVL564:
 7395              		.loc 1 3658 23 view .LVU2241
 7396 0150 FFF7FEFF 		bl	__aeabi_d2iz
 7397              	.LVL565:
 7398 0154 A083     		strh	r0, [r4, #28]	@ movhi
3659:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
 7399              		.loc 1 3659 5 is_stmt 1 view .LVU2242
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7400              		.loc 1 3654 13 is_stmt 0 view .LVU2243
 7401 0156 DDE90001 		ldrd	r0, [sp]
 7402 015a FFF7FEFF 		bl	__aeabi_d2f
 7403              	.LVL566:
 7404              		.loc 1 3659 39 view .LVU2244
 7405 015e FFF7FEFF 		bl	__aeabi_f2d
 7406              	.LVL567:
 7407 0162 11A3     		adr	r3, .L596
 7408 0164 D3E90023 		ldrd	r2, [r3]
 7409 0168 FFF7FEFF 		bl	__aeabi_dmul
ARM GAS  /tmp/ccC60hwS.s 			page 228


 7410              	.LVL568:
 7411              		.loc 1 3659 49 view .LVU2245
 7412 016c 0022     		movs	r2, #0
 7413 016e 114B     		ldr	r3, .L596+12
 7414 0170 FFF7FEFF 		bl	__aeabi_dmul
 7415              	.LVL569:
 7416              		.loc 1 3659 23 view .LVU2246
 7417 0174 FFF7FEFF 		bl	__aeabi_d2iz
 7418              	.LVL570:
3655:Src/mpu6050.c **** 
 7419              		.loc 1 3655 13 view .LVU2247
 7420 0178 3946     		mov	r1, r7
 7421              		.loc 1 3659 23 view .LVU2248
 7422 017a E083     		strh	r0, [r4, #30]	@ movhi
3660:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7423              		.loc 1 3660 5 is_stmt 1 view .LVU2249
3655:Src/mpu6050.c **** 
 7424              		.loc 1 3655 13 is_stmt 0 view .LVU2250
 7425 017c 3046     		mov	r0, r6
 7426 017e FFF7FEFF 		bl	__aeabi_d2f
 7427              	.LVL571:
 7428              		.loc 1 3660 39 view .LVU2251
 7429 0182 FFF7FEFF 		bl	__aeabi_f2d
 7430              	.LVL572:
 7431 0186 08A3     		adr	r3, .L596
 7432 0188 D3E90023 		ldrd	r2, [r3]
 7433 018c FFF7FEFF 		bl	__aeabi_dmul
 7434              	.LVL573:
 7435              		.loc 1 3660 49 view .LVU2252
 7436 0190 0022     		movs	r2, #0
 7437 0192 084B     		ldr	r3, .L596+12
 7438 0194 FFF7FEFF 		bl	__aeabi_dmul
 7439              	.LVL574:
 7440              		.loc 1 3660 23 view .LVU2253
 7441 0198 FFF7FEFF 		bl	__aeabi_d2iz
 7442              	.LVL575:
 7443 019c 2084     		strh	r0, [r4, #32]	@ movhi
3661:Src/mpu6050.c ****     
3662:Src/mpu6050.c **** }
 7444              		.loc 1 3662 1 view .LVU2254
 7445 019e 05B0     		add	sp, sp, #20
 7446              	.LCFI113:
 7447              		.cfi_def_cfa_offset 36
 7448              	.LVL576:
 7449              		.loc 1 3662 1 view .LVU2255
 7450              		@ sp needed
 7451 01a0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 7452              	.LVL577:
 7453              	.L597:
 7454              		.loc 1 3662 1 view .LVU2256
 7455 01a4 AFF30080 		.align	3
 7456              	.L596:
 7457 01a8 F8C1631A 		.word	442745336
 7458 01ac DCA54C40 		.word	1078765020
 7459 01b0 00000000 		.word	.LANCHOR3
 7460 01b4 00005940 		.word	1079574528
 7461              		.cfi_endproc
ARM GAS  /tmp/ccC60hwS.s 			page 229


 7462              	.LFE117:
 7464              		.section	.text.mpu_get_data,"ax",%progbits
 7465              		.align	1
 7466              		.global	mpu_get_data
 7467              		.syntax unified
 7468              		.thumb
 7469              		.thumb_func
 7470              		.fpu softvfp
 7472              	mpu_get_data:
 7473              	.LFB114:
3480:Src/mpu6050.c ****     
 7474              		.loc 1 3480 1 is_stmt 1 view -0
 7475              		.cfi_startproc
 7476              		@ args = 0, pretend = 0, frame = 32
 7477              		@ frame_needed = 0, uses_anonymous_args = 0
3482:Src/mpu6050.c ****     unsigned long timestamp;
 7478              		.loc 1 3482 5 view .LVU2258
3483:Src/mpu6050.c ****     unsigned char new_data = 0, new_temp = 0;
 7479              		.loc 1 3483 5 view .LVU2259
3484:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7480              		.loc 1 3484 5 view .LVU2260
 7481              	.LVL578:
3485:Src/mpu6050.c **** 
 7482              		.loc 1 3485 5 view .LVU2261
3488:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7483              		.loc 1 3488 5 view .LVU2262
3480:Src/mpu6050.c ****     
 7484              		.loc 1 3480 1 is_stmt 0 view .LVU2263
 7485 0000 30B5     		push	{r4, r5, lr}
 7486              	.LCFI114:
 7487              		.cfi_def_cfa_offset 12
 7488              		.cfi_offset 4, -12
 7489              		.cfi_offset 5, -8
 7490              		.cfi_offset 14, -4
3488:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7491              		.loc 1 3488 33 view .LVU2264
 7492 0002 544B     		ldr	r3, .L645
3480:Src/mpu6050.c ****     
 7493              		.loc 1 3480 1 view .LVU2265
 7494 0004 8BB0     		sub	sp, sp, #44
 7495              	.LCFI115:
 7496              		.cfi_def_cfa_offset 56
3488:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7497              		.loc 1 3488 5 view .LVU2266
 7498 0006 D3E90013 		ldrd	r1, r3, [r3]
 7499 000a 0DF10902 		add	r2, sp, #9
 7500 000e C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 7501 0010 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 7502 0012 FFF7FEFF 		bl	i2c_readByte
 7503              	.LVL579:
3489:Src/mpu6050.c ****             hal.new_gyro = 1;
 7504              		.loc 1 3489 5 is_stmt 1 view .LVU2267
3489:Src/mpu6050.c ****             hal.new_gyro = 1;
 7505              		.loc 1 3489 8 is_stmt 0 view .LVU2268
 7506 0016 9DF80930 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 7507 001a 4F4C     		ldr	r4, .L645+4
3490:Src/mpu6050.c ****     }
ARM GAS  /tmp/ccC60hwS.s 			page 230


 7508              		.loc 1 3490 13 is_stmt 1 view .LVU2269
3489:Src/mpu6050.c ****             hal.new_gyro = 1;
 7509              		.loc 1 3489 8 is_stmt 0 view .LVU2270
 7510 001c 13F0030F 		tst	r3, #3
3490:Src/mpu6050.c ****     }
 7511              		.loc 1 3490 26 view .LVU2271
 7512 0020 18BF     		it	ne
 7513 0022 0123     		movne	r3, #1
3493:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
 7514              		.loc 1 3493 5 view .LVU2272
 7515 0024 04A8     		add	r0, sp, #16
3490:Src/mpu6050.c ****     }
 7516              		.loc 1 3490 26 view .LVU2273
 7517 0026 18BF     		it	ne
 7518 0028 2371     		strbne	r3, [r4, #4]
3493:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
 7519              		.loc 1 3493 5 is_stmt 1 view .LVU2274
 7520 002a FFF7FEFF 		bl	get_tick_count_ms
 7521              	.LVL580:
3497:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7522              		.loc 1 3497 5 view .LVU2275
3497:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7523              		.loc 1 3497 19 is_stmt 0 view .LVU2276
 7524 002e 049B     		ldr	r3, [sp, #16]
3497:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7525              		.loc 1 3497 8 view .LVU2277
 7526 0030 2269     		ldr	r2, [r4, #16]
 7527 0032 9A42     		cmp	r2, r3
3498:Src/mpu6050.c ****         new_temp = 1;
 7528              		.loc 1 3498 9 is_stmt 1 view .LVU2278
3498:Src/mpu6050.c ****         new_temp = 1;
 7529              		.loc 1 3498 38 is_stmt 0 view .LVU2279
 7530 0034 3CBF     		itt	cc
 7531 0036 03F5FA73 		addcc	r3, r3, #500
3498:Src/mpu6050.c ****         new_temp = 1;
 7532              		.loc 1 3498 26 view .LVU2280
 7533 003a 2361     		strcc	r3, [r4, #16]
3499:Src/mpu6050.c ****     }
 7534              		.loc 1 3499 9 is_stmt 1 view .LVU2281
 7535              	.LVL581:
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7536              		.loc 1 3503 12 is_stmt 0 view .LVU2282
 7537 003c 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
3499:Src/mpu6050.c ****     }
 7538              		.loc 1 3499 18 view .LVU2283
 7539 003e 34BF     		ite	cc
 7540 0040 0125     		movcc	r5, #1
3484:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7541              		.loc 1 3484 33 view .LVU2284
 7542 0042 0025     		movcs	r5, #0
 7543              	.LVL582:
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7544              		.loc 1 3503 5 is_stmt 1 view .LVU2285
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7545              		.loc 1 3503 8 is_stmt 0 view .LVU2286
 7546 0044 002B     		cmp	r3, #0
 7547 0046 49D0     		beq	.L601
ARM GAS  /tmp/ccC60hwS.s 			page 231


3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7548              		.loc 1 3503 22 discriminator 1 view .LVU2287
 7549 0048 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 7550 004a 002B     		cmp	r3, #0
 7551 004c 46D0     		beq	.L601
 7552              	.LBB52:
3504:Src/mpu6050.c ****         static long quat[4], temperature;
 7553              		.loc 1 3504 9 is_stmt 1 view .LVU2288
3505:Src/mpu6050.c ****         unsigned char more;
 7554              		.loc 1 3505 9 view .LVU2289
3506:Src/mpu6050.c ****         /* This function gets new data from the FIFO when the DMP is in
 7555              		.loc 1 3506 9 view .LVU2290
3519:Src/mpu6050.c ****         if (!more)
 7556              		.loc 1 3519 9 view .LVU2291
 7557 004e 0DF10B03 		add	r3, sp, #11
 7558 0052 0193     		str	r3, [sp, #4]
 7559 0054 05AB     		add	r3, sp, #20
 7560 0056 0093     		str	r3, [sp]
 7561 0058 404A     		ldr	r2, .L645+8
 7562 005a 03AB     		add	r3, sp, #12
 7563 005c 08A9     		add	r1, sp, #32
 7564 005e 06A8     		add	r0, sp, #24
 7565 0060 FFF7FEFF 		bl	dmp_read_fifo
 7566              	.LVL583:
3520:Src/mpu6050.c ****             hal.new_gyro = 0;
 7567              		.loc 1 3520 9 view .LVU2292
3520:Src/mpu6050.c ****             hal.new_gyro = 0;
 7568              		.loc 1 3520 12 is_stmt 0 view .LVU2293
 7569 0064 9DF80B30 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 7570 0068 03B9     		cbnz	r3, .L602
3521:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7571              		.loc 1 3521 13 is_stmt 1 view .LVU2294
3521:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7572              		.loc 1 3521 26 is_stmt 0 view .LVU2295
 7573 006a 2371     		strb	r3, [r4, #4]
 7574              	.L602:
3522:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7575              		.loc 1 3522 9 is_stmt 1 view .LVU2296
3522:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7576              		.loc 1 3522 12 is_stmt 0 view .LVU2297
 7577 006c BDF81430 		ldrh	r3, [sp, #20]
 7578 0070 03F07003 		and	r3, r3, #112
 7579 0074 A3B1     		cbz	r3, .L604
3523:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7580              		.loc 1 3523 13 is_stmt 1 view .LVU2298
3523:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7581              		.loc 1 3523 24 is_stmt 0 view .LVU2299
 7582 0076 3A4C     		ldr	r4, .L645+12
 7583 0078 BDF81830 		ldrh	r3, [sp, #24]
 7584 007c 2380     		strh	r3, [r4]	@ movhi
3524:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7585              		.loc 1 3524 13 is_stmt 1 view .LVU2300
3524:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7586              		.loc 1 3524 24 is_stmt 0 view .LVU2301
 7587 007e BDF81A30 		ldrh	r3, [sp, #26]
 7588 0082 6380     		strh	r3, [r4, #2]	@ movhi
3525:Src/mpu6050.c ****             new_data = 1;
ARM GAS  /tmp/ccC60hwS.s 			page 232


 7589              		.loc 1 3525 13 is_stmt 1 view .LVU2302
3525:Src/mpu6050.c ****             new_data = 1;
 7590              		.loc 1 3525 24 is_stmt 0 view .LVU2303
 7591 0084 BDF81C30 		ldrh	r3, [sp, #28]
 7592 0088 A380     		strh	r3, [r4, #4]	@ movhi
3526:Src/mpu6050.c ****             if (new_temp) {
 7593              		.loc 1 3526 13 is_stmt 1 view .LVU2304
 7594              	.LVL584:
3527:Src/mpu6050.c ****                 new_temp = 0;
 7595              		.loc 1 3527 13 view .LVU2305
3527:Src/mpu6050.c ****                 new_temp = 0;
 7596              		.loc 1 3527 16 is_stmt 0 view .LVU2306
 7597 008a 4DB1     		cbz	r5, .L604
3528:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
 7598              		.loc 1 3528 17 is_stmt 1 view .LVU2307
 7599              	.LVL585:
3529:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
 7600              		.loc 1 3529 17 view .LVU2308
 7601 008c 354D     		ldr	r5, .L645+16
 7602 008e 03A9     		add	r1, sp, #12
 7603 0090 2846     		mov	r0, r5
 7604 0092 FFF7FEFF 		bl	mpu_get_temperature
 7605              	.LVL586:
3530:Src/mpu6050.c ****             }
 7606              		.loc 1 3530 17 view .LVU2309
3530:Src/mpu6050.c ****             }
 7607              		.loc 1 3530 50 is_stmt 0 view .LVU2310
 7608 0096 6422     		movs	r2, #100
 7609 0098 2B68     		ldr	r3, [r5]
 7610 009a 5343     		muls	r3, r2, r3
3530:Src/mpu6050.c ****             }
 7611              		.loc 1 3530 56 view .LVU2311
 7612 009c 1B14     		asrs	r3, r3, #16
3530:Src/mpu6050.c ****             }
 7613              		.loc 1 3530 28 view .LVU2312
 7614 009e 6384     		strh	r3, [r4, #34]	@ movhi
 7615              	.LVL587:
 7616              	.L604:
3533:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7617              		.loc 1 3533 9 is_stmt 1 view .LVU2313
3533:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7618              		.loc 1 3533 21 is_stmt 0 view .LVU2314
 7619 00a0 BDF81420 		ldrh	r2, [sp, #20]
3533:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7620              		.loc 1 3533 12 view .LVU2315
 7621 00a4 1107     		lsls	r1, r2, #28
 7622 00a6 09D5     		bpl	.L606
3534:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7623              		.loc 1 3534 13 is_stmt 1 view .LVU2316
3534:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7624              		.loc 1 3534 25 is_stmt 0 view .LVU2317
 7625 00a8 2D4B     		ldr	r3, .L645+12
 7626 00aa BDF82010 		ldrh	r1, [sp, #32]
 7627 00ae D980     		strh	r1, [r3, #6]	@ movhi
3535:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7628              		.loc 1 3535 13 is_stmt 1 view .LVU2318
3535:Src/mpu6050.c ****             mpu.accel.z = accel[2];
ARM GAS  /tmp/ccC60hwS.s 			page 233


 7629              		.loc 1 3535 25 is_stmt 0 view .LVU2319
 7630 00b0 BDF82210 		ldrh	r1, [sp, #34]
 7631 00b4 1981     		strh	r1, [r3, #8]	@ movhi
3536:Src/mpu6050.c ****             new_data = 1;
 7632              		.loc 1 3536 13 is_stmt 1 view .LVU2320
3536:Src/mpu6050.c ****             new_data = 1;
 7633              		.loc 1 3536 25 is_stmt 0 view .LVU2321
 7634 00b6 BDF82410 		ldrh	r1, [sp, #36]
 7635 00ba 5981     		strh	r1, [r3, #10]	@ movhi
3537:Src/mpu6050.c ****         }
 7636              		.loc 1 3537 13 is_stmt 1 view .LVU2322
 7637              	.LVL588:
 7638              	.L606:
3539:Src/mpu6050.c ****             mpu.quat.w = quat[0];
 7639              		.loc 1 3539 9 view .LVU2323
3539:Src/mpu6050.c ****             mpu.quat.w = quat[0];
 7640              		.loc 1 3539 12 is_stmt 0 view .LVU2324
 7641 00bc D205     		lsls	r2, r2, #23
 7642 00be 0BD5     		bpl	.L598
3540:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7643              		.loc 1 3540 13 is_stmt 1 view .LVU2325
3540:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7644              		.loc 1 3540 30 is_stmt 0 view .LVU2326
 7645 00c0 264A     		ldr	r2, .L645+8
3540:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7646              		.loc 1 3540 24 view .LVU2327
 7647 00c2 274B     		ldr	r3, .L645+12
 7648 00c4 1168     		ldr	r1, [r2]
 7649 00c6 D960     		str	r1, [r3, #12]
3541:Src/mpu6050.c ****             mpu.quat.y = quat[2];
 7650              		.loc 1 3541 13 is_stmt 1 view .LVU2328
3541:Src/mpu6050.c ****             mpu.quat.y = quat[2];
 7651              		.loc 1 3541 24 is_stmt 0 view .LVU2329
 7652 00c8 5168     		ldr	r1, [r2, #4]
 7653 00ca 1961     		str	r1, [r3, #16]
3542:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7654              		.loc 1 3542 13 is_stmt 1 view .LVU2330
3542:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7655              		.loc 1 3542 24 is_stmt 0 view .LVU2331
 7656 00cc 9168     		ldr	r1, [r2, #8]
3543:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7657              		.loc 1 3543 24 view .LVU2332
 7658 00ce D268     		ldr	r2, [r2, #12]
3542:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7659              		.loc 1 3542 24 view .LVU2333
 7660 00d0 5961     		str	r1, [r3, #20]
3543:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7661              		.loc 1 3543 13 is_stmt 1 view .LVU2334
3543:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7662              		.loc 1 3543 24 is_stmt 0 view .LVU2335
 7663 00d2 9A61     		str	r2, [r3, #24]
3544:Src/mpu6050.c ****             new_data = 1;
 7664              		.loc 1 3544 13 is_stmt 1 view .LVU2336
 7665 00d4 FFF7FEFF 		bl	mpu_calc_euler_angles
 7666              	.LVL589:
3545:Src/mpu6050.c ****         }
 7667              		.loc 1 3545 13 view .LVU2337
ARM GAS  /tmp/ccC60hwS.s 			page 234


 7668              	.L598:
3545:Src/mpu6050.c ****         }
 7669              		.loc 1 3545 13 is_stmt 0 view .LVU2338
 7670              	.LBE52:
3587:Src/mpu6050.c **** 
 7671              		.loc 1 3587 1 view .LVU2339
 7672 00d8 0BB0     		add	sp, sp, #44
 7673              	.LCFI116:
 7674              		.cfi_remember_state
 7675              		.cfi_def_cfa_offset 12
 7676              		@ sp needed
 7677 00da 30BD     		pop	{r4, r5, pc}
 7678              	.LVL590:
 7679              	.L601:
 7680              	.LCFI117:
 7681              		.cfi_restore_state
3547:Src/mpu6050.c ****         short gyro[3], accel[3];
 7682              		.loc 1 3547 12 is_stmt 1 view .LVU2340
3547:Src/mpu6050.c ****         short gyro[3], accel[3];
 7683              		.loc 1 3547 19 is_stmt 0 view .LVU2341
 7684 00dc 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
3547:Src/mpu6050.c ****         short gyro[3], accel[3];
 7685              		.loc 1 3547 15 view .LVU2342
 7686 00de 002B     		cmp	r3, #0
 7687 00e0 FAD0     		beq	.L598
 7688              	.LBB53:
3548:Src/mpu6050.c ****         long temperature;
 7689              		.loc 1 3548 9 is_stmt 1 view .LVU2343
3549:Src/mpu6050.c ****         unsigned char sensors, more;
 7690              		.loc 1 3549 9 view .LVU2344
3550:Src/mpu6050.c ****         /* This function gets new data from the FIFO. The FIFO can contain
 7691              		.loc 1 3550 9 view .LVU2345
3560:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
 7692              		.loc 1 3560 9 view .LVU2346
3560:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
 7693              		.loc 1 3560 22 is_stmt 0 view .LVU2347
 7694 00e2 0023     		movs	r3, #0
 7695 00e4 2371     		strb	r3, [r4, #4]
3561:Src/mpu6050.c ****         if (more)
 7696              		.loc 1 3561 9 is_stmt 1 view .LVU2348
 7697 00e6 0DF10B03 		add	r3, sp, #11
 7698 00ea 0093     		str	r3, [sp]
 7699 00ec 03AA     		add	r2, sp, #12
 7700 00ee 0DF10A03 		add	r3, sp, #10
 7701 00f2 08A9     		add	r1, sp, #32
 7702 00f4 06A8     		add	r0, sp, #24
 7703 00f6 FFF7FEFF 		bl	mpu_read_fifo
 7704              	.LVL591:
3562:Src/mpu6050.c ****             hal.new_gyro = 1;
 7705              		.loc 1 3562 9 view .LVU2349
3562:Src/mpu6050.c ****             hal.new_gyro = 1;
 7706              		.loc 1 3562 12 is_stmt 0 view .LVU2350
 7707 00fa 9DF80B30 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 7708 00fe 0BB1     		cbz	r3, .L609
3563:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7709              		.loc 1 3563 13 is_stmt 1 view .LVU2351
3563:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
ARM GAS  /tmp/ccC60hwS.s 			page 235


 7710              		.loc 1 3563 26 is_stmt 0 view .LVU2352
 7711 0100 0123     		movs	r3, #1
 7712 0102 2371     		strb	r3, [r4, #4]
 7713              	.L609:
3564:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7714              		.loc 1 3564 9 is_stmt 1 view .LVU2353
3564:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7715              		.loc 1 3564 12 is_stmt 0 view .LVU2354
 7716 0104 9DF80A30 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 7717 0108 13F0700F 		tst	r3, #112
 7718 010c 13D0     		beq	.L611
3565:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7719              		.loc 1 3565 13 is_stmt 1 view .LVU2355
3565:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7720              		.loc 1 3565 24 is_stmt 0 view .LVU2356
 7721 010e 144C     		ldr	r4, .L645+12
 7722 0110 BDF81830 		ldrh	r3, [sp, #24]
 7723 0114 2380     		strh	r3, [r4]	@ movhi
3566:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7724              		.loc 1 3566 13 is_stmt 1 view .LVU2357
3566:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7725              		.loc 1 3566 24 is_stmt 0 view .LVU2358
 7726 0116 BDF81A30 		ldrh	r3, [sp, #26]
 7727 011a 6380     		strh	r3, [r4, #2]	@ movhi
3567:Src/mpu6050.c ****             new_data = 1;
 7728              		.loc 1 3567 13 is_stmt 1 view .LVU2359
3567:Src/mpu6050.c ****             new_data = 1;
 7729              		.loc 1 3567 24 is_stmt 0 view .LVU2360
 7730 011c BDF81C30 		ldrh	r3, [sp, #28]
 7731 0120 A380     		strh	r3, [r4, #4]	@ movhi
3568:Src/mpu6050.c ****             if (new_temp) {
 7732              		.loc 1 3568 13 is_stmt 1 view .LVU2361
 7733              	.LVL592:
3569:Src/mpu6050.c ****                 new_temp = 0;
 7734              		.loc 1 3569 13 view .LVU2362
3569:Src/mpu6050.c ****                 new_temp = 0;
 7735              		.loc 1 3569 16 is_stmt 0 view .LVU2363
 7736 0122 45B1     		cbz	r5, .L611
3570:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
 7737              		.loc 1 3570 17 is_stmt 1 view .LVU2364
 7738              	.LVL593:
3571:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
 7739              		.loc 1 3571 17 view .LVU2365
 7740 0124 03A9     		add	r1, sp, #12
 7741 0126 05A8     		add	r0, sp, #20
 7742 0128 FFF7FEFF 		bl	mpu_get_temperature
 7743              	.LVL594:
3572:Src/mpu6050.c ****             }
 7744              		.loc 1 3572 17 view .LVU2366
3572:Src/mpu6050.c ****             }
 7745              		.loc 1 3572 50 is_stmt 0 view .LVU2367
 7746 012c 6422     		movs	r2, #100
 7747 012e 059B     		ldr	r3, [sp, #20]
 7748 0130 5343     		muls	r3, r2, r3
3572:Src/mpu6050.c ****             }
 7749              		.loc 1 3572 56 view .LVU2368
 7750 0132 1B14     		asrs	r3, r3, #16
ARM GAS  /tmp/ccC60hwS.s 			page 236


3572:Src/mpu6050.c ****             }
 7751              		.loc 1 3572 28 view .LVU2369
 7752 0134 6384     		strh	r3, [r4, #34]	@ movhi
 7753              	.LVL595:
 7754              	.L611:
3575:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7755              		.loc 1 3575 9 is_stmt 1 view .LVU2370
3575:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7756              		.loc 1 3575 12 is_stmt 0 view .LVU2371
 7757 0136 9DF80A30 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 7758 013a 1B07     		lsls	r3, r3, #28
 7759 013c CCD5     		bpl	.L598
3576:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7760              		.loc 1 3576 13 is_stmt 1 view .LVU2372
3576:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7761              		.loc 1 3576 25 is_stmt 0 view .LVU2373
 7762 013e 084B     		ldr	r3, .L645+12
 7763 0140 BDF82020 		ldrh	r2, [sp, #32]
 7764 0144 DA80     		strh	r2, [r3, #6]	@ movhi
3577:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7765              		.loc 1 3577 13 is_stmt 1 view .LVU2374
3577:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7766              		.loc 1 3577 25 is_stmt 0 view .LVU2375
 7767 0146 BDF82220 		ldrh	r2, [sp, #34]
 7768 014a 1A81     		strh	r2, [r3, #8]	@ movhi
3578:Src/mpu6050.c ****             new_data = 1;
 7769              		.loc 1 3578 13 is_stmt 1 view .LVU2376
3578:Src/mpu6050.c ****             new_data = 1;
 7770              		.loc 1 3578 25 is_stmt 0 view .LVU2377
 7771 014c BDF82420 		ldrh	r2, [sp, #36]
 7772 0150 5A81     		strh	r2, [r3, #10]	@ movhi
3579:Src/mpu6050.c ****         }
 7773              		.loc 1 3579 13 is_stmt 1 view .LVU2378
 7774              	.LVL596:
3579:Src/mpu6050.c ****         }
 7775              		.loc 1 3579 13 is_stmt 0 view .LVU2379
 7776              	.LBE53:
3583:Src/mpu6050.c ****         // do something if needed
 7777              		.loc 1 3583 5 is_stmt 1 view .LVU2380
3585:Src/mpu6050.c ****         
 7778              		.loc 1 3585 5 view .LVU2381
3587:Src/mpu6050.c **** 
 7779              		.loc 1 3587 1 is_stmt 0 view .LVU2382
 7780 0152 C1E7     		b	.L598
 7781              	.L646:
 7782              		.align	2
 7783              	.L645:
 7784 0154 00000000 		.word	.LANCHOR0
 7785 0158 00000000 		.word	.LANCHOR2
 7786 015c 00000000 		.word	.LANCHOR4
 7787 0160 00000000 		.word	.LANCHOR3
 7788 0164 00000000 		.word	.LANCHOR5
 7789              		.cfi_endproc
 7790              	.LFE114:
 7792              		.section	.rodata.mpu_tap_func.str1.1,"aMS",%progbits,1
 7793              	.LC12:
 7794 0000 54617020 		.ascii	"Tap X+ \000"
ARM GAS  /tmp/ccC60hwS.s 			page 237


 7794      582B2000 
 7795              	.LC13:
 7796 0008 54617020 		.ascii	"Tap X- \000"
 7796      582D2000 
 7797              	.LC14:
 7798 0010 54617020 		.ascii	"Tap Y+ \000"
 7798      592B2000 
 7799              	.LC15:
 7800 0018 54617020 		.ascii	"Tap Y- \000"
 7800      592D2000 
 7801              	.LC16:
 7802 0020 54617020 		.ascii	"Tap Z+ \000"
 7802      5A2B2000 
 7803              	.LC17:
 7804 0028 54617020 		.ascii	"Tap Z- \000"
 7804      5A2D2000 
 7805              		.section	.text.mpu_tap_func,"ax",%progbits
 7806              		.align	1
 7807              		.global	mpu_tap_func
 7808              		.syntax unified
 7809              		.thumb
 7810              		.thumb_func
 7811              		.fpu softvfp
 7813              	mpu_tap_func:
 7814              	.LVL597:
 7815              	.LFB118:
3663:Src/mpu6050.c **** 
3664:Src/mpu6050.c **** 
3665:Src/mpu6050.c **** void mpu_tap_func(unsigned char direction, unsigned char count)
3666:Src/mpu6050.c **** {
 7816              		.loc 1 3666 1 is_stmt 1 view -0
 7817              		.cfi_startproc
 7818              		@ args = 0, pretend = 0, frame = 0
 7819              		@ frame_needed = 0, uses_anonymous_args = 0
 7820              		@ link register save eliminated.
3667:Src/mpu6050.c ****     switch (direction) {
 7821              		.loc 1 3667 5 view .LVU2384
 7822 0000 0138     		subs	r0, r0, #1
 7823              	.LVL598:
 7824              		.loc 1 3667 5 is_stmt 0 view .LVU2385
 7825 0002 0528     		cmp	r0, #5
 7826 0004 11D8     		bhi	.L647
 7827 0006 DFE800F0 		tbb	[pc, r0]
 7828              	.L650:
 7829 000a 03       		.byte	(.L655-.L650)/2
 7830 000b 06       		.byte	(.L654-.L650)/2
 7831 000c 08       		.byte	(.L653-.L650)/2
 7832 000d 0A       		.byte	(.L652-.L650)/2
 7833 000e 0C       		.byte	(.L651-.L650)/2
 7834 000f 0E       		.byte	(.L649-.L650)/2
 7835              		.p2align 1
 7836              	.L655:
3668:Src/mpu6050.c ****     case TAP_X_UP:
3669:Src/mpu6050.c ****         consoleLog("Tap X+ ");
 7837              		.loc 1 3669 9 is_stmt 1 view .LVU2386
 7838 0010 0648     		ldr	r0, .L657
 7839              	.L656:
ARM GAS  /tmp/ccC60hwS.s 			page 238


3670:Src/mpu6050.c ****         break;
3671:Src/mpu6050.c ****     case TAP_X_DOWN:
3672:Src/mpu6050.c ****         consoleLog("Tap X- ");
3673:Src/mpu6050.c ****         break;
3674:Src/mpu6050.c ****     case TAP_Y_UP:
3675:Src/mpu6050.c ****         consoleLog("Tap Y+ ");
3676:Src/mpu6050.c ****         break;
3677:Src/mpu6050.c ****     case TAP_Y_DOWN:
3678:Src/mpu6050.c ****         consoleLog("Tap Y- ");
3679:Src/mpu6050.c ****         break;
3680:Src/mpu6050.c ****     case TAP_Z_UP:
3681:Src/mpu6050.c ****         consoleLog("Tap Z+ ");
3682:Src/mpu6050.c ****         break;
3683:Src/mpu6050.c ****     case TAP_Z_DOWN:
3684:Src/mpu6050.c ****         consoleLog("Tap Z- ");
 7840              		.loc 1 3684 9 is_stmt 0 view .LVU2387
 7841 0012 FFF7FEBF 		b	consoleLog
 7842              	.LVL599:
 7843              	.L654:
3672:Src/mpu6050.c ****         break;
 7844              		.loc 1 3672 9 is_stmt 1 view .LVU2388
 7845 0016 0648     		ldr	r0, .L657+4
 7846 0018 FBE7     		b	.L656
 7847              	.L653:
3675:Src/mpu6050.c ****         break;
 7848              		.loc 1 3675 9 view .LVU2389
 7849 001a 0648     		ldr	r0, .L657+8
 7850 001c F9E7     		b	.L656
 7851              	.L652:
3678:Src/mpu6050.c ****         break;
 7852              		.loc 1 3678 9 view .LVU2390
 7853 001e 0648     		ldr	r0, .L657+12
 7854 0020 F7E7     		b	.L656
 7855              	.L651:
3681:Src/mpu6050.c ****         break;
 7856              		.loc 1 3681 9 view .LVU2391
 7857 0022 0648     		ldr	r0, .L657+16
 7858 0024 F5E7     		b	.L656
 7859              	.L649:
 7860              		.loc 1 3684 9 view .LVU2392
 7861 0026 0648     		ldr	r0, .L657+20
 7862 0028 F3E7     		b	.L656
 7863              	.L647:
3685:Src/mpu6050.c ****         break;
3686:Src/mpu6050.c ****     default:
3687:Src/mpu6050.c ****         return;
3688:Src/mpu6050.c ****     }
3689:Src/mpu6050.c ****     #ifdef SERIAL_DEBUG
3690:Src/mpu6050.c ****         log_i("x %d\r\n", count);
3691:Src/mpu6050.c ****     #endif
3692:Src/mpu6050.c ****     return;
3693:Src/mpu6050.c **** }
 7864              		.loc 1 3693 1 is_stmt 0 view .LVU2393
 7865 002a 7047     		bx	lr
 7866              	.L658:
 7867              		.align	2
 7868              	.L657:
ARM GAS  /tmp/ccC60hwS.s 			page 239


 7869 002c 00000000 		.word	.LC12
 7870 0030 08000000 		.word	.LC13
 7871 0034 10000000 		.word	.LC14
 7872 0038 18000000 		.word	.LC15
 7873 003c 20000000 		.word	.LC16
 7874 0040 28000000 		.word	.LC17
 7875              		.cfi_endproc
 7876              	.LFE118:
 7878              		.section	.rodata.mpu_android_orient_func.str1.1,"aMS",%progbits,1
 7879              	.LC18:
 7880 0000 506F7274 		.ascii	"Portrait\015\012\000"
 7880      72616974 
 7880      0D0A00
 7881              	.LC19:
 7882 000b 4C616E64 		.ascii	"Landscape\015\012\000"
 7882      73636170 
 7882      650D0A00 
 7883              	.LC20:
 7884 0017 5265762E 		.ascii	"Rev. Portrait\015\012\000"
 7884      20506F72 
 7884      74726169 
 7884      740D0A00 
 7885              	.LC21:
 7886 0027 5265762E 		.ascii	"Rev. Landscape\015\012\000"
 7886      204C616E 
 7886      64736361 
 7886      70650D0A 
 7886      00
 7887              		.section	.text.mpu_android_orient_func,"ax",%progbits
 7888              		.align	1
 7889              		.global	mpu_android_orient_func
 7890              		.syntax unified
 7891              		.thumb
 7892              		.thumb_func
 7893              		.fpu softvfp
 7895              	mpu_android_orient_func:
 7896              	.LVL600:
 7897              	.LFB119:
3694:Src/mpu6050.c **** 
3695:Src/mpu6050.c **** 
3696:Src/mpu6050.c **** void mpu_android_orient_func(unsigned char orientation)
3697:Src/mpu6050.c **** {
 7898              		.loc 1 3697 1 is_stmt 1 view -0
 7899              		.cfi_startproc
 7900              		@ args = 0, pretend = 0, frame = 0
 7901              		@ frame_needed = 0, uses_anonymous_args = 0
 7902              		@ link register save eliminated.
3698:Src/mpu6050.c ****     switch (orientation) {
 7903              		.loc 1 3698 5 view .LVU2395
 7904 0000 0328     		cmp	r0, #3
 7905 0002 0CD8     		bhi	.L659
 7906 0004 DFE800F0 		tbb	[pc, r0]
 7907              	.L662:
 7908 0008 02       		.byte	(.L665-.L662)/2
 7909 0009 05       		.byte	(.L664-.L662)/2
 7910 000a 07       		.byte	(.L663-.L662)/2
 7911 000b 09       		.byte	(.L661-.L662)/2
ARM GAS  /tmp/ccC60hwS.s 			page 240


 7912              		.p2align 1
 7913              	.L665:
3699:Src/mpu6050.c ****     case ANDROID_ORIENT_PORTRAIT:
3700:Src/mpu6050.c ****         consoleLog("Portrait\r\n");
 7914              		.loc 1 3700 9 view .LVU2396
 7915 000c 0448     		ldr	r0, .L667
 7916              	.LVL601:
 7917              	.L666:
3701:Src/mpu6050.c ****         break;
3702:Src/mpu6050.c ****     case ANDROID_ORIENT_LANDSCAPE:
3703:Src/mpu6050.c ****         consoleLog("Landscape\r\n");
3704:Src/mpu6050.c ****         break;
3705:Src/mpu6050.c ****     case ANDROID_ORIENT_REVERSE_PORTRAIT:
3706:Src/mpu6050.c ****         consoleLog("Rev. Portrait\r\n");
3707:Src/mpu6050.c ****         break;
3708:Src/mpu6050.c ****     case ANDROID_ORIENT_REVERSE_LANDSCAPE:
3709:Src/mpu6050.c ****         consoleLog("Rev. Landscape\r\n");
 7918              		.loc 1 3709 9 is_stmt 0 view .LVU2397
 7919 000e FFF7FEBF 		b	consoleLog
 7920              	.LVL602:
 7921              	.L664:
3703:Src/mpu6050.c ****         break;
 7922              		.loc 1 3703 9 is_stmt 1 view .LVU2398
 7923 0012 0448     		ldr	r0, .L667+4
 7924              	.LVL603:
3703:Src/mpu6050.c ****         break;
 7925              		.loc 1 3703 9 is_stmt 0 view .LVU2399
 7926 0014 FBE7     		b	.L666
 7927              	.LVL604:
 7928              	.L663:
3706:Src/mpu6050.c ****         break;
 7929              		.loc 1 3706 9 is_stmt 1 view .LVU2400
 7930 0016 0448     		ldr	r0, .L667+8
 7931              	.LVL605:
3706:Src/mpu6050.c ****         break;
 7932              		.loc 1 3706 9 is_stmt 0 view .LVU2401
 7933 0018 F9E7     		b	.L666
 7934              	.LVL606:
 7935              	.L661:
 7936              		.loc 1 3709 9 is_stmt 1 view .LVU2402
 7937 001a 0448     		ldr	r0, .L667+12
 7938              	.LVL607:
 7939              		.loc 1 3709 9 is_stmt 0 view .LVU2403
 7940 001c F7E7     		b	.L666
 7941              	.LVL608:
 7942              	.L659:
3710:Src/mpu6050.c ****         break;
3711:Src/mpu6050.c ****     default:
3712:Src/mpu6050.c ****         return;
3713:Src/mpu6050.c ****     }
3714:Src/mpu6050.c **** }
 7943              		.loc 1 3714 1 view .LVU2404
 7944 001e 7047     		bx	lr
 7945              	.L668:
 7946              		.align	2
 7947              	.L667:
 7948 0020 00000000 		.word	.LC18
ARM GAS  /tmp/ccC60hwS.s 			page 241


 7949 0024 0B000000 		.word	.LC19
 7950 0028 17000000 		.word	.LC20
 7951 002c 27000000 		.word	.LC21
 7952              		.cfi_endproc
 7953              	.LFE119:
 7955              		.section	.text.mpu_print_to_console,"ax",%progbits
 7956              		.align	1
 7957              		.global	mpu_print_to_console
 7958              		.syntax unified
 7959              		.thumb
 7960              		.thumb_func
 7961              		.fpu softvfp
 7963              	mpu_print_to_console:
 7964              	.LFB120:
3715:Src/mpu6050.c **** 
3716:Src/mpu6050.c **** 
3717:Src/mpu6050.c **** /* =========================== MPU Print data =========================== */
3718:Src/mpu6050.c **** 
3719:Src/mpu6050.c **** void mpu_print_to_console(void)
3720:Src/mpu6050.c **** {
 7965              		.loc 1 3720 1 is_stmt 1 view -0
 7966              		.cfi_startproc
 7967              		@ args = 0, pretend = 0, frame = 0
 7968              		@ frame_needed = 0, uses_anonymous_args = 0
 7969              		@ link register save eliminated.
3721:Src/mpu6050.c **** #ifdef SERIAL_DEBUG
3722:Src/mpu6050.c ****     if (hal.report & PRINT_ACCEL) {
3723:Src/mpu6050.c ****         log_i( "accX:%d accY:%d accZ:%d\r\n", mpu.accel.x, mpu.accel.y, mpu.accel.z);
3724:Src/mpu6050.c ****     }
3725:Src/mpu6050.c ****     if (hal.report & PRINT_GYRO) {
3726:Src/mpu6050.c ****         log_i( "gyrX:%d gyrY:%d gyrZ:%d\r\n", mpu.gyro.x, mpu.gyro.y, mpu.gyro.z);
3727:Src/mpu6050.c ****     }
3728:Src/mpu6050.c ****     if (hal.report & PRINT_QUAT) {
3729:Src/mpu6050.c ****         log_i( "qW:%ld qX:%ld qY:%ld qZ:%ld\r\n", (long)mpu.quat.w, (long)mpu.quat.x, (long)mpu.qua
3730:Src/mpu6050.c ****     }
3731:Src/mpu6050.c ****     if (hal.report & PRINT_EULER) {
3732:Src/mpu6050.c ****         log_i( "Roll:%d Pitch:%d Yaw:%d\r\n", mpu.euler.roll, mpu.euler.pitch, mpu.euler.yaw);
3733:Src/mpu6050.c ****     }
3734:Src/mpu6050.c ****     if (hal.report & PRINT_TEMP) {
3735:Src/mpu6050.c ****         log_i( "Temp:%d\r\n", mpu.temp);
3736:Src/mpu6050.c ****     }
3737:Src/mpu6050.c ****     if (hal.report & PRINT_PEDO) {
3738:Src/mpu6050.c ****         unsigned long timestamp;
3739:Src/mpu6050.c ****         get_tick_count_ms(&timestamp);
3740:Src/mpu6050.c ****         if (timestamp > hal.next_pedo_ms) {
3741:Src/mpu6050.c ****             hal.next_pedo_ms = timestamp + PEDO_READ_MS;
3742:Src/mpu6050.c ****             unsigned long step_count, walk_time;
3743:Src/mpu6050.c ****             dmp_get_pedometer_step_count(&step_count);
3744:Src/mpu6050.c ****             dmp_get_pedometer_walk_time(&walk_time);
3745:Src/mpu6050.c ****             log_i( "Walked %ld steps in %ld sec\r\n", step_count, walk_time/1000);
3746:Src/mpu6050.c ****         }
3747:Src/mpu6050.c ****     }
3748:Src/mpu6050.c **** #endif
3749:Src/mpu6050.c **** }
 7970              		.loc 1 3749 1 view .LVU2406
 7971 0000 7047     		bx	lr
 7972              		.cfi_endproc
ARM GAS  /tmp/ccC60hwS.s 			page 242


 7973              	.LFE120:
 7975              		.section	.text.mpu_handle_input,"ax",%progbits
 7976              		.align	1
 7977              		.global	mpu_handle_input
 7978              		.syntax unified
 7979              		.thumb
 7980              		.thumb_func
 7981              		.fpu softvfp
 7983              	mpu_handle_input:
 7984              	.LVL609:
 7985              	.LFB121:
3750:Src/mpu6050.c **** 
3751:Src/mpu6050.c **** #endif // MPU_SENSOR_ENABLE
3752:Src/mpu6050.c **** 
3753:Src/mpu6050.c **** 
3754:Src/mpu6050.c **** /* =========================== User Input Handling =========================== */
3755:Src/mpu6050.c **** 
3756:Src/mpu6050.c **** void mpu_handle_input(char c)
3757:Src/mpu6050.c **** {
 7986              		.loc 1 3757 1 view -0
 7987              		.cfi_startproc
 7988              		@ args = 0, pretend = 0, frame = 0
 7989              		@ frame_needed = 0, uses_anonymous_args = 0
 7990              		@ link register save eliminated.
3758:Src/mpu6050.c **** #ifdef SERIAL_DEBUG
3759:Src/mpu6050.c ****     switch (c) {
3760:Src/mpu6050.c ****         /* This command prints the Help text. */
3761:Src/mpu6050.c ****         case 'h':
3762:Src/mpu6050.c ****             consoleLog("=== HELP ===\r\n");
3763:Src/mpu6050.c ****             consoleLog("h: Print Help\r\n");
3764:Src/mpu6050.c ****             consoleLog("x: Print Serial AUX\r\n");
3765:Src/mpu6050.c ****             #ifdef MPU_SENSOR_ENABLE
3766:Src/mpu6050.c ****             consoleLog("8: Set Accelerometer on/off\r\n");
3767:Src/mpu6050.c ****             consoleLog("9: Set Gyroscope on/off\r\n");
3768:Src/mpu6050.c ****             consoleLog("r: Print Registers\r\n");
3769:Src/mpu6050.c ****             consoleLog("a: Print Accelerometer\r\n");
3770:Src/mpu6050.c ****             consoleLog("g: Print Gyroscope\r\n");
3771:Src/mpu6050.c ****             consoleLog("q: Print Quaternion\r\n");
3772:Src/mpu6050.c ****             consoleLog("e: Print Euler angles in deg*100\r\n");
3773:Src/mpu6050.c ****             consoleLog("t: Print Temperature in degC*100\r\n");
3774:Src/mpu6050.c ****             consoleLog("p: Print Pedometer\r\n");
3775:Src/mpu6050.c ****             consoleLog("0: Reset Pedometer\r\n");
3776:Src/mpu6050.c ****             consoleLog("1: Set DMP/MPU freq 10 Hz\r\n");
3777:Src/mpu6050.c ****             consoleLog("2: Set DMP/MPU freq 50 Hz\r\n");
3778:Src/mpu6050.c ****             consoleLog("3: Set DMP/MPU freq 100 Hz\r\n");
3779:Src/mpu6050.c ****             consoleLog(",: Set DMP interrupt to gesture\r\n");
3780:Src/mpu6050.c ****             consoleLog(".: Set DMP interrupt to continuous\r\n");
3781:Src/mpu6050.c ****             consoleLog("f: Set DMP on/off\r\n");
3782:Src/mpu6050.c ****             consoleLog("v: Set Quaternion on/off\r\n");
3783:Src/mpu6050.c ****             consoleLog("w: Test low-power accel mode\r\n");
3784:Src/mpu6050.c ****             consoleLog("s: Run self-test (device must be facing up or down)\r\n");
3785:Src/mpu6050.c ****             #endif // MPU_SENSOR_ENABLE
3786:Src/mpu6050.c ****             consoleLog("============\r\n");
3787:Src/mpu6050.c ****             break;
3788:Src/mpu6050.c **** 
3789:Src/mpu6050.c ****         /* These commands print individual sensor data. */
3790:Src/mpu6050.c ****         case 'x':
ARM GAS  /tmp/ccC60hwS.s 			page 243


3791:Src/mpu6050.c ****             #ifdef SERIAL_AUX_RX
3792:Src/mpu6050.c ****             print_aux ^= PRINT_AUX;
3793:Src/mpu6050.c ****             #else
3794:Src/mpu6050.c ****             consoleLog("AUX serial NOT enabled\r\n");
3795:Src/mpu6050.c ****             #endif
3796:Src/mpu6050.c ****             break;
3797:Src/mpu6050.c **** 
3798:Src/mpu6050.c ****         #ifdef MPU_SENSOR_ENABLE
3799:Src/mpu6050.c ****         /* These commands turn off individual sensors. */
3800:Src/mpu6050.c ****         case '8':
3801:Src/mpu6050.c ****             hal.sensors ^= ACCEL_ON;
3802:Src/mpu6050.c ****             mpu_setup_gyro();
3803:Src/mpu6050.c ****             break;
3804:Src/mpu6050.c ****         case '9':
3805:Src/mpu6050.c ****             hal.sensors ^= GYRO_ON;
3806:Src/mpu6050.c ****             mpu_setup_gyro();
3807:Src/mpu6050.c ****             break;
3808:Src/mpu6050.c **** 
3809:Src/mpu6050.c ****         /* This command prints out the value of each gyro register for debugging.
3810:Src/mpu6050.c ****         * If logging is disabled, this function has no effect.
3811:Src/mpu6050.c ****         */
3812:Src/mpu6050.c ****         case 'r':
3813:Src/mpu6050.c ****             mpu_reg_dump();
3814:Src/mpu6050.c ****             break;
3815:Src/mpu6050.c **** 
3816:Src/mpu6050.c ****         /* These commands print individual sensor data. */
3817:Src/mpu6050.c ****         case 'a':
3818:Src/mpu6050.c ****             hal.report ^= PRINT_ACCEL;
3819:Src/mpu6050.c ****             break;
3820:Src/mpu6050.c ****         case 'g':
3821:Src/mpu6050.c ****             hal.report ^= PRINT_GYRO;
3822:Src/mpu6050.c ****             break;
3823:Src/mpu6050.c ****         case 'q':
3824:Src/mpu6050.c ****             hal.report ^= PRINT_QUAT;
3825:Src/mpu6050.c ****             break;
3826:Src/mpu6050.c ****         case 'e':
3827:Src/mpu6050.c ****             hal.report ^= PRINT_EULER;
3828:Src/mpu6050.c ****             break;
3829:Src/mpu6050.c ****         case 't':
3830:Src/mpu6050.c ****             hal.report ^= PRINT_TEMP;
3831:Src/mpu6050.c ****             break;
3832:Src/mpu6050.c ****         case 'p':
3833:Src/mpu6050.c ****             /* Toggle pedometer display. */
3834:Src/mpu6050.c ****             hal.report ^= PRINT_PEDO;
3835:Src/mpu6050.c ****             break;
3836:Src/mpu6050.c ****         case '0':
3837:Src/mpu6050.c ****             /* Reset pedometer. */
3838:Src/mpu6050.c ****             dmp_set_pedometer_step_count(0);
3839:Src/mpu6050.c ****             dmp_set_pedometer_walk_time(0);
3840:Src/mpu6050.c ****             consoleLog("Pedometer reset OK\r\n");
3841:Src/mpu6050.c ****             break;
3842:Src/mpu6050.c **** 
3843:Src/mpu6050.c ****         /* Depending on your application, sensor data may be needed at a faster or
3844:Src/mpu6050.c ****         * slower rate. These commands can speed up or slow down the rate at which
3845:Src/mpu6050.c ****         * the sensor data is received.
3846:Src/mpu6050.c ****         */
3847:Src/mpu6050.c ****         case '1':
ARM GAS  /tmp/ccC60hwS.s 			page 244


3848:Src/mpu6050.c ****             if (hal.dmp_on) {
3849:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(10))      {consoleLog("DMP 10 Hz\r\n");}
3850:Src/mpu6050.c ****             } else
3851:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(10))    {consoleLog("MPU 10 Hz\r\n");}
3852:Src/mpu6050.c ****             break;
3853:Src/mpu6050.c ****         case '2':
3854:Src/mpu6050.c ****             if (hal.dmp_on) {
3855:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(50))      {consoleLog("DMP 50 Hz\r\n");}
3856:Src/mpu6050.c ****             } else
3857:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(50))    {consoleLog("MPU 50 Hz\r\n");}
3858:Src/mpu6050.c ****             break;
3859:Src/mpu6050.c ****         case '3':
3860:Src/mpu6050.c ****             if (hal.dmp_on) {
3861:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(100))     {consoleLog("DMP 100 Hz\r\n");}
3862:Src/mpu6050.c ****             } else
3863:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(100))   {consoleLog("MPU 100 Hz\r\n");}
3864:Src/mpu6050.c ****             break;
3865:Src/mpu6050.c **** 
3866:Src/mpu6050.c ****             /* Set hardware to interrupt on gesture event only. This feature is
3867:Src/mpu6050.c ****             * useful for keeping the MCU asleep until the DMP detects as a tap or
3868:Src/mpu6050.c ****             * orientation event.
3869:Src/mpu6050.c ****             */
3870:Src/mpu6050.c ****             case ',':
3871:Src/mpu6050.c ****             dmp_set_interrupt_mode(DMP_INT_GESTURE);
3872:Src/mpu6050.c ****             break;
3873:Src/mpu6050.c ****         case '.':
3874:Src/mpu6050.c ****             /* Set hardware to interrupt periodically. */
3875:Src/mpu6050.c ****             dmp_set_interrupt_mode(DMP_INT_CONTINUOUS);
3876:Src/mpu6050.c ****             break;
3877:Src/mpu6050.c **** 
3878:Src/mpu6050.c ****             /* Toggle DMP. */
3879:Src/mpu6050.c ****         case 'f':
3880:Src/mpu6050.c ****             if (hal.lp_accel_mode)  /* LP accel is not compatible with the DMP. */
3881:Src/mpu6050.c ****                 return;
3882:Src/mpu6050.c ****             if (hal.dmp_on) {
3883:Src/mpu6050.c ****                 unsigned short dmp_rate;
3884:Src/mpu6050.c ****                 unsigned char mask = 0;
3885:Src/mpu6050.c ****                 hal.dmp_on = 0;
3886:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
3887:Src/mpu6050.c ****                 /* Restore FIFO settings. */
3888:Src/mpu6050.c ****                 if (hal.sensors & ACCEL_ON)
3889:Src/mpu6050.c ****                     mask |= INV_XYZ_ACCEL;
3890:Src/mpu6050.c ****                 if (hal.sensors & GYRO_ON)
3891:Src/mpu6050.c ****                     mask |= INV_XYZ_GYRO;
3892:Src/mpu6050.c ****                 if (hal.sensors & COMPASS_ON)
3893:Src/mpu6050.c ****                     mask |= INV_XYZ_COMPASS;
3894:Src/mpu6050.c ****                 mpu_configure_fifo(mask);
3895:Src/mpu6050.c ****                 /* When the DMP is used, the hardware sampling rate is fixed at
3896:Src/mpu6050.c ****                 * 200Hz, and the DMP is configured to downsample the FIFO output
3897:Src/mpu6050.c ****                 * using the function dmp_set_fifo_rate. However, when the DMP is
3898:Src/mpu6050.c ****                 * turned off, the sampling rate remains at 200Hz. This could be
3899:Src/mpu6050.c ****                 * handled in mpu6050.c, but it would need to know that
3900:Src/mpu6050.c ****                 * mpu6050_dmp.c exists. To avoid this, we'll just
3901:Src/mpu6050.c ****                 * put the extra logic in the application layer.
3902:Src/mpu6050.c ****                 */
3903:Src/mpu6050.c ****                 dmp_get_fifo_rate(&dmp_rate);
3904:Src/mpu6050.c ****                 mpu_set_sample_rate(dmp_rate);
ARM GAS  /tmp/ccC60hwS.s 			page 245


3905:Src/mpu6050.c ****                 consoleLog("DMP OFF\r\n");
3906:Src/mpu6050.c ****             } else {
3907:Src/mpu6050.c ****                 unsigned short sample_rate;
3908:Src/mpu6050.c ****                 hal.dmp_on = 1;
3909:Src/mpu6050.c ****                 /* Preserve current FIFO rate. */
3910:Src/mpu6050.c ****                 mpu_get_sample_rate(&sample_rate);
3911:Src/mpu6050.c ****                 dmp_set_fifo_rate(sample_rate);
3912:Src/mpu6050.c ****                 mpu_set_dmp_state(1);
3913:Src/mpu6050.c ****                 consoleLog("DMP ON\r\n");
3914:Src/mpu6050.c ****             }
3915:Src/mpu6050.c ****             break;
3916:Src/mpu6050.c **** 
3917:Src/mpu6050.c ****         case 'v':
3918:Src/mpu6050.c ****             /* Toggle LP quaternion.
3919:Src/mpu6050.c ****             * The DMP features can be enabled/disabled at runtime. Use this same
3920:Src/mpu6050.c ****             * approach for other features.
3921:Src/mpu6050.c ****             */
3922:Src/mpu6050.c ****             hal.dmp_features ^= DMP_FEATURE_6X_LP_QUAT;
3923:Src/mpu6050.c ****             dmp_enable_feature(hal.dmp_features);
3924:Src/mpu6050.c ****             if (!(hal.dmp_features & DMP_FEATURE_6X_LP_QUAT)) {
3925:Src/mpu6050.c ****                 consoleLog("Quat OFF\n");
3926:Src/mpu6050.c ****             } else
3927:Src/mpu6050.c ****                 consoleLog("Quat ON\n");
3928:Src/mpu6050.c ****             break;
3929:Src/mpu6050.c **** 
3930:Src/mpu6050.c ****             /* Test out low-power accel mode. */
3931:Src/mpu6050.c ****         case 'w':
3932:Src/mpu6050.c ****             if (hal.dmp_on) {
3933:Src/mpu6050.c ****                 consoleLog("Low-power mode needs DMP to be off!\r\n");
3934:Src/mpu6050.c ****                 break;  /* LP accel is not compatible with the DMP. */
3935:Src/mpu6050.c ****             }
3936:Src/mpu6050.c ****             mpu_lp_accel_mode(20);
3937:Src/mpu6050.c ****             /* When LP accel mode is enabled, the driver automatically configures
3938:Src/mpu6050.c ****             * the hardware for latched interrupts. However, the MCU sometimes
3939:Src/mpu6050.c ****             * misses the rising/falling edge, and the hal.new_gyro flag is never
3940:Src/mpu6050.c ****             * set. To avoid getting locked in this state, we're overriding the
3941:Src/mpu6050.c ****             * driver's configuration and sticking to unlatched interrupt mode.
3942:Src/mpu6050.c ****             *
3943:Src/mpu6050.c ****             * TODO: The MCU supports level-triggered interrupts.
3944:Src/mpu6050.c ****             */
3945:Src/mpu6050.c ****             mpu_set_int_latched(0);
3946:Src/mpu6050.c ****             hal.sensors &= ~(GYRO_ON|COMPASS_ON);
3947:Src/mpu6050.c ****             hal.sensors |= ACCEL_ON;
3948:Src/mpu6050.c ****             hal.lp_accel_mode = 1;
3949:Src/mpu6050.c ****             break;
3950:Src/mpu6050.c **** 
3951:Src/mpu6050.c ****         /* The hardware self test is completely localized in the gyro driver.
3952:Src/mpu6050.c ****         * Logging is assumed to be enabled; otherwise, a couple LEDs could
3953:Src/mpu6050.c ****         * probably be used here to display the test results.
3954:Src/mpu6050.c ****         */
3955:Src/mpu6050.c ****         case 's':
3956:Src/mpu6050.c ****             mpu_start_self_test();
3957:Src/mpu6050.c ****             break;
3958:Src/mpu6050.c ****         #endif // MPU_SENSOR_ENABLE
3959:Src/mpu6050.c **** 
3960:Src/mpu6050.c ****         default:
3961:Src/mpu6050.c ****             break;
ARM GAS  /tmp/ccC60hwS.s 			page 246


3962:Src/mpu6050.c ****     }
3963:Src/mpu6050.c **** #endif // SERIAL_DEBUG
3964:Src/mpu6050.c **** }
 7991              		.loc 1 3964 1 view .LVU2408
 7992 0000 7047     		bx	lr
 7993              		.cfi_endproc
 7994              	.LFE121:
 7996              		.global	test
 7997              		.global	hw
 7998              		.global	reg
 7999              		.global	mpu
 8000              		.section	.rodata
 8001              		.set	.LANCHOR1,. + 0
 8002              	.LC0:
 8003 0000 00000000 		.ascii	"\000\000\000\000\000\000"
 8003      0000
 8004              		.section	.bss.hal,"aw",%nobits
 8005              		.align	2
 8006              		.set	.LANCHOR2,. + 0
 8009              	hal:
 8010 0000 00000000 		.space	28
 8010      00000000 
 8010      00000000 
 8010      00000000 
 8010      00000000 
 8011              		.section	.bss.mpu,"aw",%nobits
 8012              		.align	2
 8013              		.set	.LANCHOR3,. + 0
 8016              	mpu:
 8017 0000 00000000 		.space	36
 8017      00000000 
 8017      00000000 
 8017      00000000 
 8017      00000000 
 8018              		.section	.bss.quat.1,"aw",%nobits
 8019              		.align	2
 8020              		.set	.LANCHOR4,. + 0
 8023              	quat.1:
 8024 0000 00000000 		.space	16
 8024      00000000 
 8024      00000000 
 8024      00000000 
 8025              		.section	.bss.temperature.0,"aw",%nobits
 8026              		.align	2
 8027              		.set	.LANCHOR5,. + 0
 8030              	temperature.0:
 8031 0000 00000000 		.space	4
 8032              		.section	.data.st,"aw"
 8033              		.align	2
 8034              		.set	.LANCHOR0,. + 0
 8037              	st:
 8038 0000 00000000 		.word	reg
 8039 0004 00000000 		.word	hw
 8040 0008 00000000 		.space	32
 8040      00000000 
 8040      00000000 
 8040      00000000 
ARM GAS  /tmp/ccC60hwS.s 			page 247


 8040      00000000 
 8041 0028 00000000 		.word	test
 8042              		.section	.rodata.hw,"a"
 8043              		.align	1
 8046              	hw:
 8047 0000 68       		.byte	104
 8048 0001 00       		.space	1
 8049 0002 0004     		.short	1024
 8050 0004 76       		.byte	118
 8051 0005 00       		.space	1
 8052 0006 5401     		.short	340
 8053 0008 F7FD     		.short	-521
 8054 000a 0001     		.short	256
 8055              		.section	.rodata.reg,"a"
 8058              	reg:
 8059 0000 75       		.byte	117
 8060 0001 19       		.byte	25
 8061 0002 1A       		.byte	26
 8062 0003 0C       		.byte	12
 8063 0004 6A       		.byte	106
 8064 0005 23       		.byte	35
 8065 0006 1B       		.byte	27
 8066 0007 1C       		.byte	28
 8067 0008 0000     		.space	2
 8068 000a 1F       		.byte	31
 8069 000b 20       		.byte	32
 8070 000c 72       		.byte	114
 8071 000d 74       		.byte	116
 8072 000e 43       		.byte	67
 8073 000f 3B       		.byte	59
 8074 0010 41       		.byte	65
 8075 0011 38       		.byte	56
 8076 0012 39       		.byte	57
 8077 0013 3A       		.byte	58
 8078 0014 00       		.space	1
 8079 0015 6B       		.byte	107
 8080 0016 6C       		.byte	108
 8081 0017 37       		.byte	55
 8082 0018 6F       		.byte	111
 8083 0019 06       		.byte	6
 8084 001a 24       		.byte	36
 8085 001b 6D       		.byte	109
 8086 001c 6E       		.byte	110
 8087 001d 70       		.byte	112
 8088              		.section	.rodata.test,"a"
 8089              		.align	2
 8092              	test:
 8093 0000 83000000 		.word	131
 8094 0004 00080000 		.word	2048
 8095 0008 00       		.byte	0
 8096 0009 01       		.byte	1
 8097 000a 00       		.byte	0
 8098 000b 18       		.byte	24
 8099 000c 3200     		.short	50
 8100 000e 05       		.byte	5
 8101 000f 00       		.space	1
 8102 0010 00002041 		.word	1092616192
ARM GAS  /tmp/ccC60hwS.s 			page 248


 8103 0014 0000D242 		.word	1121058816
 8104 0018 295C0F3E 		.word	1041194025
 8105 001c 9A99993E 		.word	1050253722
 8106 0020 3333733F 		.word	1064514355
 8107 0024 295C0F3E 		.word	1041194025
 8108              		.text
 8109              	.Letext0:
 8110              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 8111              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 8112              		.file 4 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 8113              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 8114              		.file 6 "Inc/defines.h"
 8115              		.file 7 "Inc/util.h"
 8116              		.file 8 "/usr/include/newlib/math.h"
 8117              		.file 9 "Inc/mpu6050_dmp.h"
 8118              		.file 10 "Inc/systick.h"
 8119              		.file 11 "/usr/include/newlib/string.h"
ARM GAS  /tmp/ccC60hwS.s 			page 249


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mpu6050.c
     /tmp/ccC60hwS.s:17     .text.get_st_biases:0000000000000000 $t
     /tmp/ccC60hwS.s:24     .text.get_st_biases:0000000000000000 get_st_biases
     /tmp/ccC60hwS.s:556    .text.get_st_biases:00000000000002e4 $d
     /tmp/ccC60hwS.s:563    .text.get_st_biases:00000000000002e8 $t
     /tmp/ccC60hwS.s:641    .text.set_int_enable.isra.0:0000000000000000 $t
     /tmp/ccC60hwS.s:647    .text.set_int_enable.isra.0:0000000000000000 set_int_enable.isra.0
     /tmp/ccC60hwS.s:724    .text.set_int_enable.isra.0:0000000000000048 $d
     /tmp/ccC60hwS.s:729    .text.mpu_reg_dump:0000000000000000 $t
     /tmp/ccC60hwS.s:736    .text.mpu_reg_dump:0000000000000000 mpu_reg_dump
     /tmp/ccC60hwS.s:820    .text.mpu_reg_dump:0000000000000040 $d
     /tmp/ccC60hwS.s:825    .text.mpu_read_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:832    .text.mpu_read_reg:0000000000000000 mpu_read_reg
     /tmp/ccC60hwS.s:890    .text.mpu_read_reg:0000000000000030 $d
     /tmp/ccC60hwS.s:895    .text.mpu_get_gyro_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:902    .text.mpu_get_gyro_reg:0000000000000000 mpu_get_gyro_reg
     /tmp/ccC60hwS.s:993    .text.mpu_get_gyro_reg:0000000000000054 $d
     /tmp/ccC60hwS.s:998    .text.mpu_get_accel_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:1005   .text.mpu_get_accel_reg:0000000000000000 mpu_get_accel_reg
     /tmp/ccC60hwS.s:1096   .text.mpu_get_accel_reg:0000000000000054 $d
     /tmp/ccC60hwS.s:1107   .text.mpu_get_temperature:0000000000000000 $t
     /tmp/ccC60hwS.s:1114   .text.mpu_get_temperature:0000000000000000 mpu_get_temperature
     /tmp/ccC60hwS.s:1233   .text.mpu_get_temperature:0000000000000078 $d
     /tmp/ccC60hwS.s:1239   .text.mpu_read_6500_accel_bias:0000000000000000 $t
     /tmp/ccC60hwS.s:1246   .text.mpu_read_6500_accel_bias:0000000000000000 mpu_read_6500_accel_bias
     /tmp/ccC60hwS.s:1341   .text.mpu_read_6500_accel_bias:0000000000000064 $d
     /tmp/ccC60hwS.s:1346   .text.mpu_read_6050_accel_bias:0000000000000000 $t
     /tmp/ccC60hwS.s:1353   .text.mpu_read_6050_accel_bias:0000000000000000 mpu_read_6050_accel_bias
     /tmp/ccC60hwS.s:1448   .text.mpu_read_6050_accel_bias:0000000000000064 $d
     /tmp/ccC60hwS.s:1453   .text.mpu_read_6500_gyro_bias:0000000000000000 $t
     /tmp/ccC60hwS.s:1460   .text.mpu_read_6500_gyro_bias:0000000000000000 mpu_read_6500_gyro_bias
     /tmp/ccC60hwS.s:1555   .text.mpu_read_6500_gyro_bias:0000000000000064 $d
     /tmp/ccC60hwS.s:1560   .text.mpu_set_gyro_bias_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:1567   .text.mpu_set_gyro_bias_reg:0000000000000000 mpu_set_gyro_bias_reg
     /tmp/ccC60hwS.s:1692   .text.mpu_set_gyro_bias_reg:0000000000000078 $d
     /tmp/ccC60hwS.s:1697   .text.mpu_set_accel_bias_6050_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:1704   .text.mpu_set_accel_bias_6050_reg:0000000000000000 mpu_set_accel_bias_6050_reg
     /tmp/ccC60hwS.s:1868   .text.mpu_set_accel_bias_6050_reg:00000000000000ac $d
     /tmp/ccC60hwS.s:1874   .text.mpu_set_accel_bias_6500_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:1881   .text.mpu_set_accel_bias_6500_reg:0000000000000000 mpu_set_accel_bias_6500_reg
     /tmp/ccC60hwS.s:2045   .text.mpu_set_accel_bias_6500_reg:00000000000000ac $d
     /tmp/ccC60hwS.s:2051   .text.mpu_reset_fifo:0000000000000000 $t
     /tmp/ccC60hwS.s:2058   .text.mpu_reset_fifo:0000000000000000 mpu_reset_fifo
     /tmp/ccC60hwS.s:2309   .text.mpu_reset_fifo:0000000000000164 $d
     /tmp/ccC60hwS.s:2315   .text.mpu_get_gyro_fsr:0000000000000000 $t
     /tmp/ccC60hwS.s:2322   .text.mpu_get_gyro_fsr:0000000000000000 mpu_get_gyro_fsr
     /tmp/ccC60hwS.s:2339   .text.mpu_get_gyro_fsr:000000000000000c $d
     /tmp/ccC60hwS.s:2343   .text.mpu_get_gyro_fsr:0000000000000010 $t
     /tmp/ccC60hwS.s:2382   .text.mpu_get_gyro_fsr:0000000000000030 $d
     /tmp/ccC60hwS.s:2387   .text.mpu_set_gyro_fsr:0000000000000000 $t
     /tmp/ccC60hwS.s:2394   .text.mpu_set_gyro_fsr:0000000000000000 mpu_set_gyro_fsr
     /tmp/ccC60hwS.s:2502   .text.mpu_set_gyro_fsr:000000000000006c $d
     /tmp/ccC60hwS.s:2507   .text.mpu_get_accel_fsr:0000000000000000 $t
     /tmp/ccC60hwS.s:2514   .text.mpu_get_accel_fsr:0000000000000000 mpu_get_accel_fsr
     /tmp/ccC60hwS.s:2531   .text.mpu_get_accel_fsr:000000000000000c $d
     /tmp/ccC60hwS.s:2535   .text.mpu_get_accel_fsr:0000000000000010 $t
ARM GAS  /tmp/ccC60hwS.s 			page 250


     /tmp/ccC60hwS.s:2584   .text.mpu_get_accel_fsr:0000000000000034 $d
     /tmp/ccC60hwS.s:2589   .text.mpu_set_accel_fsr:0000000000000000 $t
     /tmp/ccC60hwS.s:2596   .text.mpu_set_accel_fsr:0000000000000000 mpu_set_accel_fsr
     /tmp/ccC60hwS.s:2704   .text.mpu_set_accel_fsr:0000000000000064 $d
     /tmp/ccC60hwS.s:2709   .text.mpu_get_lpf:0000000000000000 $t
     /tmp/ccC60hwS.s:2716   .text.mpu_get_lpf:0000000000000000 mpu_get_lpf
     /tmp/ccC60hwS.s:2734   .text.mpu_get_lpf:000000000000000e $d
     /tmp/ccC60hwS.s:2740   .text.mpu_get_lpf:0000000000000014 $t
     /tmp/ccC60hwS.s:2789   .text.mpu_get_lpf:0000000000000034 $d
     /tmp/ccC60hwS.s:2794   .text.mpu_set_lpf:0000000000000000 $t
     /tmp/ccC60hwS.s:2801   .text.mpu_set_lpf:0000000000000000 mpu_set_lpf
     /tmp/ccC60hwS.s:2923   .text.mpu_set_lpf:0000000000000068 $d
     /tmp/ccC60hwS.s:2928   .text.mpu_get_sample_rate:0000000000000000 $t
     /tmp/ccC60hwS.s:2935   .text.mpu_get_sample_rate:0000000000000000 mpu_get_sample_rate
     /tmp/ccC60hwS.s:2969   .text.mpu_get_sample_rate:0000000000000018 $d
     /tmp/ccC60hwS.s:2974   .text.mpu_get_compass_sample_rate:0000000000000000 $t
     /tmp/ccC60hwS.s:2981   .text.mpu_get_compass_sample_rate:0000000000000000 mpu_get_compass_sample_rate
     /tmp/ccC60hwS.s:3003   .text.mpu_set_compass_sample_rate:0000000000000000 $t
     /tmp/ccC60hwS.s:3010   .text.mpu_set_compass_sample_rate:0000000000000000 mpu_set_compass_sample_rate
     /tmp/ccC60hwS.s:3028   .text.mpu_get_gyro_sens:0000000000000000 $t
     /tmp/ccC60hwS.s:3035   .text.mpu_get_gyro_sens:0000000000000000 mpu_get_gyro_sens
     /tmp/ccC60hwS.s:3052   .text.mpu_get_gyro_sens:000000000000000c $d
     /tmp/ccC60hwS.s:3056   .text.mpu_get_gyro_sens:0000000000000010 $t
     /tmp/ccC60hwS.s:3095   .text.mpu_get_gyro_sens:000000000000002c $d
     /tmp/ccC60hwS.s:3104   .text.mpu_get_accel_sens:0000000000000000 $t
     /tmp/ccC60hwS.s:3111   .text.mpu_get_accel_sens:0000000000000000 mpu_get_accel_sens
     /tmp/ccC60hwS.s:3128   .text.mpu_get_accel_sens:000000000000000c $d
     /tmp/ccC60hwS.s:3132   .text.mpu_get_accel_sens:0000000000000010 $t
     /tmp/ccC60hwS.s:3181   .text.mpu_get_accel_sens:000000000000003c $d
     /tmp/ccC60hwS.s:3186   .text.mpu_get_fifo_config:0000000000000000 $t
     /tmp/ccC60hwS.s:3193   .text.mpu_get_fifo_config:0000000000000000 mpu_get_fifo_config
     /tmp/ccC60hwS.s:3216   .text.mpu_get_fifo_config:000000000000000c $d
     /tmp/ccC60hwS.s:3221   .text.mpu_configure_fifo:0000000000000000 $t
     /tmp/ccC60hwS.s:3228   .text.mpu_configure_fifo:0000000000000000 mpu_configure_fifo
     /tmp/ccC60hwS.s:3323   .text.mpu_configure_fifo:0000000000000048 $d
     /tmp/ccC60hwS.s:3328   .text.mpu_get_power_state:0000000000000000 $t
     /tmp/ccC60hwS.s:3335   .text.mpu_get_power_state:0000000000000000 mpu_get_power_state
     /tmp/ccC60hwS.s:3361   .text.mpu_get_power_state:0000000000000010 $d
     /tmp/ccC60hwS.s:3366   .text.mpu_get_int_status:0000000000000000 $t
     /tmp/ccC60hwS.s:3373   .text.mpu_get_int_status:0000000000000000 mpu_get_int_status
     /tmp/ccC60hwS.s:3436   .text.mpu_get_int_status:0000000000000030 $d
     /tmp/ccC60hwS.s:3441   .text.mpu_read_fifo:0000000000000000 $t
     /tmp/ccC60hwS.s:3448   .text.mpu_read_fifo:0000000000000000 mpu_read_fifo
     /tmp/ccC60hwS.s:3803   .text.mpu_read_fifo:000000000000019c $d
     /tmp/ccC60hwS.s:3808   .text.mpu_read_fifo_stream:0000000000000000 $t
     /tmp/ccC60hwS.s:3815   .text.mpu_read_fifo_stream:0000000000000000 mpu_read_fifo_stream
     /tmp/ccC60hwS.s:3959   .text.mpu_read_fifo_stream:0000000000000094 $d
     /tmp/ccC60hwS.s:3964   .text.mpu_set_bypass:0000000000000000 $t
     /tmp/ccC60hwS.s:3971   .text.mpu_set_bypass:0000000000000000 mpu_set_bypass
     /tmp/ccC60hwS.s:4154   .text.mpu_set_bypass:00000000000000e4 $d
     /tmp/ccC60hwS.s:4159   .text.mpu_set_int_level:0000000000000000 $t
     /tmp/ccC60hwS.s:4166   .text.mpu_set_int_level:0000000000000000 mpu_set_int_level
     /tmp/ccC60hwS.s:4187   .text.mpu_set_int_level:000000000000000c $d
     /tmp/ccC60hwS.s:4192   .text.mpu_set_int_latched:0000000000000000 $t
     /tmp/ccC60hwS.s:4199   .text.mpu_set_int_latched:0000000000000000 mpu_set_int_latched
     /tmp/ccC60hwS.s:4291   .text.mpu_set_int_latched:0000000000000060 $d
     /tmp/ccC60hwS.s:4296   .text.mpu_lp_accel_mode:0000000000000000 $t
ARM GAS  /tmp/ccC60hwS.s 			page 251


     /tmp/ccC60hwS.s:4303   .text.mpu_lp_accel_mode:0000000000000000 mpu_lp_accel_mode
     /tmp/ccC60hwS.s:4484   .text.mpu_lp_accel_mode:00000000000000ac $d
     /tmp/ccC60hwS.s:4489   .text.mpu_set_sample_rate:0000000000000000 $t
     /tmp/ccC60hwS.s:4496   .text.mpu_set_sample_rate:0000000000000000 mpu_set_sample_rate
     /tmp/ccC60hwS.s:4616   .text.mpu_set_sample_rate:000000000000007c $d
     /tmp/ccC60hwS.s:4621   .text.mpu_set_sensors:0000000000000000 $t
     /tmp/ccC60hwS.s:4628   .text.mpu_set_sensors:0000000000000000 mpu_set_sensors
     /tmp/ccC60hwS.s:4796   .text.mpu_set_sensors:00000000000000bc $d
     /tmp/ccC60hwS.s:4801   .text.mpu_init:0000000000000000 $t
     /tmp/ccC60hwS.s:4808   .text.mpu_init:0000000000000000 mpu_init
     /tmp/ccC60hwS.s:4977   .text.mpu_init:00000000000000b0 $d
     /tmp/ccC60hwS.s:4982   .text.mpu_write_mem:0000000000000000 $t
     /tmp/ccC60hwS.s:4989   .text.mpu_write_mem:0000000000000000 mpu_write_mem
     /tmp/ccC60hwS.s:5089   .text.mpu_write_mem:000000000000005c $d
     /tmp/ccC60hwS.s:5094   .text.mpu_read_mem:0000000000000000 $t
     /tmp/ccC60hwS.s:5101   .text.mpu_read_mem:0000000000000000 mpu_read_mem
     /tmp/ccC60hwS.s:5201   .text.mpu_read_mem:000000000000005c $d
     /tmp/ccC60hwS.s:5206   .text.mpu_load_firmware:0000000000000000 $t
     /tmp/ccC60hwS.s:5213   .text.mpu_load_firmware:0000000000000000 mpu_load_firmware
     /tmp/ccC60hwS.s:5365   .text.mpu_load_firmware:000000000000009c $d
     /tmp/ccC60hwS.s:5370   .text.mpu_set_dmp_state:0000000000000000 $t
     /tmp/ccC60hwS.s:5377   .text.mpu_set_dmp_state:0000000000000000 mpu_set_dmp_state
     /tmp/ccC60hwS.s:5503   .text.mpu_set_dmp_state:0000000000000078 $d
     /tmp/ccC60hwS.s:5511   .text.mpu_run_self_test:0000000000000000 $t
     /tmp/ccC60hwS.s:5518   .text.mpu_run_self_test:0000000000000000 mpu_run_self_test
     /tmp/ccC60hwS.s:6222   .text.mpu_run_self_test:00000000000002ec $d
     /tmp/ccC60hwS.s:6238   .text.mpu_get_dmp_state:0000000000000000 $t
     /tmp/ccC60hwS.s:6245   .text.mpu_get_dmp_state:0000000000000000 mpu_get_dmp_state
     /tmp/ccC60hwS.s:6268   .text.mpu_get_dmp_state:000000000000000c $d
     /tmp/ccC60hwS.s:6273   .text.mpu_get_compass_reg:0000000000000000 $t
     /tmp/ccC60hwS.s:6280   .text.mpu_get_compass_reg:0000000000000000 mpu_get_compass_reg
     /tmp/ccC60hwS.s:6298   .text.mpu_get_compass_fsr:0000000000000000 $t
     /tmp/ccC60hwS.s:6305   .text.mpu_get_compass_fsr:0000000000000000 mpu_get_compass_fsr
     /tmp/ccC60hwS.s:6323   .text.mpu_lp_motion_interrupt:0000000000000000 $t
     /tmp/ccC60hwS.s:6330   .text.mpu_lp_motion_interrupt:0000000000000000 mpu_lp_motion_interrupt
     /tmp/ccC60hwS.s:6505   .text.mpu_lp_motion_interrupt:000000000000009c $d
     /tmp/ccC60hwS.s:6523   .text.mpu_start_self_test:0000000000000000 $t
     /tmp/ccC60hwS.s:6530   .text.mpu_start_self_test:0000000000000000 mpu_start_self_test
     /tmp/ccC60hwS.s:6610   .text.mpu_start_self_test:0000000000000038 $d
     /tmp/ccC60hwS.s:6627   .text.mpu_setup_gyro:0000000000000000 $t
     /tmp/ccC60hwS.s:6634   .text.mpu_setup_gyro:0000000000000000 mpu_setup_gyro
     /tmp/ccC60hwS.s:6732   .text.mpu_setup_gyro:0000000000000050 $d
     /tmp/ccC60hwS.s:6741   .text.inv_row_2_scale:0000000000000000 $t
     /tmp/ccC60hwS.s:6748   .text.inv_row_2_scale:0000000000000000 inv_row_2_scale
     /tmp/ccC60hwS.s:6849   .text.inv_orientation_matrix_to_scalar:0000000000000000 $t
     /tmp/ccC60hwS.s:6856   .text.inv_orientation_matrix_to_scalar:0000000000000000 inv_orientation_matrix_to_scalar
     /tmp/ccC60hwS.s:6913   .text.mpu_config:0000000000000000 $t
     /tmp/ccC60hwS.s:6920   .text.mpu_config:0000000000000000 mpu_config
     /tmp/ccC60hwS.s:6994   .text.mpu_config:0000000000000048 $d
     /tmp/ccC60hwS.s:7002   .text.mpu_read_gyro_raw:0000000000000000 $t
     /tmp/ccC60hwS.s:7009   .text.mpu_read_gyro_raw:0000000000000000 mpu_read_gyro_raw
     /tmp/ccC60hwS.s:7057   .text.mpu_read_gyro_raw:0000000000000034 $d
     /tmp/ccC60hwS.s:7063   .text.mpu_read_accel_raw:0000000000000000 $t
     /tmp/ccC60hwS.s:7070   .text.mpu_read_accel_raw:0000000000000000 mpu_read_accel_raw
     /tmp/ccC60hwS.s:7118   .text.mpu_read_accel_raw:0000000000000034 $d
     /tmp/ccC60hwS.s:7128   .text.mpu_calc_euler_angles:0000000000000000 $t
     /tmp/ccC60hwS.s:7135   .text.mpu_calc_euler_angles:0000000000000000 mpu_calc_euler_angles
ARM GAS  /tmp/ccC60hwS.s 			page 252


     /tmp/ccC60hwS.s:7457   .text.mpu_calc_euler_angles:00000000000001a8 $d
     /tmp/ccC60hwS.s:7465   .text.mpu_get_data:0000000000000000 $t
     /tmp/ccC60hwS.s:7472   .text.mpu_get_data:0000000000000000 mpu_get_data
     /tmp/ccC60hwS.s:7784   .text.mpu_get_data:0000000000000154 $d
     /tmp/ccC60hwS.s:7806   .text.mpu_tap_func:0000000000000000 $t
     /tmp/ccC60hwS.s:7813   .text.mpu_tap_func:0000000000000000 mpu_tap_func
     /tmp/ccC60hwS.s:7829   .text.mpu_tap_func:000000000000000a $d
     /tmp/ccC60hwS.s:7835   .text.mpu_tap_func:0000000000000010 $t
     /tmp/ccC60hwS.s:7869   .text.mpu_tap_func:000000000000002c $d
     /tmp/ccC60hwS.s:7888   .text.mpu_android_orient_func:0000000000000000 $t
     /tmp/ccC60hwS.s:7895   .text.mpu_android_orient_func:0000000000000000 mpu_android_orient_func
     /tmp/ccC60hwS.s:7908   .text.mpu_android_orient_func:0000000000000008 $d
     /tmp/ccC60hwS.s:7912   .text.mpu_android_orient_func:000000000000000c $t
     /tmp/ccC60hwS.s:7948   .text.mpu_android_orient_func:0000000000000020 $d
     /tmp/ccC60hwS.s:7956   .text.mpu_print_to_console:0000000000000000 $t
     /tmp/ccC60hwS.s:7963   .text.mpu_print_to_console:0000000000000000 mpu_print_to_console
     /tmp/ccC60hwS.s:7976   .text.mpu_handle_input:0000000000000000 $t
     /tmp/ccC60hwS.s:7983   .text.mpu_handle_input:0000000000000000 mpu_handle_input
     /tmp/ccC60hwS.s:8092   .rodata.test:0000000000000000 test
     /tmp/ccC60hwS.s:8046   .rodata.hw:0000000000000000 hw
     /tmp/ccC60hwS.s:8058   .rodata.reg:0000000000000000 reg
     /tmp/ccC60hwS.s:8016   .bss.mpu:0000000000000000 mpu
     /tmp/ccC60hwS.s:8005   .bss.hal:0000000000000000 $d
     /tmp/ccC60hwS.s:8009   .bss.hal:0000000000000000 hal
     /tmp/ccC60hwS.s:8012   .bss.mpu:0000000000000000 $d
     /tmp/ccC60hwS.s:8019   .bss.quat.1:0000000000000000 $d
     /tmp/ccC60hwS.s:8023   .bss.quat.1:0000000000000000 quat.1
     /tmp/ccC60hwS.s:8026   .bss.temperature.0:0000000000000000 $d
     /tmp/ccC60hwS.s:8030   .bss.temperature.0:0000000000000000 temperature.0
     /tmp/ccC60hwS.s:8033   .data.st:0000000000000000 $d
     /tmp/ccC60hwS.s:8037   .data.st:0000000000000000 st
     /tmp/ccC60hwS.s:8043   .rodata.hw:0000000000000000 $d
     /tmp/ccC60hwS.s:8067   .rodata.reg:0000000000000008 $d
     /tmp/ccC60hwS.s:8089   .rodata.test:0000000000000000 $d

UNDEFINED SYMBOLS
__aeabi_ldivmod
i2c_writeBytes
delay_1ms
i2c_readBytes
get_tick_count_ms
__aeabi_i2f
__aeabi_fsub
__aeabi_fdiv
__aeabi_fadd
__aeabi_fmul
__aeabi_f2iz
memcmp
__aeabi_fcmpeq
__aeabi_fcmpgt
__aeabi_fcmplt
consoleLog
__aeabi_f2d
__aeabi_d2f
__aeabi_dmul
__aeabi_d2iz
atan2
ARM GAS  /tmp/ccC60hwS.s 			page 253


asin
i2c_readByte
dmp_read_fifo
