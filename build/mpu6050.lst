ARM GAS  /tmp/cc39PcX6.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"mpu6050.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_ldivmod
  16              		.section	.text.get_st_biases,"ax",%progbits
  17              		.align	1
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	get_st_biases:
  25              	.LVL0:
  26              	.LFB99:
  27              		.file 1 "Src/mpu6050.c"
   1:Src/mpu6050.c **** /**
   2:Src/mpu6050.c ****   * This file was taken from InvenSense MotionApps v6.12 library and
   3:Src/mpu6050.c ****   * refactored for the hoverboard-sideboard-hack project.
   4:Src/mpu6050.c ****   *
   5:Src/mpu6050.c ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   6:Src/mpu6050.c ****   * Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
   7:Src/mpu6050.c ****   *
   8:Src/mpu6050.c ****   * This program is free software: you can redistribute it and/or modify
   9:Src/mpu6050.c ****   * it under the terms of the GNU General Public License as published by
  10:Src/mpu6050.c ****   * the Free Software Foundation, either version 3 of the License, or
  11:Src/mpu6050.c ****   * (at your option) any later version.
  12:Src/mpu6050.c ****   *
  13:Src/mpu6050.c ****   * This program is distributed in the hope that it will be useful,
  14:Src/mpu6050.c ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:Src/mpu6050.c ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:Src/mpu6050.c ****   * GNU General Public License for more details.
  17:Src/mpu6050.c ****   *
  18:Src/mpu6050.c ****   * You should have received a copy of the GNU General Public License
  19:Src/mpu6050.c ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  20:Src/mpu6050.c **** */
  21:Src/mpu6050.c **** 
  22:Src/mpu6050.c **** // Includes
  23:Src/mpu6050.c **** #include <stdio.h>
  24:Src/mpu6050.c **** #include <stdlib.h>
  25:Src/mpu6050.c **** #include <string.h>
  26:Src/mpu6050.c **** #include <math.h>
  27:Src/mpu6050.c **** #include "systick.h" 	
  28:Src/mpu6050.c **** #include "defines.h"
  29:Src/mpu6050.c **** #include "config.h"
  30:Src/mpu6050.c **** #include "util.h"
  31:Src/mpu6050.c **** #include "mpu6050.h"
ARM GAS  /tmp/cc39PcX6.s 			page 2


  32:Src/mpu6050.c **** #include "mpu6050_dmp.h"
  33:Src/mpu6050.c **** 
  34:Src/mpu6050.c **** 
  35:Src/mpu6050.c **** /* The following functions must be defined for this platform:
  36:Src/mpu6050.c ****  * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
  37:Src/mpu6050.c ****  *      unsigned char length, unsigned char const *data)
  38:Src/mpu6050.c ****  * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
  39:Src/mpu6050.c ****  *      unsigned char length, unsigned char *data)
  40:Src/mpu6050.c ****  * delay_ms(unsigned long num_ms)
  41:Src/mpu6050.c ****  * get_ms(unsigned long *count)
  42:Src/mpu6050.c ****  * labs(long x)
  43:Src/mpu6050.c ****  * fabsf(float x)
  44:Src/mpu6050.c ****  * min(int a, int b)
  45:Src/mpu6050.c ****  */
  46:Src/mpu6050.c **** 
  47:Src/mpu6050.c **** MPU_Data mpu;                                       // holds the MPU-6050 data
  48:Src/mpu6050.c **** 
  49:Src/mpu6050.c **** #ifdef SERIAL_AUX_RX
  50:Src/mpu6050.c **** uint8_t print_aux = 0;                              // print AUX serial data
  51:Src/mpu6050.c **** #endif
  52:Src/mpu6050.c **** 
  53:Src/mpu6050.c **** #ifdef  MPU_SENSOR_ENABLE
  54:Src/mpu6050.c **** 
  55:Src/mpu6050.c **** static signed char MPU_ORIENTATION[9] = {1, 0, 0,   // [-] MPU Sensor orientation matrix: set this 
  56:Src/mpu6050.c ****                                          0, 1, 0,
  57:Src/mpu6050.c ****                                          0, 0, 1};
  58:Src/mpu6050.c **** 
  59:Src/mpu6050.c **** 
  60:Src/mpu6050.c **** #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
  61:Src/mpu6050.c **** #error  Which gyro are you using? Define MPUxxxx in config.h
  62:Src/mpu6050.c **** #endif
  63:Src/mpu6050.c **** 
  64:Src/mpu6050.c **** 
  65:Src/mpu6050.c **** 
  66:Src/mpu6050.c **** /* Time for some messy macro work. =]
  67:Src/mpu6050.c ****  * #define MPU9150
  68:Src/mpu6050.c ****  * is equivalent to..
  69:Src/mpu6050.c ****  * #define MPU6050
  70:Src/mpu6050.c ****  * #define AK8975_SECONDARY
  71:Src/mpu6050.c ****  *
  72:Src/mpu6050.c ****  * #define MPU9250
  73:Src/mpu6050.c ****  * is equivalent to..
  74:Src/mpu6050.c ****  * #define MPU6500
  75:Src/mpu6050.c ****  * #define AK8963_SECONDARY
  76:Src/mpu6050.c ****  */
  77:Src/mpu6050.c **** #if defined MPU9150
  78:Src/mpu6050.c **** #ifndef MPU6050
  79:Src/mpu6050.c **** #define MPU6050
  80:Src/mpu6050.c **** #endif                          /* #ifndef MPU6050 */
  81:Src/mpu6050.c **** #if defined AK8963_SECONDARY
  82:Src/mpu6050.c **** #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
  83:Src/mpu6050.c **** #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
  84:Src/mpu6050.c **** #define AK8975_SECONDARY
  85:Src/mpu6050.c **** #endif                          /* #if defined AK8963_SECONDARY */
  86:Src/mpu6050.c **** #elif defined MPU9250           /* #if defined MPU9150 */
  87:Src/mpu6050.c **** #ifndef MPU6500
  88:Src/mpu6050.c **** #define MPU6500
ARM GAS  /tmp/cc39PcX6.s 			page 3


  89:Src/mpu6050.c **** #endif                          /* #ifndef MPU6500 */
  90:Src/mpu6050.c **** #if defined AK8975_SECONDARY
  91:Src/mpu6050.c **** #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
  92:Src/mpu6050.c **** #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
  93:Src/mpu6050.c **** #define AK8963_SECONDARY
  94:Src/mpu6050.c **** #endif                          /* #if defined AK8975_SECONDARY */
  95:Src/mpu6050.c **** #endif                          /* #if defined MPU9150 */
  96:Src/mpu6050.c **** 
  97:Src/mpu6050.c **** #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
  98:Src/mpu6050.c **** #define AK89xx_SECONDARY
  99:Src/mpu6050.c **** #else
 100:Src/mpu6050.c **** /* #warning "No compass = less profit for Invensense. Lame." */
 101:Src/mpu6050.c **** #endif
 102:Src/mpu6050.c **** 
 103:Src/mpu6050.c **** static int set_int_enable(unsigned char enable);
 104:Src/mpu6050.c **** 
 105:Src/mpu6050.c **** /* Hardware registers needed by driver. */
 106:Src/mpu6050.c **** struct gyro_reg_s {
 107:Src/mpu6050.c ****     unsigned char who_am_i;
 108:Src/mpu6050.c ****     unsigned char rate_div;
 109:Src/mpu6050.c ****     unsigned char lpf;
 110:Src/mpu6050.c ****     unsigned char prod_id;
 111:Src/mpu6050.c ****     unsigned char user_ctrl;
 112:Src/mpu6050.c ****     unsigned char fifo_en;
 113:Src/mpu6050.c ****     unsigned char gyro_cfg;
 114:Src/mpu6050.c ****     unsigned char accel_cfg;
 115:Src/mpu6050.c ****     unsigned char accel_cfg2;
 116:Src/mpu6050.c ****     unsigned char lp_accel_odr;
 117:Src/mpu6050.c ****     unsigned char motion_thr;
 118:Src/mpu6050.c ****     unsigned char motion_dur;
 119:Src/mpu6050.c ****     unsigned char fifo_count_h;
 120:Src/mpu6050.c ****     unsigned char fifo_r_w;
 121:Src/mpu6050.c ****     unsigned char raw_gyro;
 122:Src/mpu6050.c ****     unsigned char raw_accel;
 123:Src/mpu6050.c ****     unsigned char temp;
 124:Src/mpu6050.c ****     unsigned char int_enable;
 125:Src/mpu6050.c ****     unsigned char dmp_int_status;
 126:Src/mpu6050.c ****     unsigned char int_status;
 127:Src/mpu6050.c ****     unsigned char accel_intel;
 128:Src/mpu6050.c ****     unsigned char pwr_mgmt_1;
 129:Src/mpu6050.c ****     unsigned char pwr_mgmt_2;
 130:Src/mpu6050.c ****     unsigned char int_pin_cfg;
 131:Src/mpu6050.c ****     unsigned char mem_r_w;
 132:Src/mpu6050.c ****     unsigned char accel_offs;
 133:Src/mpu6050.c ****     unsigned char i2c_mst;
 134:Src/mpu6050.c ****     unsigned char bank_sel;
 135:Src/mpu6050.c ****     unsigned char mem_start_addr;
 136:Src/mpu6050.c ****     unsigned char prgm_start_h;
 137:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 138:Src/mpu6050.c ****     unsigned char s0_addr;
 139:Src/mpu6050.c ****     unsigned char s0_reg;
 140:Src/mpu6050.c ****     unsigned char s0_ctrl;
 141:Src/mpu6050.c ****     unsigned char s1_addr;
 142:Src/mpu6050.c ****     unsigned char s1_reg;
 143:Src/mpu6050.c ****     unsigned char s1_ctrl;
 144:Src/mpu6050.c ****     unsigned char s4_ctrl;
 145:Src/mpu6050.c ****     unsigned char s0_do;
ARM GAS  /tmp/cc39PcX6.s 			page 4


 146:Src/mpu6050.c ****     unsigned char s1_do;
 147:Src/mpu6050.c ****     unsigned char i2c_delay_ctrl;
 148:Src/mpu6050.c ****     unsigned char raw_compass;
 149:Src/mpu6050.c ****     /* The I2C_MST_VDDIO bit is in this register. */
 150:Src/mpu6050.c ****     unsigned char yg_offs_tc;
 151:Src/mpu6050.c **** #endif
 152:Src/mpu6050.c **** };
 153:Src/mpu6050.c **** 
 154:Src/mpu6050.c **** /* Information specific to a particular device. */
 155:Src/mpu6050.c **** struct hw_s {
 156:Src/mpu6050.c ****     unsigned char addr;
 157:Src/mpu6050.c ****     unsigned short max_fifo;
 158:Src/mpu6050.c ****     unsigned char num_reg;
 159:Src/mpu6050.c ****     unsigned short temp_sens;
 160:Src/mpu6050.c ****     short temp_offset;
 161:Src/mpu6050.c ****     unsigned short bank_size;
 162:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 163:Src/mpu6050.c ****     unsigned short compass_fsr;
 164:Src/mpu6050.c **** #endif
 165:Src/mpu6050.c **** };
 166:Src/mpu6050.c **** 
 167:Src/mpu6050.c **** /* When entering motion interrupt mode, the driver keeps track of the
 168:Src/mpu6050.c ****  * previous state so that it can be restored at a later time.
 169:Src/mpu6050.c ****  * TODO: This is tacky. Fix it.
 170:Src/mpu6050.c ****  */
 171:Src/mpu6050.c **** struct motion_int_cache_s {
 172:Src/mpu6050.c ****     unsigned short gyro_fsr;
 173:Src/mpu6050.c ****     unsigned char accel_fsr;
 174:Src/mpu6050.c ****     unsigned short lpf;
 175:Src/mpu6050.c ****     unsigned short sample_rate;
 176:Src/mpu6050.c ****     unsigned char sensors_on;
 177:Src/mpu6050.c ****     unsigned char fifo_sensors;
 178:Src/mpu6050.c ****     unsigned char dmp_on;
 179:Src/mpu6050.c **** };
 180:Src/mpu6050.c **** 
 181:Src/mpu6050.c **** /* Cached chip configuration data.
 182:Src/mpu6050.c ****  * TODO: A lot of these can be handled with a bitmask.
 183:Src/mpu6050.c ****  */
 184:Src/mpu6050.c **** struct chip_cfg_s {
 185:Src/mpu6050.c ****     /* Matches gyro_cfg >> 3 & 0x03 */
 186:Src/mpu6050.c ****     unsigned char gyro_fsr;
 187:Src/mpu6050.c ****     /* Matches accel_cfg >> 3 & 0x03 */
 188:Src/mpu6050.c ****     unsigned char accel_fsr;
 189:Src/mpu6050.c ****     /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
 190:Src/mpu6050.c ****     unsigned char sensors;
 191:Src/mpu6050.c ****     /* Matches config register. */
 192:Src/mpu6050.c ****     unsigned char lpf;
 193:Src/mpu6050.c ****     unsigned char clk_src;
 194:Src/mpu6050.c ****     /* Sample rate, NOT rate divider. */
 195:Src/mpu6050.c ****     unsigned short sample_rate;
 196:Src/mpu6050.c ****     /* Matches fifo_en register. */
 197:Src/mpu6050.c ****     unsigned char fifo_enable;
 198:Src/mpu6050.c ****     /* Matches int enable register. */
 199:Src/mpu6050.c ****     unsigned char int_enable;
 200:Src/mpu6050.c ****     /* 1 if devices on auxiliary I2C bus appear on the primary. */
 201:Src/mpu6050.c ****     unsigned char bypass_mode;
 202:Src/mpu6050.c ****     /* 1 if half-sensitivity.
ARM GAS  /tmp/cc39PcX6.s 			page 5


 203:Src/mpu6050.c ****      * NOTE: This doesn't belong here, but everything else in hw_s is const,
 204:Src/mpu6050.c ****      * and this allows us to save some precious RAM.
 205:Src/mpu6050.c ****      */
 206:Src/mpu6050.c ****     unsigned char accel_half;
 207:Src/mpu6050.c ****     /* 1 if device in low-power accel-only mode. */
 208:Src/mpu6050.c ****     unsigned char lp_accel_mode;
 209:Src/mpu6050.c ****     /* 1 if interrupts are only triggered on motion events. */
 210:Src/mpu6050.c ****     unsigned char int_motion_only;
 211:Src/mpu6050.c ****     struct motion_int_cache_s cache;
 212:Src/mpu6050.c ****     /* 1 for active low interrupts. */
 213:Src/mpu6050.c ****     unsigned char active_low_int;
 214:Src/mpu6050.c ****     /* 1 for latched interrupts. */
 215:Src/mpu6050.c ****     unsigned char latched_int;
 216:Src/mpu6050.c ****     /* 1 if DMP is enabled. */
 217:Src/mpu6050.c ****     unsigned char dmp_on;
 218:Src/mpu6050.c ****     /* Ensures that DMP will only be loaded once. */
 219:Src/mpu6050.c ****     unsigned char dmp_loaded;
 220:Src/mpu6050.c ****     /* Sampling rate used when DMP is enabled. */
 221:Src/mpu6050.c ****     unsigned short dmp_sample_rate;
 222:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 223:Src/mpu6050.c ****     /* Compass sample rate. */
 224:Src/mpu6050.c ****     unsigned short compass_sample_rate;
 225:Src/mpu6050.c ****     unsigned char compass_addr;
 226:Src/mpu6050.c ****     short mag_sens_adj[3];
 227:Src/mpu6050.c **** #endif
 228:Src/mpu6050.c **** };
 229:Src/mpu6050.c **** 
 230:Src/mpu6050.c **** /* Information for self-test. */
 231:Src/mpu6050.c **** struct test_s {
 232:Src/mpu6050.c ****     unsigned long gyro_sens;
 233:Src/mpu6050.c ****     unsigned long accel_sens;
 234:Src/mpu6050.c ****     unsigned char reg_rate_div;
 235:Src/mpu6050.c ****     unsigned char reg_lpf;
 236:Src/mpu6050.c ****     unsigned char reg_gyro_fsr;
 237:Src/mpu6050.c ****     unsigned char reg_accel_fsr;
 238:Src/mpu6050.c ****     unsigned short wait_ms;
 239:Src/mpu6050.c ****     unsigned char packet_thresh;
 240:Src/mpu6050.c ****     float min_dps;
 241:Src/mpu6050.c ****     float max_dps;
 242:Src/mpu6050.c ****     float max_gyro_var;
 243:Src/mpu6050.c ****     float min_g;
 244:Src/mpu6050.c ****     float max_g;
 245:Src/mpu6050.c ****     float max_accel_var;
 246:Src/mpu6050.c **** #ifdef MPU6500
 247:Src/mpu6050.c ****     float max_g_offset;
 248:Src/mpu6050.c ****     unsigned short sample_wait_ms;
 249:Src/mpu6050.c **** #endif
 250:Src/mpu6050.c **** };
 251:Src/mpu6050.c **** 
 252:Src/mpu6050.c **** /* Gyro driver state variables. */
 253:Src/mpu6050.c **** struct gyro_state_s {
 254:Src/mpu6050.c ****     const struct gyro_reg_s *reg;
 255:Src/mpu6050.c ****     const struct hw_s *hw;
 256:Src/mpu6050.c ****     struct chip_cfg_s chip_cfg;
 257:Src/mpu6050.c ****     const struct test_s *test;
 258:Src/mpu6050.c **** };
 259:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 6


 260:Src/mpu6050.c **** /* Filter configurations. */
 261:Src/mpu6050.c **** enum lpf_e {
 262:Src/mpu6050.c ****     INV_FILTER_256HZ_NOLPF2 = 0,
 263:Src/mpu6050.c ****     INV_FILTER_188HZ,
 264:Src/mpu6050.c ****     INV_FILTER_98HZ,
 265:Src/mpu6050.c ****     INV_FILTER_42HZ,
 266:Src/mpu6050.c ****     INV_FILTER_20HZ,
 267:Src/mpu6050.c ****     INV_FILTER_10HZ,
 268:Src/mpu6050.c ****     INV_FILTER_5HZ,
 269:Src/mpu6050.c ****     INV_FILTER_2100HZ_NOLPF,
 270:Src/mpu6050.c ****     NUM_FILTER
 271:Src/mpu6050.c **** };
 272:Src/mpu6050.c **** 
 273:Src/mpu6050.c **** /* Full scale ranges. */
 274:Src/mpu6050.c **** enum gyro_fsr_e {
 275:Src/mpu6050.c ****     INV_FSR_250DPS = 0,
 276:Src/mpu6050.c ****     INV_FSR_500DPS,
 277:Src/mpu6050.c ****     INV_FSR_1000DPS,
 278:Src/mpu6050.c ****     INV_FSR_2000DPS,
 279:Src/mpu6050.c ****     NUM_GYRO_FSR
 280:Src/mpu6050.c **** };
 281:Src/mpu6050.c **** 
 282:Src/mpu6050.c **** /* Full scale ranges. */
 283:Src/mpu6050.c **** enum accel_fsr_e {
 284:Src/mpu6050.c ****     INV_FSR_2G = 0,
 285:Src/mpu6050.c ****     INV_FSR_4G,
 286:Src/mpu6050.c ****     INV_FSR_8G,
 287:Src/mpu6050.c ****     INV_FSR_16G,
 288:Src/mpu6050.c ****     NUM_ACCEL_FSR
 289:Src/mpu6050.c **** };
 290:Src/mpu6050.c **** 
 291:Src/mpu6050.c **** /* Clock sources. */
 292:Src/mpu6050.c **** enum clock_sel_e {
 293:Src/mpu6050.c ****     INV_CLK_INTERNAL = 0,
 294:Src/mpu6050.c ****     INV_CLK_PLL,
 295:Src/mpu6050.c ****     NUM_CLK
 296:Src/mpu6050.c **** };
 297:Src/mpu6050.c **** 
 298:Src/mpu6050.c **** /* Low-power accel wakeup rates. */
 299:Src/mpu6050.c **** enum lp_accel_rate_e {
 300:Src/mpu6050.c **** #if defined MPU6050
 301:Src/mpu6050.c ****     INV_LPA_1_25HZ,
 302:Src/mpu6050.c ****     INV_LPA_5HZ,
 303:Src/mpu6050.c ****     INV_LPA_20HZ,
 304:Src/mpu6050.c ****     INV_LPA_40HZ
 305:Src/mpu6050.c **** #elif defined MPU6500
 306:Src/mpu6050.c ****     INV_LPA_0_3125HZ,
 307:Src/mpu6050.c ****     INV_LPA_0_625HZ,
 308:Src/mpu6050.c ****     INV_LPA_1_25HZ,
 309:Src/mpu6050.c ****     INV_LPA_2_5HZ,
 310:Src/mpu6050.c ****     INV_LPA_5HZ,
 311:Src/mpu6050.c ****     INV_LPA_10HZ,
 312:Src/mpu6050.c ****     INV_LPA_20HZ,
 313:Src/mpu6050.c ****     INV_LPA_40HZ,
 314:Src/mpu6050.c ****     INV_LPA_80HZ,
 315:Src/mpu6050.c ****     INV_LPA_160HZ,
 316:Src/mpu6050.c ****     INV_LPA_320HZ,
ARM GAS  /tmp/cc39PcX6.s 			page 7


 317:Src/mpu6050.c ****     INV_LPA_640HZ
 318:Src/mpu6050.c **** #endif
 319:Src/mpu6050.c **** };
 320:Src/mpu6050.c **** 
 321:Src/mpu6050.c **** #define BIT_I2C_MST_VDDIO   (0x80)
 322:Src/mpu6050.c **** #define BIT_FIFO_EN         (0x40)
 323:Src/mpu6050.c **** #define BIT_DMP_EN          (0x80)
 324:Src/mpu6050.c **** #define BIT_FIFO_RST        (0x04)
 325:Src/mpu6050.c **** #define BIT_DMP_RST         (0x08)
 326:Src/mpu6050.c **** #define BIT_FIFO_OVERFLOW   (0x10)
 327:Src/mpu6050.c **** #define BIT_DATA_RDY_EN     (0x01)
 328:Src/mpu6050.c **** #define BIT_DMP_INT_EN      (0x02)
 329:Src/mpu6050.c **** #define BIT_MOT_INT_EN      (0x40)
 330:Src/mpu6050.c **** #define BITS_FSR            (0x18)
 331:Src/mpu6050.c **** #define BITS_LPF            (0x07)
 332:Src/mpu6050.c **** #define BITS_HPF            (0x07)
 333:Src/mpu6050.c **** #define BITS_CLK            (0x07)
 334:Src/mpu6050.c **** #define BIT_FIFO_SIZE_1024  (0x40)
 335:Src/mpu6050.c **** #define BIT_FIFO_SIZE_2048  (0x80)
 336:Src/mpu6050.c **** #define BIT_FIFO_SIZE_4096  (0xC0)
 337:Src/mpu6050.c **** #define BIT_RESET           (0x80)
 338:Src/mpu6050.c **** #define BIT_SLEEP           (0x40)
 339:Src/mpu6050.c **** #define BIT_S0_DELAY_EN     (0x01)
 340:Src/mpu6050.c **** #define BIT_S2_DELAY_EN     (0x04)
 341:Src/mpu6050.c **** #define BITS_SLAVE_LENGTH   (0x0F)
 342:Src/mpu6050.c **** #define BIT_SLAVE_BYTE_SW   (0x40)
 343:Src/mpu6050.c **** #define BIT_SLAVE_GROUP     (0x10)
 344:Src/mpu6050.c **** #define BIT_SLAVE_EN        (0x80)
 345:Src/mpu6050.c **** #define BIT_I2C_READ        (0x80)
 346:Src/mpu6050.c **** #define BITS_I2C_MASTER_DLY (0x1F)
 347:Src/mpu6050.c **** #define BIT_AUX_IF_EN       (0x20)
 348:Src/mpu6050.c **** #define BIT_ACTL            (0x80)
 349:Src/mpu6050.c **** #define BIT_LATCH_EN        (0x20)
 350:Src/mpu6050.c **** #define BIT_ANY_RD_CLR      (0x10)
 351:Src/mpu6050.c **** #define BIT_BYPASS_EN       (0x02)
 352:Src/mpu6050.c **** #define BITS_WOM_EN         (0xC0)
 353:Src/mpu6050.c **** #define BIT_LPA_CYCLE       (0x20)
 354:Src/mpu6050.c **** #define BIT_STBY_XA         (0x20)
 355:Src/mpu6050.c **** #define BIT_STBY_YA         (0x10)
 356:Src/mpu6050.c **** #define BIT_STBY_ZA         (0x08)
 357:Src/mpu6050.c **** #define BIT_STBY_XG         (0x04)
 358:Src/mpu6050.c **** #define BIT_STBY_YG         (0x02)
 359:Src/mpu6050.c **** #define BIT_STBY_ZG         (0x01)
 360:Src/mpu6050.c **** #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
 361:Src/mpu6050.c **** #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
 362:Src/mpu6050.c **** 
 363:Src/mpu6050.c **** #if defined AK8975_SECONDARY
 364:Src/mpu6050.c **** #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
 365:Src/mpu6050.c **** #define AK89xx_FSR                  (9830)
 366:Src/mpu6050.c **** #elif defined AK8963_SECONDARY
 367:Src/mpu6050.c **** #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
 368:Src/mpu6050.c **** #define AK89xx_FSR                  (4915)
 369:Src/mpu6050.c **** #endif
 370:Src/mpu6050.c **** 
 371:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 372:Src/mpu6050.c **** #define AKM_REG_WHOAMI      (0x00)
 373:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 8


 374:Src/mpu6050.c **** #define AKM_REG_ST1         (0x02)
 375:Src/mpu6050.c **** #define AKM_REG_HXL         (0x03)
 376:Src/mpu6050.c **** #define AKM_REG_ST2         (0x09)
 377:Src/mpu6050.c **** 
 378:Src/mpu6050.c **** #define AKM_REG_CNTL        (0x0A)
 379:Src/mpu6050.c **** #define AKM_REG_ASTC        (0x0C)
 380:Src/mpu6050.c **** #define AKM_REG_ASAX        (0x10)
 381:Src/mpu6050.c **** #define AKM_REG_ASAY        (0x11)
 382:Src/mpu6050.c **** #define AKM_REG_ASAZ        (0x12)
 383:Src/mpu6050.c **** 
 384:Src/mpu6050.c **** #define AKM_DATA_READY      (0x01)
 385:Src/mpu6050.c **** #define AKM_DATA_OVERRUN    (0x02)
 386:Src/mpu6050.c **** #define AKM_OVERFLOW        (0x80)
 387:Src/mpu6050.c **** #define AKM_DATA_ERROR      (0x40)
 388:Src/mpu6050.c **** 
 389:Src/mpu6050.c **** #define AKM_BIT_SELF_TEST   (0x40)
 390:Src/mpu6050.c **** 
 391:Src/mpu6050.c **** #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
 392:Src/mpu6050.c **** #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
 393:Src/mpu6050.c **** #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
 394:Src/mpu6050.c **** #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
 395:Src/mpu6050.c **** 
 396:Src/mpu6050.c **** #define AKM_WHOAMI      (0x48)
 397:Src/mpu6050.c **** #endif
 398:Src/mpu6050.c **** 
 399:Src/mpu6050.c **** #if defined MPU6050
 400:Src/mpu6050.c **** const struct gyro_reg_s reg = {
 401:Src/mpu6050.c ****     .who_am_i       = 0x75,
 402:Src/mpu6050.c ****     .rate_div       = 0x19,
 403:Src/mpu6050.c ****     .lpf            = 0x1A,
 404:Src/mpu6050.c ****     .prod_id        = 0x0C,
 405:Src/mpu6050.c ****     .user_ctrl      = 0x6A,
 406:Src/mpu6050.c ****     .fifo_en        = 0x23,
 407:Src/mpu6050.c ****     .gyro_cfg       = 0x1B,
 408:Src/mpu6050.c ****     .accel_cfg      = 0x1C,
 409:Src/mpu6050.c ****     .motion_thr     = 0x1F,
 410:Src/mpu6050.c ****     .motion_dur     = 0x20,
 411:Src/mpu6050.c ****     .fifo_count_h   = 0x72,
 412:Src/mpu6050.c ****     .fifo_r_w       = 0x74,
 413:Src/mpu6050.c ****     .raw_gyro       = 0x43,
 414:Src/mpu6050.c ****     .raw_accel      = 0x3B,
 415:Src/mpu6050.c ****     .temp           = 0x41,
 416:Src/mpu6050.c ****     .int_enable     = 0x38,
 417:Src/mpu6050.c ****     .dmp_int_status = 0x39,
 418:Src/mpu6050.c ****     .int_status     = 0x3A,
 419:Src/mpu6050.c ****     .pwr_mgmt_1     = 0x6B,
 420:Src/mpu6050.c ****     .pwr_mgmt_2     = 0x6C,
 421:Src/mpu6050.c ****     .int_pin_cfg    = 0x37,
 422:Src/mpu6050.c ****     .mem_r_w        = 0x6F,
 423:Src/mpu6050.c ****     .accel_offs     = 0x06,
 424:Src/mpu6050.c ****     .i2c_mst        = 0x24,
 425:Src/mpu6050.c ****     .bank_sel       = 0x6D,
 426:Src/mpu6050.c ****     .mem_start_addr = 0x6E,
 427:Src/mpu6050.c ****     .prgm_start_h   = 0x70
 428:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 429:Src/mpu6050.c ****     ,.raw_compass   = 0x49,
 430:Src/mpu6050.c ****     .yg_offs_tc     = 0x01,
ARM GAS  /tmp/cc39PcX6.s 			page 9


 431:Src/mpu6050.c ****     .s0_addr        = 0x25,
 432:Src/mpu6050.c ****     .s0_reg         = 0x26,
 433:Src/mpu6050.c ****     .s0_ctrl        = 0x27,
 434:Src/mpu6050.c ****     .s1_addr        = 0x28,
 435:Src/mpu6050.c ****     .s1_reg         = 0x29,
 436:Src/mpu6050.c ****     .s1_ctrl        = 0x2A,
 437:Src/mpu6050.c ****     .s4_ctrl        = 0x34,
 438:Src/mpu6050.c ****     .s0_do          = 0x63,
 439:Src/mpu6050.c ****     .s1_do          = 0x64,
 440:Src/mpu6050.c ****     .i2c_delay_ctrl = 0x67
 441:Src/mpu6050.c **** #endif
 442:Src/mpu6050.c **** };
 443:Src/mpu6050.c **** const struct hw_s hw = {
 444:Src/mpu6050.c ****     .addr           = 0x68,
 445:Src/mpu6050.c ****     .max_fifo       = 1024,
 446:Src/mpu6050.c ****     .num_reg        = 118,
 447:Src/mpu6050.c ****     .temp_sens      = 340,
 448:Src/mpu6050.c ****     .temp_offset    = -521,
 449:Src/mpu6050.c ****     .bank_size      = 256
 450:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 451:Src/mpu6050.c ****     ,.compass_fsr    = AK89xx_FSR
 452:Src/mpu6050.c **** #endif
 453:Src/mpu6050.c **** };
 454:Src/mpu6050.c **** 
 455:Src/mpu6050.c **** const struct test_s test = {
 456:Src/mpu6050.c ****     .gyro_sens      = 32768/250,
 457:Src/mpu6050.c ****     .accel_sens     = 32768/16,
 458:Src/mpu6050.c ****     .reg_rate_div   = 0,    /* 1kHz. */
 459:Src/mpu6050.c ****     .reg_lpf        = 1,    /* 188Hz. */
 460:Src/mpu6050.c ****     .reg_gyro_fsr   = 0,    /* 250dps. */
 461:Src/mpu6050.c ****     .reg_accel_fsr  = 0x18, /* 16g. */
 462:Src/mpu6050.c ****     .wait_ms        = 50,
 463:Src/mpu6050.c ****     .packet_thresh  = 5,    /* 5% */
 464:Src/mpu6050.c ****     .min_dps        = 10.f,
 465:Src/mpu6050.c ****     .max_dps        = 105.f,
 466:Src/mpu6050.c ****     .max_gyro_var   = 0.14f,
 467:Src/mpu6050.c ****     .min_g          = 0.3f,
 468:Src/mpu6050.c ****     .max_g          = 0.95f,
 469:Src/mpu6050.c ****     .max_accel_var  = 0.14f
 470:Src/mpu6050.c **** };
 471:Src/mpu6050.c **** 
 472:Src/mpu6050.c **** static struct gyro_state_s st = {
 473:Src/mpu6050.c ****     .reg = &reg,
 474:Src/mpu6050.c ****     .hw = &hw,
 475:Src/mpu6050.c ****     .test = &test
 476:Src/mpu6050.c **** };
 477:Src/mpu6050.c **** #elif defined MPU6500
 478:Src/mpu6050.c **** const struct gyro_reg_s reg = {
 479:Src/mpu6050.c ****     .who_am_i       = 0x75,
 480:Src/mpu6050.c ****     .rate_div       = 0x19,
 481:Src/mpu6050.c ****     .lpf            = 0x1A,
 482:Src/mpu6050.c ****     .prod_id        = 0x0C,
 483:Src/mpu6050.c ****     .user_ctrl      = 0x6A,
 484:Src/mpu6050.c ****     .fifo_en        = 0x23,
 485:Src/mpu6050.c ****     .gyro_cfg       = 0x1B,
 486:Src/mpu6050.c ****     .accel_cfg      = 0x1C,
 487:Src/mpu6050.c ****     .accel_cfg2     = 0x1D,
ARM GAS  /tmp/cc39PcX6.s 			page 10


 488:Src/mpu6050.c ****     .lp_accel_odr   = 0x1E,
 489:Src/mpu6050.c ****     .motion_thr     = 0x1F,
 490:Src/mpu6050.c ****     .motion_dur     = 0x20,
 491:Src/mpu6050.c ****     .fifo_count_h   = 0x72,
 492:Src/mpu6050.c ****     .fifo_r_w       = 0x74,
 493:Src/mpu6050.c ****     .raw_gyro       = 0x43,
 494:Src/mpu6050.c ****     .raw_accel      = 0x3B,
 495:Src/mpu6050.c ****     .temp           = 0x41,
 496:Src/mpu6050.c ****     .int_enable     = 0x38,
 497:Src/mpu6050.c ****     .dmp_int_status = 0x39,
 498:Src/mpu6050.c ****     .int_status     = 0x3A,
 499:Src/mpu6050.c ****     .accel_intel    = 0x69,
 500:Src/mpu6050.c ****     .pwr_mgmt_1     = 0x6B,
 501:Src/mpu6050.c ****     .pwr_mgmt_2     = 0x6C,
 502:Src/mpu6050.c ****     .int_pin_cfg    = 0x37,
 503:Src/mpu6050.c ****     .mem_r_w        = 0x6F,
 504:Src/mpu6050.c ****     .accel_offs     = 0x77,
 505:Src/mpu6050.c ****     .i2c_mst        = 0x24,
 506:Src/mpu6050.c ****     .bank_sel       = 0x6D,
 507:Src/mpu6050.c ****     .mem_start_addr = 0x6E,
 508:Src/mpu6050.c ****     .prgm_start_h   = 0x70
 509:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 510:Src/mpu6050.c ****     ,.raw_compass   = 0x49,
 511:Src/mpu6050.c ****     .s0_addr        = 0x25,
 512:Src/mpu6050.c ****     .s0_reg         = 0x26,
 513:Src/mpu6050.c ****     .s0_ctrl        = 0x27,
 514:Src/mpu6050.c ****     .s1_addr        = 0x28,
 515:Src/mpu6050.c ****     .s1_reg         = 0x29,
 516:Src/mpu6050.c ****     .s1_ctrl        = 0x2A,
 517:Src/mpu6050.c ****     .s4_ctrl        = 0x34,
 518:Src/mpu6050.c ****     .s0_do          = 0x63,
 519:Src/mpu6050.c ****     .s1_do          = 0x64,
 520:Src/mpu6050.c ****     .i2c_delay_ctrl = 0x67
 521:Src/mpu6050.c **** #endif
 522:Src/mpu6050.c **** };
 523:Src/mpu6050.c **** const struct hw_s hw = {
 524:Src/mpu6050.c ****     .addr           = 0x68,
 525:Src/mpu6050.c ****     .max_fifo       = 1024,
 526:Src/mpu6050.c ****     .num_reg        = 128,
 527:Src/mpu6050.c ****     .temp_sens      = 321,
 528:Src/mpu6050.c ****     .temp_offset    = 0,
 529:Src/mpu6050.c ****     .bank_size      = 256
 530:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 531:Src/mpu6050.c ****     ,.compass_fsr    = AK89xx_FSR
 532:Src/mpu6050.c **** #endif
 533:Src/mpu6050.c **** };
 534:Src/mpu6050.c **** 
 535:Src/mpu6050.c **** const struct test_s test = {
 536:Src/mpu6050.c ****     .gyro_sens      = 32768/250,
 537:Src/mpu6050.c ****     .accel_sens     = 32768/2,  	    // FSR = +-2G = 16384 LSB/G
 538:Src/mpu6050.c ****     .reg_rate_div   = 0,    			// 1kHz.
 539:Src/mpu6050.c ****     .reg_lpf        = 2,    			// 92Hz low pass filter
 540:Src/mpu6050.c ****     .reg_gyro_fsr   = 0,    			// 250dps.
 541:Src/mpu6050.c ****     .reg_accel_fsr  = 0x0,  			// Accel FSR setting = 2g.
 542:Src/mpu6050.c ****     .wait_ms        = 200,   			// 200ms stabilization time
 543:Src/mpu6050.c ****     .packet_thresh  = 200,    		    // 200 samples
 544:Src/mpu6050.c ****     .min_dps        = 20.f,  			// 20 dps for Gyro Criteria C
ARM GAS  /tmp/cc39PcX6.s 			page 11


 545:Src/mpu6050.c ****     .max_dps        = 60.f, 			// Must exceed 60 dps threshold for Gyro Criteria B
 546:Src/mpu6050.c ****     .max_gyro_var   = .5f, 				// Must exceed +50% variation for Gyro Criteria A
 547:Src/mpu6050.c ****     .min_g          = .225f, 			// Accel must exceed Min 225 mg for Criteria B
 548:Src/mpu6050.c ****     .max_g          = .675f, 			// Accel cannot exceed Max 675 mg for Criteria B
 549:Src/mpu6050.c ****     .max_accel_var  = .5f,  			// Accel must be within 50% variation for Criteria A
 550:Src/mpu6050.c ****     .max_g_offset   = .5f,   			// 500 mg for Accel Criteria C
 551:Src/mpu6050.c ****     .sample_wait_ms = 10    			// 10ms sample time wait
 552:Src/mpu6050.c **** };
 553:Src/mpu6050.c **** 
 554:Src/mpu6050.c **** static struct gyro_state_s st = {
 555:Src/mpu6050.c ****     .reg = &reg,
 556:Src/mpu6050.c ****     .hw = &hw,
 557:Src/mpu6050.c ****     .test = &test
 558:Src/mpu6050.c **** };
 559:Src/mpu6050.c **** #endif
 560:Src/mpu6050.c **** 
 561:Src/mpu6050.c **** #define MAX_PACKET_LENGTH (12)
 562:Src/mpu6050.c **** #ifdef MPU6500
 563:Src/mpu6050.c **** #define HWST_MAX_PACKET_LENGTH (512)
 564:Src/mpu6050.c **** #endif
 565:Src/mpu6050.c **** 
 566:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 567:Src/mpu6050.c **** static int setup_compass(void);
 568:Src/mpu6050.c **** #define MAX_COMPASS_SAMPLE_RATE (100)
 569:Src/mpu6050.c **** #endif
 570:Src/mpu6050.c **** 
 571:Src/mpu6050.c **** /**
 572:Src/mpu6050.c ****  *  @brief      Enable/disable data ready interrupt.
 573:Src/mpu6050.c ****  *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready interrupt is used.
 574:Src/mpu6050.c ****  *  @param[in]  enable      1 to enable interrupt.
 575:Src/mpu6050.c ****  *  @return     0 if successful.
 576:Src/mpu6050.c ****  */
 577:Src/mpu6050.c **** static int set_int_enable(unsigned char enable)
 578:Src/mpu6050.c **** {
 579:Src/mpu6050.c ****     unsigned char tmp;
 580:Src/mpu6050.c **** 
 581:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
 582:Src/mpu6050.c ****         if (enable)
 583:Src/mpu6050.c ****             tmp = BIT_DMP_INT_EN;
 584:Src/mpu6050.c ****         else
 585:Src/mpu6050.c ****             tmp = 0x00;
 586:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 587:Src/mpu6050.c ****             return -1;
 588:Src/mpu6050.c ****         st.chip_cfg.int_enable = tmp;
 589:Src/mpu6050.c ****     } else {
 590:Src/mpu6050.c ****         if (!st.chip_cfg.sensors)
 591:Src/mpu6050.c ****             return -1;
 592:Src/mpu6050.c ****         if (enable && st.chip_cfg.int_enable)
 593:Src/mpu6050.c ****             return 0;
 594:Src/mpu6050.c ****         if (enable)
 595:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 596:Src/mpu6050.c ****         else
 597:Src/mpu6050.c ****             tmp = 0x00;
 598:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 599:Src/mpu6050.c ****             return -1;
 600:Src/mpu6050.c ****         st.chip_cfg.int_enable = tmp;
 601:Src/mpu6050.c ****     }
ARM GAS  /tmp/cc39PcX6.s 			page 12


 602:Src/mpu6050.c ****     return 0;
 603:Src/mpu6050.c **** }
 604:Src/mpu6050.c **** 
 605:Src/mpu6050.c **** /**
 606:Src/mpu6050.c ****  *  @brief      Register dump for testing.
 607:Src/mpu6050.c ****  *  @return     0 if successful.
 608:Src/mpu6050.c ****  */
 609:Src/mpu6050.c **** int mpu_reg_dump(void)
 610:Src/mpu6050.c **** {
 611:Src/mpu6050.c ****     unsigned char ii;
 612:Src/mpu6050.c ****     unsigned char data;
 613:Src/mpu6050.c **** 
 614:Src/mpu6050.c ****     for (ii = 0; ii < st.hw->num_reg; ii++) {
 615:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 616:Src/mpu6050.c ****             continue;
 617:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, ii, 1, &data))
 618:Src/mpu6050.c ****             return -1;
 619:Src/mpu6050.c ****             #ifdef SERIAL_DEBUG
 620:Src/mpu6050.c ****                 log_i("%#5x: %#5x\r\n", ii, data);
 621:Src/mpu6050.c ****             #endif
 622:Src/mpu6050.c ****     }
 623:Src/mpu6050.c ****     return 0;
 624:Src/mpu6050.c **** }
 625:Src/mpu6050.c **** 
 626:Src/mpu6050.c **** /**
 627:Src/mpu6050.c ****  *  @brief      Read from a single register.
 628:Src/mpu6050.c ****  *  NOTE: The memory and FIFO read/write registers cannot be accessed.
 629:Src/mpu6050.c ****  *  @param[in]  reg     Register address.
 630:Src/mpu6050.c ****  *  @param[out] data    Register data.
 631:Src/mpu6050.c ****  *  @return     0 if successful.
 632:Src/mpu6050.c ****  */
 633:Src/mpu6050.c **** int mpu_read_reg(unsigned char reg, unsigned char *data)
 634:Src/mpu6050.c **** {
 635:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 636:Src/mpu6050.c ****         return -1;
 637:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 638:Src/mpu6050.c ****         return -1;
 639:Src/mpu6050.c ****     return i2c_read(st.hw->addr, reg, 1, data);
 640:Src/mpu6050.c **** }
 641:Src/mpu6050.c **** 
 642:Src/mpu6050.c **** /**
 643:Src/mpu6050.c ****  *  @brief      Initialize hardware.
 644:Src/mpu6050.c ****  *  Initial configuration:\n
 645:Src/mpu6050.c ****  *  Gyro FSR: +/- 2000DPS\n
 646:Src/mpu6050.c ****  *  Accel FSR +/- 2G\n
 647:Src/mpu6050.c ****  *  DLPF: 42Hz\n
 648:Src/mpu6050.c ****  *  FIFO rate: 50Hz\n
 649:Src/mpu6050.c ****  *  Clock source: Gyro PLL\n
 650:Src/mpu6050.c ****  *  FIFO: Disabled.\n
 651:Src/mpu6050.c ****  *  Data ready interrupt: Disabled, active low, unlatched.
 652:Src/mpu6050.c ****  *  @param[in]  int_param   Platform-specific parameters to interrupt API.
 653:Src/mpu6050.c ****  *  @return     0 if successful.
 654:Src/mpu6050.c ****  */
 655:Src/mpu6050.c **** int mpu_init(void)
 656:Src/mpu6050.c **** {
 657:Src/mpu6050.c ****     unsigned char data[6];
 658:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 13


 659:Src/mpu6050.c ****     /* Reset device. */
 660:Src/mpu6050.c ****     data[0] = BIT_RESET;
 661:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 662:Src/mpu6050.c ****         return -1;
 663:Src/mpu6050.c ****     delay_ms(100);
 664:Src/mpu6050.c **** 
 665:Src/mpu6050.c ****     /* Wake up chip. */
 666:Src/mpu6050.c ****     data[0] = 0x00;
 667:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 668:Src/mpu6050.c ****         return -1;
 669:Src/mpu6050.c **** 
 670:Src/mpu6050.c ****    st.chip_cfg.accel_half = 0;
 671:Src/mpu6050.c **** 
 672:Src/mpu6050.c **** #ifdef MPU6500
 673:Src/mpu6050.c ****     /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
 674:Src/mpu6050.c ****      * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
 675:Src/mpu6050.c ****      */
 676:Src/mpu6050.c ****     data[0] = BIT_FIFO_SIZE_1024 | 0x8;
 677:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
 678:Src/mpu6050.c ****         return -1;
 679:Src/mpu6050.c **** #endif
 680:Src/mpu6050.c **** 
 681:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
 682:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 683:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 684:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 685:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 686:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 687:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 688:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 689:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 690:Src/mpu6050.c ****     st.chip_cfg.compass_sample_rate = 0xFFFF;
 691:Src/mpu6050.c **** #endif
 692:Src/mpu6050.c ****     /* mpu_set_sensors always preserves this setting. */
 693:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 694:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 695:Src/mpu6050.c ****     st.chip_cfg.active_low_int = 1;
 696:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 697:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 698:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 699:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 700:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 701:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 702:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = 0;
 703:Src/mpu6050.c **** 
 704:Src/mpu6050.c ****     if (mpu_set_gyro_fsr(MPU_GYRO_FSR))
 705:Src/mpu6050.c ****         return -1;
 706:Src/mpu6050.c ****     if (mpu_set_accel_fsr(MPU_ACCEL_FSR))
 707:Src/mpu6050.c ****         return -1;
 708:Src/mpu6050.c ****     if (mpu_set_lpf(42))
 709:Src/mpu6050.c ****         return -1;
 710:Src/mpu6050.c ****     if (mpu_set_sample_rate(50))
 711:Src/mpu6050.c ****         return -1;
 712:Src/mpu6050.c ****     if (mpu_configure_fifo(0))
 713:Src/mpu6050.c ****         return -1;
 714:Src/mpu6050.c **** 
 715:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
ARM GAS  /tmp/cc39PcX6.s 			page 14


 716:Src/mpu6050.c ****     setup_compass();
 717:Src/mpu6050.c ****     if (mpu_set_compass_sample_rate(10))
 718:Src/mpu6050.c ****         return -1;
 719:Src/mpu6050.c **** #else
 720:Src/mpu6050.c ****     /* Already disabled by setup_compass. */
 721:Src/mpu6050.c ****     if (mpu_set_bypass(0))
 722:Src/mpu6050.c ****         return -1;
 723:Src/mpu6050.c **** #endif
 724:Src/mpu6050.c **** 
 725:Src/mpu6050.c ****     mpu_set_sensors(0);
 726:Src/mpu6050.c ****     return 0;
 727:Src/mpu6050.c **** }
 728:Src/mpu6050.c **** 
 729:Src/mpu6050.c **** /**
 730:Src/mpu6050.c ****  *  @brief      Enter low-power accel-only mode.
 731:Src/mpu6050.c ****  *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
 732:Src/mpu6050.c ****  *  the accelerometer at one of the following frequencies:
 733:Src/mpu6050.c ****  *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
 734:Src/mpu6050.c ****  *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
 735:Src/mpu6050.c ****  *  \n If the requested rate is not one listed above, the device will be set to
 736:Src/mpu6050.c ****  *  the next highest rate. Requesting a rate above the maximum supported
 737:Src/mpu6050.c ****  *  frequency will result in an error.
 738:Src/mpu6050.c ****  *  \n To select a fractional wake-up frequency, round down the value passed to
 739:Src/mpu6050.c ****  *  @e rate.
 740:Src/mpu6050.c ****  *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
 741:Src/mpu6050.c ****  *                          accel mode.
 742:Src/mpu6050.c ****  *  @return     0 if successful.
 743:Src/mpu6050.c ****  */
 744:Src/mpu6050.c **** int mpu_lp_accel_mode(unsigned short rate)
 745:Src/mpu6050.c **** {
 746:Src/mpu6050.c ****     unsigned char tmp[2];
 747:Src/mpu6050.c **** 
 748:Src/mpu6050.c ****     if (rate > 40)
 749:Src/mpu6050.c ****         return -1;
 750:Src/mpu6050.c **** 
 751:Src/mpu6050.c ****     if (!rate) {
 752:Src/mpu6050.c ****         mpu_set_int_latched(0);
 753:Src/mpu6050.c ****         tmp[0] = 0;
 754:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 755:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 756:Src/mpu6050.c ****             return -1;
 757:Src/mpu6050.c ****         st.chip_cfg.lp_accel_mode = 0;
 758:Src/mpu6050.c ****         return 0;
 759:Src/mpu6050.c ****     }
 760:Src/mpu6050.c ****     /* For LP accel, we automatically configure the hardware to produce latched
 761:Src/mpu6050.c ****      * interrupts. In LP accel mode, the hardware cycles into sleep mode before
 762:Src/mpu6050.c ****      * it gets a chance to deassert the interrupt pin; therefore, we shift this
 763:Src/mpu6050.c ****      * responsibility over to the MCU.
 764:Src/mpu6050.c ****      *
 765:Src/mpu6050.c ****      * Any register read will clear the interrupt.
 766:Src/mpu6050.c ****      */
 767:Src/mpu6050.c ****     mpu_set_int_latched(1);
 768:Src/mpu6050.c **** #if defined MPU6050
 769:Src/mpu6050.c ****     tmp[0] = BIT_LPA_CYCLE;
 770:Src/mpu6050.c ****     if (rate == 1) {
 771:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 772:Src/mpu6050.c ****         mpu_set_lpf(5);
ARM GAS  /tmp/cc39PcX6.s 			page 15


 773:Src/mpu6050.c ****     } else if (rate <= 5) {
 774:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 775:Src/mpu6050.c ****         mpu_set_lpf(5);
 776:Src/mpu6050.c ****     } else if (rate <= 20) {
 777:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 778:Src/mpu6050.c ****         mpu_set_lpf(10);
 779:Src/mpu6050.c ****     } else {
 780:Src/mpu6050.c ****         tmp[1] = INV_LPA_40HZ;
 781:Src/mpu6050.c ****         mpu_set_lpf(20);
 782:Src/mpu6050.c ****     }
 783:Src/mpu6050.c ****     tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
 784:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 785:Src/mpu6050.c ****         return -1;
 786:Src/mpu6050.c **** #elif defined MPU6500
 787:Src/mpu6050.c ****     /* Set wake frequency. */
 788:Src/mpu6050.c ****     if (rate == 1)
 789:Src/mpu6050.c ****         tmp[0] = INV_LPA_1_25HZ;
 790:Src/mpu6050.c ****     else if (rate == 2)
 791:Src/mpu6050.c ****         tmp[0] = INV_LPA_2_5HZ;
 792:Src/mpu6050.c ****     else if (rate <= 5)
 793:Src/mpu6050.c ****         tmp[0] = INV_LPA_5HZ;
 794:Src/mpu6050.c ****     else if (rate <= 10)
 795:Src/mpu6050.c ****         tmp[0] = INV_LPA_10HZ;
 796:Src/mpu6050.c ****     else if (rate <= 20)
 797:Src/mpu6050.c ****         tmp[0] = INV_LPA_20HZ;
 798:Src/mpu6050.c ****     else if (rate <= 40)
 799:Src/mpu6050.c ****         tmp[0] = INV_LPA_40HZ;
 800:Src/mpu6050.c ****     else if (rate <= 80)
 801:Src/mpu6050.c ****         tmp[0] = INV_LPA_80HZ;
 802:Src/mpu6050.c ****     else if (rate <= 160)
 803:Src/mpu6050.c ****         tmp[0] = INV_LPA_160HZ;
 804:Src/mpu6050.c ****     else if (rate <= 320)
 805:Src/mpu6050.c ****         tmp[0] = INV_LPA_320HZ;
 806:Src/mpu6050.c ****     else
 807:Src/mpu6050.c ****         tmp[0] = INV_LPA_640HZ;
 808:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
 809:Src/mpu6050.c ****         return -1;
 810:Src/mpu6050.c ****     tmp[0] = BIT_LPA_CYCLE;
 811:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
 812:Src/mpu6050.c ****         return -1;
 813:Src/mpu6050.c **** #endif
 814:Src/mpu6050.c ****     st.chip_cfg.sensors = INV_XYZ_ACCEL;
 815:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 816:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 817:Src/mpu6050.c ****     mpu_configure_fifo(0);
 818:Src/mpu6050.c **** 
 819:Src/mpu6050.c ****     return 0;
 820:Src/mpu6050.c **** }
 821:Src/mpu6050.c **** 
 822:Src/mpu6050.c **** /**
 823:Src/mpu6050.c ****  *  @brief      Read raw gyro data directly from the registers.
 824:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
 825:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 826:Src/mpu6050.c ****  *  @return     0 if successful.
 827:Src/mpu6050.c ****  */
 828:Src/mpu6050.c **** int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
 829:Src/mpu6050.c **** {
ARM GAS  /tmp/cc39PcX6.s 			page 16


 830:Src/mpu6050.c ****     unsigned char tmp[6];
 831:Src/mpu6050.c **** 
 832:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
 833:Src/mpu6050.c ****         return -1;
 834:Src/mpu6050.c **** 
 835:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
 836:Src/mpu6050.c ****         return -1;
 837:Src/mpu6050.c ****     data[0] = (tmp[0] << 8) | tmp[1];
 838:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 839:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 840:Src/mpu6050.c ****     if (timestamp)
 841:Src/mpu6050.c ****         get_ms(timestamp);
 842:Src/mpu6050.c ****     return 0;
 843:Src/mpu6050.c **** }
 844:Src/mpu6050.c **** 
 845:Src/mpu6050.c **** /**
 846:Src/mpu6050.c ****  *  @brief      Read raw accel data directly from the registers.
 847:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
 848:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 849:Src/mpu6050.c ****  *  @return     0 if successful.
 850:Src/mpu6050.c ****  */
 851:Src/mpu6050.c **** int mpu_get_accel_reg(short *data, unsigned long *timestamp)
 852:Src/mpu6050.c **** {
 853:Src/mpu6050.c ****     unsigned char tmp[6];
 854:Src/mpu6050.c **** 
 855:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
 856:Src/mpu6050.c ****         return -1;
 857:Src/mpu6050.c **** 
 858:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
 859:Src/mpu6050.c ****         return -1;
 860:Src/mpu6050.c ****     data[0] = (tmp[0] << 8) | tmp[1];
 861:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 862:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 863:Src/mpu6050.c ****     if (timestamp)
 864:Src/mpu6050.c ****         get_ms(timestamp);
 865:Src/mpu6050.c ****     return 0;
 866:Src/mpu6050.c **** }
 867:Src/mpu6050.c **** 
 868:Src/mpu6050.c **** /**
 869:Src/mpu6050.c ****  *  @brief      Read temperature data directly from the registers.
 870:Src/mpu6050.c ****  *  @param[out] data        Data in q16 format.
 871:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 872:Src/mpu6050.c ****  *  @return     0 if successful.
 873:Src/mpu6050.c ****  */
 874:Src/mpu6050.c **** int mpu_get_temperature(long *data, unsigned long *timestamp)
 875:Src/mpu6050.c **** {
 876:Src/mpu6050.c ****     unsigned char tmp[2];
 877:Src/mpu6050.c ****     short raw;
 878:Src/mpu6050.c **** 
 879:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
 880:Src/mpu6050.c ****         return -1;
 881:Src/mpu6050.c **** 
 882:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
 883:Src/mpu6050.c ****         return -1;
 884:Src/mpu6050.c ****     raw = (tmp[0] << 8) | tmp[1];
 885:Src/mpu6050.c ****     if (timestamp)
 886:Src/mpu6050.c ****         get_ms(timestamp);
ARM GAS  /tmp/cc39PcX6.s 			page 17


 887:Src/mpu6050.c **** 
 888:Src/mpu6050.c ****     data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
 889:Src/mpu6050.c ****     return 0;
 890:Src/mpu6050.c **** }
 891:Src/mpu6050.c **** 
 892:Src/mpu6050.c **** /**
 893:Src/mpu6050.c ****  *  @brief      Read biases to the accel bias 6500 registers.
 894:Src/mpu6050.c ****  *  This function reads from the MPU6500 accel offset cancellations registers.
 895:Src/mpu6050.c ****  *  The format are G in +-8G format. The register is initialized with OTP 
 896:Src/mpu6050.c ****  *  factory trim values.
 897:Src/mpu6050.c ****  *  @param[in]  accel_bias  returned structure with the accel bias
 898:Src/mpu6050.c ****  *  @return     0 if successful.
 899:Src/mpu6050.c ****  */
 900:Src/mpu6050.c **** int mpu_read_6500_accel_bias(long *accel_bias) {
 901:Src/mpu6050.c ****     unsigned char data[6];
 902:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
 903:Src/mpu6050.c ****         return -1;
 904:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
 905:Src/mpu6050.c ****         return -1;
 906:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7D, 2, &data[4]))
 907:Src/mpu6050.c ****         return -1;
 908:Src/mpu6050.c ****     accel_bias[0] = ((long)data[0]<<8) | data[1];
 909:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 910:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 911:Src/mpu6050.c ****     return 0;
 912:Src/mpu6050.c **** }
 913:Src/mpu6050.c **** 
 914:Src/mpu6050.c **** /**
 915:Src/mpu6050.c ****  *  @brief      Read biases to the accel bias 6050 registers.
 916:Src/mpu6050.c ****  *  This function reads from the MPU6050 accel offset cancellations registers.
 917:Src/mpu6050.c ****  *  The format are G in +-8G format. The register is initialized with OTP 
 918:Src/mpu6050.c ****  *  factory trim values.
 919:Src/mpu6050.c ****  *  @param[in]  accel_bias  returned structure with the accel bias
 920:Src/mpu6050.c ****  *  @return     0 if successful.
 921:Src/mpu6050.c ****  */
 922:Src/mpu6050.c **** int mpu_read_6050_accel_bias(long *accel_bias) {
 923:Src/mpu6050.c ****     unsigned char data[6];
 924:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
 925:Src/mpu6050.c ****         return -1;
 926:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
 927:Src/mpu6050.c ****         return -1;
 928:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0A, 2, &data[4]))
 929:Src/mpu6050.c ****         return -1;
 930:Src/mpu6050.c ****     accel_bias[0] = ((long)data[0]<<8) | data[1];
 931:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 932:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 933:Src/mpu6050.c ****     return 0;
 934:Src/mpu6050.c **** }
 935:Src/mpu6050.c **** 
 936:Src/mpu6050.c **** int mpu_read_6500_gyro_bias(long *gyro_bias) {
 937:Src/mpu6050.c ****     unsigned char data[6];
 938:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
 939:Src/mpu6050.c ****         return -1;
 940:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
 941:Src/mpu6050.c ****         return -1;
 942:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x17, 2, &data[4]))
 943:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 18


 944:Src/mpu6050.c ****     gyro_bias[0] = ((long)data[0]<<8) | data[1];
 945:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 946:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 947:Src/mpu6050.c ****     return 0;
 948:Src/mpu6050.c **** }
 949:Src/mpu6050.c **** 
 950:Src/mpu6050.c **** /**
 951:Src/mpu6050.c ****  *  @brief      Push biases to the gyro bias 6500/6050 registers.
 952:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
 953:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
 954:Src/mpu6050.c ****  *  in +-1000dps format.
 955:Src/mpu6050.c ****  *  @param[in]  gyro_bias  New biases.
 956:Src/mpu6050.c ****  *  @return     0 if successful.
 957:Src/mpu6050.c ****  */
 958:Src/mpu6050.c **** int mpu_set_gyro_bias_reg(long *gyro_bias)
 959:Src/mpu6050.c **** {
 960:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 961:Src/mpu6050.c ****     int i=0;
 962:Src/mpu6050.c ****     for(i=0;i<3;i++) {
 963:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 964:Src/mpu6050.c ****     }
 965:Src/mpu6050.c ****     data[0] = (gyro_bias[0] >> 8) & 0xff;
 966:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 967:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 968:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 969:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 970:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 971:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 972:Src/mpu6050.c ****         return -1;
 973:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
 974:Src/mpu6050.c ****         return -1;
 975:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x17, 2, &data[4]))
 976:Src/mpu6050.c ****         return -1;
 977:Src/mpu6050.c ****     return 0;
 978:Src/mpu6050.c **** }
 979:Src/mpu6050.c **** 
 980:Src/mpu6050.c **** /**
 981:Src/mpu6050.c ****  *  @brief      Push biases to the accel bias 6050 registers.
 982:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
 983:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
 984:Src/mpu6050.c ****  *  in +-16G format.
 985:Src/mpu6050.c ****  *  @param[in]  accel_bias  New biases.
 986:Src/mpu6050.c ****  *  @return     0 if successful.
 987:Src/mpu6050.c ****  */
 988:Src/mpu6050.c **** int mpu_set_accel_bias_6050_reg(const long *accel_bias) {
 989:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 990:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 991:Src/mpu6050.c **** 
 992:Src/mpu6050.c ****     if(mpu_read_6050_accel_bias(accel_reg_bias))
 993:Src/mpu6050.c ****         return -1;
 994:Src/mpu6050.c **** 
 995:Src/mpu6050.c ****     accel_reg_bias[0] -= (accel_bias[0] & ~1);
 996:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 997:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 998:Src/mpu6050.c **** 
 999:Src/mpu6050.c ****     data[0] = (accel_reg_bias[0] >> 8) & 0xff;
1000:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
ARM GAS  /tmp/cc39PcX6.s 			page 19


1001:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
1002:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
1003:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
1004:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
1005:Src/mpu6050.c **** 
1006:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x06, 2, &data[0]))
1007:Src/mpu6050.c ****         return -1;
1008:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x08, 2, &data[2]))
1009:Src/mpu6050.c ****         return -1;
1010:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x0A, 2, &data[4]))
1011:Src/mpu6050.c ****         return -1;
1012:Src/mpu6050.c **** 
1013:Src/mpu6050.c ****     return 0;
1014:Src/mpu6050.c **** }
1015:Src/mpu6050.c **** 
1016:Src/mpu6050.c **** 
1017:Src/mpu6050.c **** 
1018:Src/mpu6050.c **** /**
1019:Src/mpu6050.c ****  *  @brief      Push biases to the accel bias 6500 registers.
1020:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
1021:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
1022:Src/mpu6050.c ****  *  in +-16G format.
1023:Src/mpu6050.c ****  *  @param[in]  accel_bias  New biases.
1024:Src/mpu6050.c ****  *  @return     0 if successful.
1025:Src/mpu6050.c ****  */
1026:Src/mpu6050.c **** int mpu_set_accel_bias_6500_reg(const long *accel_bias) {
1027:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
1028:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
1029:Src/mpu6050.c **** 
1030:Src/mpu6050.c ****     if(mpu_read_6500_accel_bias(accel_reg_bias))
1031:Src/mpu6050.c ****         return -1;
1032:Src/mpu6050.c **** 
1033:Src/mpu6050.c ****     // Preserve bit 0 of factory value (for temperature compensation)
1034:Src/mpu6050.c ****     accel_reg_bias[0] -= (accel_bias[0] & ~1);
1035:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
1036:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
1037:Src/mpu6050.c **** 
1038:Src/mpu6050.c ****     data[0] = (accel_reg_bias[0] >> 8) & 0xff;
1039:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
1040:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
1041:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
1042:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
1043:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
1044:Src/mpu6050.c **** 
1045:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x77, 2, &data[0]))
1046:Src/mpu6050.c ****         return -1;
1047:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x7A, 2, &data[2]))
1048:Src/mpu6050.c ****         return -1;
1049:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x7D, 2, &data[4]))
1050:Src/mpu6050.c ****         return -1;
1051:Src/mpu6050.c **** 
1052:Src/mpu6050.c ****     return 0;
1053:Src/mpu6050.c **** }
1054:Src/mpu6050.c **** 
1055:Src/mpu6050.c **** 
1056:Src/mpu6050.c **** /**
1057:Src/mpu6050.c ****  *  @brief  Reset FIFO read/write pointers.
ARM GAS  /tmp/cc39PcX6.s 			page 20


1058:Src/mpu6050.c ****  *  @return 0 if successful.
1059:Src/mpu6050.c ****  */
1060:Src/mpu6050.c **** int mpu_reset_fifo(void)
1061:Src/mpu6050.c **** {
1062:Src/mpu6050.c ****     unsigned char data;
1063:Src/mpu6050.c **** 
1064:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1065:Src/mpu6050.c ****         return -1;
1066:Src/mpu6050.c **** 
1067:Src/mpu6050.c ****     data = 0;
1068:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1069:Src/mpu6050.c ****         return -1;
1070:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
1071:Src/mpu6050.c ****         return -1;
1072:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1073:Src/mpu6050.c ****         return -1;
1074:Src/mpu6050.c **** 
1075:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
1076:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
1077:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1078:Src/mpu6050.c ****             return -1;
1079:Src/mpu6050.c ****         delay_ms(50);
1080:Src/mpu6050.c ****         data = BIT_DMP_EN | BIT_FIFO_EN;
1081:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1082:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
1083:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1084:Src/mpu6050.c ****             return -1;
1085:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
1086:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
1087:Src/mpu6050.c ****         else
1088:Src/mpu6050.c ****             data = 0;
1089:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1090:Src/mpu6050.c ****             return -1;
1091:Src/mpu6050.c ****         data = 0;
1092:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
1093:Src/mpu6050.c ****             return -1;
1094:Src/mpu6050.c ****     } else {
1095:Src/mpu6050.c ****         data = BIT_FIFO_RST;
1096:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1097:Src/mpu6050.c ****             return -1;
1098:Src/mpu6050.c ****         if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
1099:Src/mpu6050.c ****             data = BIT_FIFO_EN;
1100:Src/mpu6050.c ****         else
1101:Src/mpu6050.c ****             data = BIT_FIFO_EN | BIT_AUX_IF_EN;
1102:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1103:Src/mpu6050.c ****             return -1;
1104:Src/mpu6050.c ****         delay_ms(50);
1105:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
1106:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
1107:Src/mpu6050.c ****         else
1108:Src/mpu6050.c ****             data = 0;
1109:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1110:Src/mpu6050.c ****             return -1;
1111:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
1112:Src/mpu6050.c ****             return -1;
1113:Src/mpu6050.c ****     }
1114:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/cc39PcX6.s 			page 21


1115:Src/mpu6050.c **** }
1116:Src/mpu6050.c **** 
1117:Src/mpu6050.c **** /**
1118:Src/mpu6050.c ****  *  @brief      Get the gyro full-scale range.
1119:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
1120:Src/mpu6050.c ****  *  @return     0 if successful.
1121:Src/mpu6050.c ****  */
1122:Src/mpu6050.c **** int mpu_get_gyro_fsr(unsigned short *fsr)
1123:Src/mpu6050.c **** {
1124:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
1125:Src/mpu6050.c ****     case INV_FSR_250DPS:
1126:Src/mpu6050.c ****         fsr[0] = 250;
1127:Src/mpu6050.c ****         break;
1128:Src/mpu6050.c ****     case INV_FSR_500DPS:
1129:Src/mpu6050.c ****         fsr[0] = 500;
1130:Src/mpu6050.c ****         break;
1131:Src/mpu6050.c ****     case INV_FSR_1000DPS:
1132:Src/mpu6050.c ****         fsr[0] = 1000;
1133:Src/mpu6050.c ****         break;
1134:Src/mpu6050.c ****     case INV_FSR_2000DPS:
1135:Src/mpu6050.c ****         fsr[0] = 2000;
1136:Src/mpu6050.c ****         break;
1137:Src/mpu6050.c ****     default:
1138:Src/mpu6050.c ****         fsr[0] = 0;
1139:Src/mpu6050.c ****         break;
1140:Src/mpu6050.c ****     }
1141:Src/mpu6050.c ****     return 0;
1142:Src/mpu6050.c **** }
1143:Src/mpu6050.c **** 
1144:Src/mpu6050.c **** /**
1145:Src/mpu6050.c ****  *  @brief      Set the gyro full-scale range.
1146:Src/mpu6050.c ****  *  @param[in]  fsr Desired full-scale range.
1147:Src/mpu6050.c ****  *  @return     0 if successful.
1148:Src/mpu6050.c ****  */
1149:Src/mpu6050.c **** int mpu_set_gyro_fsr(unsigned short fsr)
1150:Src/mpu6050.c **** {
1151:Src/mpu6050.c ****     unsigned char data;
1152:Src/mpu6050.c **** 
1153:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1154:Src/mpu6050.c ****         return -1;
1155:Src/mpu6050.c **** 
1156:Src/mpu6050.c ****     switch (fsr) {
1157:Src/mpu6050.c ****     case 250:
1158:Src/mpu6050.c ****         data = INV_FSR_250DPS << 3;
1159:Src/mpu6050.c ****         break;
1160:Src/mpu6050.c ****     case 500:
1161:Src/mpu6050.c ****         data = INV_FSR_500DPS << 3;
1162:Src/mpu6050.c ****         break;
1163:Src/mpu6050.c ****     case 1000:
1164:Src/mpu6050.c ****         data = INV_FSR_1000DPS << 3;
1165:Src/mpu6050.c ****         break;
1166:Src/mpu6050.c ****     case 2000:
1167:Src/mpu6050.c ****         data = INV_FSR_2000DPS << 3;
1168:Src/mpu6050.c ****         break;
1169:Src/mpu6050.c ****     default:
1170:Src/mpu6050.c ****         return -1;
1171:Src/mpu6050.c ****     }
ARM GAS  /tmp/cc39PcX6.s 			page 22


1172:Src/mpu6050.c **** 
1173:Src/mpu6050.c ****     if (st.chip_cfg.gyro_fsr == (data >> 3))
1174:Src/mpu6050.c ****         return 0;
1175:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
1176:Src/mpu6050.c ****         return -1;
1177:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = data >> 3;
1178:Src/mpu6050.c ****     return 0;
1179:Src/mpu6050.c **** }
1180:Src/mpu6050.c **** 
1181:Src/mpu6050.c **** /**
1182:Src/mpu6050.c ****  *  @brief      Get the accel full-scale range.
1183:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
1184:Src/mpu6050.c ****  *  @return     0 if successful.
1185:Src/mpu6050.c ****  */
1186:Src/mpu6050.c **** int mpu_get_accel_fsr(unsigned char *fsr)
1187:Src/mpu6050.c **** {
1188:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
1189:Src/mpu6050.c ****     case INV_FSR_2G:
1190:Src/mpu6050.c ****         fsr[0] = 2;
1191:Src/mpu6050.c ****         break;
1192:Src/mpu6050.c ****     case INV_FSR_4G:
1193:Src/mpu6050.c ****         fsr[0] = 4;
1194:Src/mpu6050.c ****         break;
1195:Src/mpu6050.c ****     case INV_FSR_8G:
1196:Src/mpu6050.c ****         fsr[0] = 8;
1197:Src/mpu6050.c ****         break;
1198:Src/mpu6050.c ****     case INV_FSR_16G:
1199:Src/mpu6050.c ****         fsr[0] = 16;
1200:Src/mpu6050.c ****         break;
1201:Src/mpu6050.c ****     default:
1202:Src/mpu6050.c ****         return -1;
1203:Src/mpu6050.c ****     }
1204:Src/mpu6050.c ****     if (st.chip_cfg.accel_half)
1205:Src/mpu6050.c ****         fsr[0] <<= 1;
1206:Src/mpu6050.c ****     return 0;
1207:Src/mpu6050.c **** }
1208:Src/mpu6050.c **** 
1209:Src/mpu6050.c **** /**
1210:Src/mpu6050.c ****  *  @brief      Set the accel full-scale range.
1211:Src/mpu6050.c ****  *  @param[in]  fsr Desired full-scale range.
1212:Src/mpu6050.c ****  *  @return     0 if successful.
1213:Src/mpu6050.c ****  */
1214:Src/mpu6050.c **** int mpu_set_accel_fsr(unsigned char fsr)
1215:Src/mpu6050.c **** {
1216:Src/mpu6050.c ****     unsigned char data;
1217:Src/mpu6050.c **** 
1218:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1219:Src/mpu6050.c ****         return -1;
1220:Src/mpu6050.c **** 
1221:Src/mpu6050.c ****     switch (fsr) {
1222:Src/mpu6050.c ****     case 2:
1223:Src/mpu6050.c ****         data = INV_FSR_2G << 3;
1224:Src/mpu6050.c ****         break;
1225:Src/mpu6050.c ****     case 4:
1226:Src/mpu6050.c ****         data = INV_FSR_4G << 3;
1227:Src/mpu6050.c ****         break;
1228:Src/mpu6050.c ****     case 8:
ARM GAS  /tmp/cc39PcX6.s 			page 23


1229:Src/mpu6050.c ****         data = INV_FSR_8G << 3;
1230:Src/mpu6050.c ****         break;
1231:Src/mpu6050.c ****     case 16:
1232:Src/mpu6050.c ****         data = INV_FSR_16G << 3;
1233:Src/mpu6050.c ****         break;
1234:Src/mpu6050.c ****     default:
1235:Src/mpu6050.c ****         return -1;
1236:Src/mpu6050.c ****     }
1237:Src/mpu6050.c **** 
1238:Src/mpu6050.c ****     if (st.chip_cfg.accel_fsr == (data >> 3))
1239:Src/mpu6050.c ****         return 0;
1240:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
1241:Src/mpu6050.c ****         return -1;
1242:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = data >> 3;
1243:Src/mpu6050.c ****     return 0;
1244:Src/mpu6050.c **** }
1245:Src/mpu6050.c **** 
1246:Src/mpu6050.c **** /**
1247:Src/mpu6050.c ****  *  @brief      Get the current DLPF setting.
1248:Src/mpu6050.c ****  *  @param[out] lpf Current LPF setting.
1249:Src/mpu6050.c ****  *  0 if successful.
1250:Src/mpu6050.c ****  */
1251:Src/mpu6050.c **** int mpu_get_lpf(unsigned short *lpf)
1252:Src/mpu6050.c **** {
1253:Src/mpu6050.c ****     switch (st.chip_cfg.lpf) {
1254:Src/mpu6050.c ****     case INV_FILTER_188HZ:
1255:Src/mpu6050.c ****         lpf[0] = 188;
1256:Src/mpu6050.c ****         break;
1257:Src/mpu6050.c ****     case INV_FILTER_98HZ:
1258:Src/mpu6050.c ****         lpf[0] = 98;
1259:Src/mpu6050.c ****         break;
1260:Src/mpu6050.c ****     case INV_FILTER_42HZ:
1261:Src/mpu6050.c ****         lpf[0] = 42;
1262:Src/mpu6050.c ****         break;
1263:Src/mpu6050.c ****     case INV_FILTER_20HZ:
1264:Src/mpu6050.c ****         lpf[0] = 20;
1265:Src/mpu6050.c ****         break;
1266:Src/mpu6050.c ****     case INV_FILTER_10HZ:
1267:Src/mpu6050.c ****         lpf[0] = 10;
1268:Src/mpu6050.c ****         break;
1269:Src/mpu6050.c ****     case INV_FILTER_5HZ:
1270:Src/mpu6050.c ****         lpf[0] = 5;
1271:Src/mpu6050.c ****         break;
1272:Src/mpu6050.c ****     case INV_FILTER_256HZ_NOLPF2:
1273:Src/mpu6050.c ****     case INV_FILTER_2100HZ_NOLPF:
1274:Src/mpu6050.c ****     default:
1275:Src/mpu6050.c ****         lpf[0] = 0;
1276:Src/mpu6050.c ****         break;
1277:Src/mpu6050.c ****     }
1278:Src/mpu6050.c ****     return 0;
1279:Src/mpu6050.c **** }
1280:Src/mpu6050.c **** 
1281:Src/mpu6050.c **** /**
1282:Src/mpu6050.c ****  *  @brief      Set digital low pass filter.
1283:Src/mpu6050.c ****  *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
1284:Src/mpu6050.c ****  *  @param[in]  lpf Desired LPF setting.
1285:Src/mpu6050.c ****  *  @return     0 if successful.
ARM GAS  /tmp/cc39PcX6.s 			page 24


1286:Src/mpu6050.c ****  */
1287:Src/mpu6050.c **** int mpu_set_lpf(unsigned short lpf)
1288:Src/mpu6050.c **** {
1289:Src/mpu6050.c ****     unsigned char data;
1290:Src/mpu6050.c **** 
1291:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1292:Src/mpu6050.c ****         return -1;
1293:Src/mpu6050.c **** 
1294:Src/mpu6050.c ****     if (lpf >= 188)
1295:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
1296:Src/mpu6050.c ****     else if (lpf >= 98)
1297:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
1298:Src/mpu6050.c ****     else if (lpf >= 42)
1299:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
1300:Src/mpu6050.c ****     else if (lpf >= 20)
1301:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
1302:Src/mpu6050.c ****     else if (lpf >= 10)
1303:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
1304:Src/mpu6050.c ****     else
1305:Src/mpu6050.c ****         data = INV_FILTER_5HZ;
1306:Src/mpu6050.c **** 
1307:Src/mpu6050.c ****     if (st.chip_cfg.lpf == data)
1308:Src/mpu6050.c ****         return 0;
1309:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
1310:Src/mpu6050.c ****         return -1;
1311:Src/mpu6050.c ****     st.chip_cfg.lpf = data;
1312:Src/mpu6050.c ****     return 0;
1313:Src/mpu6050.c **** }
1314:Src/mpu6050.c **** 
1315:Src/mpu6050.c **** /**
1316:Src/mpu6050.c ****  *  @brief      Get sampling rate.
1317:Src/mpu6050.c ****  *  @param[out] rate    Current sampling rate (Hz).
1318:Src/mpu6050.c ****  *  @return     0 if successful.
1319:Src/mpu6050.c ****  */
1320:Src/mpu6050.c **** int mpu_get_sample_rate(unsigned short *rate)
1321:Src/mpu6050.c **** {
1322:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1323:Src/mpu6050.c ****         return -1;
1324:Src/mpu6050.c ****     else
1325:Src/mpu6050.c ****         rate[0] = st.chip_cfg.sample_rate;
1326:Src/mpu6050.c ****     return 0;
1327:Src/mpu6050.c **** }
1328:Src/mpu6050.c **** 
1329:Src/mpu6050.c **** /**
1330:Src/mpu6050.c ****  *  @brief      Set sampling rate.
1331:Src/mpu6050.c ****  *  Sampling rate must be between 4Hz and 1kHz.
1332:Src/mpu6050.c ****  *  @param[in]  rate    Desired sampling rate (Hz).
1333:Src/mpu6050.c ****  *  @return     0 if successful.
1334:Src/mpu6050.c ****  */
1335:Src/mpu6050.c **** int mpu_set_sample_rate(unsigned short rate)
1336:Src/mpu6050.c **** {
1337:Src/mpu6050.c ****     unsigned char data;
1338:Src/mpu6050.c **** 
1339:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1340:Src/mpu6050.c ****         return -1;
1341:Src/mpu6050.c **** 
1342:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
ARM GAS  /tmp/cc39PcX6.s 			page 25


1343:Src/mpu6050.c ****         return -1;
1344:Src/mpu6050.c ****     else {
1345:Src/mpu6050.c ****         if (st.chip_cfg.lp_accel_mode) {
1346:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
1347:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
1348:Src/mpu6050.c ****                 mpu_lp_accel_mode(rate);
1349:Src/mpu6050.c ****                 return 0;
1350:Src/mpu6050.c ****             }
1351:Src/mpu6050.c ****             /* Requested rate exceeds the allowed frequencies in LP accel mode,
1352:Src/mpu6050.c ****              * switch back to full-power mode.
1353:Src/mpu6050.c ****              */
1354:Src/mpu6050.c ****             mpu_lp_accel_mode(0);
1355:Src/mpu6050.c ****         }
1356:Src/mpu6050.c ****         if (rate < 4)
1357:Src/mpu6050.c ****             rate = 4;
1358:Src/mpu6050.c ****         else if (rate > 1000)
1359:Src/mpu6050.c ****             rate = 1000;
1360:Src/mpu6050.c **** 
1361:Src/mpu6050.c ****         data = 1000 / rate - 1;
1362:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
1363:Src/mpu6050.c ****             return -1;
1364:Src/mpu6050.c **** 
1365:Src/mpu6050.c ****         st.chip_cfg.sample_rate = 1000 / (1 + data);
1366:Src/mpu6050.c **** 
1367:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1368:Src/mpu6050.c ****         mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
1369:Src/mpu6050.c **** #endif
1370:Src/mpu6050.c **** 
1371:Src/mpu6050.c ****         /* Automatically set LPF to 1/2 sampling rate. */
1372:Src/mpu6050.c ****         mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
1373:Src/mpu6050.c ****         return 0;
1374:Src/mpu6050.c ****     }
1375:Src/mpu6050.c **** }
1376:Src/mpu6050.c **** 
1377:Src/mpu6050.c **** /**
1378:Src/mpu6050.c ****  *  @brief      Get compass sampling rate.
1379:Src/mpu6050.c ****  *  @param[out] rate    Current compass sampling rate (Hz).
1380:Src/mpu6050.c ****  *  @return     0 if successful.
1381:Src/mpu6050.c ****  */
1382:Src/mpu6050.c **** int mpu_get_compass_sample_rate(unsigned short *rate)
1383:Src/mpu6050.c **** {
1384:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1385:Src/mpu6050.c ****     rate[0] = st.chip_cfg.compass_sample_rate;
1386:Src/mpu6050.c ****     return 0;
1387:Src/mpu6050.c **** #else
1388:Src/mpu6050.c ****     rate[0] = 0;
1389:Src/mpu6050.c ****     return -1;
1390:Src/mpu6050.c **** #endif
1391:Src/mpu6050.c **** }
1392:Src/mpu6050.c **** 
1393:Src/mpu6050.c **** /**
1394:Src/mpu6050.c ****  *  @brief      Set compass sampling rate.
1395:Src/mpu6050.c ****  *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
1396:Src/mpu6050.c ****  *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
1397:Src/mpu6050.c ****  *  sampling rate.
1398:Src/mpu6050.c ****  *
1399:Src/mpu6050.c ****  *  \n WARNING: The new rate may be different than what was requested. Call
ARM GAS  /tmp/cc39PcX6.s 			page 26


1400:Src/mpu6050.c ****  *  mpu_get_compass_sample_rate to check the actual setting.
1401:Src/mpu6050.c ****  *  @param[in]  rate    Desired compass sampling rate (Hz).
1402:Src/mpu6050.c ****  *  @return     0 if successful.
1403:Src/mpu6050.c ****  */
1404:Src/mpu6050.c **** int mpu_set_compass_sample_rate(unsigned short rate)
1405:Src/mpu6050.c **** {
1406:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1407:Src/mpu6050.c ****     unsigned char div;
1408:Src/mpu6050.c ****     if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
1409:Src/mpu6050.c ****         return -1;
1410:Src/mpu6050.c **** 
1411:Src/mpu6050.c ****     div = st.chip_cfg.sample_rate / rate - 1;
1412:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
1413:Src/mpu6050.c ****         return -1;
1414:Src/mpu6050.c ****     st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
1415:Src/mpu6050.c ****     return 0;
1416:Src/mpu6050.c **** #else
1417:Src/mpu6050.c ****     return -1;
1418:Src/mpu6050.c **** #endif
1419:Src/mpu6050.c **** }
1420:Src/mpu6050.c **** 
1421:Src/mpu6050.c **** /**
1422:Src/mpu6050.c ****  *  @brief      Get gyro sensitivity scale factor.
1423:Src/mpu6050.c ****  *  @param[out] sens    Conversion from hardware units to dps.
1424:Src/mpu6050.c ****  *  @return     0 if successful.
1425:Src/mpu6050.c ****  */
1426:Src/mpu6050.c **** int mpu_get_gyro_sens(float *sens)
1427:Src/mpu6050.c **** {
1428:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
1429:Src/mpu6050.c ****     case INV_FSR_250DPS:
1430:Src/mpu6050.c ****         sens[0] = 131.f;
1431:Src/mpu6050.c ****         break;
1432:Src/mpu6050.c ****     case INV_FSR_500DPS:
1433:Src/mpu6050.c ****         sens[0] = 65.5f;
1434:Src/mpu6050.c ****         break;
1435:Src/mpu6050.c ****     case INV_FSR_1000DPS:
1436:Src/mpu6050.c ****         sens[0] = 32.8f;
1437:Src/mpu6050.c ****         break;
1438:Src/mpu6050.c ****     case INV_FSR_2000DPS:
1439:Src/mpu6050.c ****         sens[0] = 16.4f;
1440:Src/mpu6050.c ****         break;
1441:Src/mpu6050.c ****     default:
1442:Src/mpu6050.c ****         return -1;
1443:Src/mpu6050.c ****     }
1444:Src/mpu6050.c ****     return 0;
1445:Src/mpu6050.c **** }
1446:Src/mpu6050.c **** 
1447:Src/mpu6050.c **** /**
1448:Src/mpu6050.c ****  *  @brief      Get accel sensitivity scale factor.
1449:Src/mpu6050.c ****  *  @param[out] sens    Conversion from hardware units to g's.
1450:Src/mpu6050.c ****  *  @return     0 if successful.
1451:Src/mpu6050.c ****  */
1452:Src/mpu6050.c **** int mpu_get_accel_sens(unsigned short *sens)
1453:Src/mpu6050.c **** {
1454:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
1455:Src/mpu6050.c ****     case INV_FSR_2G:
1456:Src/mpu6050.c ****         sens[0] = 16384;
ARM GAS  /tmp/cc39PcX6.s 			page 27


1457:Src/mpu6050.c ****         break;
1458:Src/mpu6050.c ****     case INV_FSR_4G:
1459:Src/mpu6050.c ****         sens[0] = 8192;
1460:Src/mpu6050.c ****         break;
1461:Src/mpu6050.c ****     case INV_FSR_8G:
1462:Src/mpu6050.c ****         sens[0] = 4096;
1463:Src/mpu6050.c ****         break;
1464:Src/mpu6050.c ****     case INV_FSR_16G:
1465:Src/mpu6050.c ****         sens[0] = 2048;
1466:Src/mpu6050.c ****         break;
1467:Src/mpu6050.c ****     default:
1468:Src/mpu6050.c ****         return -1;
1469:Src/mpu6050.c ****     }
1470:Src/mpu6050.c ****     if (st.chip_cfg.accel_half)
1471:Src/mpu6050.c ****         sens[0] >>= 1;
1472:Src/mpu6050.c ****     return 0;
1473:Src/mpu6050.c **** }
1474:Src/mpu6050.c **** 
1475:Src/mpu6050.c **** /**
1476:Src/mpu6050.c ****  *  @brief      Get current FIFO configuration.
1477:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1478:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1479:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1480:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1481:Src/mpu6050.c ****  *  @param[out] sensors Mask of sensors in FIFO.
1482:Src/mpu6050.c ****  *  @return     0 if successful.
1483:Src/mpu6050.c ****  */
1484:Src/mpu6050.c **** int mpu_get_fifo_config(unsigned char *sensors)
1485:Src/mpu6050.c **** {
1486:Src/mpu6050.c ****     sensors[0] = st.chip_cfg.fifo_enable;
1487:Src/mpu6050.c ****     return 0;
1488:Src/mpu6050.c **** }
1489:Src/mpu6050.c **** 
1490:Src/mpu6050.c **** /**
1491:Src/mpu6050.c ****  *  @brief      Select which sensors are pushed to FIFO.
1492:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1493:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1494:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1495:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1496:Src/mpu6050.c ****  *  @param[in]  sensors Mask of sensors to push to FIFO.
1497:Src/mpu6050.c ****  *  @return     0 if successful.
1498:Src/mpu6050.c ****  */
1499:Src/mpu6050.c **** int mpu_configure_fifo(unsigned char sensors)
1500:Src/mpu6050.c **** {
1501:Src/mpu6050.c ****     unsigned char prev;
1502:Src/mpu6050.c ****     int result = 0;
1503:Src/mpu6050.c **** 
1504:Src/mpu6050.c ****     /* Compass data isn't going into the FIFO. Stop trying. */
1505:Src/mpu6050.c ****     sensors &= ~INV_XYZ_COMPASS;
1506:Src/mpu6050.c **** 
1507:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1508:Src/mpu6050.c ****         return 0;
1509:Src/mpu6050.c ****     else {
1510:Src/mpu6050.c ****         if (!(st.chip_cfg.sensors))
1511:Src/mpu6050.c ****             return -1;
1512:Src/mpu6050.c ****         prev = st.chip_cfg.fifo_enable;
1513:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
ARM GAS  /tmp/cc39PcX6.s 			page 28


1514:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
1515:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
1516:Src/mpu6050.c ****              * asleep.
1517:Src/mpu6050.c ****              */
1518:Src/mpu6050.c ****             result = -1;
1519:Src/mpu6050.c ****         else
1520:Src/mpu6050.c ****             result = 0;
1521:Src/mpu6050.c ****         if (sensors || st.chip_cfg.lp_accel_mode)
1522:Src/mpu6050.c ****             set_int_enable(1);
1523:Src/mpu6050.c ****         else
1524:Src/mpu6050.c ****             set_int_enable(0);
1525:Src/mpu6050.c ****         if (sensors) {
1526:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
1527:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
1528:Src/mpu6050.c ****                 return -1;
1529:Src/mpu6050.c ****             }
1530:Src/mpu6050.c ****         }
1531:Src/mpu6050.c ****     }
1532:Src/mpu6050.c **** 
1533:Src/mpu6050.c ****     return result;
1534:Src/mpu6050.c **** }
1535:Src/mpu6050.c **** 
1536:Src/mpu6050.c **** /**
1537:Src/mpu6050.c ****  *  @brief      Get current power state.
1538:Src/mpu6050.c ****  *  @param[in]  power_on    1 if turned on, 0 if suspended.
1539:Src/mpu6050.c ****  *  @return     0 if successful.
1540:Src/mpu6050.c ****  */
1541:Src/mpu6050.c **** int mpu_get_power_state(unsigned char *power_on)
1542:Src/mpu6050.c **** {
1543:Src/mpu6050.c ****     if (st.chip_cfg.sensors)
1544:Src/mpu6050.c ****         power_on[0] = 1;
1545:Src/mpu6050.c ****     else
1546:Src/mpu6050.c ****         power_on[0] = 0;
1547:Src/mpu6050.c ****     return 0;
1548:Src/mpu6050.c **** }
1549:Src/mpu6050.c **** 
1550:Src/mpu6050.c **** /**
1551:Src/mpu6050.c ****  *  @brief      Turn specific sensors on/off.
1552:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1553:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1554:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1555:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1556:Src/mpu6050.c ****  *  \n INV_XYZ_COMPASS
1557:Src/mpu6050.c ****  *  @param[in]  sensors    Mask of sensors to wake.
1558:Src/mpu6050.c ****  *  @return     0 if successful.
1559:Src/mpu6050.c ****  */
1560:Src/mpu6050.c **** int mpu_set_sensors(unsigned char sensors)
1561:Src/mpu6050.c **** {
1562:Src/mpu6050.c ****     unsigned char data;
1563:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1564:Src/mpu6050.c ****     unsigned char user_ctrl;
1565:Src/mpu6050.c **** #endif
1566:Src/mpu6050.c **** 
1567:Src/mpu6050.c ****     if (sensors & INV_XYZ_GYRO)
1568:Src/mpu6050.c ****         data = INV_CLK_PLL;
1569:Src/mpu6050.c ****     else if (sensors)
1570:Src/mpu6050.c ****         data = 0;
ARM GAS  /tmp/cc39PcX6.s 			page 29


1571:Src/mpu6050.c ****     else
1572:Src/mpu6050.c ****         data = BIT_SLEEP;
1573:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
1574:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
1575:Src/mpu6050.c ****         return -1;
1576:Src/mpu6050.c ****     }
1577:Src/mpu6050.c ****     st.chip_cfg.clk_src = data & ~BIT_SLEEP;
1578:Src/mpu6050.c **** 
1579:Src/mpu6050.c ****     data = 0;
1580:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
1581:Src/mpu6050.c ****         data |= BIT_STBY_XG;
1582:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
1583:Src/mpu6050.c ****         data |= BIT_STBY_YG;
1584:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
1585:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
1586:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
1587:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
1588:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
1589:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
1590:Src/mpu6050.c ****         return -1;
1591:Src/mpu6050.c ****     }
1592:Src/mpu6050.c **** 
1593:Src/mpu6050.c ****     if (sensors && (sensors != INV_XYZ_ACCEL))
1594:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
1595:Src/mpu6050.c ****         mpu_set_int_latched(0);
1596:Src/mpu6050.c **** 
1597:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1598:Src/mpu6050.c **** #ifdef AK89xx_BYPASS
1599:Src/mpu6050.c ****     if (sensors & INV_XYZ_COMPASS)
1600:Src/mpu6050.c ****         mpu_set_bypass(1);
1601:Src/mpu6050.c ****     else
1602:Src/mpu6050.c ****         mpu_set_bypass(0);
1603:Src/mpu6050.c **** #else
1604:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
1605:Src/mpu6050.c ****         return -1;
1606:Src/mpu6050.c ****     /* Handle AKM power management. */
1607:Src/mpu6050.c ****     if (sensors & INV_XYZ_COMPASS) {
1608:Src/mpu6050.c ****         data = AKM_SINGLE_MEASUREMENT;
1609:Src/mpu6050.c ****         user_ctrl |= BIT_AUX_IF_EN;
1610:Src/mpu6050.c ****     } else {
1611:Src/mpu6050.c ****         data = AKM_POWER_DOWN;
1612:Src/mpu6050.c ****         user_ctrl &= ~BIT_AUX_IF_EN;
1613:Src/mpu6050.c ****     }
1614:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1615:Src/mpu6050.c ****         user_ctrl |= BIT_DMP_EN;
1616:Src/mpu6050.c ****     else
1617:Src/mpu6050.c ****         user_ctrl &= ~BIT_DMP_EN;
1618:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
1619:Src/mpu6050.c ****         return -1;
1620:Src/mpu6050.c ****     /* Enable/disable I2C master mode. */
1621:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
1622:Src/mpu6050.c ****         return -1;
1623:Src/mpu6050.c **** #endif
1624:Src/mpu6050.c **** #endif
1625:Src/mpu6050.c **** 
1626:Src/mpu6050.c ****     st.chip_cfg.sensors = sensors;
1627:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
ARM GAS  /tmp/cc39PcX6.s 			page 30


1628:Src/mpu6050.c ****     delay_ms(50);
1629:Src/mpu6050.c ****     return 0;
1630:Src/mpu6050.c **** }
1631:Src/mpu6050.c **** 
1632:Src/mpu6050.c **** /**
1633:Src/mpu6050.c ****  *  @brief      Read the MPU interrupt status registers.
1634:Src/mpu6050.c ****  *  @param[out] status  Mask of interrupt bits.
1635:Src/mpu6050.c ****  *  @return     0 if successful.
1636:Src/mpu6050.c ****  */
1637:Src/mpu6050.c **** int mpu_get_int_status(short *status)
1638:Src/mpu6050.c **** {
1639:Src/mpu6050.c ****     unsigned char tmp[2];
1640:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1641:Src/mpu6050.c ****         return -1;
1642:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
1643:Src/mpu6050.c ****         return -1;
1644:Src/mpu6050.c ****     status[0] = (tmp[0] << 8) | tmp[1];
1645:Src/mpu6050.c ****     return 0;
1646:Src/mpu6050.c **** }
1647:Src/mpu6050.c **** 
1648:Src/mpu6050.c **** /**
1649:Src/mpu6050.c ****  *  @brief      Get one packet from the FIFO.
1650:Src/mpu6050.c ****  *  If @e sensors does not contain a particular sensor, disregard the data
1651:Src/mpu6050.c ****  *  returned to that pointer.
1652:Src/mpu6050.c ****  *  \n @e sensors can contain a combination of the following flags:
1653:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1654:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1655:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1656:Src/mpu6050.c ****  *  \n If the FIFO has no new data, @e sensors will be zero.
1657:Src/mpu6050.c ****  *  \n If the FIFO is disabled, @e sensors will be zero and this function will
1658:Src/mpu6050.c ****  *  return a non-zero error code.
1659:Src/mpu6050.c ****  *  @param[out] gyro        Gyro data in hardware units.
1660:Src/mpu6050.c ****  *  @param[out] accel       Accel data in hardware units.
1661:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds.
1662:Src/mpu6050.c ****  *  @param[out] sensors     Mask of sensors read from FIFO.
1663:Src/mpu6050.c ****  *  @param[out] more        Number of remaining packets.
1664:Src/mpu6050.c ****  *  @return     0 if successful.
1665:Src/mpu6050.c ****  */
1666:Src/mpu6050.c **** int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
1667:Src/mpu6050.c ****         unsigned char *sensors, unsigned char *more)
1668:Src/mpu6050.c **** {
1669:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
1670:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
1671:Src/mpu6050.c ****     unsigned char packet_size = 0;
1672:Src/mpu6050.c ****     unsigned short fifo_count, index = 0;
1673:Src/mpu6050.c **** 
1674:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1675:Src/mpu6050.c ****         return -1;
1676:Src/mpu6050.c **** 
1677:Src/mpu6050.c ****     sensors[0] = 0;
1678:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1679:Src/mpu6050.c ****         return -1;
1680:Src/mpu6050.c ****     if (!st.chip_cfg.fifo_enable)
1681:Src/mpu6050.c ****         return -1;
1682:Src/mpu6050.c **** 
1683:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_X_GYRO)
1684:Src/mpu6050.c ****         packet_size += 2;
ARM GAS  /tmp/cc39PcX6.s 			page 31


1685:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
1686:Src/mpu6050.c ****         packet_size += 2;
1687:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
1688:Src/mpu6050.c ****         packet_size += 2;
1689:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
1690:Src/mpu6050.c ****         packet_size += 6;
1691:Src/mpu6050.c **** 
1692:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
1693:Src/mpu6050.c ****         return -1;
1694:Src/mpu6050.c ****     fifo_count = (data[0] << 8) | data[1];
1695:Src/mpu6050.c ****     if (fifo_count < packet_size)
1696:Src/mpu6050.c ****         return 0;
1697:Src/mpu6050.c ****         // #ifdef SERIAL_DEBUG
1698:Src/mpu6050.c ****         // log_i("FIFO count: %hd\r\n", fifo_count);
1699:Src/mpu6050.c ****         // #endif
1700:Src/mpu6050.c ****     if (fifo_count > (st.hw->max_fifo >> 1)) {
1701:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
1702:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
1703:Src/mpu6050.c ****             return -1;
1704:Src/mpu6050.c ****         if (data[0] & BIT_FIFO_OVERFLOW) {
1705:Src/mpu6050.c ****             mpu_reset_fifo();
1706:Src/mpu6050.c ****             return -2;
1707:Src/mpu6050.c ****         }
1708:Src/mpu6050.c ****     }
1709:Src/mpu6050.c ****     get_ms((unsigned long*)timestamp);
1710:Src/mpu6050.c **** 
1711:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
1712:Src/mpu6050.c ****         return -1;
1713:Src/mpu6050.c ****     more[0] = fifo_count / packet_size - 1;
1714:Src/mpu6050.c ****     sensors[0] = 0;
1715:Src/mpu6050.c **** 
1716:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
1717:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
1718:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
1719:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
1720:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
1721:Src/mpu6050.c ****         index += 6;
1722:Src/mpu6050.c ****     }
1723:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
1724:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
1725:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
1726:Src/mpu6050.c ****         index += 2;
1727:Src/mpu6050.c ****     }
1728:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
1729:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
1730:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
1731:Src/mpu6050.c ****         index += 2;
1732:Src/mpu6050.c ****     }
1733:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
1734:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
1735:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
1736:Src/mpu6050.c ****         index += 2;
1737:Src/mpu6050.c ****     }
1738:Src/mpu6050.c **** 
1739:Src/mpu6050.c ****     return 0;
1740:Src/mpu6050.c **** }
1741:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 32


1742:Src/mpu6050.c **** /**
1743:Src/mpu6050.c ****  *  @brief      Get one unparsed packet from the FIFO.
1744:Src/mpu6050.c ****  *  This function should be used if the packet is to be parsed elsewhere.
1745:Src/mpu6050.c ****  *  @param[in]  length  Length of one FIFO packet.
1746:Src/mpu6050.c ****  *  @param[in]  data    FIFO packet.
1747:Src/mpu6050.c ****  *  @param[in]  more    Number of remaining packets.
1748:Src/mpu6050.c ****  */
1749:Src/mpu6050.c **** int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
1750:Src/mpu6050.c ****     unsigned char *more)
1751:Src/mpu6050.c **** {
1752:Src/mpu6050.c ****     unsigned char tmp[2];
1753:Src/mpu6050.c ****     unsigned short fifo_count;
1754:Src/mpu6050.c ****     if (!st.chip_cfg.dmp_on)
1755:Src/mpu6050.c ****         return -1;
1756:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1757:Src/mpu6050.c ****         return -1;
1758:Src/mpu6050.c **** 
1759:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
1760:Src/mpu6050.c ****         return -1;
1761:Src/mpu6050.c ****     fifo_count = (tmp[0] << 8) | tmp[1];
1762:Src/mpu6050.c ****     if (fifo_count < length) {
1763:Src/mpu6050.c ****         more[0] = 0;
1764:Src/mpu6050.c ****         return -1;
1765:Src/mpu6050.c ****     }
1766:Src/mpu6050.c ****     if (fifo_count > (st.hw->max_fifo >> 1)) {
1767:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
1768:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
1769:Src/mpu6050.c ****             return -1;
1770:Src/mpu6050.c ****         if (tmp[0] & BIT_FIFO_OVERFLOW) {
1771:Src/mpu6050.c ****             mpu_reset_fifo();
1772:Src/mpu6050.c ****             return -2;
1773:Src/mpu6050.c ****         }
1774:Src/mpu6050.c ****     }
1775:Src/mpu6050.c **** 
1776:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
1777:Src/mpu6050.c ****         return -1;
1778:Src/mpu6050.c ****     more[0] = fifo_count / length - 1;
1779:Src/mpu6050.c ****     return 0;
1780:Src/mpu6050.c **** }
1781:Src/mpu6050.c **** 
1782:Src/mpu6050.c **** /**
1783:Src/mpu6050.c ****  *  @brief      Set device to bypass mode.
1784:Src/mpu6050.c ****  *  @param[in]  bypass_on   1 to enable bypass mode.
1785:Src/mpu6050.c ****  *  @return     0 if successful.
1786:Src/mpu6050.c ****  */
1787:Src/mpu6050.c **** int mpu_set_bypass(unsigned char bypass_on)
1788:Src/mpu6050.c **** {
1789:Src/mpu6050.c ****     unsigned char tmp;
1790:Src/mpu6050.c **** 
1791:Src/mpu6050.c ****     if (st.chip_cfg.bypass_mode == bypass_on)
1792:Src/mpu6050.c ****         return 0;
1793:Src/mpu6050.c **** 
1794:Src/mpu6050.c ****     if (bypass_on) {
1795:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1796:Src/mpu6050.c ****             return -1;
1797:Src/mpu6050.c ****         tmp &= ~BIT_AUX_IF_EN;
1798:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
ARM GAS  /tmp/cc39PcX6.s 			page 33


1799:Src/mpu6050.c ****             return -1;
1800:Src/mpu6050.c ****         delay_ms(3);
1801:Src/mpu6050.c ****         tmp = BIT_BYPASS_EN;
1802:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
1803:Src/mpu6050.c ****             tmp |= BIT_ACTL;
1804:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
1805:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1806:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1807:Src/mpu6050.c ****             return -1;
1808:Src/mpu6050.c ****     } else {
1809:Src/mpu6050.c ****         /* Enable I2C master mode if compass is being used. */
1810:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1811:Src/mpu6050.c ****             return -1;
1812:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1813:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
1814:Src/mpu6050.c ****         else
1815:Src/mpu6050.c ****             tmp &= ~BIT_AUX_IF_EN;
1816:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1817:Src/mpu6050.c ****             return -1;
1818:Src/mpu6050.c ****         delay_ms(3);
1819:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
1820:Src/mpu6050.c ****             tmp = BIT_ACTL;
1821:Src/mpu6050.c ****         else
1822:Src/mpu6050.c ****             tmp = 0;
1823:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
1824:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1825:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1826:Src/mpu6050.c ****             return -1;
1827:Src/mpu6050.c ****     }
1828:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = bypass_on;
1829:Src/mpu6050.c ****     return 0;
1830:Src/mpu6050.c **** }
1831:Src/mpu6050.c **** 
1832:Src/mpu6050.c **** /**
1833:Src/mpu6050.c ****  *  @brief      Set interrupt level.
1834:Src/mpu6050.c ****  *  @param[in]  active_low  1 for active low, 0 for active high.
1835:Src/mpu6050.c ****  *  @return     0 if successful.
1836:Src/mpu6050.c ****  */
1837:Src/mpu6050.c **** int mpu_set_int_level(unsigned char active_low)
1838:Src/mpu6050.c **** {
1839:Src/mpu6050.c ****     st.chip_cfg.active_low_int = active_low;
1840:Src/mpu6050.c ****     return 0;
1841:Src/mpu6050.c **** }
1842:Src/mpu6050.c **** 
1843:Src/mpu6050.c **** /**
1844:Src/mpu6050.c ****  *  @brief      Enable latched interrupts.
1845:Src/mpu6050.c ****  *  Any MPU register will clear the interrupt.
1846:Src/mpu6050.c ****  *  @param[in]  enable  1 to enable, 0 to disable.
1847:Src/mpu6050.c ****  *  @return     0 if successful.
1848:Src/mpu6050.c ****  */
1849:Src/mpu6050.c **** int mpu_set_int_latched(unsigned char enable)
1850:Src/mpu6050.c **** {
1851:Src/mpu6050.c ****     unsigned char tmp;
1852:Src/mpu6050.c ****     if (st.chip_cfg.latched_int == enable)
1853:Src/mpu6050.c ****         return 0;
1854:Src/mpu6050.c **** 
1855:Src/mpu6050.c ****     if (enable)
ARM GAS  /tmp/cc39PcX6.s 			page 34


1856:Src/mpu6050.c ****         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
1857:Src/mpu6050.c ****     else
1858:Src/mpu6050.c ****         tmp = 0;
1859:Src/mpu6050.c ****     if (st.chip_cfg.bypass_mode)
1860:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
1861:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
1862:Src/mpu6050.c ****         tmp |= BIT_ACTL;
1863:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1864:Src/mpu6050.c ****         return -1;
1865:Src/mpu6050.c ****     st.chip_cfg.latched_int = enable;
1866:Src/mpu6050.c ****     return 0;
1867:Src/mpu6050.c **** }
1868:Src/mpu6050.c **** 
1869:Src/mpu6050.c **** #ifdef MPU6050
1870:Src/mpu6050.c **** static int get_accel_prod_shift(float *st_shift)
1871:Src/mpu6050.c **** {
1872:Src/mpu6050.c ****     unsigned char tmp[4], shift_code[3], ii;
1873:Src/mpu6050.c **** 
1874:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
1875:Src/mpu6050.c ****         return 0x07;
1876:Src/mpu6050.c **** 
1877:Src/mpu6050.c ****     shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
1878:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
1879:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
1880:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
1881:Src/mpu6050.c ****         if (!shift_code[ii]) {
1882:Src/mpu6050.c ****             st_shift[ii] = 0.f;
1883:Src/mpu6050.c ****             continue;
1884:Src/mpu6050.c ****         }
1885:Src/mpu6050.c ****         /* Equivalent to..
1886:Src/mpu6050.c ****          * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
1887:Src/mpu6050.c ****          */
1888:Src/mpu6050.c ****         st_shift[ii] = 0.34f;
1889:Src/mpu6050.c ****         while (--shift_code[ii])
1890:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
1891:Src/mpu6050.c ****     }
1892:Src/mpu6050.c ****     return 0;
1893:Src/mpu6050.c **** }
1894:Src/mpu6050.c **** 
1895:Src/mpu6050.c **** static int accel_self_test(long *bias_regular, long *bias_st)
1896:Src/mpu6050.c **** {
1897:Src/mpu6050.c ****     int jj, result = 0;
1898:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
1899:Src/mpu6050.c **** 
1900:Src/mpu6050.c ****     get_accel_prod_shift(st_shift);
1901:Src/mpu6050.c ****     for(jj = 0; jj < 3; jj++) {
1902:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
1903:Src/mpu6050.c ****         if (st_shift[jj]) {
1904:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
1905:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
1906:Src/mpu6050.c ****                 result |= 1 << jj;
1907:Src/mpu6050.c ****         } else if ((st_shift_cust < test.min_g) ||
1908:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
1909:Src/mpu6050.c ****             result |= 1 << jj;
1910:Src/mpu6050.c ****     }
1911:Src/mpu6050.c **** 
1912:Src/mpu6050.c ****     return result;
ARM GAS  /tmp/cc39PcX6.s 			page 35


1913:Src/mpu6050.c **** }
1914:Src/mpu6050.c **** 
1915:Src/mpu6050.c **** static int gyro_self_test(long *bias_regular, long *bias_st)
1916:Src/mpu6050.c **** {
1917:Src/mpu6050.c ****     int jj, result = 0;
1918:Src/mpu6050.c ****     unsigned char tmp[3];
1919:Src/mpu6050.c ****     float st_shift, st_shift_cust, st_shift_var;
1920:Src/mpu6050.c **** 
1921:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
1922:Src/mpu6050.c ****         return 0x07;
1923:Src/mpu6050.c **** 
1924:Src/mpu6050.c ****     tmp[0] &= 0x1F;
1925:Src/mpu6050.c ****     tmp[1] &= 0x1F;
1926:Src/mpu6050.c ****     tmp[2] &= 0x1F;
1927:Src/mpu6050.c **** 
1928:Src/mpu6050.c ****     for (jj = 0; jj < 3; jj++) {
1929:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
1930:Src/mpu6050.c ****         if (tmp[jj]) {
1931:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
1932:Src/mpu6050.c ****             while (--tmp[jj])
1933:Src/mpu6050.c ****                 st_shift *= 1.046f;
1934:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
1935:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
1936:Src/mpu6050.c ****                 result |= 1 << jj;
1937:Src/mpu6050.c ****         } else if ((st_shift_cust < test.min_dps) ||
1938:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
1939:Src/mpu6050.c ****             result |= 1 << jj;
1940:Src/mpu6050.c ****     }
1941:Src/mpu6050.c ****     return result;
1942:Src/mpu6050.c **** }
1943:Src/mpu6050.c **** 
1944:Src/mpu6050.c **** #endif 
1945:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1946:Src/mpu6050.c **** static int compass_self_test(void)
1947:Src/mpu6050.c **** {
1948:Src/mpu6050.c ****     unsigned char tmp[6];
1949:Src/mpu6050.c ****     unsigned char tries = 10;
1950:Src/mpu6050.c ****     int result = 0x07;
1951:Src/mpu6050.c ****     short data;
1952:Src/mpu6050.c **** 
1953:Src/mpu6050.c ****     mpu_set_bypass(1);
1954:Src/mpu6050.c **** 
1955:Src/mpu6050.c ****     tmp[0] = AKM_POWER_DOWN;
1956:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
1957:Src/mpu6050.c ****         return 0x07;
1958:Src/mpu6050.c ****     tmp[0] = AKM_BIT_SELF_TEST;
1959:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
1960:Src/mpu6050.c ****         goto AKM_restore;
1961:Src/mpu6050.c ****     tmp[0] = AKM_MODE_SELF_TEST;
1962:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
1963:Src/mpu6050.c ****         goto AKM_restore;
1964:Src/mpu6050.c **** 
1965:Src/mpu6050.c ****     do {
1966:Src/mpu6050.c ****         delay_ms(10);
1967:Src/mpu6050.c ****         if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
1968:Src/mpu6050.c ****             goto AKM_restore;
1969:Src/mpu6050.c ****         if (tmp[0] & AKM_DATA_READY)
ARM GAS  /tmp/cc39PcX6.s 			page 36


1970:Src/mpu6050.c ****             break;
1971:Src/mpu6050.c ****     } while (tries--);
1972:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY))
1973:Src/mpu6050.c ****         goto AKM_restore;
1974:Src/mpu6050.c **** 
1975:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
1976:Src/mpu6050.c ****         goto AKM_restore;
1977:Src/mpu6050.c **** 
1978:Src/mpu6050.c ****     result = 0;
1979:Src/mpu6050.c **** #if defined MPU9150
1980:Src/mpu6050.c ****     data = (short)(tmp[1] << 8) | tmp[0];
1981:Src/mpu6050.c ****     if ((data > 100) || (data < -100))
1982:Src/mpu6050.c ****         result |= 0x01;
1983:Src/mpu6050.c ****     data = (short)(tmp[3] << 8) | tmp[2];
1984:Src/mpu6050.c ****     if ((data > 100) || (data < -100))
1985:Src/mpu6050.c ****         result |= 0x02;
1986:Src/mpu6050.c ****     data = (short)(tmp[5] << 8) | tmp[4];
1987:Src/mpu6050.c ****     if ((data > -300) || (data < -1000))
1988:Src/mpu6050.c ****         result |= 0x04;
1989:Src/mpu6050.c **** #elif defined MPU9250
1990:Src/mpu6050.c ****     data = (short)(tmp[1] << 8) | tmp[0];
1991:Src/mpu6050.c ****     if ((data > 200) || (data < -200))  
1992:Src/mpu6050.c ****         result |= 0x01;
1993:Src/mpu6050.c ****     data = (short)(tmp[3] << 8) | tmp[2];
1994:Src/mpu6050.c ****     if ((data > 200) || (data < -200))  
1995:Src/mpu6050.c ****         result |= 0x02;
1996:Src/mpu6050.c ****     data = (short)(tmp[5] << 8) | tmp[4];
1997:Src/mpu6050.c ****     if ((data > -800) || (data < -3200))  
1998:Src/mpu6050.c ****         result |= 0x04;
1999:Src/mpu6050.c **** #endif
2000:Src/mpu6050.c **** AKM_restore:
2001:Src/mpu6050.c ****     tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
2002:Src/mpu6050.c ****     i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
2003:Src/mpu6050.c ****     tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
2004:Src/mpu6050.c ****     i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
2005:Src/mpu6050.c ****     mpu_set_bypass(0);
2006:Src/mpu6050.c ****     return result;
2007:Src/mpu6050.c **** }
2008:Src/mpu6050.c **** #endif
2009:Src/mpu6050.c **** 
2010:Src/mpu6050.c **** static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
2011:Src/mpu6050.c **** {
  28              		.loc 1 2011 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 0, uses_anonymous_args = 0
2012:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  32              		.loc 1 2012 5 view .LVU1
2013:Src/mpu6050.c ****     unsigned char packet_count, ii;
  33              		.loc 1 2013 5 view .LVU2
2014:Src/mpu6050.c ****     unsigned short fifo_count;
  34              		.loc 1 2014 5 view .LVU3
2015:Src/mpu6050.c **** 
2016:Src/mpu6050.c ****     data[0] = 0x01;
  35              		.loc 1 2016 5 view .LVU4
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  36              		.loc 1 2011 1 is_stmt 0 view .LVU5
ARM GAS  /tmp/cc39PcX6.s 			page 37


  37 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
  38              	.LCFI0:
  39              		.cfi_def_cfa_offset 28
  40              		.cfi_offset 4, -28
  41              		.cfi_offset 5, -24
  42              		.cfi_offset 6, -20
  43              		.cfi_offset 7, -16
  44              		.cfi_offset 8, -12
  45              		.cfi_offset 9, -8
  46              		.cfi_offset 14, -4
2017:Src/mpu6050.c ****     data[1] = 0;
  47              		.loc 1 2017 13 view .LVU6
  48 0004 0023     		movs	r3, #0
2016:Src/mpu6050.c ****     data[1] = 0;
  49              		.loc 1 2016 13 view .LVU7
  50 0006 0127     		movs	r7, #1
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  51              		.loc 1 2011 1 view .LVU8
  52 0008 85B0     		sub	sp, sp, #20
  53              	.LCFI1:
  54              		.cfi_def_cfa_offset 48
2018:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
  55              		.loc 1 2018 34 view .LVU9
  56 000a B64C     		ldr	r4, .L22
2017:Src/mpu6050.c ****     data[1] = 0;
  57              		.loc 1 2017 13 view .LVU10
  58 000c 8DF80530 		strb	r3, [sp, #5]
2016:Src/mpu6050.c ****     data[1] = 0;
  59              		.loc 1 2016 13 view .LVU11
  60 0010 8DF80470 		strb	r7, [sp, #4]
2017:Src/mpu6050.c ****     data[1] = 0;
  61              		.loc 1 2017 5 is_stmt 1 view .LVU12
  62              		.loc 1 2018 5 view .LVU13
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  63              		.loc 1 2011 1 is_stmt 0 view .LVU14
  64 0014 0646     		mov	r6, r0
  65 0016 0D46     		mov	r5, r1
  66              		.loc 1 2018 9 view .LVU15
  67 0018 D4E90010 		ldrd	r1, r0, [r4]
  68              	.LVL1:
2011:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  69              		.loc 1 2011 1 view .LVU16
  70 001c 9046     		mov	r8, r2
  71              		.loc 1 2018 9 view .LVU17
  72 001e 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
  73 0020 0222     		movs	r2, #2
  74              	.LVL2:
  75              		.loc 1 2018 9 view .LVU18
  76 0022 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
  77 0024 01AB     		add	r3, sp, #4
  78 0026 FFF7FEFF 		bl	i2c_writeBytes
  79              	.LVL3:
  80              		.loc 1 2018 8 view .LVU19
  81 002a 8146     		mov	r9, r0
  82 002c 20B1     		cbz	r0, .L2
  83              	.L4:
2019:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 38


  84              		.loc 1 2019 16 view .LVU20
  85 002e 4FF0FF30 		mov	r0, #-1
  86              	.L1:
2020:Src/mpu6050.c ****     delay_ms(200);
2021:Src/mpu6050.c ****     data[0] = 0;
2022:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
2023:Src/mpu6050.c ****         return -1;
2024:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2025:Src/mpu6050.c ****         return -1;
2026:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
2027:Src/mpu6050.c ****         return -1;
2028:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2029:Src/mpu6050.c ****         return -1;
2030:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2031:Src/mpu6050.c ****         return -1;
2032:Src/mpu6050.c ****     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
2033:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2034:Src/mpu6050.c ****         return -1;
2035:Src/mpu6050.c ****     delay_ms(15);
2036:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
2037:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
2038:Src/mpu6050.c ****         return -1;
2039:Src/mpu6050.c ****     data[0] = st.test->reg_rate_div;
2040:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
2041:Src/mpu6050.c ****         return -1;
2042:Src/mpu6050.c ****     if (hw_test)
2043:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
2044:Src/mpu6050.c ****     else
2045:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr;
2046:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
2047:Src/mpu6050.c ****         return -1;
2048:Src/mpu6050.c **** 
2049:Src/mpu6050.c ****     if (hw_test)
2050:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
2051:Src/mpu6050.c ****     else
2052:Src/mpu6050.c ****         data[0] = test.reg_accel_fsr;
2053:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
2054:Src/mpu6050.c ****         return -1;
2055:Src/mpu6050.c ****     if (hw_test)
2056:Src/mpu6050.c ****         delay_ms(200);
2057:Src/mpu6050.c **** 
2058:Src/mpu6050.c ****     /* Fill FIFO for test.wait_ms milliseconds. */
2059:Src/mpu6050.c ****     data[0] = BIT_FIFO_EN;
2060:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2061:Src/mpu6050.c ****         return -1;
2062:Src/mpu6050.c **** 
2063:Src/mpu6050.c ****     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2064:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2065:Src/mpu6050.c ****         return -1;
2066:Src/mpu6050.c ****     delay_ms(test.wait_ms);
2067:Src/mpu6050.c ****     data[0] = 0;
2068:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2069:Src/mpu6050.c ****         return -1;
2070:Src/mpu6050.c **** 
2071:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
2072:Src/mpu6050.c ****         return -1;
2073:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 39


2074:Src/mpu6050.c ****     fifo_count = (data[0] << 8) | data[1];
2075:Src/mpu6050.c ****     packet_count = fifo_count / MAX_PACKET_LENGTH;
2076:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
2077:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
2078:Src/mpu6050.c **** 
2079:Src/mpu6050.c ****     for (ii = 0; ii < packet_count; ii++) {
2080:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
2081:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
2082:Src/mpu6050.c ****             return -1;
2083:Src/mpu6050.c ****         accel_cur[0] = ((short)data[0] << 8) | data[1];
2084:Src/mpu6050.c ****         accel_cur[1] = ((short)data[2] << 8) | data[3];
2085:Src/mpu6050.c ****         accel_cur[2] = ((short)data[4] << 8) | data[5];
2086:Src/mpu6050.c ****         accel[0] += (long)accel_cur[0];
2087:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
2088:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
2089:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
2090:Src/mpu6050.c ****         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
2091:Src/mpu6050.c ****         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
2092:Src/mpu6050.c ****         gyro[0] += (long)gyro_cur[0];
2093:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
2094:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
2095:Src/mpu6050.c ****     }
2096:Src/mpu6050.c **** #ifdef EMPL_NO_64BIT
2097:Src/mpu6050.c ****     gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
2098:Src/mpu6050.c ****     gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
2099:Src/mpu6050.c ****     gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
2100:Src/mpu6050.c ****     if (has_accel) {
2101:Src/mpu6050.c ****         accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
2102:Src/mpu6050.c ****             packet_count);
2103:Src/mpu6050.c ****         accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
2104:Src/mpu6050.c ****             packet_count);
2105:Src/mpu6050.c ****         accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
2106:Src/mpu6050.c ****             packet_count);
2107:Src/mpu6050.c ****         /* Don't remove gravity! */
2108:Src/mpu6050.c ****         accel[2] -= 65536L;
2109:Src/mpu6050.c ****     }
2110:Src/mpu6050.c **** #else
2111:Src/mpu6050.c ****     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
2112:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
2113:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
2114:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
2115:Src/mpu6050.c ****         packet_count);
2116:Src/mpu6050.c ****     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
2117:Src/mpu6050.c ****         packet_count);
2118:Src/mpu6050.c ****     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
2119:Src/mpu6050.c ****         packet_count);
2120:Src/mpu6050.c ****     /* Don't remove gravity! */
2121:Src/mpu6050.c ****     if (accel[2] > 0L)
2122:Src/mpu6050.c ****         accel[2] -= 65536L;
2123:Src/mpu6050.c ****     else
2124:Src/mpu6050.c ****         accel[2] += 65536L;
2125:Src/mpu6050.c **** #endif
2126:Src/mpu6050.c **** 
2127:Src/mpu6050.c ****     return 0;
2128:Src/mpu6050.c **** }
  87              		.loc 1 2128 1 view .LVU21
  88 0032 05B0     		add	sp, sp, #20
ARM GAS  /tmp/cc39PcX6.s 			page 40


  89              	.LCFI2:
  90              		.cfi_remember_state
  91              		.cfi_def_cfa_offset 28
  92              		@ sp needed
  93 0034 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
  94              	.LVL4:
  95              	.L2:
  96              	.LCFI3:
  97              		.cfi_restore_state
2020:Src/mpu6050.c ****     delay_ms(200);
  98              		.loc 1 2020 5 is_stmt 1 view .LVU22
  99 0038 C820     		movs	r0, #200
 100 003a FFF7FEFF 		bl	delay_1ms
 101              	.LVL5:
2021:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
 102              		.loc 1 2021 5 view .LVU23
2022:Src/mpu6050.c ****         return -1;
 103              		.loc 1 2022 9 is_stmt 0 view .LVU24
 104 003e D4E90010 		ldrd	r1, r0, [r4]
2021:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
 105              		.loc 1 2021 13 view .LVU25
 106 0042 8DF80490 		strb	r9, [sp, #4]
2022:Src/mpu6050.c ****         return -1;
 107              		.loc 1 2022 5 is_stmt 1 view .LVU26
2022:Src/mpu6050.c ****         return -1;
 108              		.loc 1 2022 9 is_stmt 0 view .LVU27
 109 0046 3A46     		mov	r2, r7
 110 0048 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 111 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 112 004c 01AB     		add	r3, sp, #4
 113 004e FFF7FEFF 		bl	i2c_writeBytes
 114              	.LVL6:
2022:Src/mpu6050.c ****         return -1;
 115              		.loc 1 2022 8 view .LVU28
 116 0052 0028     		cmp	r0, #0
 117 0054 EBD1     		bne	.L4
2024:Src/mpu6050.c ****         return -1;
 118              		.loc 1 2024 5 is_stmt 1 view .LVU29
2024:Src/mpu6050.c ****         return -1;
 119              		.loc 1 2024 9 is_stmt 0 view .LVU30
 120 0056 D4E90010 		ldrd	r1, r0, [r4]
 121 005a 3A46     		mov	r2, r7
 122 005c 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 123 005e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 124 0060 01AB     		add	r3, sp, #4
 125 0062 FFF7FEFF 		bl	i2c_writeBytes
 126              	.LVL7:
2024:Src/mpu6050.c ****         return -1;
 127              		.loc 1 2024 8 view .LVU31
 128 0066 0028     		cmp	r0, #0
 129 0068 E1D1     		bne	.L4
2026:Src/mpu6050.c ****         return -1;
 130              		.loc 1 2026 5 is_stmt 1 view .LVU32
2026:Src/mpu6050.c ****         return -1;
 131              		.loc 1 2026 9 is_stmt 0 view .LVU33
 132 006a D4E90010 		ldrd	r1, r0, [r4]
 133 006e 3A46     		mov	r2, r7
ARM GAS  /tmp/cc39PcX6.s 			page 41


 134 0070 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 135 0072 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 136 0074 01AB     		add	r3, sp, #4
 137 0076 FFF7FEFF 		bl	i2c_writeBytes
 138              	.LVL8:
2026:Src/mpu6050.c ****         return -1;
 139              		.loc 1 2026 8 view .LVU34
 140 007a 0028     		cmp	r0, #0
 141 007c D7D1     		bne	.L4
2028:Src/mpu6050.c ****         return -1;
 142              		.loc 1 2028 5 is_stmt 1 view .LVU35
2028:Src/mpu6050.c ****         return -1;
 143              		.loc 1 2028 9 is_stmt 0 view .LVU36
 144 007e D4E90010 		ldrd	r1, r0, [r4]
 145 0082 3A46     		mov	r2, r7
 146 0084 897E     		ldrb	r1, [r1, #26]	@ zero_extendqisi2
 147 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 148 0088 01AB     		add	r3, sp, #4
 149 008a FFF7FEFF 		bl	i2c_writeBytes
 150              	.LVL9:
2028:Src/mpu6050.c ****         return -1;
 151              		.loc 1 2028 8 view .LVU37
 152 008e 0028     		cmp	r0, #0
 153 0090 CDD1     		bne	.L4
2030:Src/mpu6050.c ****         return -1;
 154              		.loc 1 2030 5 is_stmt 1 view .LVU38
2030:Src/mpu6050.c ****         return -1;
 155              		.loc 1 2030 9 is_stmt 0 view .LVU39
 156 0092 D4E90010 		ldrd	r1, r0, [r4]
 157 0096 3A46     		mov	r2, r7
 158 0098 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 159 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 160 009c 01AB     		add	r3, sp, #4
 161 009e FFF7FEFF 		bl	i2c_writeBytes
 162              	.LVL10:
2030:Src/mpu6050.c ****         return -1;
 163              		.loc 1 2030 8 view .LVU40
 164 00a2 0028     		cmp	r0, #0
 165 00a4 C3D1     		bne	.L4
2032:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 166              		.loc 1 2032 5 is_stmt 1 view .LVU41
2033:Src/mpu6050.c ****         return -1;
 167              		.loc 1 2033 9 is_stmt 0 view .LVU42
 168 00a6 D4E90010 		ldrd	r1, r0, [r4]
2032:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 169              		.loc 1 2032 13 view .LVU43
 170 00aa 0C23     		movs	r3, #12
 171 00ac 8DF80430 		strb	r3, [sp, #4]
2033:Src/mpu6050.c ****         return -1;
 172              		.loc 1 2033 5 is_stmt 1 view .LVU44
2033:Src/mpu6050.c ****         return -1;
 173              		.loc 1 2033 9 is_stmt 0 view .LVU45
 174 00b0 3A46     		mov	r2, r7
 175 00b2 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 176 00b4 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 177 00b6 01AB     		add	r3, sp, #4
 178 00b8 FFF7FEFF 		bl	i2c_writeBytes
ARM GAS  /tmp/cc39PcX6.s 			page 42


 179              	.LVL11:
2033:Src/mpu6050.c ****         return -1;
 180              		.loc 1 2033 8 view .LVU46
 181 00bc 0028     		cmp	r0, #0
 182 00be B6D1     		bne	.L4
2035:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
 183              		.loc 1 2035 5 is_stmt 1 view .LVU47
 184 00c0 0F20     		movs	r0, #15
 185 00c2 FFF7FEFF 		bl	delay_1ms
 186              	.LVL12:
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 187              		.loc 1 2036 5 view .LVU48
2037:Src/mpu6050.c ****         return -1;
 188              		.loc 1 2037 9 is_stmt 0 view .LVU49
 189 00c6 D4E90010 		ldrd	r1, r0, [r4]
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 190              		.loc 1 2036 22 view .LVU50
 191 00ca A36A     		ldr	r3, [r4, #40]
2037:Src/mpu6050.c ****         return -1;
 192              		.loc 1 2037 9 view .LVU51
 193 00cc 3A46     		mov	r2, r7
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 194              		.loc 1 2036 13 view .LVU52
 195 00ce 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
2037:Src/mpu6050.c ****         return -1;
 196              		.loc 1 2037 9 view .LVU53
 197 00d0 8978     		ldrb	r1, [r1, #2]	@ zero_extendqisi2
2036:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 198              		.loc 1 2036 13 view .LVU54
 199 00d2 8DF80430 		strb	r3, [sp, #4]
2037:Src/mpu6050.c ****         return -1;
 200              		.loc 1 2037 5 is_stmt 1 view .LVU55
2037:Src/mpu6050.c ****         return -1;
 201              		.loc 1 2037 9 is_stmt 0 view .LVU56
 202 00d6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 203 00d8 01AB     		add	r3, sp, #4
 204 00da FFF7FEFF 		bl	i2c_writeBytes
 205              	.LVL13:
2037:Src/mpu6050.c ****         return -1;
 206              		.loc 1 2037 8 view .LVU57
 207 00de 0028     		cmp	r0, #0
 208 00e0 A5D1     		bne	.L4
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 209              		.loc 1 2039 5 is_stmt 1 view .LVU58
2040:Src/mpu6050.c ****         return -1;
 210              		.loc 1 2040 9 is_stmt 0 view .LVU59
 211 00e2 D4E90010 		ldrd	r1, r0, [r4]
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 212              		.loc 1 2039 22 view .LVU60
 213 00e6 A36A     		ldr	r3, [r4, #40]
2040:Src/mpu6050.c ****         return -1;
 214              		.loc 1 2040 9 view .LVU61
 215 00e8 3A46     		mov	r2, r7
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 216              		.loc 1 2039 13 view .LVU62
 217 00ea 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
2040:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 43


 218              		.loc 1 2040 9 view .LVU63
 219 00ec 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 220              		.loc 1 2039 13 view .LVU64
 221 00ee 8DF80430 		strb	r3, [sp, #4]
2040:Src/mpu6050.c ****         return -1;
 222              		.loc 1 2040 5 is_stmt 1 view .LVU65
2040:Src/mpu6050.c ****         return -1;
 223              		.loc 1 2040 9 is_stmt 0 view .LVU66
 224 00f2 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 225 00f4 01AB     		add	r3, sp, #4
 226 00f6 FFF7FEFF 		bl	i2c_writeBytes
 227              	.LVL14:
2040:Src/mpu6050.c ****         return -1;
 228              		.loc 1 2040 8 view .LVU67
 229 00fa 0028     		cmp	r0, #0
 230 00fc 97D1     		bne	.L4
2042:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
 231              		.loc 1 2042 5 is_stmt 1 view .LVU68
2043:Src/mpu6050.c ****     else
 232              		.loc 1 2043 26 is_stmt 0 view .LVU69
 233 00fe A36A     		ldr	r3, [r4, #40]
 234 0100 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
2042:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
 235              		.loc 1 2042 8 view .LVU70
 236 0102 B8F1000F 		cmp	r8, #0
 237 0106 01D0     		beq	.L5
2043:Src/mpu6050.c ****     else
 238              		.loc 1 2043 9 is_stmt 1 view .LVU71
2043:Src/mpu6050.c ****     else
 239              		.loc 1 2043 17 is_stmt 0 view .LVU72
 240 0108 43F0E003 		orr	r3, r3, #224
 241              	.L5:
 242 010c 8DF80430 		strb	r3, [sp, #4]
2046:Src/mpu6050.c ****         return -1;
 243              		.loc 1 2046 5 is_stmt 1 view .LVU73
2046:Src/mpu6050.c ****         return -1;
 244              		.loc 1 2046 9 is_stmt 0 view .LVU74
 245 0110 D4E90010 		ldrd	r1, r0, [r4]
 246 0114 0122     		movs	r2, #1
 247 0116 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 248 0118 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 249 011a 01AB     		add	r3, sp, #4
 250 011c FFF7FEFF 		bl	i2c_writeBytes
 251              	.LVL15:
2046:Src/mpu6050.c ****         return -1;
 252              		.loc 1 2046 8 view .LVU75
 253 0120 0028     		cmp	r0, #0
 254 0122 84D1     		bne	.L4
2049:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
 255              		.loc 1 2049 5 is_stmt 1 view .LVU76
2049:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
 256              		.loc 1 2049 8 is_stmt 0 view .LVU77
 257 0124 B8F1000F 		cmp	r8, #0
 258 0128 00F0D980 		beq	.L14
2050:Src/mpu6050.c ****     else
 259              		.loc 1 2050 9 is_stmt 1 view .LVU78
ARM GAS  /tmp/cc39PcX6.s 			page 44


2050:Src/mpu6050.c ****     else
 260              		.loc 1 2050 26 is_stmt 0 view .LVU79
 261 012c A36A     		ldr	r3, [r4, #40]
2050:Src/mpu6050.c ****     else
 262              		.loc 1 2050 17 view .LVU80
 263 012e DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 264 0130 43F0E003 		orr	r3, r3, #224
 265              	.L6:
 266 0134 8DF80430 		strb	r3, [sp, #4]
2053:Src/mpu6050.c ****         return -1;
 267              		.loc 1 2053 5 is_stmt 1 view .LVU81
2053:Src/mpu6050.c ****         return -1;
 268              		.loc 1 2053 9 is_stmt 0 view .LVU82
 269 0138 D4E90010 		ldrd	r1, r0, [r4]
 270 013c 0122     		movs	r2, #1
 271 013e C979     		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 272 0140 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 273 0142 01AB     		add	r3, sp, #4
 274 0144 FFF7FEFF 		bl	i2c_writeBytes
 275              	.LVL16:
2053:Src/mpu6050.c ****         return -1;
 276              		.loc 1 2053 8 view .LVU83
 277 0148 0028     		cmp	r0, #0
 278 014a 7FF470AF 		bne	.L4
2055:Src/mpu6050.c ****         delay_ms(200);
 279              		.loc 1 2055 5 is_stmt 1 view .LVU84
2055:Src/mpu6050.c ****         delay_ms(200);
 280              		.loc 1 2055 8 is_stmt 0 view .LVU85
 281 014e B8F1000F 		cmp	r8, #0
 282 0152 02D0     		beq	.L7
2056:Src/mpu6050.c **** 
 283              		.loc 1 2056 9 is_stmt 1 view .LVU86
 284 0154 C820     		movs	r0, #200
 285 0156 FFF7FEFF 		bl	delay_1ms
 286              	.LVL17:
 287              	.L7:
2059:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 288              		.loc 1 2059 5 view .LVU87
2060:Src/mpu6050.c ****         return -1;
 289              		.loc 1 2060 9 is_stmt 0 view .LVU88
 290 015a D4E90010 		ldrd	r1, r0, [r4]
2059:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 291              		.loc 1 2059 13 view .LVU89
 292 015e 4023     		movs	r3, #64
 293 0160 8DF80430 		strb	r3, [sp, #4]
2060:Src/mpu6050.c ****         return -1;
 294              		.loc 1 2060 5 is_stmt 1 view .LVU90
2060:Src/mpu6050.c ****         return -1;
 295              		.loc 1 2060 9 is_stmt 0 view .LVU91
 296 0164 0122     		movs	r2, #1
 297 0166 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 298 0168 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 299 016a 01AB     		add	r3, sp, #4
 300 016c FFF7FEFF 		bl	i2c_writeBytes
 301              	.LVL18:
2060:Src/mpu6050.c ****         return -1;
 302              		.loc 1 2060 8 view .LVU92
ARM GAS  /tmp/cc39PcX6.s 			page 45


 303 0170 0028     		cmp	r0, #0
 304 0172 7FF45CAF 		bne	.L4
2063:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 305              		.loc 1 2063 5 is_stmt 1 view .LVU93
2064:Src/mpu6050.c ****         return -1;
 306              		.loc 1 2064 9 is_stmt 0 view .LVU94
 307 0176 D4E90010 		ldrd	r1, r0, [r4]
2063:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 308              		.loc 1 2063 13 view .LVU95
 309 017a 7823     		movs	r3, #120
 310 017c 8DF80430 		strb	r3, [sp, #4]
2064:Src/mpu6050.c ****         return -1;
 311              		.loc 1 2064 5 is_stmt 1 view .LVU96
2064:Src/mpu6050.c ****         return -1;
 312              		.loc 1 2064 9 is_stmt 0 view .LVU97
 313 0180 0122     		movs	r2, #1
 314 0182 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 315 0184 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 316 0186 01AB     		add	r3, sp, #4
 317 0188 FFF7FEFF 		bl	i2c_writeBytes
 318              	.LVL19:
2064:Src/mpu6050.c ****         return -1;
 319              		.loc 1 2064 8 view .LVU98
 320 018c 0746     		mov	r7, r0
 321 018e 0028     		cmp	r0, #0
 322 0190 7FF44DAF 		bne	.L4
2066:Src/mpu6050.c ****     data[0] = 0;
 323              		.loc 1 2066 5 is_stmt 1 view .LVU99
 324 0194 3220     		movs	r0, #50
 325 0196 FFF7FEFF 		bl	delay_1ms
 326              	.LVL20:
2067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 327              		.loc 1 2067 5 view .LVU100
2068:Src/mpu6050.c ****         return -1;
 328              		.loc 1 2068 9 is_stmt 0 view .LVU101
 329 019a D4E90010 		ldrd	r1, r0, [r4]
2067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 330              		.loc 1 2067 13 view .LVU102
 331 019e 8DF80470 		strb	r7, [sp, #4]
2068:Src/mpu6050.c ****         return -1;
 332              		.loc 1 2068 5 is_stmt 1 view .LVU103
2068:Src/mpu6050.c ****         return -1;
 333              		.loc 1 2068 9 is_stmt 0 view .LVU104
 334 01a2 0122     		movs	r2, #1
 335 01a4 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 336 01a6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 337 01a8 01AB     		add	r3, sp, #4
 338 01aa FFF7FEFF 		bl	i2c_writeBytes
 339              	.LVL21:
2068:Src/mpu6050.c ****         return -1;
 340              		.loc 1 2068 8 view .LVU105
 341 01ae 0028     		cmp	r0, #0
 342 01b0 7FF43DAF 		bne	.L4
2071:Src/mpu6050.c ****         return -1;
 343              		.loc 1 2071 5 is_stmt 1 view .LVU106
2071:Src/mpu6050.c ****         return -1;
 344              		.loc 1 2071 9 is_stmt 0 view .LVU107
ARM GAS  /tmp/cc39PcX6.s 			page 46


 345 01b4 D4E90010 		ldrd	r1, r0, [r4]
 346 01b8 0222     		movs	r2, #2
 347 01ba 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 348 01bc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 349 01be 01AB     		add	r3, sp, #4
 350 01c0 FFF7FEFF 		bl	i2c_readBytes
 351              	.LVL22:
2071:Src/mpu6050.c ****         return -1;
 352              		.loc 1 2071 8 view .LVU108
 353 01c4 0028     		cmp	r0, #0
 354 01c6 7FF432AF 		bne	.L4
2074:Src/mpu6050.c ****     packet_count = fifo_count / MAX_PACKET_LENGTH;
 355              		.loc 1 2074 5 is_stmt 1 view .LVU109
 356              	.LVL23:
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 357              		.loc 1 2075 5 view .LVU110
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 358              		.loc 1 2075 18 is_stmt 0 view .LVU111
 359 01ca 0C23     		movs	r3, #12
 360 01cc BDF80470 		ldrh	r7, [sp, #4]
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 361              		.loc 1 2079 5 view .LVU112
 362 01d0 8046     		mov	r8, r0
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 363              		.loc 1 2075 18 view .LVU113
 364 01d2 7FBA     		rev16	r7, r7
 365 01d4 BFB2     		uxth	r7, r7
 366 01d6 B7FBF3F7 		udiv	r7, r7, r3
2076:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 367              		.loc 1 2076 23 view .LVU114
 368 01da C6E90100 		strd	r0, r0, [r6, #4]
2076:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 369              		.loc 1 2076 13 view .LVU115
 370 01de 3060     		str	r0, [r6]
2077:Src/mpu6050.c **** 
 371              		.loc 1 2077 25 view .LVU116
 372 01e0 C5E90100 		strd	r0, r0, [r5, #4]
2075:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 373              		.loc 1 2075 18 view .LVU117
 374 01e4 FFB2     		uxtb	r7, r7
 375              	.LVL24:
2076:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 376              		.loc 1 2076 5 is_stmt 1 view .LVU118
2077:Src/mpu6050.c **** 
 377              		.loc 1 2077 5 view .LVU119
2077:Src/mpu6050.c **** 
 378              		.loc 1 2077 14 is_stmt 0 view .LVU120
 379 01e6 2860     		str	r0, [r5]
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 380              		.loc 1 2079 5 is_stmt 1 view .LVU121
 381              	.LVL25:
 382              	.L8:
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 383              		.loc 1 2079 18 discriminator 1 view .LVU122
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 384              		.loc 1 2079 5 is_stmt 0 discriminator 1 view .LVU123
 385 01e8 5FFA88F3 		uxtb	r3, r8
ARM GAS  /tmp/cc39PcX6.s 			page 47


 386 01ec BB42     		cmp	r3, r7
 387 01ee 7BD3     		bcc	.L9
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 388              		.loc 1 2111 5 is_stmt 1 view .LVU124
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 389              		.loc 1 2111 23 is_stmt 0 view .LVU125
 390 01f0 3468     		ldr	r4, [r6]
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 391              		.loc 1 2111 47 view .LVU126
 392 01f2 8322     		movs	r2, #131
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 393              		.loc 1 2111 23 view .LVU127
 394 01f4 E117     		asrs	r1, r4, #31
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 395              		.loc 1 2111 41 view .LVU128
 396 01f6 0904     		lsls	r1, r1, #16
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 397              		.loc 1 2111 47 view .LVU129
 398 01f8 0023     		movs	r3, #0
 399 01fa 2004     		lsls	r0, r4, #16
 400 01fc 41EA1441 		orr	r1, r1, r4, lsr #16
 401 0200 FFF7FEFF 		bl	__aeabi_ldivmod
 402              	.LVL26:
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 403              		.loc 1 2111 64 view .LVU130
 404 0204 3A46     		mov	r2, r7
 405 0206 0023     		movs	r3, #0
 406 0208 FFF7FEFF 		bl	__aeabi_ldivmod
 407              	.LVL27:
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 408              		.loc 1 2112 23 view .LVU131
 409 020c 7468     		ldr	r4, [r6, #4]
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 410              		.loc 1 2112 47 view .LVU132
 411 020e 8322     		movs	r2, #131
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 412              		.loc 1 2112 23 view .LVU133
 413 0210 E117     		asrs	r1, r4, #31
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 414              		.loc 1 2112 41 view .LVU134
 415 0212 0904     		lsls	r1, r1, #16
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 416              		.loc 1 2112 47 view .LVU135
 417 0214 0023     		movs	r3, #0
2111:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 418              		.loc 1 2111 15 view .LVU136
 419 0216 3060     		str	r0, [r6]
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 420              		.loc 1 2112 5 is_stmt 1 view .LVU137
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 421              		.loc 1 2112 47 is_stmt 0 view .LVU138
 422 0218 41EA1441 		orr	r1, r1, r4, lsr #16
 423 021c 2004     		lsls	r0, r4, #16
 424 021e FFF7FEFF 		bl	__aeabi_ldivmod
 425              	.LVL28:
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 426              		.loc 1 2112 64 view .LVU139
ARM GAS  /tmp/cc39PcX6.s 			page 48


 427 0222 3A46     		mov	r2, r7
 428 0224 0023     		movs	r3, #0
 429 0226 FFF7FEFF 		bl	__aeabi_ldivmod
 430              	.LVL29:
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 431              		.loc 1 2113 23 view .LVU140
 432 022a B468     		ldr	r4, [r6, #8]
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 433              		.loc 1 2113 47 view .LVU141
 434 022c 8322     		movs	r2, #131
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 435              		.loc 1 2113 23 view .LVU142
 436 022e E117     		asrs	r1, r4, #31
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 437              		.loc 1 2113 41 view .LVU143
 438 0230 0904     		lsls	r1, r1, #16
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 439              		.loc 1 2113 47 view .LVU144
 440 0232 0023     		movs	r3, #0
2112:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 441              		.loc 1 2112 15 view .LVU145
 442 0234 7060     		str	r0, [r6, #4]
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 443              		.loc 1 2113 5 is_stmt 1 view .LVU146
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 444              		.loc 1 2113 47 is_stmt 0 view .LVU147
 445 0236 41EA1441 		orr	r1, r1, r4, lsr #16
 446 023a 2004     		lsls	r0, r4, #16
 447 023c FFF7FEFF 		bl	__aeabi_ldivmod
 448              	.LVL30:
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 449              		.loc 1 2113 64 view .LVU148
 450 0240 0023     		movs	r3, #0
 451 0242 3A46     		mov	r2, r7
 452 0244 FFF7FEFF 		bl	__aeabi_ldivmod
 453              	.LVL31:
2113:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 454              		.loc 1 2113 15 view .LVU149
 455 0248 B060     		str	r0, [r6, #8]
2114:Src/mpu6050.c ****         packet_count);
 456              		.loc 1 2114 5 is_stmt 1 view .LVU150
2114:Src/mpu6050.c ****         packet_count);
 457              		.loc 1 2114 24 is_stmt 0 view .LVU151
 458 024a 2B68     		ldr	r3, [r5]
 459 024c D917     		asrs	r1, r3, #31
2114:Src/mpu6050.c ****         packet_count);
 460              		.loc 1 2114 43 view .LVU152
 461 024e 0904     		lsls	r1, r1, #16
2114:Src/mpu6050.c ****         packet_count);
 462              		.loc 1 2114 49 view .LVU153
 463 0250 51EA1341 		orrs	r1, r1, r3, lsr #16
2114:Src/mpu6050.c ****         packet_count);
 464              		.loc 1 2114 43 view .LVU154
 465 0254 4FEA0340 		lsl	r0, r3, #16
2114:Src/mpu6050.c ****         packet_count);
 466              		.loc 1 2114 49 view .LVU155
 467 0258 04D5     		bpl	.L10
ARM GAS  /tmp/cc39PcX6.s 			page 49


 468 025a 40F2FF73 		movw	r3, #2047
 469 025e C018     		adds	r0, r0, r3
 470 0260 41F10001 		adc	r1, r1, #0
 471              	.L10:
 472 0264 C00A     		lsrs	r0, r0, #11
2114:Src/mpu6050.c ****         packet_count);
 473              		.loc 1 2114 67 view .LVU156
 474 0266 0023     		movs	r3, #0
 475 0268 40EA4150 		orr	r0, r0, r1, lsl #21
 476 026c 3A46     		mov	r2, r7
 477 026e C912     		asrs	r1, r1, #11
 478 0270 FFF7FEFF 		bl	__aeabi_ldivmod
 479              	.LVL32:
2116:Src/mpu6050.c ****         packet_count);
 480              		.loc 1 2116 24 view .LVU157
 481 0274 6B68     		ldr	r3, [r5, #4]
2114:Src/mpu6050.c ****         packet_count);
 482              		.loc 1 2114 16 view .LVU158
 483 0276 2860     		str	r0, [r5]
2116:Src/mpu6050.c ****         packet_count);
 484              		.loc 1 2116 5 is_stmt 1 view .LVU159
2116:Src/mpu6050.c ****         packet_count);
 485              		.loc 1 2116 24 is_stmt 0 view .LVU160
 486 0278 D917     		asrs	r1, r3, #31
2116:Src/mpu6050.c ****         packet_count);
 487              		.loc 1 2116 43 view .LVU161
 488 027a 0904     		lsls	r1, r1, #16
2116:Src/mpu6050.c ****         packet_count);
 489              		.loc 1 2116 49 view .LVU162
 490 027c 51EA1341 		orrs	r1, r1, r3, lsr #16
2116:Src/mpu6050.c ****         packet_count);
 491              		.loc 1 2116 43 view .LVU163
 492 0280 4FEA0340 		lsl	r0, r3, #16
2116:Src/mpu6050.c ****         packet_count);
 493              		.loc 1 2116 49 view .LVU164
 494 0284 04D5     		bpl	.L11
 495 0286 40F2FF73 		movw	r3, #2047
 496 028a C018     		adds	r0, r0, r3
 497 028c 41F10001 		adc	r1, r1, #0
 498              	.L11:
 499 0290 C00A     		lsrs	r0, r0, #11
2116:Src/mpu6050.c ****         packet_count);
 500              		.loc 1 2116 67 view .LVU165
 501 0292 0023     		movs	r3, #0
 502 0294 40EA4150 		orr	r0, r0, r1, lsl #21
 503 0298 3A46     		mov	r2, r7
 504 029a C912     		asrs	r1, r1, #11
 505 029c FFF7FEFF 		bl	__aeabi_ldivmod
 506              	.LVL33:
2118:Src/mpu6050.c ****         packet_count);
 507              		.loc 1 2118 24 view .LVU166
 508 02a0 AB68     		ldr	r3, [r5, #8]
2116:Src/mpu6050.c ****         packet_count);
 509              		.loc 1 2116 16 view .LVU167
 510 02a2 6860     		str	r0, [r5, #4]
2118:Src/mpu6050.c ****         packet_count);
 511              		.loc 1 2118 5 is_stmt 1 view .LVU168
ARM GAS  /tmp/cc39PcX6.s 			page 50


2118:Src/mpu6050.c ****         packet_count);
 512              		.loc 1 2118 24 is_stmt 0 view .LVU169
 513 02a4 D917     		asrs	r1, r3, #31
2118:Src/mpu6050.c ****         packet_count);
 514              		.loc 1 2118 43 view .LVU170
 515 02a6 0904     		lsls	r1, r1, #16
2118:Src/mpu6050.c ****         packet_count);
 516              		.loc 1 2118 49 view .LVU171
 517 02a8 51EA1341 		orrs	r1, r1, r3, lsr #16
2118:Src/mpu6050.c ****         packet_count);
 518              		.loc 1 2118 43 view .LVU172
 519 02ac 4FEA0340 		lsl	r0, r3, #16
2118:Src/mpu6050.c ****         packet_count);
 520              		.loc 1 2118 49 view .LVU173
 521 02b0 04D5     		bpl	.L12
 522 02b2 40F2FF73 		movw	r3, #2047
 523 02b6 C018     		adds	r0, r0, r3
 524 02b8 41F10001 		adc	r1, r1, #0
 525              	.L12:
 526 02bc C00A     		lsrs	r0, r0, #11
2118:Src/mpu6050.c ****         packet_count);
 527              		.loc 1 2118 67 view .LVU174
 528 02be 40EA4150 		orr	r0, r0, r1, lsl #21
 529 02c2 3A46     		mov	r2, r7
 530 02c4 0023     		movs	r3, #0
 531 02c6 C912     		asrs	r1, r1, #11
 532 02c8 FFF7FEFF 		bl	__aeabi_ldivmod
 533              	.LVL34:
2121:Src/mpu6050.c ****         accel[2] -= 65536L;
 534              		.loc 1 2121 5 is_stmt 1 view .LVU175
2121:Src/mpu6050.c ****         accel[2] -= 65536L;
 535              		.loc 1 2121 8 is_stmt 0 view .LVU176
 536 02cc 0028     		cmp	r0, #0
2122:Src/mpu6050.c ****     else
 537              		.loc 1 2122 9 is_stmt 1 view .LVU177
2122:Src/mpu6050.c ****     else
 538              		.loc 1 2122 18 is_stmt 0 view .LVU178
 539 02ce CCBF     		ite	gt
 540 02d0 A0F58030 		subgt	r0, r0, #65536
2124:Src/mpu6050.c **** #endif
 541              		.loc 1 2124 9 is_stmt 1 view .LVU179
2124:Src/mpu6050.c **** #endif
 542              		.loc 1 2124 18 is_stmt 0 view .LVU180
 543 02d4 00F58030 		addle	r0, r0, #65536
 544 02d8 A860     		str	r0, [r5, #8]
2127:Src/mpu6050.c **** }
 545              		.loc 1 2127 12 view .LVU181
 546 02da 0020     		movs	r0, #0
 547 02dc A9E6     		b	.L1
 548              	.LVL35:
 549              	.L14:
2052:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
 550              		.loc 1 2052 17 view .LVU182
 551 02de 1823     		movs	r3, #24
 552 02e0 28E7     		b	.L6
 553              	.L23:
 554 02e2 00BF     		.align	2
ARM GAS  /tmp/cc39PcX6.s 			page 51


 555              	.L22:
 556 02e4 00000000 		.word	.LANCHOR0
 557              	.LVL36:
 558              	.L9:
 559              	.LBB7:
2080:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
 560              		.loc 1 2080 9 is_stmt 1 view .LVU183
2081:Src/mpu6050.c ****             return -1;
 561              		.loc 1 2081 9 view .LVU184
2081:Src/mpu6050.c ****             return -1;
 562              		.loc 1 2081 13 is_stmt 0 view .LVU185
 563 02e8 D4E90010 		ldrd	r1, r0, [r4]
 564 02ec 0C22     		movs	r2, #12
 565 02ee 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 566 02f0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 567 02f2 01AB     		add	r3, sp, #4
 568 02f4 FFF7FEFF 		bl	i2c_readBytes
 569              	.LVL37:
2081:Src/mpu6050.c ****             return -1;
 570              		.loc 1 2081 12 view .LVU186
 571 02f8 08F10108 		add	r8, r8, #1
 572              	.LVL38:
2081:Src/mpu6050.c ****             return -1;
 573              		.loc 1 2081 12 view .LVU187
 574 02fc 0028     		cmp	r0, #0
 575 02fe 7FF496AE 		bne	.L4
2083:Src/mpu6050.c ****         accel_cur[1] = ((short)data[2] << 8) | data[3];
 576              		.loc 1 2083 9 is_stmt 1 view .LVU188
 577              	.LVL39:
2084:Src/mpu6050.c ****         accel_cur[2] = ((short)data[4] << 8) | data[5];
 578              		.loc 1 2084 9 view .LVU189
 579 0302 BDF80630 		ldrh	r3, [sp, #6]
 580 0306 D9BA     		revsh	r1, r3
 581              	.LVL40:
2085:Src/mpu6050.c ****         accel[0] += (long)accel_cur[0];
 582              		.loc 1 2085 9 view .LVU190
 583 0308 BDF80830 		ldrh	r3, [sp, #8]
 584 030c DABA     		revsh	r2, r3
 585              	.LVL41:
2086:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 586              		.loc 1 2086 9 view .LVU191
2086:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 587              		.loc 1 2086 21 is_stmt 0 view .LVU192
 588 030e BDF80430 		ldrh	r3, [sp, #4]
 589 0312 D8BA     		revsh	r0, r3
2086:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 590              		.loc 1 2086 18 view .LVU193
 591 0314 2B68     		ldr	r3, [r5]
 592 0316 0344     		add	r3, r3, r0
 593 0318 2B60     		str	r3, [r5]
2087:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
 594              		.loc 1 2087 9 is_stmt 1 view .LVU194
2087:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
 595              		.loc 1 2087 18 is_stmt 0 view .LVU195
 596 031a 6B68     		ldr	r3, [r5, #4]
 597 031c 0B44     		add	r3, r3, r1
 598 031e 6B60     		str	r3, [r5, #4]
ARM GAS  /tmp/cc39PcX6.s 			page 52


2088:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
 599              		.loc 1 2088 9 is_stmt 1 view .LVU196
2088:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
 600              		.loc 1 2088 18 is_stmt 0 view .LVU197
 601 0320 AB68     		ldr	r3, [r5, #8]
 602 0322 1344     		add	r3, r3, r2
 603 0324 AB60     		str	r3, [r5, #8]
2089:Src/mpu6050.c ****         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
 604              		.loc 1 2089 9 is_stmt 1 view .LVU198
 605              	.LVL42:
2090:Src/mpu6050.c ****         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
 606              		.loc 1 2090 9 view .LVU199
 607 0326 BDF80C30 		ldrh	r3, [sp, #12]
 608 032a D9BA     		revsh	r1, r3
 609              	.LVL43:
2091:Src/mpu6050.c ****         gyro[0] += (long)gyro_cur[0];
 610              		.loc 1 2091 9 view .LVU200
 611 032c BDF80E30 		ldrh	r3, [sp, #14]
 612 0330 DABA     		revsh	r2, r3
 613              	.LVL44:
2092:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 614              		.loc 1 2092 9 view .LVU201
2092:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 615              		.loc 1 2092 20 is_stmt 0 view .LVU202
 616 0332 BDF80A30 		ldrh	r3, [sp, #10]
 617 0336 D8BA     		revsh	r0, r3
2092:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 618              		.loc 1 2092 17 view .LVU203
 619 0338 3368     		ldr	r3, [r6]
 620 033a 0344     		add	r3, r3, r0
 621 033c 3360     		str	r3, [r6]
2093:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
 622              		.loc 1 2093 9 is_stmt 1 view .LVU204
2093:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
 623              		.loc 1 2093 17 is_stmt 0 view .LVU205
 624 033e 7368     		ldr	r3, [r6, #4]
 625 0340 0B44     		add	r3, r3, r1
 626 0342 7360     		str	r3, [r6, #4]
2094:Src/mpu6050.c ****     }
 627              		.loc 1 2094 9 is_stmt 1 view .LVU206
2094:Src/mpu6050.c ****     }
 628              		.loc 1 2094 17 is_stmt 0 view .LVU207
 629 0344 B368     		ldr	r3, [r6, #8]
 630 0346 1344     		add	r3, r3, r2
 631 0348 B360     		str	r3, [r6, #8]
 632              	.LBE7:
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 633              		.loc 1 2079 37 is_stmt 1 view .LVU208
 634              	.LVL45:
2079:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 635              		.loc 1 2079 37 is_stmt 0 view .LVU209
 636 034a 4DE7     		b	.L8
 637              		.cfi_endproc
 638              	.LFE99:
 640              		.section	.rodata.mpu_tap_func.str1.1,"aMS",%progbits,1
 641              	.LC0:
 642 0000 54617020 		.ascii	"Tap X+ \000"
ARM GAS  /tmp/cc39PcX6.s 			page 53


 642      582B2000 
 643              	.LC1:
 644 0008 54617020 		.ascii	"Tap X- \000"
 644      582D2000 
 645              	.LC2:
 646 0010 54617020 		.ascii	"Tap Y+ \000"
 646      592B2000 
 647              	.LC3:
 648 0018 54617020 		.ascii	"Tap Y- \000"
 648      592D2000 
 649              	.LC4:
 650 0020 54617020 		.ascii	"Tap Z+ \000"
 650      5A2B2000 
 651              	.LC5:
 652 0028 54617020 		.ascii	"Tap Z- \000"
 652      5A2D2000 
 653              		.section	.text.mpu_tap_func,"ax",%progbits
 654              		.align	1
 655              		.global	mpu_tap_func
 656              		.syntax unified
 657              		.thumb
 658              		.thumb_func
 659              		.fpu softvfp
 661              	mpu_tap_func:
 662              	.LVL46:
 663              	.LFB118:
2129:Src/mpu6050.c **** 
2130:Src/mpu6050.c **** #ifdef MPU6500
2131:Src/mpu6050.c **** #define REG_6500_XG_ST_DATA     0x0
2132:Src/mpu6050.c **** #define REG_6500_XA_ST_DATA     0xD
2133:Src/mpu6050.c **** static const unsigned short mpu_6500_st_tb[256] = {
2134:Src/mpu6050.c ****     2620,2646,2672,2699,2726,2753,2781,2808, //7
2135:Src/mpu6050.c ****     2837,2865,2894,2923,2952,2981,3011,3041, //15
2136:Src/mpu6050.c ****     3072,3102,3133,3165,3196,3228,3261,3293, //23
2137:Src/mpu6050.c ****     3326,3359,3393,3427,3461,3496,3531,3566, //31
2138:Src/mpu6050.c ****     3602,3638,3674,3711,3748,3786,3823,3862, //39
2139:Src/mpu6050.c ****     3900,3939,3979,4019,4059,4099,4140,4182, //47
2140:Src/mpu6050.c ****     4224,4266,4308,4352,4395,4439,4483,4528, //55
2141:Src/mpu6050.c ****     4574,4619,4665,4712,4759,4807,4855,4903, //63
2142:Src/mpu6050.c ****     4953,5002,5052,5103,5154,5205,5257,5310, //71
2143:Src/mpu6050.c ****     5363,5417,5471,5525,5581,5636,5693,5750, //79
2144:Src/mpu6050.c ****     5807,5865,5924,5983,6043,6104,6165,6226, //87
2145:Src/mpu6050.c ****     6289,6351,6415,6479,6544,6609,6675,6742, //95
2146:Src/mpu6050.c ****     6810,6878,6946,7016,7086,7157,7229,7301, //103
2147:Src/mpu6050.c ****     7374,7448,7522,7597,7673,7750,7828,7906, //111
2148:Src/mpu6050.c ****     7985,8065,8145,8227,8309,8392,8476,8561, //119
2149:Src/mpu6050.c ****     8647,8733,8820,8909,8998,9088,9178,9270,
2150:Src/mpu6050.c ****     9363,9457,9551,9647,9743,9841,9939,10038,
2151:Src/mpu6050.c ****     10139,10240,10343,10446,10550,10656,10763,10870,
2152:Src/mpu6050.c ****     10979,11089,11200,11312,11425,11539,11654,11771,
2153:Src/mpu6050.c ****     11889,12008,12128,12249,12371,12495,12620,12746,
2154:Src/mpu6050.c ****     12874,13002,13132,13264,13396,13530,13666,13802,
2155:Src/mpu6050.c ****     13940,14080,14221,14363,14506,14652,14798,14946,
2156:Src/mpu6050.c ****     15096,15247,15399,15553,15709,15866,16024,16184,
2157:Src/mpu6050.c ****     16346,16510,16675,16842,17010,17180,17352,17526,
2158:Src/mpu6050.c ****     17701,17878,18057,18237,18420,18604,18790,18978,
2159:Src/mpu6050.c ****     19167,19359,19553,19748,19946,20145,20347,20550,
ARM GAS  /tmp/cc39PcX6.s 			page 54


2160:Src/mpu6050.c ****     20756,20963,21173,21385,21598,21814,22033,22253,
2161:Src/mpu6050.c ****     22475,22700,22927,23156,23388,23622,23858,24097,
2162:Src/mpu6050.c ****     24338,24581,24827,25075,25326,25579,25835,26093,
2163:Src/mpu6050.c ****     26354,26618,26884,27153,27424,27699,27976,28255,
2164:Src/mpu6050.c ****     28538,28823,29112,29403,29697,29994,30294,30597,
2165:Src/mpu6050.c ****     30903,31212,31524,31839,32157,32479,32804,33132
2166:Src/mpu6050.c **** };
2167:Src/mpu6050.c **** static int accel_6500_self_test(long *bias_regular, long *bias_st, int debug)
2168:Src/mpu6050.c **** {
2169:Src/mpu6050.c ****     int i, result = 0, otp_value_zero = 0;
2170:Src/mpu6050.c ****     float accel_st_al_min, accel_st_al_max;
2171:Src/mpu6050.c ****     float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], accel_offset_max;
2172:Src/mpu6050.c ****     unsigned char regs[3];
2173:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, REG_6500_XA_ST_DATA, 3, regs)) {
2174:Src/mpu6050.c ****         if(debug)
2175:Src/mpu6050.c ****             log_i("Reading OTP Register Error\r\n");
2176:Src/mpu6050.c ****         return 0x07;
2177:Src/mpu6050.c ****     }
2178:Src/mpu6050.c ****     if(debug)
2179:Src/mpu6050.c ****         log_i("Accel OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
2180:Src/mpu6050.c ****     for (i = 0; i < 3; i++) {
2181:Src/mpu6050.c ****         if (regs[i] != 0) {
2182:Src/mpu6050.c ****             ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
2183:Src/mpu6050.c ****             ct_shift_prod[i] *= 65536.f;
2184:Src/mpu6050.c ****             ct_shift_prod[i] /= test.accel_sens;
2185:Src/mpu6050.c ****         }
2186:Src/mpu6050.c ****         else {
2187:Src/mpu6050.c ****             ct_shift_prod[i] = 0;
2188:Src/mpu6050.c ****             otp_value_zero = 1;
2189:Src/mpu6050.c ****         }
2190:Src/mpu6050.c ****     }
2191:Src/mpu6050.c ****     if(otp_value_zero == 0) {
2192:Src/mpu6050.c ****         if(debug)
2193:Src/mpu6050.c ****             log_i("ACCEL:CRITERIA A\r\n");
2194:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2195:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2196:Src/mpu6050.c ****             if(debug) {
2197:Src/mpu6050.c ****                 log_i("Bias_Shift=%ld, Bias_Reg=%ld, Bias_HWST=%ld\r\n",
2198:Src/mpu6050.c ****                         (long)st_shift_cust[i], bias_regular[i],
2199:Src/mpu6050.c ****                         bias_st[i]);
2200:Src/mpu6050.c ****                 log_i("OTP value: %ld\r\n", (long)ct_shift_prod[i]);
2201:Src/mpu6050.c ****             }
2202:Src/mpu6050.c **** 
2203:Src/mpu6050.c ****             st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i] - 1.f;
2204:Src/mpu6050.c **** 
2205:Src/mpu6050.c ****             if(debug)
2206:Src/mpu6050.c ****                 log_i("ratio=%ld, threshold=%ld\r\n", (long)st_shift_ratio[i],
2207:Src/mpu6050.c ****                             (long)test.max_accel_var);
2208:Src/mpu6050.c **** 
2209:Src/mpu6050.c ****             if (fabs(st_shift_ratio[i]) > test.max_accel_var) {
2210:Src/mpu6050.c ****                 if(debug)
2211:Src/mpu6050.c ****                     log_i("ACCEL Fail Axis = %d\r\n", i);
2212:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2213:Src/mpu6050.c ****             }
2214:Src/mpu6050.c ****         }
2215:Src/mpu6050.c ****     }
2216:Src/mpu6050.c ****     else {
ARM GAS  /tmp/cc39PcX6.s 			page 55


2217:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria B */
2218:Src/mpu6050.c ****         accel_st_al_min = test.min_g * 65536.f;
2219:Src/mpu6050.c ****         accel_st_al_max = test.max_g * 65536.f;
2220:Src/mpu6050.c **** 
2221:Src/mpu6050.c ****         if(debug) {
2222:Src/mpu6050.c ****             log_i("ACCEL:CRITERIA B\r\n");
2223:Src/mpu6050.c ****             log_i("Min MG: %ld\r\n", (long)accel_st_al_min);
2224:Src/mpu6050.c ****             log_i("Max MG: %ld\r\n", (long)accel_st_al_max);
2225:Src/mpu6050.c ****         }
2226:Src/mpu6050.c **** 
2227:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2228:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2229:Src/mpu6050.c **** 
2230:Src/mpu6050.c ****             if(debug)
2231:Src/mpu6050.c ****                 log_i("Bias_shift=%ld, st=%ld, reg=%ld\r\n", (long)st_shift_cust[i], bias_st[i], bi
2232:Src/mpu6050.c ****             if(st_shift_cust[i] < accel_st_al_min || st_shift_cust[i] > accel_st_al_max) {
2233:Src/mpu6050.c ****                 if(debug)
2234:Src/mpu6050.c ****                     log_i("Accel FAIL axis:%d <= 225mg or >= 675mg\r\n", i);
2235:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2236:Src/mpu6050.c ****             }
2237:Src/mpu6050.c ****         }
2238:Src/mpu6050.c ****     }
2239:Src/mpu6050.c **** 
2240:Src/mpu6050.c ****     if(result == 0) {
2241:Src/mpu6050.c ****     /* Self Test Pass/Fail Criteria C */
2242:Src/mpu6050.c ****         accel_offset_max = test.max_g_offset * 65536.f;
2243:Src/mpu6050.c ****         if(debug)
2244:Src/mpu6050.c ****             log_i("Accel:CRITERIA C: bias less than %ld\n", (long)accel_offset_max);
2245:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2246:Src/mpu6050.c ****             if(fabs(bias_regular[i]) > accel_offset_max) {
2247:Src/mpu6050.c ****                 if(debug)
2248:Src/mpu6050.c ****                     log_i("FAILED: Accel axis:%d = %ld > 500mg\n", i, bias_regular[i]);
2249:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2250:Src/mpu6050.c ****             }
2251:Src/mpu6050.c ****         }
2252:Src/mpu6050.c ****     }
2253:Src/mpu6050.c **** 
2254:Src/mpu6050.c ****     return result;
2255:Src/mpu6050.c **** }
2256:Src/mpu6050.c **** 
2257:Src/mpu6050.c **** static int gyro_6500_self_test(long *bias_regular, long *bias_st, int debug)
2258:Src/mpu6050.c **** {
2259:Src/mpu6050.c ****     int i, result = 0, otp_value_zero = 0;
2260:Src/mpu6050.c ****     float gyro_st_al_max;
2261:Src/mpu6050.c ****     float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], gyro_offset_max;
2262:Src/mpu6050.c ****     unsigned char regs[3];
2263:Src/mpu6050.c **** 
2264:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, REG_6500_XG_ST_DATA, 3, regs)) {
2265:Src/mpu6050.c ****         if(debug)
2266:Src/mpu6050.c ****             log_i("Reading OTP Register Error.\n");
2267:Src/mpu6050.c ****         return 0x07;
2268:Src/mpu6050.c ****     }
2269:Src/mpu6050.c **** 
2270:Src/mpu6050.c ****     if(debug)
2271:Src/mpu6050.c ****         log_i("Gyro OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
2272:Src/mpu6050.c **** 
2273:Src/mpu6050.c ****     for (i = 0; i < 3; i++) {
ARM GAS  /tmp/cc39PcX6.s 			page 56


2274:Src/mpu6050.c ****         if (regs[i] != 0) {
2275:Src/mpu6050.c ****             ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
2276:Src/mpu6050.c ****             ct_shift_prod[i] *= 65536.f;
2277:Src/mpu6050.c ****             ct_shift_prod[i] /= test.gyro_sens;
2278:Src/mpu6050.c ****         }
2279:Src/mpu6050.c ****         else {
2280:Src/mpu6050.c ****             ct_shift_prod[i] = 0;
2281:Src/mpu6050.c ****             otp_value_zero = 1;
2282:Src/mpu6050.c ****         }
2283:Src/mpu6050.c ****     }
2284:Src/mpu6050.c **** 
2285:Src/mpu6050.c ****     if(otp_value_zero == 0) {
2286:Src/mpu6050.c ****         if(debug)
2287:Src/mpu6050.c ****             log_i("GYRO:CRITERIA A\n");
2288:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria A */
2289:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2290:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2291:Src/mpu6050.c **** 
2292:Src/mpu6050.c ****             if(debug) {
2293:Src/mpu6050.c ****                 log_i("Bias_Shift=%ld, Bias_Reg=%ld, Bias_HWST=%ld\r\n",
2294:Src/mpu6050.c ****                         (long)st_shift_cust[i], bias_regular[i],
2295:Src/mpu6050.c ****                         bias_st[i]);
2296:Src/mpu6050.c ****                 log_i("OTP value: %ld\r\n", (long)ct_shift_prod[i]);
2297:Src/mpu6050.c ****             }
2298:Src/mpu6050.c **** 
2299:Src/mpu6050.c ****             st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i];
2300:Src/mpu6050.c **** 
2301:Src/mpu6050.c ****             if(debug)
2302:Src/mpu6050.c ****                 log_i("ratio=%ld, threshold=%ld\r\n", (long)st_shift_ratio[i],
2303:Src/mpu6050.c ****                             (long)test.max_gyro_var);
2304:Src/mpu6050.c **** 
2305:Src/mpu6050.c ****             if (fabs(st_shift_ratio[i]) < test.max_gyro_var) {
2306:Src/mpu6050.c ****                 if(debug)
2307:Src/mpu6050.c ****                     log_i("Gyro Fail Axis = %d\n", i);
2308:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2309:Src/mpu6050.c ****             }
2310:Src/mpu6050.c ****         }
2311:Src/mpu6050.c ****     }
2312:Src/mpu6050.c ****     else {
2313:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria B */
2314:Src/mpu6050.c ****         gyro_st_al_max = test.max_dps * 65536.f;
2315:Src/mpu6050.c **** 
2316:Src/mpu6050.c ****         if(debug) {
2317:Src/mpu6050.c ****             log_i("GYRO:CRITERIA B\r\n");
2318:Src/mpu6050.c ****             log_i("Max DPS: %ld\r\n", (long)gyro_st_al_max);
2319:Src/mpu6050.c ****         }
2320:Src/mpu6050.c **** 
2321:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2322:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2323:Src/mpu6050.c **** 
2324:Src/mpu6050.c ****             if(debug)
2325:Src/mpu6050.c ****                 log_i("Bias_shift=%ld, st=%ld, reg=%ld\r\n", (long)st_shift_cust[i], bias_st[i], bi
2326:Src/mpu6050.c ****             if(st_shift_cust[i] < gyro_st_al_max) {
2327:Src/mpu6050.c ****                 if(debug)
2328:Src/mpu6050.c ****                     log_i("GYRO FAIL axis:%d greater than 60dps\r\n", i);
2329:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2330:Src/mpu6050.c ****             }
ARM GAS  /tmp/cc39PcX6.s 			page 57


2331:Src/mpu6050.c ****         }
2332:Src/mpu6050.c ****     }
2333:Src/mpu6050.c **** 
2334:Src/mpu6050.c ****     if(result == 0) {
2335:Src/mpu6050.c ****     /* Self Test Pass/Fail Criteria C */
2336:Src/mpu6050.c ****         gyro_offset_max = test.min_dps * 65536.f;
2337:Src/mpu6050.c ****         if(debug)
2338:Src/mpu6050.c ****             log_i("Gyro:CRITERIA C: bias less than %ld\r\n", (long)gyro_offset_max);
2339:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2340:Src/mpu6050.c ****             if(fabs(bias_regular[i]) > gyro_offset_max) {
2341:Src/mpu6050.c ****                 if(debug)
2342:Src/mpu6050.c ****                     log_i("FAILED: Gyro axis:%d = %ld > 20dps\r\n", i, bias_regular[i]);
2343:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2344:Src/mpu6050.c ****             }
2345:Src/mpu6050.c ****         }
2346:Src/mpu6050.c ****     }
2347:Src/mpu6050.c ****     return result;
2348:Src/mpu6050.c **** }
2349:Src/mpu6050.c **** 
2350:Src/mpu6050.c **** static int get_st_6500_biases(long *gyro, long *accel, unsigned char hw_test, int debug)
2351:Src/mpu6050.c **** {
2352:Src/mpu6050.c ****     unsigned char data[HWST_MAX_PACKET_LENGTH];
2353:Src/mpu6050.c ****     unsigned char packet_count, ii;
2354:Src/mpu6050.c ****     unsigned short fifo_count;
2355:Src/mpu6050.c ****     int s = 0, read_size = 0, ind;
2356:Src/mpu6050.c **** 
2357:Src/mpu6050.c ****     data[0] = 0x01;
2358:Src/mpu6050.c ****     data[1] = 0;
2359:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
2360:Src/mpu6050.c ****         return -1;
2361:Src/mpu6050.c ****     delay_ms(200);
2362:Src/mpu6050.c ****     data[0] = 0;
2363:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
2364:Src/mpu6050.c ****         return -1;
2365:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2366:Src/mpu6050.c ****         return -1;
2367:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
2368:Src/mpu6050.c ****         return -1;
2369:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2370:Src/mpu6050.c ****         return -1;
2371:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2372:Src/mpu6050.c ****         return -1;
2373:Src/mpu6050.c ****     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
2374:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2375:Src/mpu6050.c ****         return -1;
2376:Src/mpu6050.c ****     delay_ms(15);
2377:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
2378:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
2379:Src/mpu6050.c ****         return -1;
2380:Src/mpu6050.c ****     data[0] = st.test->reg_rate_div;
2381:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
2382:Src/mpu6050.c ****         return -1;
2383:Src/mpu6050.c ****     if (hw_test)
2384:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
2385:Src/mpu6050.c ****     else
2386:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr;
2387:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
ARM GAS  /tmp/cc39PcX6.s 			page 58


2388:Src/mpu6050.c ****         return -1;
2389:Src/mpu6050.c **** 
2390:Src/mpu6050.c ****     if (hw_test)
2391:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
2392:Src/mpu6050.c ****     else
2393:Src/mpu6050.c ****         data[0] = test.reg_accel_fsr;
2394:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
2395:Src/mpu6050.c ****         return -1;
2396:Src/mpu6050.c **** 
2397:Src/mpu6050.c ****     delay_ms(test.wait_ms);  //wait 200ms for sensors to stabilize
2398:Src/mpu6050.c **** 
2399:Src/mpu6050.c ****     /* Enable FIFO */
2400:Src/mpu6050.c ****     data[0] = BIT_FIFO_EN;
2401:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2402:Src/mpu6050.c ****         return -1;
2403:Src/mpu6050.c ****     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2404:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2405:Src/mpu6050.c ****         return -1;
2406:Src/mpu6050.c **** 
2407:Src/mpu6050.c ****     //initialize the bias return values
2408:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
2409:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
2410:Src/mpu6050.c **** 
2411:Src/mpu6050.c ****     if(debug)
2412:Src/mpu6050.c ****         log_i("Starting Bias Loop Reads\r\n");
2413:Src/mpu6050.c **** 
2414:Src/mpu6050.c ****     //start reading samples
2415:Src/mpu6050.c ****     while (s < test.packet_thresh) {
2416:Src/mpu6050.c ****         delay_ms(test.sample_wait_ms); //wait 10ms to fill FIFO
2417:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
2418:Src/mpu6050.c ****             return -1;
2419:Src/mpu6050.c ****         fifo_count = (data[0] << 8) | data[1];
2420:Src/mpu6050.c ****         packet_count = fifo_count / MAX_PACKET_LENGTH;
2421:Src/mpu6050.c ****         if ((test.packet_thresh - s) < packet_count)
2422:Src/mpu6050.c ****                     packet_count = test.packet_thresh - s;
2423:Src/mpu6050.c ****         read_size = packet_count * MAX_PACKET_LENGTH;
2424:Src/mpu6050.c **** 
2425:Src/mpu6050.c ****         //burst read from FIFO
2426:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, read_size, data))
2427:Src/mpu6050.c ****                         return -1;
2428:Src/mpu6050.c ****         ind = 0;
2429:Src/mpu6050.c ****         for (ii = 0; ii < packet_count; ii++) {
2430:Src/mpu6050.c ****             short accel_cur[3], gyro_cur[3];
2431:Src/mpu6050.c ****             accel_cur[0] = ((short)data[ind + 0] << 8) | data[ind + 1];
2432:Src/mpu6050.c ****             accel_cur[1] = ((short)data[ind + 2] << 8) | data[ind + 3];
2433:Src/mpu6050.c ****             accel_cur[2] = ((short)data[ind + 4] << 8) | data[ind + 5];
2434:Src/mpu6050.c ****             accel[0] += (long)accel_cur[0];
2435:Src/mpu6050.c ****             accel[1] += (long)accel_cur[1];
2436:Src/mpu6050.c ****             accel[2] += (long)accel_cur[2];
2437:Src/mpu6050.c ****             gyro_cur[0] = (((short)data[ind + 6] << 8) | data[ind + 7]);
2438:Src/mpu6050.c ****             gyro_cur[1] = (((short)data[ind + 8] << 8) | data[ind + 9]);
2439:Src/mpu6050.c ****             gyro_cur[2] = (((short)data[ind + 10] << 8) | data[ind + 11]);
2440:Src/mpu6050.c ****             gyro[0] += (long)gyro_cur[0];
2441:Src/mpu6050.c ****             gyro[1] += (long)gyro_cur[1];
2442:Src/mpu6050.c ****             gyro[2] += (long)gyro_cur[2];
2443:Src/mpu6050.c ****             ind += MAX_PACKET_LENGTH;
2444:Src/mpu6050.c ****         }
ARM GAS  /tmp/cc39PcX6.s 			page 59


2445:Src/mpu6050.c ****         s += packet_count;
2446:Src/mpu6050.c ****     }
2447:Src/mpu6050.c **** 
2448:Src/mpu6050.c ****     if(debug)
2449:Src/mpu6050.c ****         log_i("Samples: %d\r\n", s);
2450:Src/mpu6050.c **** 
2451:Src/mpu6050.c ****     //stop FIFO
2452:Src/mpu6050.c ****     data[0] = 0;
2453:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2454:Src/mpu6050.c ****         return -1;
2455:Src/mpu6050.c **** 
2456:Src/mpu6050.c ****     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / s);
2457:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / s);
2458:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / s);
2459:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens / s);
2460:Src/mpu6050.c ****     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens / s);
2461:Src/mpu6050.c ****     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens / s);
2462:Src/mpu6050.c ****     /* remove gravity from bias calculation */
2463:Src/mpu6050.c ****     if (accel[2] > 0L)
2464:Src/mpu6050.c ****         accel[2] -= 65536L;
2465:Src/mpu6050.c ****     else
2466:Src/mpu6050.c ****         accel[2] += 65536L;
2467:Src/mpu6050.c **** 
2468:Src/mpu6050.c **** 
2469:Src/mpu6050.c ****     if(debug) {
2470:Src/mpu6050.c ****         log_i("Accel offset data HWST bit=%d: %ld %ld %ld\r\n", hw_test, accel[0], accel[1], accel[
2471:Src/mpu6050.c ****         log_i("Gyro offset data HWST bit=%d: %ld %ld %ld\r\n", hw_test, gyro[0], gyro[1], gyro[2]);
2472:Src/mpu6050.c ****     }
2473:Src/mpu6050.c **** 
2474:Src/mpu6050.c ****     return 0;
2475:Src/mpu6050.c **** }
2476:Src/mpu6050.c **** /**
2477:Src/mpu6050.c ****  *  @brief      Trigger gyro/accel/compass self-test for MPU6500/MPU9250
2478:Src/mpu6050.c ****  *  On success/error, the self-test returns a mask representing the sensor(s)
2479:Src/mpu6050.c ****  *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
2480:Src/mpu6050.c ****  *  a zero (0) indicates a failure.
2481:Src/mpu6050.c ****  *
2482:Src/mpu6050.c ****  *  \n The mask is defined as follows:
2483:Src/mpu6050.c ****  *  \n Bit 0:   Gyro.
2484:Src/mpu6050.c ****  *  \n Bit 1:   Accel.
2485:Src/mpu6050.c ****  *  \n Bit 2:   Compass.
2486:Src/mpu6050.c ****  *
2487:Src/mpu6050.c ****  *  @param[out] gyro        Gyro biases in q16 format.
2488:Src/mpu6050.c ****  *  @param[out] accel       Accel biases (if applicable) in q16 format.
2489:Src/mpu6050.c ****  *  @param[in]  debug       Debug flag used to print out more detailed logs. Must first set up logg
2490:Src/mpu6050.c ****  *  @return     Result mask (see above).
2491:Src/mpu6050.c ****  */
2492:Src/mpu6050.c **** int mpu_run_6500_self_test(long *gyro, long *accel, unsigned char debug)
2493:Src/mpu6050.c **** {
2494:Src/mpu6050.c ****     const unsigned char tries = 2;
2495:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
2496:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
2497:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2498:Src/mpu6050.c ****     unsigned char compass_result;
2499:Src/mpu6050.c **** #endif
2500:Src/mpu6050.c ****     int ii;
2501:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 60


2502:Src/mpu6050.c ****     int result;
2503:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
2504:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
2505:Src/mpu6050.c ****     unsigned char dmp_was_on;
2506:Src/mpu6050.c **** 
2507:Src/mpu6050.c **** 
2508:Src/mpu6050.c **** 
2509:Src/mpu6050.c ****     if(debug)
2510:Src/mpu6050.c ****         log_i("Starting MPU6500 HWST!\r\n");
2511:Src/mpu6050.c **** 
2512:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
2513:Src/mpu6050.c ****         mpu_set_dmp_state(0);
2514:Src/mpu6050.c ****         dmp_was_on = 1;
2515:Src/mpu6050.c ****     } else
2516:Src/mpu6050.c ****         dmp_was_on = 0;
2517:Src/mpu6050.c **** 
2518:Src/mpu6050.c ****     /* Get initial settings. */
2519:Src/mpu6050.c ****     mpu_get_gyro_fsr(&gyro_fsr);
2520:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
2521:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
2522:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
2523:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
2524:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
2525:Src/mpu6050.c **** 
2526:Src/mpu6050.c ****     if(debug)
2527:Src/mpu6050.c ****         log_i("Retrieving Biases\r\n");
2528:Src/mpu6050.c **** 
2529:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2530:Src/mpu6050.c ****         if (!get_st_6500_biases(gyro, accel, 0, debug))
2531:Src/mpu6050.c ****             break;
2532:Src/mpu6050.c ****     if (ii == tries) {
2533:Src/mpu6050.c ****         /* If we reach this point, we most likely encountered an I2C error.
2534:Src/mpu6050.c ****          * We'll just report an error for all three sensors.
2535:Src/mpu6050.c ****          */
2536:Src/mpu6050.c ****         if(debug)
2537:Src/mpu6050.c ****             log_i("Retrieving Biases Error - possible I2C error\r\n");
2538:Src/mpu6050.c **** 
2539:Src/mpu6050.c ****         result = 0;
2540:Src/mpu6050.c ****         goto restore;
2541:Src/mpu6050.c ****     }
2542:Src/mpu6050.c **** 
2543:Src/mpu6050.c ****     if(debug)
2544:Src/mpu6050.c ****         log_i("Retrieving ST Biases\r\n");
2545:Src/mpu6050.c **** 
2546:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2547:Src/mpu6050.c ****         if (!get_st_6500_biases(gyro_st, accel_st, 1, debug))
2548:Src/mpu6050.c ****             break;
2549:Src/mpu6050.c ****     if (ii == tries) {
2550:Src/mpu6050.c **** 
2551:Src/mpu6050.c ****         if(debug)
2552:Src/mpu6050.c ****             log_i("Retrieving ST Biases Error - possible I2C error\r\n");
2553:Src/mpu6050.c **** 
2554:Src/mpu6050.c ****         /* Again, probably an I2C error. */
2555:Src/mpu6050.c ****         result = 0;
2556:Src/mpu6050.c ****         goto restore;
2557:Src/mpu6050.c ****     }
2558:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 61


2559:Src/mpu6050.c ****     accel_result = accel_6500_self_test(accel, accel_st, debug);
2560:Src/mpu6050.c ****     if(debug)
2561:Src/mpu6050.c ****         log_i("Accel Self Test Results: %d\r\n", accel_result);
2562:Src/mpu6050.c **** 
2563:Src/mpu6050.c ****     gyro_result = gyro_6500_self_test(gyro, gyro_st, debug);
2564:Src/mpu6050.c ****     if(debug)
2565:Src/mpu6050.c ****         log_i("Gyro Self Test Results: %d\r\n", gyro_result);
2566:Src/mpu6050.c **** 
2567:Src/mpu6050.c ****     result = 0;
2568:Src/mpu6050.c ****     if (!gyro_result)
2569:Src/mpu6050.c ****         result |= 0x01;
2570:Src/mpu6050.c ****     if (!accel_result)
2571:Src/mpu6050.c ****         result |= 0x02;
2572:Src/mpu6050.c **** 
2573:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2574:Src/mpu6050.c ****     compass_result = compass_self_test();
2575:Src/mpu6050.c ****     if(debug)
2576:Src/mpu6050.c ****         log_i("Compass Self Test Results: %d\r\n", compass_result);
2577:Src/mpu6050.c ****     if (!compass_result)
2578:Src/mpu6050.c ****         result |= 0x04;
2579:Src/mpu6050.c **** #else
2580:Src/mpu6050.c ****     result |= 0x04;
2581:Src/mpu6050.c **** #endif
2582:Src/mpu6050.c **** restore:
2583:Src/mpu6050.c ****     if(debug)
2584:Src/mpu6050.c ****         log_i("Exiting HWST\r\n");
2585:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
2586:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
2587:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
2588:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
2589:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
2590:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
2591:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
2592:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
2593:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
2594:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
2595:Src/mpu6050.c ****     mpu_set_lpf(lpf);
2596:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
2597:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
2598:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
2599:Src/mpu6050.c **** 
2600:Src/mpu6050.c ****     if (dmp_was_on)
2601:Src/mpu6050.c ****         mpu_set_dmp_state(1);
2602:Src/mpu6050.c **** 
2603:Src/mpu6050.c ****     return result;
2604:Src/mpu6050.c **** }
2605:Src/mpu6050.c **** #endif
2606:Src/mpu6050.c ****  /*
2607:Src/mpu6050.c ****  *  \n This function must be called with the device either face-up or face-down
2608:Src/mpu6050.c ****  *  (z-axis is parallel to gravity).
2609:Src/mpu6050.c ****  *  @param[out] gyro        Gyro biases in q16 format.
2610:Src/mpu6050.c ****  *  @param[out] accel       Accel biases (if applicable) in q16 format.
2611:Src/mpu6050.c ****  *  @return     Result mask (see above).
2612:Src/mpu6050.c ****  */
2613:Src/mpu6050.c **** int mpu_run_self_test(long *gyro, long *accel)
2614:Src/mpu6050.c **** {
2615:Src/mpu6050.c **** #ifdef MPU6050
ARM GAS  /tmp/cc39PcX6.s 			page 62


2616:Src/mpu6050.c ****     const unsigned char tries = 2;
2617:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
2618:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
2619:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2620:Src/mpu6050.c ****     unsigned char compass_result;
2621:Src/mpu6050.c **** #endif
2622:Src/mpu6050.c ****     int ii;
2623:Src/mpu6050.c **** #endif
2624:Src/mpu6050.c ****     int result;
2625:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
2626:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
2627:Src/mpu6050.c ****     unsigned char dmp_was_on;
2628:Src/mpu6050.c **** 
2629:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
2630:Src/mpu6050.c ****         mpu_set_dmp_state(0);
2631:Src/mpu6050.c ****         dmp_was_on = 1;
2632:Src/mpu6050.c ****     } else
2633:Src/mpu6050.c ****         dmp_was_on = 0;
2634:Src/mpu6050.c **** 
2635:Src/mpu6050.c ****     /* Get initial settings. */
2636:Src/mpu6050.c ****     mpu_get_gyro_fsr(&gyro_fsr);
2637:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
2638:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
2639:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
2640:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
2641:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
2642:Src/mpu6050.c **** 
2643:Src/mpu6050.c ****     /* For older chips, the self-test will be different. */
2644:Src/mpu6050.c **** #if defined MPU6050
2645:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2646:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
2647:Src/mpu6050.c ****             break;
2648:Src/mpu6050.c ****     if (ii == tries) {
2649:Src/mpu6050.c ****         /* If we reach this point, we most likely encountered an I2C error.
2650:Src/mpu6050.c ****          * We'll just report an error for all three sensors.
2651:Src/mpu6050.c ****          */
2652:Src/mpu6050.c ****         result = 0;
2653:Src/mpu6050.c ****         goto restore;
2654:Src/mpu6050.c ****     }
2655:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2656:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
2657:Src/mpu6050.c ****             break;
2658:Src/mpu6050.c ****     if (ii == tries) {
2659:Src/mpu6050.c ****         /* Again, probably an I2C error. */
2660:Src/mpu6050.c ****         result = 0;
2661:Src/mpu6050.c ****         goto restore;
2662:Src/mpu6050.c ****     }
2663:Src/mpu6050.c ****     accel_result = accel_self_test(accel, accel_st);
2664:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
2665:Src/mpu6050.c **** 
2666:Src/mpu6050.c ****     result = 0;
2667:Src/mpu6050.c ****     if (!gyro_result)
2668:Src/mpu6050.c ****         result |= 0x01;
2669:Src/mpu6050.c ****     if (!accel_result)
2670:Src/mpu6050.c ****         result |= 0x02;
2671:Src/mpu6050.c **** 
2672:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
ARM GAS  /tmp/cc39PcX6.s 			page 63


2673:Src/mpu6050.c ****     compass_result = compass_self_test();
2674:Src/mpu6050.c ****     if (!compass_result)
2675:Src/mpu6050.c ****         result |= 0x04;
2676:Src/mpu6050.c **** #else
2677:Src/mpu6050.c ****         result |= 0x04;
2678:Src/mpu6050.c **** #endif
2679:Src/mpu6050.c **** restore:
2680:Src/mpu6050.c **** #elif defined MPU6500
2681:Src/mpu6050.c ****     /* For now, this function will return a "pass" result for all three sensors
2682:Src/mpu6050.c ****      * for compatibility with current test applications.
2683:Src/mpu6050.c ****      */
2684:Src/mpu6050.c ****     get_st_biases(gyro, accel, 0);
2685:Src/mpu6050.c ****     result = 0x7;
2686:Src/mpu6050.c **** #endif
2687:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
2688:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
2689:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
2690:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
2691:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
2692:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
2693:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
2694:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
2695:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
2696:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
2697:Src/mpu6050.c ****     mpu_set_lpf(lpf);
2698:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
2699:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
2700:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
2701:Src/mpu6050.c **** 
2702:Src/mpu6050.c ****     if (dmp_was_on)
2703:Src/mpu6050.c ****         mpu_set_dmp_state(1);
2704:Src/mpu6050.c **** 
2705:Src/mpu6050.c ****     return result;
2706:Src/mpu6050.c **** }
2707:Src/mpu6050.c **** 
2708:Src/mpu6050.c **** /**
2709:Src/mpu6050.c ****  *  @brief      Write to the DMP memory.
2710:Src/mpu6050.c ****  *  This function prevents I2C writes past the bank boundaries. The DMP memory
2711:Src/mpu6050.c ****  *  is only accessible when the chip is awake.
2712:Src/mpu6050.c ****  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2713:Src/mpu6050.c ****  *  @param[in]  length      Number of bytes to write.
2714:Src/mpu6050.c ****  *  @param[in]  data        Bytes to write to memory.
2715:Src/mpu6050.c ****  *  @return     0 if successful.
2716:Src/mpu6050.c ****  */
2717:Src/mpu6050.c **** int mpu_write_mem(unsigned short mem_addr, unsigned short length,
2718:Src/mpu6050.c ****         unsigned char *data)
2719:Src/mpu6050.c **** {
2720:Src/mpu6050.c ****     unsigned char tmp[2];
2721:Src/mpu6050.c **** 
2722:Src/mpu6050.c ****     if (!data)
2723:Src/mpu6050.c ****         return -1;
2724:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
2725:Src/mpu6050.c ****         return -1;
2726:Src/mpu6050.c **** 
2727:Src/mpu6050.c ****     tmp[0] = (unsigned char)(mem_addr >> 8);
2728:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
2729:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 64


2730:Src/mpu6050.c ****     /* Check bank boundaries. */
2731:Src/mpu6050.c ****     if (tmp[1] + length > st.hw->bank_size)
2732:Src/mpu6050.c ****         return -1;
2733:Src/mpu6050.c **** 
2734:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2735:Src/mpu6050.c ****         return -1;
2736:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
2737:Src/mpu6050.c ****         return -1;
2738:Src/mpu6050.c ****     return 0;
2739:Src/mpu6050.c **** }
2740:Src/mpu6050.c **** 
2741:Src/mpu6050.c **** /**
2742:Src/mpu6050.c ****  *  @brief      Read from the DMP memory.
2743:Src/mpu6050.c ****  *  This function prevents I2C reads past the bank boundaries. The DMP memory
2744:Src/mpu6050.c ****  *  is only accessible when the chip is awake.
2745:Src/mpu6050.c ****  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2746:Src/mpu6050.c ****  *  @param[in]  length      Number of bytes to read.
2747:Src/mpu6050.c ****  *  @param[out] data        Bytes read from memory.
2748:Src/mpu6050.c ****  *  @return     0 if successful.
2749:Src/mpu6050.c ****  */
2750:Src/mpu6050.c **** int mpu_read_mem(unsigned short mem_addr, unsigned short length,
2751:Src/mpu6050.c ****         unsigned char *data)
2752:Src/mpu6050.c **** {
2753:Src/mpu6050.c ****     unsigned char tmp[2];
2754:Src/mpu6050.c **** 
2755:Src/mpu6050.c ****     if (!data)
2756:Src/mpu6050.c ****         return -1;
2757:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
2758:Src/mpu6050.c ****         return -1;
2759:Src/mpu6050.c **** 
2760:Src/mpu6050.c ****     tmp[0] = (unsigned char)(mem_addr >> 8);
2761:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
2762:Src/mpu6050.c **** 
2763:Src/mpu6050.c ****     /* Check bank boundaries. */
2764:Src/mpu6050.c ****     if (tmp[1] + length > st.hw->bank_size)
2765:Src/mpu6050.c ****         return -1;
2766:Src/mpu6050.c **** 
2767:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2768:Src/mpu6050.c ****         return -1;
2769:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
2770:Src/mpu6050.c ****         return -1;
2771:Src/mpu6050.c ****     return 0;
2772:Src/mpu6050.c **** }
2773:Src/mpu6050.c **** 
2774:Src/mpu6050.c **** /**
2775:Src/mpu6050.c ****  *  @brief      Load and verify DMP image.
2776:Src/mpu6050.c ****  *  @param[in]  length      Length of DMP image.
2777:Src/mpu6050.c ****  *  @param[in]  firmware    DMP code.
2778:Src/mpu6050.c ****  *  @param[in]  start_addr  Starting address of DMP code memory.
2779:Src/mpu6050.c ****  *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
2780:Src/mpu6050.c ****  *  @return     0 if successful.
2781:Src/mpu6050.c ****  */
2782:Src/mpu6050.c **** int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
2783:Src/mpu6050.c ****     unsigned short start_addr, unsigned short sample_rate)
2784:Src/mpu6050.c **** {
2785:Src/mpu6050.c ****     unsigned short ii;
2786:Src/mpu6050.c ****     unsigned short this_write;
ARM GAS  /tmp/cc39PcX6.s 			page 65


2787:Src/mpu6050.c ****     /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
2788:Src/mpu6050.c **** #define LOAD_CHUNK  (16)
2789:Src/mpu6050.c ****     unsigned char cur[LOAD_CHUNK], tmp[2];
2790:Src/mpu6050.c **** 
2791:Src/mpu6050.c ****     if (st.chip_cfg.dmp_loaded)
2792:Src/mpu6050.c ****         /* DMP should only be loaded once. */
2793:Src/mpu6050.c ****         return -1;
2794:Src/mpu6050.c **** 
2795:Src/mpu6050.c ****     if (!firmware)
2796:Src/mpu6050.c ****         return -1;
2797:Src/mpu6050.c ****     for (ii = 0; ii < length; ii += this_write) {
2798:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
2799:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
2800:Src/mpu6050.c ****             return -1;
2801:Src/mpu6050.c ****         if (mpu_read_mem(ii, this_write, cur))
2802:Src/mpu6050.c ****             return -1;
2803:Src/mpu6050.c ****         if (memcmp(firmware+ii, cur, this_write))
2804:Src/mpu6050.c ****             return -2;
2805:Src/mpu6050.c ****     }
2806:Src/mpu6050.c **** 
2807:Src/mpu6050.c ****     /* Set program start address. */
2808:Src/mpu6050.c ****     tmp[0] = start_addr >> 8;
2809:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
2810:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
2811:Src/mpu6050.c ****         return -1;
2812:Src/mpu6050.c **** 
2813:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 1;
2814:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
2815:Src/mpu6050.c ****     return 0;
2816:Src/mpu6050.c **** }
2817:Src/mpu6050.c **** 
2818:Src/mpu6050.c **** /**
2819:Src/mpu6050.c ****  *  @brief      Enable/disable DMP support.
2820:Src/mpu6050.c ****  *  @param[in]  enable  1 to turn on the DMP.
2821:Src/mpu6050.c ****  *  @return     0 if successful.
2822:Src/mpu6050.c ****  */
2823:Src/mpu6050.c **** int mpu_set_dmp_state(unsigned char enable)
2824:Src/mpu6050.c **** {
2825:Src/mpu6050.c ****     unsigned char tmp;
2826:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on == enable)
2827:Src/mpu6050.c ****         return 0;
2828:Src/mpu6050.c **** 
2829:Src/mpu6050.c ****     if (enable) {
2830:Src/mpu6050.c ****         if (!st.chip_cfg.dmp_loaded)
2831:Src/mpu6050.c ****             return -1;
2832:Src/mpu6050.c ****         /* Disable data ready interrupt. */
2833:Src/mpu6050.c ****         set_int_enable(0);
2834:Src/mpu6050.c ****         /* Disable bypass mode. */
2835:Src/mpu6050.c ****         mpu_set_bypass(0);
2836:Src/mpu6050.c ****         /* Keep constant sample rate, FIFO rate controlled by DMP. */
2837:Src/mpu6050.c ****         mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
2838:Src/mpu6050.c ****         /* Remove FIFO elements. */
2839:Src/mpu6050.c ****         tmp = 0;
2840:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
2841:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 1;
2842:Src/mpu6050.c ****         /* Enable DMP interrupt. */
2843:Src/mpu6050.c ****         set_int_enable(1);
ARM GAS  /tmp/cc39PcX6.s 			page 66


2844:Src/mpu6050.c ****         mpu_reset_fifo();
2845:Src/mpu6050.c ****     } else {
2846:Src/mpu6050.c ****         /* Disable DMP interrupt. */
2847:Src/mpu6050.c ****         set_int_enable(0);
2848:Src/mpu6050.c ****         /* Restore FIFO settings. */
2849:Src/mpu6050.c ****         tmp = st.chip_cfg.fifo_enable;
2850:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
2851:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
2852:Src/mpu6050.c ****         mpu_reset_fifo();
2853:Src/mpu6050.c ****     }
2854:Src/mpu6050.c ****     return 0;
2855:Src/mpu6050.c **** }
2856:Src/mpu6050.c **** 
2857:Src/mpu6050.c **** /**
2858:Src/mpu6050.c ****  *  @brief      Get DMP state.
2859:Src/mpu6050.c ****  *  @param[out] enabled 1 if enabled.
2860:Src/mpu6050.c ****  *  @return     0 if successful.
2861:Src/mpu6050.c ****  */
2862:Src/mpu6050.c **** int mpu_get_dmp_state(unsigned char *enabled)
2863:Src/mpu6050.c **** {
2864:Src/mpu6050.c ****     enabled[0] = st.chip_cfg.dmp_on;
2865:Src/mpu6050.c ****     return 0;
2866:Src/mpu6050.c **** }
2867:Src/mpu6050.c **** 
2868:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2869:Src/mpu6050.c **** /* This initialization is similar to the one in ak8975.c. */
2870:Src/mpu6050.c **** static int setup_compass(void)
2871:Src/mpu6050.c **** {
2872:Src/mpu6050.c ****     unsigned char data[4], akm_addr;
2873:Src/mpu6050.c **** 
2874:Src/mpu6050.c ****     mpu_set_bypass(1);
2875:Src/mpu6050.c **** 
2876:Src/mpu6050.c ****     /* Find compass. Possible addresses range from 0x0C to 0x0F. */
2877:Src/mpu6050.c ****     for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
2878:Src/mpu6050.c ****         int result;
2879:Src/mpu6050.c ****         result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
2880:Src/mpu6050.c ****         if (!result && (data[0] == AKM_WHOAMI))
2881:Src/mpu6050.c ****             break;
2882:Src/mpu6050.c ****     }
2883:Src/mpu6050.c **** 
2884:Src/mpu6050.c ****     if (akm_addr > 0x0F) {
2885:Src/mpu6050.c ****         /* TODO: Handle this case in all compass-related functions. */
2886:Src/mpu6050.c ****         #ifdef SERIAL_DEBUG
2887:Src/mpu6050.c ****             log_i("Compass not found\r\n");
2888:Src/mpu6050.c ****         #endif
2889:Src/mpu6050.c ****         return -1;
2890:Src/mpu6050.c ****     }
2891:Src/mpu6050.c **** 
2892:Src/mpu6050.c ****     st.chip_cfg.compass_addr = akm_addr;
2893:Src/mpu6050.c **** 
2894:Src/mpu6050.c ****     data[0] = AKM_POWER_DOWN;
2895:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2896:Src/mpu6050.c ****         return -1;
2897:Src/mpu6050.c ****     delay_ms(1);
2898:Src/mpu6050.c **** 
2899:Src/mpu6050.c ****     data[0] = AKM_FUSE_ROM_ACCESS;
2900:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
ARM GAS  /tmp/cc39PcX6.s 			page 67


2901:Src/mpu6050.c ****         return -1;
2902:Src/mpu6050.c ****     delay_ms(1);
2903:Src/mpu6050.c **** 
2904:Src/mpu6050.c ****     /* Get sensitivity adjustment data from fuse ROM. */
2905:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
2906:Src/mpu6050.c ****         return -1;
2907:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
2908:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
2909:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
2910:Src/mpu6050.c **** 
2911:Src/mpu6050.c ****     data[0] = AKM_POWER_DOWN;
2912:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2913:Src/mpu6050.c ****         return -1;
2914:Src/mpu6050.c ****     delay_ms(1);
2915:Src/mpu6050.c **** 
2916:Src/mpu6050.c ****     mpu_set_bypass(0);
2917:Src/mpu6050.c **** 
2918:Src/mpu6050.c ****     /* Set up master mode, master clock, and ES bit. */
2919:Src/mpu6050.c ****     data[0] = 0x40;
2920:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2921:Src/mpu6050.c ****         return -1;
2922:Src/mpu6050.c **** 
2923:Src/mpu6050.c ****     /* Slave 0 reads from AKM data registers. */
2924:Src/mpu6050.c ****     data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
2925:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
2926:Src/mpu6050.c ****         return -1;
2927:Src/mpu6050.c **** 
2928:Src/mpu6050.c ****     /* Compass reads start at this register. */
2929:Src/mpu6050.c ****     data[0] = AKM_REG_ST1;
2930:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
2931:Src/mpu6050.c ****         return -1;
2932:Src/mpu6050.c **** 
2933:Src/mpu6050.c ****     /* Enable slave 0, 8-byte reads. */
2934:Src/mpu6050.c ****     data[0] = BIT_SLAVE_EN | 8;
2935:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
2936:Src/mpu6050.c ****         return -1;
2937:Src/mpu6050.c **** 
2938:Src/mpu6050.c ****     /* Slave 1 changes AKM measurement mode. */
2939:Src/mpu6050.c ****     data[0] = st.chip_cfg.compass_addr;
2940:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
2941:Src/mpu6050.c ****         return -1;
2942:Src/mpu6050.c **** 
2943:Src/mpu6050.c ****     /* AKM measurement mode register. */
2944:Src/mpu6050.c ****     data[0] = AKM_REG_CNTL;
2945:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
2946:Src/mpu6050.c ****         return -1;
2947:Src/mpu6050.c **** 
2948:Src/mpu6050.c ****     /* Enable slave 1, 1-byte writes. */
2949:Src/mpu6050.c ****     data[0] = BIT_SLAVE_EN | 1;
2950:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
2951:Src/mpu6050.c ****         return -1;
2952:Src/mpu6050.c **** 
2953:Src/mpu6050.c ****     /* Set slave 1 data. */
2954:Src/mpu6050.c ****     data[0] = AKM_SINGLE_MEASUREMENT;
2955:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
2956:Src/mpu6050.c ****         return -1;
2957:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 68


2958:Src/mpu6050.c ****     /* Trigger slave 0 and slave 1 actions at each sample. */
2959:Src/mpu6050.c ****     data[0] = 0x03;
2960:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
2961:Src/mpu6050.c ****         return -1;
2962:Src/mpu6050.c **** 
2963:Src/mpu6050.c **** #ifdef MPU9150
2964:Src/mpu6050.c ****     /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
2965:Src/mpu6050.c ****     data[0] = BIT_I2C_MST_VDDIO;
2966:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
2967:Src/mpu6050.c ****         return -1;
2968:Src/mpu6050.c **** #endif
2969:Src/mpu6050.c **** 
2970:Src/mpu6050.c ****     return 0;
2971:Src/mpu6050.c **** }
2972:Src/mpu6050.c **** #endif
2973:Src/mpu6050.c **** 
2974:Src/mpu6050.c **** /**
2975:Src/mpu6050.c ****  *  @brief      Read raw compass data.
2976:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
2977:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
2978:Src/mpu6050.c ****  *  @return     0 if successful.
2979:Src/mpu6050.c ****  */
2980:Src/mpu6050.c **** int mpu_get_compass_reg(short *data, unsigned long *timestamp)
2981:Src/mpu6050.c **** {
2982:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2983:Src/mpu6050.c ****     unsigned char tmp[9];
2984:Src/mpu6050.c **** 
2985:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
2986:Src/mpu6050.c ****         return -1;
2987:Src/mpu6050.c **** 
2988:Src/mpu6050.c **** #ifdef AK89xx_BYPASS
2989:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
2990:Src/mpu6050.c ****         return -1;
2991:Src/mpu6050.c ****     tmp[8] = AKM_SINGLE_MEASUREMENT;
2992:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
2993:Src/mpu6050.c ****         return -1;
2994:Src/mpu6050.c **** #else
2995:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
2996:Src/mpu6050.c ****         return -1;
2997:Src/mpu6050.c **** #endif
2998:Src/mpu6050.c **** 
2999:Src/mpu6050.c **** #if defined AK8975_SECONDARY
3000:Src/mpu6050.c ****     /* AK8975 doesn't have the overrun error bit. */
3001:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY))
3002:Src/mpu6050.c ****         return -2;
3003:Src/mpu6050.c ****     if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
3004:Src/mpu6050.c ****         return -3;
3005:Src/mpu6050.c **** #elif defined AK8963_SECONDARY
3006:Src/mpu6050.c ****     /* AK8963 doesn't have the data read error bit. */
3007:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
3008:Src/mpu6050.c ****         return -2;
3009:Src/mpu6050.c ****     if (tmp[7] & AKM_OVERFLOW)
3010:Src/mpu6050.c ****         return -3;
3011:Src/mpu6050.c **** #endif
3012:Src/mpu6050.c ****     data[0] = (tmp[2] << 8) | tmp[1];
3013:Src/mpu6050.c ****     data[1] = (tmp[4] << 8) | tmp[3];
3014:Src/mpu6050.c ****     data[2] = (tmp[6] << 8) | tmp[5];
ARM GAS  /tmp/cc39PcX6.s 			page 69


3015:Src/mpu6050.c **** 
3016:Src/mpu6050.c ****     data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
3017:Src/mpu6050.c ****     data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
3018:Src/mpu6050.c ****     data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
3019:Src/mpu6050.c **** 
3020:Src/mpu6050.c ****     if (timestamp)
3021:Src/mpu6050.c ****         get_ms(timestamp);
3022:Src/mpu6050.c ****     return 0;
3023:Src/mpu6050.c **** #else
3024:Src/mpu6050.c ****     return -1;
3025:Src/mpu6050.c **** #endif
3026:Src/mpu6050.c **** }
3027:Src/mpu6050.c **** 
3028:Src/mpu6050.c **** /**
3029:Src/mpu6050.c ****  *  @brief      Get the compass full-scale range.
3030:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
3031:Src/mpu6050.c ****  *  @return     0 if successful.
3032:Src/mpu6050.c ****  */
3033:Src/mpu6050.c **** int mpu_get_compass_fsr(unsigned short *fsr)
3034:Src/mpu6050.c **** {
3035:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
3036:Src/mpu6050.c ****     fsr[0] = st.hw->compass_fsr;
3037:Src/mpu6050.c ****     return 0;
3038:Src/mpu6050.c **** #else
3039:Src/mpu6050.c ****     return -1;
3040:Src/mpu6050.c **** #endif
3041:Src/mpu6050.c **** }
3042:Src/mpu6050.c **** 
3043:Src/mpu6050.c **** /**
3044:Src/mpu6050.c ****  *  @brief      Enters LP accel motion interrupt mode.
3045:Src/mpu6050.c ****  *  The behaviour of this feature is very different between the MPU6050 and the
3046:Src/mpu6050.c ****  *  MPU6500. Each chip's version of this feature is explained below.
3047:Src/mpu6050.c ****  *
3048:Src/mpu6050.c ****  *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
3049:Src/mpu6050.c ****  *  increments.
3050:Src/mpu6050.c ****  *
3051:Src/mpu6050.c ****  *  \n Low-power accel mode supports the following frequencies:
3052:Src/mpu6050.c ****  *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
3053:Src/mpu6050.c ****  *
3054:Src/mpu6050.c ****  *  \n MPU6500:
3055:Src/mpu6050.c ****  *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
3056:Src/mpu6050.c ****  *  sample. The hardware monitors the accel data and detects any large change
3057:Src/mpu6050.c ****  *  over a short period of time.
3058:Src/mpu6050.c ****  *
3059:Src/mpu6050.c ****  *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
3060:Src/mpu6050.c ****  *  increments.
3061:Src/mpu6050.c ****  *
3062:Src/mpu6050.c ****  *  \n MPU6500 Low-power accel mode supports the following frequencies:
3063:Src/mpu6050.c ****  *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
3064:Src/mpu6050.c ****  *
3065:Src/mpu6050.c ****  *  \n\n NOTES:
3066:Src/mpu6050.c ****  *  \n The driver will round down @e thresh to the nearest supported value if
3067:Src/mpu6050.c ****  *  an unsupported threshold is selected.
3068:Src/mpu6050.c ****  *  \n To select a fractional wake-up frequency, round down the value passed to
3069:Src/mpu6050.c ****  *  @e lpa_freq.
3070:Src/mpu6050.c ****  *  \n The MPU6500 does not support a delay parameter. If this function is used
3071:Src/mpu6050.c ****  *  for the MPU6500, the value passed to @e time will be ignored.
ARM GAS  /tmp/cc39PcX6.s 			page 70


3072:Src/mpu6050.c ****  *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
3073:Src/mpu6050.c ****  *  the previous configuration.
3074:Src/mpu6050.c ****  *
3075:Src/mpu6050.c ****  *  @param[in]  thresh      Motion threshold in mg.
3076:Src/mpu6050.c ****  *  @param[in]  time        Duration in milliseconds that the accel data must
3077:Src/mpu6050.c ****  *                          exceed @e thresh before motion is reported.
3078:Src/mpu6050.c ****  *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
3079:Src/mpu6050.c ****  *  @return     0 if successful.
3080:Src/mpu6050.c ****  */
3081:Src/mpu6050.c **** int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time, unsigned short lpa_freq)
3082:Src/mpu6050.c **** {
3083:Src/mpu6050.c **** 
3084:Src/mpu6050.c **** #if defined MPU6500
3085:Src/mpu6050.c ****     unsigned char data[3];
3086:Src/mpu6050.c **** #endif
3087:Src/mpu6050.c ****     if (lpa_freq) {
3088:Src/mpu6050.c **** #if defined MPU6500
3089:Src/mpu6050.c ****         unsigned char thresh_hw;
3090:Src/mpu6050.c **** 
3091:Src/mpu6050.c ****         /* 1LSb = 4mg. */
3092:Src/mpu6050.c ****         if (thresh > 1020)
3093:Src/mpu6050.c ****             thresh_hw = 255;
3094:Src/mpu6050.c ****         else if (thresh < 4)
3095:Src/mpu6050.c ****             thresh_hw = 1;
3096:Src/mpu6050.c ****         else
3097:Src/mpu6050.c ****             thresh_hw = thresh >> 2;
3098:Src/mpu6050.c **** #endif
3099:Src/mpu6050.c **** 
3100:Src/mpu6050.c ****         if (!time)
3101:Src/mpu6050.c ****             /* Minimum duration must be 1ms. */
3102:Src/mpu6050.c ****             time = 1;
3103:Src/mpu6050.c **** 
3104:Src/mpu6050.c **** #if defined MPU6500
3105:Src/mpu6050.c ****         if (lpa_freq > 640)
3106:Src/mpu6050.c ****             /* At this point, the chip has not been re-configured, so the
3107:Src/mpu6050.c ****              * function can safely exit.
3108:Src/mpu6050.c ****              */
3109:Src/mpu6050.c ****             return -1;
3110:Src/mpu6050.c **** #endif
3111:Src/mpu6050.c **** 
3112:Src/mpu6050.c ****         if (!st.chip_cfg.int_motion_only) {
3113:Src/mpu6050.c ****             /* Store current settings for later. */
3114:Src/mpu6050.c ****             if (st.chip_cfg.dmp_on) {
3115:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
3116:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 1;
3117:Src/mpu6050.c ****             } else
3118:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 0;
3119:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
3120:Src/mpu6050.c ****             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
3121:Src/mpu6050.c ****             mpu_get_lpf(&st.chip_cfg.cache.lpf);
3122:Src/mpu6050.c ****             mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
3123:Src/mpu6050.c ****             st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
3124:Src/mpu6050.c ****             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
3125:Src/mpu6050.c ****         }
3126:Src/mpu6050.c **** 
3127:Src/mpu6050.c **** #if defined MPU6500
3128:Src/mpu6050.c ****         /* Disable hardware interrupts. */
ARM GAS  /tmp/cc39PcX6.s 			page 71


3129:Src/mpu6050.c ****         set_int_enable(0);
3130:Src/mpu6050.c **** 
3131:Src/mpu6050.c ****         /* Enter full-power accel-only mode, no FIFO/DMP. */
3132:Src/mpu6050.c ****         data[0] = 0;
3133:Src/mpu6050.c ****         data[1] = 0;
3134:Src/mpu6050.c ****         data[2] = BIT_STBY_XYZG;
3135:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
3136:Src/mpu6050.c ****             goto lp_int_restore;
3137:Src/mpu6050.c **** 
3138:Src/mpu6050.c ****         /* Set motion threshold. */
3139:Src/mpu6050.c ****         data[0] = thresh_hw;
3140:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
3141:Src/mpu6050.c ****             goto lp_int_restore;
3142:Src/mpu6050.c **** 
3143:Src/mpu6050.c ****         /* Set wake frequency. */
3144:Src/mpu6050.c ****         if (lpa_freq == 1)
3145:Src/mpu6050.c ****             data[0] = INV_LPA_1_25HZ;
3146:Src/mpu6050.c ****         else if (lpa_freq == 2)
3147:Src/mpu6050.c ****             data[0] = INV_LPA_2_5HZ;
3148:Src/mpu6050.c ****         else if (lpa_freq <= 5)
3149:Src/mpu6050.c ****             data[0] = INV_LPA_5HZ;
3150:Src/mpu6050.c ****         else if (lpa_freq <= 10)
3151:Src/mpu6050.c ****             data[0] = INV_LPA_10HZ;
3152:Src/mpu6050.c ****         else if (lpa_freq <= 20)
3153:Src/mpu6050.c ****             data[0] = INV_LPA_20HZ;
3154:Src/mpu6050.c ****         else if (lpa_freq <= 40)
3155:Src/mpu6050.c ****             data[0] = INV_LPA_40HZ;
3156:Src/mpu6050.c ****         else if (lpa_freq <= 80)
3157:Src/mpu6050.c ****             data[0] = INV_LPA_80HZ;
3158:Src/mpu6050.c ****         else if (lpa_freq <= 160)
3159:Src/mpu6050.c ****             data[0] = INV_LPA_160HZ;
3160:Src/mpu6050.c ****         else if (lpa_freq <= 320)
3161:Src/mpu6050.c ****             data[0] = INV_LPA_320HZ;
3162:Src/mpu6050.c ****         else
3163:Src/mpu6050.c ****             data[0] = INV_LPA_640HZ;
3164:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
3165:Src/mpu6050.c ****             goto lp_int_restore;
3166:Src/mpu6050.c **** 
3167:Src/mpu6050.c ****         /* Enable motion interrupt (MPU6500 version). */
3168:Src/mpu6050.c ****         data[0] = BITS_WOM_EN;
3169:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
3170:Src/mpu6050.c ****             goto lp_int_restore;
3171:Src/mpu6050.c **** 
3172:Src/mpu6050.c ****         /* Enable cycle mode. */
3173:Src/mpu6050.c ****         data[0] = BIT_LPA_CYCLE;
3174:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
3175:Src/mpu6050.c ****             goto lp_int_restore;
3176:Src/mpu6050.c **** 
3177:Src/mpu6050.c ****         /* Enable interrupt. */
3178:Src/mpu6050.c ****         data[0] = BIT_MOT_INT_EN;
3179:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
3180:Src/mpu6050.c ****             goto lp_int_restore;
3181:Src/mpu6050.c **** 
3182:Src/mpu6050.c ****         st.chip_cfg.int_motion_only = 1;
3183:Src/mpu6050.c ****         return 0;
3184:Src/mpu6050.c **** #endif
3185:Src/mpu6050.c ****     } else {
ARM GAS  /tmp/cc39PcX6.s 			page 72


3186:Src/mpu6050.c ****         /* Don't "restore" the previous state if no state has been saved. */
3187:Src/mpu6050.c ****         unsigned int ii;
3188:Src/mpu6050.c ****         char *cache_ptr = (char*)&st.chip_cfg.cache;
3189:Src/mpu6050.c ****         for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
3190:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
3191:Src/mpu6050.c ****                 goto lp_int_restore;
3192:Src/mpu6050.c ****         }
3193:Src/mpu6050.c ****         /* If we reach this point, motion interrupt mode hasn't been used yet. */
3194:Src/mpu6050.c ****         return -1;
3195:Src/mpu6050.c ****     }
3196:Src/mpu6050.c **** lp_int_restore:
3197:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
3198:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
3199:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
3200:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
3201:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
3202:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
3203:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
3204:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
3205:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
3206:Src/mpu6050.c ****     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
3207:Src/mpu6050.c ****     mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
3208:Src/mpu6050.c ****     mpu_set_lpf(st.chip_cfg.cache.lpf);
3209:Src/mpu6050.c ****     mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
3210:Src/mpu6050.c ****     mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
3211:Src/mpu6050.c **** 
3212:Src/mpu6050.c ****     if (st.chip_cfg.cache.dmp_on)
3213:Src/mpu6050.c ****         mpu_set_dmp_state(1);
3214:Src/mpu6050.c **** 
3215:Src/mpu6050.c **** #ifdef MPU6500
3216:Src/mpu6050.c ****     /* Disable motion interrupt (MPU6500 version). */
3217:Src/mpu6050.c ****     data[0] = 0;
3218:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
3219:Src/mpu6050.c ****         goto lp_int_restore;
3220:Src/mpu6050.c **** #endif
3221:Src/mpu6050.c **** 
3222:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
3223:Src/mpu6050.c ****     return 0;
3224:Src/mpu6050.c **** }
3225:Src/mpu6050.c **** 
3226:Src/mpu6050.c **** /*
3227:Src/mpu6050.c ****  *  This function must be called with the device either face-up or face-down
3228:Src/mpu6050.c ****  *  (z-axis is parallel to gravity).
3229:Src/mpu6050.c ****  */
3230:Src/mpu6050.c **** void mpu_start_self_test(void)
3231:Src/mpu6050.c **** {
3232:Src/mpu6050.c ****     int result;
3233:Src/mpu6050.c ****     long gyro[3], accel[3];
3234:Src/mpu6050.c **** 
3235:Src/mpu6050.c **** #if defined (MPU6500) || defined (MPU9250)
3236:Src/mpu6050.c ****     result = mpu_run_6500_self_test(gyro, accel, 0);
3237:Src/mpu6050.c **** #elif defined (MPU6050) || defined (MPU9150)
3238:Src/mpu6050.c ****     result = mpu_run_self_test(gyro, accel);
3239:Src/mpu6050.c **** #endif
3240:Src/mpu6050.c ****     #ifdef SERIAL_DEBUG
3241:Src/mpu6050.c ****         log_i("accel: %ld %ld %ld\r\n",
3242:Src/mpu6050.c ****                                 accel[0],
ARM GAS  /tmp/cc39PcX6.s 			page 73


3243:Src/mpu6050.c ****                                 accel[1],
3244:Src/mpu6050.c ****                                 accel[2]);
3245:Src/mpu6050.c ****         log_i("gyro: %ld %ld %ld\r\n",
3246:Src/mpu6050.c ****                                 gyro[0],
3247:Src/mpu6050.c ****                                 gyro[1],
3248:Src/mpu6050.c ****                                 gyro[2]);
3249:Src/mpu6050.c ****     #endif
3250:Src/mpu6050.c ****     if (result == 0x7) {
3251:Src/mpu6050.c ****         consoleLog("Passed!\r\n");
3252:Src/mpu6050.c ****         /* Test passed. We can trust the gyro data here, so now we need to update calibrated data*/
3253:Src/mpu6050.c **** 
3254:Src/mpu6050.c **** #ifdef USE_CAL_HW_REGISTERS
3255:Src/mpu6050.c ****         /*
3256:Src/mpu6050.c ****          * This portion of the code uses the HW offset registers that are in the MPUxxxx devices
3257:Src/mpu6050.c ****          * instead of pushing the cal data to the MPL software library
3258:Src/mpu6050.c ****          */
3259:Src/mpu6050.c ****         unsigned char i = 0;
3260:Src/mpu6050.c **** 
3261:Src/mpu6050.c ****         for(i = 0; i<3; i++) {
3262:Src/mpu6050.c ****             gyro[i] = (long)(gyro[i] * 32.8f); //convert to +-1000dps
3263:Src/mpu6050.c ****             accel[i] *= 2048.f; //convert to +-16G
3264:Src/mpu6050.c ****             accel[i] = accel[i] >> 16;
3265:Src/mpu6050.c ****             gyro[i] = (long)(gyro[i] >> 16);
3266:Src/mpu6050.c ****         }
3267:Src/mpu6050.c **** 
3268:Src/mpu6050.c ****         mpu_set_gyro_bias_reg(gyro);
3269:Src/mpu6050.c **** 
3270:Src/mpu6050.c ****         #if defined (MPU6500) || defined (MPU9250)
3271:Src/mpu6050.c ****                 mpu_set_accel_bias_6500_reg(accel);
3272:Src/mpu6050.c ****         #elif defined (MPU6050) || defined (MPU9150)
3273:Src/mpu6050.c ****                 mpu_set_accel_bias_6050_reg(accel);
3274:Src/mpu6050.c ****         #endif
3275:Src/mpu6050.c **** #endif
3276:Src/mpu6050.c ****     }
3277:Src/mpu6050.c ****     else {
3278:Src/mpu6050.c ****         if (!(result & 0x1))
3279:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
3280:Src/mpu6050.c ****         if (!(result & 0x2))
3281:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
3282:Src/mpu6050.c ****         if (!(result & 0x4))
3283:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
3284:Src/mpu6050.c ****      }
3285:Src/mpu6050.c **** 
3286:Src/mpu6050.c **** }
3287:Src/mpu6050.c **** 
3288:Src/mpu6050.c **** 
3289:Src/mpu6050.c **** 
3290:Src/mpu6050.c **** //=========================================================================================
3291:Src/mpu6050.c **** struct hal_s {
3292:Src/mpu6050.c ****     unsigned char lp_accel_mode;
3293:Src/mpu6050.c ****     unsigned char sensors;
3294:Src/mpu6050.c ****     unsigned char dmp_on;
3295:Src/mpu6050.c ****     unsigned char wait_for_tap;
3296:Src/mpu6050.c ****     volatile unsigned char new_gyro;
3297:Src/mpu6050.c ****     unsigned long no_dmp_hz;
3298:Src/mpu6050.c ****     unsigned long next_pedo_ms;
3299:Src/mpu6050.c ****     unsigned long next_temp_ms;
ARM GAS  /tmp/cc39PcX6.s 			page 74


3300:Src/mpu6050.c ****     unsigned int report;
3301:Src/mpu6050.c ****     unsigned short dmp_features;
3302:Src/mpu6050.c **** };
3303:Src/mpu6050.c **** static struct hal_s hal = {0};
3304:Src/mpu6050.c **** 
3305:Src/mpu6050.c **** 
3306:Src/mpu6050.c **** /* This fuction handle sensor on/off combinations. */
3307:Src/mpu6050.c **** void mpu_setup_gyro(void)
3308:Src/mpu6050.c **** {
3309:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
3310:Src/mpu6050.c ****     if (hal.sensors & ACCEL_ON) {
3311:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
3312:Src/mpu6050.c ****         consoleLog("Accel ON\r\n");
3313:Src/mpu6050.c ****     } else {
3314:Src/mpu6050.c ****         consoleLog("Accel OFF\r\n");
3315:Src/mpu6050.c ****     }
3316:Src/mpu6050.c ****     if (hal.sensors & GYRO_ON) {
3317:Src/mpu6050.c ****         mask |= INV_XYZ_GYRO;
3318:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
3319:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
3320:Src/mpu6050.c ****     } else {
3321:Src/mpu6050.c ****         consoleLog("Gyro OFF\r\n");
3322:Src/mpu6050.c ****     }
3323:Src/mpu6050.c **** #ifdef COMPASS_ENABLED
3324:Src/mpu6050.c ****     if (hal.sensors & COMPASS_ON) {
3325:Src/mpu6050.c ****         mask |= INV_XYZ_COMPASS;
3326:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
3327:Src/mpu6050.c ****     }
3328:Src/mpu6050.c **** #endif
3329:Src/mpu6050.c ****     /* If you need a power transition, this function should be called with a
3330:Src/mpu6050.c ****      * mask of the sensors still enabled. The driver turns off any sensors
3331:Src/mpu6050.c ****      * excluded from this mask.
3332:Src/mpu6050.c ****      */
3333:Src/mpu6050.c ****     mpu_set_sensors(mask);
3334:Src/mpu6050.c ****     mpu_configure_fifo(mask);
3335:Src/mpu6050.c ****     if (lp_accel_was_on) {
3336:Src/mpu6050.c ****         unsigned short rate;
3337:Src/mpu6050.c ****         hal.lp_accel_mode = 0;
3338:Src/mpu6050.c ****         /* Switching out of LP accel, notify MPL of new accel sampling rate. */
3339:Src/mpu6050.c ****         mpu_get_sample_rate(&rate);
3340:Src/mpu6050.c ****     }
3341:Src/mpu6050.c **** }
3342:Src/mpu6050.c **** 
3343:Src/mpu6050.c **** unsigned short inv_row_2_scale(const signed char *row)
3344:Src/mpu6050.c **** {
3345:Src/mpu6050.c ****     unsigned short b;
3346:Src/mpu6050.c **** 
3347:Src/mpu6050.c ****     if (row[0] > 0)
3348:Src/mpu6050.c ****         b = 0;
3349:Src/mpu6050.c ****     else if (row[0] < 0)
3350:Src/mpu6050.c ****         b = 4;
3351:Src/mpu6050.c ****     else if (row[1] > 0)
3352:Src/mpu6050.c ****         b = 1;
3353:Src/mpu6050.c ****     else if (row[1] < 0)
3354:Src/mpu6050.c ****         b = 5;
3355:Src/mpu6050.c ****     else if (row[2] > 0)
3356:Src/mpu6050.c ****         b = 2;
ARM GAS  /tmp/cc39PcX6.s 			page 75


3357:Src/mpu6050.c ****     else if (row[2] < 0)
3358:Src/mpu6050.c ****         b = 6;
3359:Src/mpu6050.c ****     else
3360:Src/mpu6050.c ****         b = 7;      // error
3361:Src/mpu6050.c ****     return b;
3362:Src/mpu6050.c **** }
3363:Src/mpu6050.c **** 
3364:Src/mpu6050.c **** /*
3365:Src/mpu6050.c ****  *  This function converts the Sensor orientation matric to a scalar
3366:Src/mpu6050.c ****  */
3367:Src/mpu6050.c **** unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx)
3368:Src/mpu6050.c **** {
3369:Src/mpu6050.c ****     unsigned short scalar;
3370:Src/mpu6050.c ****     scalar  = inv_row_2_scale(mtx);
3371:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 3) << 3;
3372:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 6) << 6;
3373:Src/mpu6050.c **** 
3374:Src/mpu6050.c ****     return scalar;
3375:Src/mpu6050.c **** }
3376:Src/mpu6050.c **** 
3377:Src/mpu6050.c **** 
3378:Src/mpu6050.c **** /**
3379:Src/mpu6050.c ****  *  @}
3380:Src/mpu6050.c ****  */
3381:Src/mpu6050.c **** 
3382:Src/mpu6050.c **** /* =========================== MPU-6050 Configuration =========================== */
3383:Src/mpu6050.c **** int mpu_config(void)
3384:Src/mpu6050.c **** {
3385:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
3386:Src/mpu6050.c **** 
3387:Src/mpu6050.c ****     if(mpu_init()) {
3388:Src/mpu6050.c ****         consoleLog("FAIL (MPU)\r\n");
3389:Src/mpu6050.c ****         return -1;
3390:Src/mpu6050.c ****     }
3391:Src/mpu6050.c **** 
3392:Src/mpu6050.c ****     /* Get/set hardware configuration. Start gyro. */
3393:Src/mpu6050.c ****     /* Wake up all sensors. */
3394:Src/mpu6050.c ****     mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL);
3395:Src/mpu6050.c **** 
3396:Src/mpu6050.c ****     /* Push both gyro and accel data into the FIFO. */
3397:Src/mpu6050.c ****     mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);
3398:Src/mpu6050.c ****     mpu_set_sample_rate(MPU_DEFAULT_HZ);
3399:Src/mpu6050.c **** 
3400:Src/mpu6050.c ****     /* Read back configuration in case it was set improperly. */
3401:Src/mpu6050.c ****     // mpu_get_sample_rate(&gyro_rate);
3402:Src/mpu6050.c ****     // mpu_get_gyro_fsr(&gyro_fsr);
3403:Src/mpu6050.c ****     // mpu_get_accel_fsr(&accel_fsr);
3404:Src/mpu6050.c **** 
3405:Src/mpu6050.c ****     /* Initialize HAL state variables. */
3406:Src/mpu6050.c ****     hal.sensors             = ACCEL_ON | GYRO_ON;
3407:Src/mpu6050.c ****     hal.dmp_on              = 0;
3408:Src/mpu6050.c ****     hal.report              = 0;
3409:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
3410:Src/mpu6050.c ****     hal.next_temp_ms        = 0;
3411:Src/mpu6050.c **** 
3412:Src/mpu6050.c **** #ifdef MPU_DMP_ENABLE
3413:Src/mpu6050.c ****     /* To initialize the DMP:
ARM GAS  /tmp/cc39PcX6.s 			page 76


3414:Src/mpu6050.c ****      * 1. Call dmp_load_motion_driver_firmware(). This pushes the DMP image in
3415:Src/mpu6050.c ****      *    inv_mpu_dmp_motion_driver.h into the MPU memory.
3416:Src/mpu6050.c ****      * 2. Push the gyro and accel orientation matrix to the DMP.
3417:Src/mpu6050.c ****      * 3. Register gesture callbacks. Don't worry, these callbacks won't be
3418:Src/mpu6050.c ****      *    executed unless the corresponding feature is enabled.
3419:Src/mpu6050.c ****      * 4. Call dmp_enable_feature(mask) to enable different features.
3420:Src/mpu6050.c ****      * 5. Call dmp_set_fifo_rate(freq) to select a DMP output rate.
3421:Src/mpu6050.c ****      * 6. Call any feature-specific control functions.
3422:Src/mpu6050.c ****      *
3423:Src/mpu6050.c ****      * To enable the DMP, just call mpu_set_dmp_state(1). This function can
3424:Src/mpu6050.c ****      * be called repeatedly to enable and disable the DMP at runtime.
3425:Src/mpu6050.c ****      *
3426:Src/mpu6050.c ****      * The following is a short summary of the features supported in the DMP
3427:Src/mpu6050.c ****      * image provided in inv_mpu_dmp_motion_driver.c:
3428:Src/mpu6050.c ****      * DMP_FEATURE_LP_QUAT: Generate a gyro-only quaternion on the DMP at
3429:Src/mpu6050.c ****      * 200Hz. Integrating the gyro data at higher rates reduces numerical
3430:Src/mpu6050.c ****      * errors (compared to integration on the MCU at a lower sampling rate).
3431:Src/mpu6050.c ****      * DMP_FEATURE_6X_LP_QUAT: Generate a gyro/accel quaternion on the DMP at
3432:Src/mpu6050.c ****      * 200Hz. Cannot be used in combination with DMP_FEATURE_LP_QUAT.
3433:Src/mpu6050.c ****      * DMP_FEATURE_TAP: Detect taps along the X, Y, and Z axes.
3434:Src/mpu6050.c ****      * DMP_FEATURE_ANDROID_ORIENT: Google's screen rotation algorithm. Triggers
3435:Src/mpu6050.c ****      * an event at the four orientations where the screen should rotate.
3436:Src/mpu6050.c ****      * DMP_FEATURE_GYRO_CAL: Calibrates the gyro data after eight seconds of
3437:Src/mpu6050.c ****      * no motion.
3438:Src/mpu6050.c ****      * DMP_FEATURE_SEND_RAW_ACCEL: Add raw accelerometer data to the FIFO.
3439:Src/mpu6050.c ****      * DMP_FEATURE_SEND_RAW_GYRO: Add raw gyro data to the FIFO.
3440:Src/mpu6050.c ****      * DMP_FEATURE_SEND_CAL_GYRO: Add calibrated gyro data to the FIFO. Cannot
3441:Src/mpu6050.c ****      * be used in combination with DMP_FEATURE_SEND_RAW_GYRO.
3442:Src/mpu6050.c ****      */
3443:Src/mpu6050.c ****         consoleLog(" writing DMP... ");
3444:Src/mpu6050.c ****         if (dmp_load_motion_driver_firmware()) {
3445:Src/mpu6050.c ****             consoleLog(" FAIL (DMP)\r\n");
3446:Src/mpu6050.c ****             return -1;
3447:Src/mpu6050.c ****         }
3448:Src/mpu6050.c ****     dmp_set_orientation(inv_orientation_matrix_to_scalar(MPU_ORIENTATION));
3449:Src/mpu6050.c ****     dmp_register_tap_cb(mpu_tap_func);
3450:Src/mpu6050.c ****     dmp_register_android_orient_cb(mpu_android_orient_func);
3451:Src/mpu6050.c ****     /*
3452:Src/mpu6050.c ****      * Known Bug -
3453:Src/mpu6050.c ****      * DMP when enabled will sample sensor data at 200Hz and output to FIFO at the rate
3454:Src/mpu6050.c ****      * specified in the dmp_set_fifo_rate API. The DMP will then sent an interrupt once
3455:Src/mpu6050.c ****      * a sample has been put into the FIFO. Therefore if the dmp_set_fifo_rate is at 25Hz
3456:Src/mpu6050.c ****      * there will be a 25Hz interrupt from the MPU device.
3457:Src/mpu6050.c ****      *
3458:Src/mpu6050.c ****      * There is a known issue in which if you do not enable DMP_FEATURE_TAP
3459:Src/mpu6050.c ****      * then the interrupts will be at 200Hz even if fifo rate
3460:Src/mpu6050.c ****      * is set at a different rate. To avoid this issue include the DMP_FEATURE_TAP
3461:Src/mpu6050.c ****      *
3462:Src/mpu6050.c ****      * DMP sensor fusion works only with gyro at +-2000dps and accel +-2G
3463:Src/mpu6050.c ****      */
3464:Src/mpu6050.c ****     hal.dmp_features = 	DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT |
3465:Src/mpu6050.c ****                         DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_C
3466:Src/mpu6050.c ****     dmp_enable_feature(hal.dmp_features);
3467:Src/mpu6050.c ****     dmp_set_fifo_rate(MPU_DEFAULT_HZ);
3468:Src/mpu6050.c ****     mpu_set_dmp_state(1);
3469:Src/mpu6050.c ****     hal.dmp_on = 1;
3470:Src/mpu6050.c **** #endif
ARM GAS  /tmp/cc39PcX6.s 			page 77


3471:Src/mpu6050.c **** 
3472:Src/mpu6050.c ****     consoleLog(" OK\r\n");	
3473:Src/mpu6050.c ****     return 0;
3474:Src/mpu6050.c **** }
3475:Src/mpu6050.c **** 
3476:Src/mpu6050.c **** 
3477:Src/mpu6050.c **** /* =========================== MPU-6050 Get Packet Data =========================== */
3478:Src/mpu6050.c **** 
3479:Src/mpu6050.c **** void mpu_get_data(void)
3480:Src/mpu6050.c **** {
3481:Src/mpu6050.c ****     
3482:Src/mpu6050.c ****     unsigned long sensor_timestamp;
3483:Src/mpu6050.c ****     unsigned long timestamp;
3484:Src/mpu6050.c ****     unsigned char new_data = 0, new_temp = 0;
3485:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
3486:Src/mpu6050.c **** 
3487:Src/mpu6050.c ****     // check for DMP interrupt bit or Data Ready interrupt bit (in case DMP is disabled) -> this in
3488:Src/mpu6050.c ****     i2c_readByte(st.hw->addr, st.reg->int_status, &mpu_int_status);
3489:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
3490:Src/mpu6050.c ****             hal.new_gyro = 1;
3491:Src/mpu6050.c ****     }
3492:Src/mpu6050.c **** 
3493:Src/mpu6050.c ****     get_tick_count_ms(&timestamp);
3494:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
3495:Src/mpu6050.c ****      * Let's make them timer-based.
3496:Src/mpu6050.c ****      */
3497:Src/mpu6050.c ****     if (timestamp > hal.next_temp_ms) {
3498:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
3499:Src/mpu6050.c ****         new_temp = 1;
3500:Src/mpu6050.c ****     }
3501:Src/mpu6050.c **** 
3502:Src/mpu6050.c **** 
3503:Src/mpu6050.c ****     if (hal.new_gyro && hal.dmp_on) {
3504:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
3505:Src/mpu6050.c ****         static long quat[4], temperature;
3506:Src/mpu6050.c ****         unsigned char more;
3507:Src/mpu6050.c ****         /* This function gets new data from the FIFO when the DMP is in
3508:Src/mpu6050.c ****             * use. The FIFO can contain any combination of gyro, accel,
3509:Src/mpu6050.c ****             * quaternion, and gesture data. The sensors parameter tells the
3510:Src/mpu6050.c ****             * caller which data fields were actually populated with new data.
3511:Src/mpu6050.c ****             * For example, if sensors == (INV_XYZ_GYRO | INV_WXYZ_QUAT), then
3512:Src/mpu6050.c ****             * the FIFO isn't being filled with accel data.
3513:Src/mpu6050.c ****             * The driver parses the gesture data to determine if a gesture
3514:Src/mpu6050.c ****             * event has occurred; on an event, the application will be notified
3515:Src/mpu6050.c ****             * via a callback (assuming that a callback function was properly
3516:Src/mpu6050.c ****             * registered). The more parameter is non-zero if there are
3517:Src/mpu6050.c ****             * leftover packets in the FIFO.
3518:Src/mpu6050.c ****             */
3519:Src/mpu6050.c ****         dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors, &more);
3520:Src/mpu6050.c ****         if (!more)
3521:Src/mpu6050.c ****             hal.new_gyro = 0;
3522:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
3523:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
3524:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
3525:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
3526:Src/mpu6050.c ****             new_data = 1;
3527:Src/mpu6050.c ****             if (new_temp) {
ARM GAS  /tmp/cc39PcX6.s 			page 78


3528:Src/mpu6050.c ****                 new_temp = 0;
3529:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
3530:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
3531:Src/mpu6050.c ****             }
3532:Src/mpu6050.c ****         }
3533:Src/mpu6050.c ****         if (sensors & INV_XYZ_ACCEL) {
3534:Src/mpu6050.c ****             mpu.accel.x = accel[0];
3535:Src/mpu6050.c ****             mpu.accel.y = accel[1];
3536:Src/mpu6050.c ****             mpu.accel.z = accel[2];
3537:Src/mpu6050.c ****             new_data = 1;
3538:Src/mpu6050.c ****         }
3539:Src/mpu6050.c ****         if (sensors & INV_WXYZ_QUAT) {
3540:Src/mpu6050.c ****             mpu.quat.w = quat[0];
3541:Src/mpu6050.c ****             mpu.quat.x = quat[1];
3542:Src/mpu6050.c ****             mpu.quat.y = quat[2];
3543:Src/mpu6050.c ****             mpu.quat.z = quat[3];
3544:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
3545:Src/mpu6050.c ****             new_data = 1;
3546:Src/mpu6050.c ****         }
3547:Src/mpu6050.c ****     } else if (hal.new_gyro) {
3548:Src/mpu6050.c ****         short gyro[3], accel[3];
3549:Src/mpu6050.c ****         long temperature;
3550:Src/mpu6050.c ****         unsigned char sensors, more;
3551:Src/mpu6050.c ****         /* This function gets new data from the FIFO. The FIFO can contain
3552:Src/mpu6050.c ****             * gyro, accel, both, or neither. The sensors parameter tells the
3553:Src/mpu6050.c ****             * caller which data fields were actually populated with new data.
3554:Src/mpu6050.c ****             * For example, if sensors == INV_XYZ_GYRO, then the FIFO isn't
3555:Src/mpu6050.c ****             * being filled with accel data. The more parameter is non-zero if
3556:Src/mpu6050.c ****             * there are leftover packets in the FIFO. The HAL can use this
3557:Src/mpu6050.c ****             * information to increase the frequency at which this function is
3558:Src/mpu6050.c ****             * called.
3559:Src/mpu6050.c ****             */
3560:Src/mpu6050.c ****         hal.new_gyro = 0;
3561:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
3562:Src/mpu6050.c ****         if (more)
3563:Src/mpu6050.c ****             hal.new_gyro = 1;
3564:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
3565:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
3566:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
3567:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
3568:Src/mpu6050.c ****             new_data = 1;
3569:Src/mpu6050.c ****             if (new_temp) {
3570:Src/mpu6050.c ****                 new_temp = 0;
3571:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
3572:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
3573:Src/mpu6050.c ****             }
3574:Src/mpu6050.c ****         }
3575:Src/mpu6050.c ****         if (sensors & INV_XYZ_ACCEL) {
3576:Src/mpu6050.c ****             mpu.accel.x = accel[0];
3577:Src/mpu6050.c ****             mpu.accel.y = accel[1];
3578:Src/mpu6050.c ****             mpu.accel.z = accel[2];
3579:Src/mpu6050.c ****             new_data = 1;
3580:Src/mpu6050.c ****         }
3581:Src/mpu6050.c ****     }
3582:Src/mpu6050.c **** 
3583:Src/mpu6050.c ****     if (new_data) {
3584:Src/mpu6050.c ****         // do something if needed
ARM GAS  /tmp/cc39PcX6.s 			page 79


3585:Src/mpu6050.c ****     }
3586:Src/mpu6050.c ****         
3587:Src/mpu6050.c **** }
3588:Src/mpu6050.c **** 
3589:Src/mpu6050.c **** 
3590:Src/mpu6050.c **** /* =========================== MPU-6050 Post-processing Functions =========================== */
3591:Src/mpu6050.c **** 
3592:Src/mpu6050.c **** void mpu_read_gyro_raw(void)
3593:Src/mpu6050.c **** {
3594:Src/mpu6050.c ****     uint8_t buffer[6];
3595:Src/mpu6050.c **** 
3596:Src/mpu6050.c ****     // Read 6 BYTES of data starting from GYRO_XOUT_H register (the MPU-6050 automatically incremen
3597:Src/mpu6050.c ****     i2c_readBytes(st.hw->addr, st.reg->raw_accel, 6, buffer);
3598:Src/mpu6050.c **** 
3599:Src/mpu6050.c ****     mpu.gyro.x = (int16_t)(buffer[0] << 8 | buffer[1]);
3600:Src/mpu6050.c ****     mpu.gyro.y = (int16_t)(buffer[2] << 8 | buffer[3]);
3601:Src/mpu6050.c ****     mpu.gyro.z = (int16_t)(buffer[4] << 8 | buffer[5]);
3602:Src/mpu6050.c **** 
3603:Src/mpu6050.c ****     /*** convert the RAW hardware units values into dps (/s)
3604:Src/mpu6050.c ****          we have to divide according to the Full scale value set in FS_SEL,
3605:Src/mpu6050.c ****          configured to 2000/s (check MPU_GYRO_FSR). So we need to divide by 16.4 LSB//s
3606:Src/mpu6050.c ****          for more details check GYRO_CONFIG Register              ****/
3607:Src/mpu6050.c ****     //Gx = mpu.gyro.x / 16.4;
3608:Src/mpu6050.c ****     //Gy = mpu.gyro.y / 16.4;
3609:Src/mpu6050.c ****     //Gz = mpu.gyro.z / 16.4;
3610:Src/mpu6050.c **** }
3611:Src/mpu6050.c **** 
3612:Src/mpu6050.c **** 
3613:Src/mpu6050.c **** void mpu_read_accel_raw(void)
3614:Src/mpu6050.c **** {
3615:Src/mpu6050.c ****     uint8_t buffer[6];
3616:Src/mpu6050.c **** 
3617:Src/mpu6050.c ****     // Read 6 BYTES of data starting from ACCEL_XOUT_H register (the MPU-6050 automatically increme
3618:Src/mpu6050.c ****     i2c_readBytes(st.hw->addr, st.reg->raw_gyro, 6, buffer);
3619:Src/mpu6050.c ****     
3620:Src/mpu6050.c ****     mpu.accel.x = (int16_t)(buffer[0] << 8 | buffer[1]);
3621:Src/mpu6050.c ****     mpu.accel.y = (int16_t)(buffer[2] << 8 | buffer[3]);
3622:Src/mpu6050.c ****     mpu.accel.z = (int16_t)(buffer[4] << 8 | buffer[5]);
3623:Src/mpu6050.c **** 
3624:Src/mpu6050.c **** 
3625:Src/mpu6050.c ****     /*** convert the RAW hardware units into acceleration in 'g'
3626:Src/mpu6050.c ****          we have to divide according to the Full scale value set in FS_SEL,
3627:Src/mpu6050.c ****          configured to 2g (check MPU_ACCEL_FSR). So we need to divide by 16384.0 LSB/g
3628:Src/mpu6050.c ****          for more details check ACCEL_CONFIG Register              ****/
3629:Src/mpu6050.c ****     //Ax = mpu.accel.x / 16384.0;
3630:Src/mpu6050.c ****     //Ay = mpu.accel.y / 16384.0;
3631:Src/mpu6050.c ****     //Az = mpu.accel.z / 16384.0;
3632:Src/mpu6050.c **** }
3633:Src/mpu6050.c **** 
3634:Src/mpu6050.c **** /*
3635:Src/mpu6050.c ****  * Calculate Euler Angles
3636:Src/mpu6050.c ****  * aerospace sequence, to obtain sensor attitude:
3637:Src/mpu6050.c ****  * 1. roll  (x-axis rotation)
3638:Src/mpu6050.c ****  * 2. pitch (y-axis rotation)
3639:Src/mpu6050.c ****  * 3. yaw   (z-axis rotation)
3640:Src/mpu6050.c ****  */
3641:Src/mpu6050.c **** void mpu_calc_euler_angles(void) {
ARM GAS  /tmp/cc39PcX6.s 			page 80


3642:Src/mpu6050.c ****     
3643:Src/mpu6050.c ****     float w, x, y, z;
3644:Src/mpu6050.c ****     float yaw, pitch, roll;
3645:Src/mpu6050.c **** 
3646:Src/mpu6050.c ****     // Convert quaternions[q30] to quaternion[float]
3647:Src/mpu6050.c ****     w = (float)mpu.quat.w / q30;        // q30 = 2^30
3648:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
3649:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
3650:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
3651:Src/mpu6050.c **** 
3652:Src/mpu6050.c ****     // Calculate Euler angles: source <https://en.wikipedia.org/wiki/Conversion_between_quaternions
3653:Src/mpu6050.c ****     roll    = atan2(2*(w*x + y*z), 1 - 2*(x*x + y*y));      // roll  (x-axis rotation)
3654:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
3655:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
3656:Src/mpu6050.c **** 
3657:Src/mpu6050.c ****     // Convert [rad] to [deg*100]
3658:Src/mpu6050.c ****     mpu.euler.roll  = (int16_t)(roll  * RAD2DEG * 100);
3659:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
3660:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
3661:Src/mpu6050.c ****     
3662:Src/mpu6050.c **** }
3663:Src/mpu6050.c **** 
3664:Src/mpu6050.c **** 
3665:Src/mpu6050.c **** void mpu_tap_func(unsigned char direction, unsigned char count)
3666:Src/mpu6050.c **** {
 664              		.loc 1 3666 1 is_stmt 1 view -0
 665              		.cfi_startproc
 666              		@ args = 0, pretend = 0, frame = 0
 667              		@ frame_needed = 0, uses_anonymous_args = 0
 668              		@ link register save eliminated.
3667:Src/mpu6050.c ****     switch (direction) {
 669              		.loc 1 3667 5 view .LVU211
 670 0000 0138     		subs	r0, r0, #1
 671              	.LVL47:
 672              		.loc 1 3667 5 is_stmt 0 view .LVU212
 673 0002 0528     		cmp	r0, #5
 674 0004 11D8     		bhi	.L24
 675 0006 DFE800F0 		tbb	[pc, r0]
 676              	.L27:
 677 000a 03       		.byte	(.L32-.L27)/2
 678 000b 06       		.byte	(.L31-.L27)/2
 679 000c 08       		.byte	(.L30-.L27)/2
 680 000d 0A       		.byte	(.L29-.L27)/2
 681 000e 0C       		.byte	(.L28-.L27)/2
 682 000f 0E       		.byte	(.L26-.L27)/2
 683              		.p2align 1
 684              	.L32:
3668:Src/mpu6050.c ****     case TAP_X_UP:
3669:Src/mpu6050.c ****         consoleLog("Tap X+ ");
 685              		.loc 1 3669 9 is_stmt 1 view .LVU213
 686 0010 0648     		ldr	r0, .L34
 687              	.L33:
3670:Src/mpu6050.c ****         break;
3671:Src/mpu6050.c ****     case TAP_X_DOWN:
3672:Src/mpu6050.c ****         consoleLog("Tap X- ");
3673:Src/mpu6050.c ****         break;
3674:Src/mpu6050.c ****     case TAP_Y_UP:
ARM GAS  /tmp/cc39PcX6.s 			page 81


3675:Src/mpu6050.c ****         consoleLog("Tap Y+ ");
3676:Src/mpu6050.c ****         break;
3677:Src/mpu6050.c ****     case TAP_Y_DOWN:
3678:Src/mpu6050.c ****         consoleLog("Tap Y- ");
3679:Src/mpu6050.c ****         break;
3680:Src/mpu6050.c ****     case TAP_Z_UP:
3681:Src/mpu6050.c ****         consoleLog("Tap Z+ ");
3682:Src/mpu6050.c ****         break;
3683:Src/mpu6050.c ****     case TAP_Z_DOWN:
3684:Src/mpu6050.c ****         consoleLog("Tap Z- ");
 688              		.loc 1 3684 9 is_stmt 0 view .LVU214
 689 0012 FFF7FEBF 		b	consoleLog
 690              	.LVL48:
 691              	.L31:
3672:Src/mpu6050.c ****         break;
 692              		.loc 1 3672 9 is_stmt 1 view .LVU215
 693 0016 0648     		ldr	r0, .L34+4
 694 0018 FBE7     		b	.L33
 695              	.L30:
3675:Src/mpu6050.c ****         break;
 696              		.loc 1 3675 9 view .LVU216
 697 001a 0648     		ldr	r0, .L34+8
 698 001c F9E7     		b	.L33
 699              	.L29:
3678:Src/mpu6050.c ****         break;
 700              		.loc 1 3678 9 view .LVU217
 701 001e 0648     		ldr	r0, .L34+12
 702 0020 F7E7     		b	.L33
 703              	.L28:
3681:Src/mpu6050.c ****         break;
 704              		.loc 1 3681 9 view .LVU218
 705 0022 0648     		ldr	r0, .L34+16
 706 0024 F5E7     		b	.L33
 707              	.L26:
 708              		.loc 1 3684 9 view .LVU219
 709 0026 0648     		ldr	r0, .L34+20
 710 0028 F3E7     		b	.L33
 711              	.L24:
3685:Src/mpu6050.c ****         break;
3686:Src/mpu6050.c ****     default:
3687:Src/mpu6050.c ****         return;
3688:Src/mpu6050.c ****     }
3689:Src/mpu6050.c ****     #ifdef SERIAL_DEBUG
3690:Src/mpu6050.c ****         log_i("x %d\r\n", count);
3691:Src/mpu6050.c ****     #endif
3692:Src/mpu6050.c ****     return;
3693:Src/mpu6050.c **** }
 712              		.loc 1 3693 1 is_stmt 0 view .LVU220
 713 002a 7047     		bx	lr
 714              	.L35:
 715              		.align	2
 716              	.L34:
 717 002c 00000000 		.word	.LC0
 718 0030 08000000 		.word	.LC1
 719 0034 10000000 		.word	.LC2
 720 0038 18000000 		.word	.LC3
 721 003c 20000000 		.word	.LC4
ARM GAS  /tmp/cc39PcX6.s 			page 82


 722 0040 28000000 		.word	.LC5
 723              		.cfi_endproc
 724              	.LFE118:
 726              		.section	.rodata.mpu_android_orient_func.str1.1,"aMS",%progbits,1
 727              	.LC6:
 728 0000 506F7274 		.ascii	"Portrait\015\012\000"
 728      72616974 
 728      0D0A00
 729              	.LC7:
 730 000b 4C616E64 		.ascii	"Landscape\015\012\000"
 730      73636170 
 730      650D0A00 
 731              	.LC8:
 732 0017 5265762E 		.ascii	"Rev. Portrait\015\012\000"
 732      20506F72 
 732      74726169 
 732      740D0A00 
 733              	.LC9:
 734 0027 5265762E 		.ascii	"Rev. Landscape\015\012\000"
 734      204C616E 
 734      64736361 
 734      70650D0A 
 734      00
 735              		.section	.text.mpu_android_orient_func,"ax",%progbits
 736              		.align	1
 737              		.global	mpu_android_orient_func
 738              		.syntax unified
 739              		.thumb
 740              		.thumb_func
 741              		.fpu softvfp
 743              	mpu_android_orient_func:
 744              	.LVL49:
 745              	.LFB119:
3694:Src/mpu6050.c **** 
3695:Src/mpu6050.c **** 
3696:Src/mpu6050.c **** void mpu_android_orient_func(unsigned char orientation)
3697:Src/mpu6050.c **** {
 746              		.loc 1 3697 1 is_stmt 1 view -0
 747              		.cfi_startproc
 748              		@ args = 0, pretend = 0, frame = 0
 749              		@ frame_needed = 0, uses_anonymous_args = 0
 750              		@ link register save eliminated.
3698:Src/mpu6050.c ****     switch (orientation) {
 751              		.loc 1 3698 5 view .LVU222
 752 0000 0328     		cmp	r0, #3
 753 0002 0CD8     		bhi	.L36
 754 0004 DFE800F0 		tbb	[pc, r0]
 755              	.L39:
 756 0008 02       		.byte	(.L42-.L39)/2
 757 0009 05       		.byte	(.L41-.L39)/2
 758 000a 07       		.byte	(.L40-.L39)/2
 759 000b 09       		.byte	(.L38-.L39)/2
 760              		.p2align 1
 761              	.L42:
3699:Src/mpu6050.c ****     case ANDROID_ORIENT_PORTRAIT:
3700:Src/mpu6050.c ****         consoleLog("Portrait\r\n");
 762              		.loc 1 3700 9 view .LVU223
ARM GAS  /tmp/cc39PcX6.s 			page 83


 763 000c 0448     		ldr	r0, .L44
 764              	.LVL50:
 765              	.L43:
3701:Src/mpu6050.c ****         break;
3702:Src/mpu6050.c ****     case ANDROID_ORIENT_LANDSCAPE:
3703:Src/mpu6050.c ****         consoleLog("Landscape\r\n");
3704:Src/mpu6050.c ****         break;
3705:Src/mpu6050.c ****     case ANDROID_ORIENT_REVERSE_PORTRAIT:
3706:Src/mpu6050.c ****         consoleLog("Rev. Portrait\r\n");
3707:Src/mpu6050.c ****         break;
3708:Src/mpu6050.c ****     case ANDROID_ORIENT_REVERSE_LANDSCAPE:
3709:Src/mpu6050.c ****         consoleLog("Rev. Landscape\r\n");
 766              		.loc 1 3709 9 is_stmt 0 view .LVU224
 767 000e FFF7FEBF 		b	consoleLog
 768              	.LVL51:
 769              	.L41:
3703:Src/mpu6050.c ****         break;
 770              		.loc 1 3703 9 is_stmt 1 view .LVU225
 771 0012 0448     		ldr	r0, .L44+4
 772              	.LVL52:
3703:Src/mpu6050.c ****         break;
 773              		.loc 1 3703 9 is_stmt 0 view .LVU226
 774 0014 FBE7     		b	.L43
 775              	.LVL53:
 776              	.L40:
3706:Src/mpu6050.c ****         break;
 777              		.loc 1 3706 9 is_stmt 1 view .LVU227
 778 0016 0448     		ldr	r0, .L44+8
 779              	.LVL54:
3706:Src/mpu6050.c ****         break;
 780              		.loc 1 3706 9 is_stmt 0 view .LVU228
 781 0018 F9E7     		b	.L43
 782              	.LVL55:
 783              	.L38:
 784              		.loc 1 3709 9 is_stmt 1 view .LVU229
 785 001a 0448     		ldr	r0, .L44+12
 786              	.LVL56:
 787              		.loc 1 3709 9 is_stmt 0 view .LVU230
 788 001c F7E7     		b	.L43
 789              	.LVL57:
 790              	.L36:
3710:Src/mpu6050.c ****         break;
3711:Src/mpu6050.c ****     default:
3712:Src/mpu6050.c ****         return;
3713:Src/mpu6050.c ****     }
3714:Src/mpu6050.c **** }
 791              		.loc 1 3714 1 view .LVU231
 792 001e 7047     		bx	lr
 793              	.L45:
 794              		.align	2
 795              	.L44:
 796 0020 00000000 		.word	.LC6
 797 0024 0B000000 		.word	.LC7
 798 0028 17000000 		.word	.LC8
 799 002c 27000000 		.word	.LC9
 800              		.cfi_endproc
 801              	.LFE119:
ARM GAS  /tmp/cc39PcX6.s 			page 84


 803              		.section	.text.set_int_enable.isra.0,"ax",%progbits
 804              		.align	1
 805              		.syntax unified
 806              		.thumb
 807              		.thumb_func
 808              		.fpu softvfp
 810              	set_int_enable.isra.0:
 811              	.LVL58:
 812              	.LFB124:
 577:Src/mpu6050.c **** {
 813              		.loc 1 577 12 is_stmt 1 view -0
 814              		.cfi_startproc
 815              		@ args = 0, pretend = 0, frame = 8
 816              		@ frame_needed = 0, uses_anonymous_args = 0
 579:Src/mpu6050.c **** 
 817              		.loc 1 579 5 view .LVU233
 581:Src/mpu6050.c ****         if (enable)
 818              		.loc 1 581 5 view .LVU234
 577:Src/mpu6050.c **** {
 819              		.loc 1 577 12 is_stmt 0 view .LVU235
 820 0000 13B5     		push	{r0, r1, r4, lr}
 821              	.LCFI4:
 822              		.cfi_def_cfa_offset 16
 823              		.cfi_offset 4, -8
 824              		.cfi_offset 14, -4
 581:Src/mpu6050.c ****         if (enable)
 825              		.loc 1 581 20 view .LVU236
 826 0002 114C     		ldr	r4, .L59
 581:Src/mpu6050.c ****         if (enable)
 827              		.loc 1 581 8 view .LVU237
 828 0004 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 829 0008 2BB1     		cbz	r3, .L47
 582:Src/mpu6050.c ****             tmp = BIT_DMP_INT_EN;
 830              		.loc 1 582 9 is_stmt 1 view .LVU238
 583:Src/mpu6050.c ****         else
 831              		.loc 1 583 17 is_stmt 0 view .LVU239
 832 000a 0028     		cmp	r0, #0
 833 000c 18BF     		it	ne
 834 000e 0220     		movne	r0, #2
 835              	.LVL59:
 836              	.L52:
 594:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 837              		.loc 1 594 9 is_stmt 1 view .LVU240
 597:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 838              		.loc 1 597 13 view .LVU241
 597:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 839              		.loc 1 597 17 is_stmt 0 view .LVU242
 840 0010 8DF80700 		strb	r0, [sp, #7]
 841 0014 08E0     		b	.L53
 842              	.LVL60:
 843              	.L47:
 590:Src/mpu6050.c ****             return -1;
 844              		.loc 1 590 9 is_stmt 1 view .LVU243
 590:Src/mpu6050.c ****             return -1;
 845              		.loc 1 590 12 is_stmt 0 view .LVU244
 846 0016 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 847 0018 9BB1     		cbz	r3, .L46
ARM GAS  /tmp/cc39PcX6.s 			page 85


 592:Src/mpu6050.c ****             return 0;
 848              		.loc 1 592 9 is_stmt 1 view .LVU245
 592:Src/mpu6050.c ****             return 0;
 849              		.loc 1 592 12 is_stmt 0 view .LVU246
 850 001a 0028     		cmp	r0, #0
 851 001c F8D0     		beq	.L52
 592:Src/mpu6050.c ****             return 0;
 852              		.loc 1 592 20 view .LVU247
 853 001e 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
 854 0020 7BB9     		cbnz	r3, .L46
 594:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 855              		.loc 1 594 9 is_stmt 1 view .LVU248
 595:Src/mpu6050.c ****         else
 856              		.loc 1 595 13 view .LVU249
 595:Src/mpu6050.c ****         else
 857              		.loc 1 595 17 is_stmt 0 view .LVU250
 858 0022 0123     		movs	r3, #1
 859 0024 8DF80730 		strb	r3, [sp, #7]
 860              	.LVL61:
 861              	.L53:
 598:Src/mpu6050.c ****             return -1;
 862              		.loc 1 598 9 is_stmt 1 view .LVU251
 598:Src/mpu6050.c ****             return -1;
 863              		.loc 1 598 13 is_stmt 0 view .LVU252
 864 0028 D4E90010 		ldrd	r1, r0, [r4]
 865 002c 0122     		movs	r2, #1
 866 002e 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 867 0030 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 868 0032 0DF10703 		add	r3, sp, #7
 869 0036 FFF7FEFF 		bl	i2c_writeBytes
 870              	.LVL62:
 598:Src/mpu6050.c ****             return -1;
 871              		.loc 1 598 12 view .LVU253
 872 003a 10B9     		cbnz	r0, .L46
 600:Src/mpu6050.c ****     }
 873              		.loc 1 600 9 is_stmt 1 view .LVU254
 600:Src/mpu6050.c ****     }
 874              		.loc 1 600 32 is_stmt 0 view .LVU255
 875 003c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 876 0040 6374     		strb	r3, [r4, #17]
 877              	.L46:
 603:Src/mpu6050.c **** 
 878              		.loc 1 603 1 view .LVU256
 879 0042 02B0     		add	sp, sp, #8
 880              	.LCFI5:
 881              		.cfi_def_cfa_offset 8
 882              		@ sp needed
 883 0044 10BD     		pop	{r4, pc}
 884              	.L60:
 885 0046 00BF     		.align	2
 886              	.L59:
 887 0048 00000000 		.word	.LANCHOR0
 888              		.cfi_endproc
 889              	.LFE124:
 891              		.section	.text.mpu_reg_dump,"ax",%progbits
 892              		.align	1
 893              		.global	mpu_reg_dump
ARM GAS  /tmp/cc39PcX6.s 			page 86


 894              		.syntax unified
 895              		.thumb
 896              		.thumb_func
 897              		.fpu softvfp
 899              	mpu_reg_dump:
 900              	.LFB60:
 610:Src/mpu6050.c ****     unsigned char ii;
 901              		.loc 1 610 1 is_stmt 1 view -0
 902              		.cfi_startproc
 903              		@ args = 0, pretend = 0, frame = 8
 904              		@ frame_needed = 0, uses_anonymous_args = 0
 611:Src/mpu6050.c ****     unsigned char data;
 905              		.loc 1 611 5 view .LVU258
 612:Src/mpu6050.c **** 
 906              		.loc 1 612 5 view .LVU259
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 907              		.loc 1 614 5 view .LVU260
 908              	.LVL63:
 610:Src/mpu6050.c ****     unsigned char ii;
 909              		.loc 1 610 1 is_stmt 0 view .LVU261
 910 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 911              	.LCFI6:
 912              		.cfi_def_cfa_offset 24
 913              		.cfi_offset 4, -12
 914              		.cfi_offset 5, -8
 915              		.cfi_offset 14, -4
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 916              		.loc 1 614 5 view .LVU262
 917 0002 0024     		movs	r4, #0
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 918              		.loc 1 614 25 view .LVU263
 919 0004 0E4D     		ldr	r5, .L68
 920              	.LVL64:
 921              	.L62:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 922              		.loc 1 614 25 discriminator 1 view .LVU264
 923 0006 6868     		ldr	r0, [r5, #4]
 924 0008 E1B2     		uxtb	r1, r4
 925              	.LVL65:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 926              		.loc 1 614 18 is_stmt 1 discriminator 1 view .LVU265
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 927              		.loc 1 614 5 is_stmt 0 discriminator 1 view .LVU266
 928 000a 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 929 000c 8B42     		cmp	r3, r1
 930 000e 02D8     		bhi	.L66
 623:Src/mpu6050.c **** }
 931              		.loc 1 623 12 view .LVU267
 932 0010 0020     		movs	r0, #0
 933              	.LVL66:
 934              	.L61:
 624:Src/mpu6050.c **** 
 935              		.loc 1 624 1 view .LVU268
 936 0012 03B0     		add	sp, sp, #12
 937              	.LCFI7:
 938              		.cfi_remember_state
 939              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/cc39PcX6.s 			page 87


 940              		@ sp needed
 941 0014 30BD     		pop	{r4, r5, pc}
 942              	.LVL67:
 943              	.L66:
 944              	.LCFI8:
 945              		.cfi_restore_state
 615:Src/mpu6050.c ****             continue;
 946              		.loc 1 615 9 is_stmt 1 view .LVU269
 615:Src/mpu6050.c ****             continue;
 947              		.loc 1 615 21 is_stmt 0 view .LVU270
 948 0016 2B68     		ldr	r3, [r5]
 615:Src/mpu6050.c ****             continue;
 949              		.loc 1 615 12 view .LVU271
 950 0018 5A7B     		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 951 001a 8A42     		cmp	r2, r1
 952 001c 01D1     		bne	.L63
 953              	.LVL68:
 954              	.L64:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 955              		.loc 1 614 39 is_stmt 1 view .LVU272
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 956              		.loc 1 614 39 is_stmt 0 view .LVU273
 957 001e 0134     		adds	r4, r4, #1
 958              	.LVL69:
 614:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 959              		.loc 1 614 39 view .LVU274
 960 0020 F1E7     		b	.L62
 961              	.LVL70:
 962              	.L63:
 615:Src/mpu6050.c ****             continue;
 963              		.loc 1 615 36 discriminator 1 view .LVU275
 964 0022 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 965 0024 8B42     		cmp	r3, r1
 966 0026 FAD0     		beq	.L64
 617:Src/mpu6050.c ****             return -1;
 967              		.loc 1 617 9 is_stmt 1 view .LVU276
 617:Src/mpu6050.c ****             return -1;
 968              		.loc 1 617 13 is_stmt 0 view .LVU277
 969 0028 0122     		movs	r2, #1
 970 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 971 002c 0DF10703 		add	r3, sp, #7
 972 0030 FFF7FEFF 		bl	i2c_readBytes
 973              	.LVL71:
 617:Src/mpu6050.c ****             return -1;
 974              		.loc 1 617 12 view .LVU278
 975 0034 0028     		cmp	r0, #0
 976 0036 F2D0     		beq	.L64
 618:Src/mpu6050.c ****             #ifdef SERIAL_DEBUG
 977              		.loc 1 618 20 view .LVU279
 978 0038 4FF0FF30 		mov	r0, #-1
 979 003c E9E7     		b	.L61
 980              	.L69:
 981 003e 00BF     		.align	2
 982              	.L68:
 983 0040 00000000 		.word	.LANCHOR0
 984              		.cfi_endproc
 985              	.LFE60:
ARM GAS  /tmp/cc39PcX6.s 			page 88


 987              		.section	.text.mpu_read_reg,"ax",%progbits
 988              		.align	1
 989              		.global	mpu_read_reg
 990              		.syntax unified
 991              		.thumb
 992              		.thumb_func
 993              		.fpu softvfp
 995              	mpu_read_reg:
 996              	.LVL72:
 997              	.LFB61:
 634:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 998              		.loc 1 634 1 is_stmt 1 view -0
 999              		.cfi_startproc
 1000              		@ args = 0, pretend = 0, frame = 0
 1001              		@ frame_needed = 0, uses_anonymous_args = 0
 635:Src/mpu6050.c ****         return -1;
 1002              		.loc 1 635 5 view .LVU281
 634:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 1003              		.loc 1 634 1 is_stmt 0 view .LVU282
 1004 0000 10B5     		push	{r4, lr}
 1005              	.LCFI9:
 1006              		.cfi_def_cfa_offset 8
 1007              		.cfi_offset 4, -8
 1008              		.cfi_offset 14, -4
 635:Src/mpu6050.c ****         return -1;
 1009              		.loc 1 635 18 view .LVU283
 1010 0002 0B4A     		ldr	r2, .L75
 634:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 1011              		.loc 1 634 1 view .LVU284
 1012 0004 0B46     		mov	r3, r1
 635:Src/mpu6050.c ****         return -1;
 1013              		.loc 1 635 18 view .LVU285
 1014 0006 1168     		ldr	r1, [r2]
 1015              	.LVL73:
 635:Src/mpu6050.c ****         return -1;
 1016              		.loc 1 635 8 view .LVU286
 1017 0008 4C7B     		ldrb	r4, [r1, #13]	@ zero_extendqisi2
 1018 000a 8442     		cmp	r4, r0
 1019 000c 0CD0     		beq	.L74
 635:Src/mpu6050.c ****         return -1;
 1020              		.loc 1 635 33 discriminator 1 view .LVU287
 1021 000e 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 1022 0010 8142     		cmp	r1, r0
 1023 0012 09D0     		beq	.L74
 637:Src/mpu6050.c ****         return -1;
 1024              		.loc 1 637 5 is_stmt 1 view .LVU288
 637:Src/mpu6050.c ****         return -1;
 1025              		.loc 1 637 18 is_stmt 0 view .LVU289
 1026 0014 5468     		ldr	r4, [r2, #4]
 637:Src/mpu6050.c ****         return -1;
 1027              		.loc 1 637 8 view .LVU290
 1028 0016 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 1029 0018 8242     		cmp	r2, r0
 1030 001a 05D9     		bls	.L74
 639:Src/mpu6050.c **** }
 1031              		.loc 1 639 5 is_stmt 1 view .LVU291
 639:Src/mpu6050.c **** }
ARM GAS  /tmp/cc39PcX6.s 			page 89


 1032              		.loc 1 639 12 is_stmt 0 view .LVU292
 1033 001c 0146     		mov	r1, r0
 1034 001e 0122     		movs	r2, #1
 1035 0020 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 1036              	.LVL74:
 639:Src/mpu6050.c **** }
 1037              		.loc 1 639 12 view .LVU293
 1038 0022 FFF7FEFF 		bl	i2c_readBytes
 1039              	.LVL75:
 1040              	.L70:
 640:Src/mpu6050.c **** 
 1041              		.loc 1 640 1 view .LVU294
 1042 0026 10BD     		pop	{r4, pc}
 1043              	.LVL76:
 1044              	.L74:
 636:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 1045              		.loc 1 636 16 view .LVU295
 1046 0028 4FF0FF30 		mov	r0, #-1
 1047              	.LVL77:
 636:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 1048              		.loc 1 636 16 view .LVU296
 1049 002c FBE7     		b	.L70
 1050              	.L76:
 1051 002e 00BF     		.align	2
 1052              	.L75:
 1053 0030 00000000 		.word	.LANCHOR0
 1054              		.cfi_endproc
 1055              	.LFE61:
 1057              		.section	.text.mpu_get_gyro_reg,"ax",%progbits
 1058              		.align	1
 1059              		.global	mpu_get_gyro_reg
 1060              		.syntax unified
 1061              		.thumb
 1062              		.thumb_func
 1063              		.fpu softvfp
 1065              	mpu_get_gyro_reg:
 1066              	.LVL78:
 1067              	.LFB64:
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 1068              		.loc 1 829 1 is_stmt 1 view -0
 1069              		.cfi_startproc
 1070              		@ args = 0, pretend = 0, frame = 8
 1071              		@ frame_needed = 0, uses_anonymous_args = 0
 830:Src/mpu6050.c **** 
 1072              		.loc 1 830 5 view .LVU298
 832:Src/mpu6050.c ****         return -1;
 1073              		.loc 1 832 5 view .LVU299
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 1074              		.loc 1 829 1 is_stmt 0 view .LVU300
 1075 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1076              	.LCFI10:
 1077              		.cfi_def_cfa_offset 24
 1078              		.cfi_offset 4, -16
 1079              		.cfi_offset 5, -12
 1080              		.cfi_offset 6, -8
 1081              		.cfi_offset 14, -4
 832:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 90


 1082              		.loc 1 832 22 view .LVU301
 1083 0002 144B     		ldr	r3, .L82
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 1084              		.loc 1 829 1 view .LVU302
 1085 0004 0546     		mov	r5, r0
 832:Src/mpu6050.c ****         return -1;
 1086              		.loc 1 832 8 view .LVU303
 1087 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 829:Src/mpu6050.c ****     unsigned char tmp[6];
 1088              		.loc 1 829 1 view .LVU304
 1089 0008 0C46     		mov	r4, r1
 832:Src/mpu6050.c ****         return -1;
 1090              		.loc 1 832 8 view .LVU305
 1091 000a 12F0700F 		tst	r2, #112
 1092 000e 03D1     		bne	.L78
 1093              	.LVL79:
 1094              	.L80:
 833:Src/mpu6050.c **** 
 1095              		.loc 1 833 16 view .LVU306
 1096 0010 4FF0FF30 		mov	r0, #-1
 1097              	.L77:
 843:Src/mpu6050.c **** 
 1098              		.loc 1 843 1 view .LVU307
 1099 0014 02B0     		add	sp, sp, #8
 1100              	.LCFI11:
 1101              		.cfi_remember_state
 1102              		.cfi_def_cfa_offset 16
 1103              		@ sp needed
 1104 0016 70BD     		pop	{r4, r5, r6, pc}
 1105              	.LVL80:
 1106              	.L78:
 1107              	.LCFI12:
 1108              		.cfi_restore_state
 835:Src/mpu6050.c ****         return -1;
 1109              		.loc 1 835 5 is_stmt 1 view .LVU308
 835:Src/mpu6050.c ****         return -1;
 1110              		.loc 1 835 9 is_stmt 0 view .LVU309
 1111 0018 D3E90010 		ldrd	r1, r0, [r3]
 1112              	.LVL81:
 835:Src/mpu6050.c ****         return -1;
 1113              		.loc 1 835 9 view .LVU310
 1114 001c 0622     		movs	r2, #6
 1115 001e 6B46     		mov	r3, sp
 1116 0020 897B     		ldrb	r1, [r1, #14]	@ zero_extendqisi2
 1117 0022 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1118 0024 FFF7FEFF 		bl	i2c_readBytes
 1119              	.LVL82:
 835:Src/mpu6050.c ****         return -1;
 1120              		.loc 1 835 8 view .LVU311
 1121 0028 0646     		mov	r6, r0
 1122 002a 0028     		cmp	r0, #0
 1123 002c F0D1     		bne	.L80
 837:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1124              		.loc 1 837 5 is_stmt 1 view .LVU312
 837:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1125              		.loc 1 837 13 is_stmt 0 view .LVU313
 1126 002e BDF80030 		ldrh	r3, [sp]
ARM GAS  /tmp/cc39PcX6.s 			page 91


 841:Src/mpu6050.c ****     return 0;
 1127              		.loc 1 841 9 view .LVU314
 1128 0032 2046     		mov	r0, r4
 837:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1129              		.loc 1 837 13 view .LVU315
 1130 0034 5BBA     		rev16	r3, r3
 1131 0036 2B80     		strh	r3, [r5]	@ movhi
 838:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1132              		.loc 1 838 5 is_stmt 1 view .LVU316
 838:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1133              		.loc 1 838 13 is_stmt 0 view .LVU317
 1134 0038 BDF80230 		ldrh	r3, [sp, #2]
 1135 003c 5BBA     		rev16	r3, r3
 1136 003e 6B80     		strh	r3, [r5, #2]	@ movhi
 839:Src/mpu6050.c ****     if (timestamp)
 1137              		.loc 1 839 5 is_stmt 1 view .LVU318
 839:Src/mpu6050.c ****     if (timestamp)
 1138              		.loc 1 839 13 is_stmt 0 view .LVU319
 1139 0040 BDF80430 		ldrh	r3, [sp, #4]
 1140 0044 5BBA     		rev16	r3, r3
 1141 0046 AB80     		strh	r3, [r5, #4]	@ movhi
 840:Src/mpu6050.c ****         get_ms(timestamp);
 1142              		.loc 1 840 5 is_stmt 1 view .LVU320
 840:Src/mpu6050.c ****         get_ms(timestamp);
 1143              		.loc 1 840 8 is_stmt 0 view .LVU321
 1144 0048 002C     		cmp	r4, #0
 1145 004a E3D0     		beq	.L77
 1146              	.LVL83:
 841:Src/mpu6050.c ****     return 0;
 1147              		.loc 1 841 9 is_stmt 1 view .LVU322
 1148 004c FFF7FEFF 		bl	get_tick_count_ms
 1149              	.LVL84:
 842:Src/mpu6050.c **** }
 1150              		.loc 1 842 12 is_stmt 0 view .LVU323
 1151 0050 3046     		mov	r0, r6
 1152 0052 DFE7     		b	.L77
 1153              	.L83:
 1154              		.align	2
 1155              	.L82:
 1156 0054 00000000 		.word	.LANCHOR0
 1157              		.cfi_endproc
 1158              	.LFE64:
 1160              		.section	.text.mpu_get_accel_reg,"ax",%progbits
 1161              		.align	1
 1162              		.global	mpu_get_accel_reg
 1163              		.syntax unified
 1164              		.thumb
 1165              		.thumb_func
 1166              		.fpu softvfp
 1168              	mpu_get_accel_reg:
 1169              	.LVL85:
 1170              	.LFB65:
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1171              		.loc 1 852 1 is_stmt 1 view -0
 1172              		.cfi_startproc
 1173              		@ args = 0, pretend = 0, frame = 8
 1174              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc39PcX6.s 			page 92


 853:Src/mpu6050.c **** 
 1175              		.loc 1 853 5 view .LVU325
 855:Src/mpu6050.c ****         return -1;
 1176              		.loc 1 855 5 view .LVU326
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1177              		.loc 1 852 1 is_stmt 0 view .LVU327
 1178 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1179              	.LCFI13:
 1180              		.cfi_def_cfa_offset 24
 1181              		.cfi_offset 4, -16
 1182              		.cfi_offset 5, -12
 1183              		.cfi_offset 6, -8
 1184              		.cfi_offset 14, -4
 855:Src/mpu6050.c ****         return -1;
 1185              		.loc 1 855 22 view .LVU328
 1186 0002 144B     		ldr	r3, .L89
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1187              		.loc 1 852 1 view .LVU329
 1188 0004 0546     		mov	r5, r0
 855:Src/mpu6050.c ****         return -1;
 1189              		.loc 1 855 8 view .LVU330
 1190 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 852:Src/mpu6050.c ****     unsigned char tmp[6];
 1191              		.loc 1 852 1 view .LVU331
 1192 0008 0C46     		mov	r4, r1
 855:Src/mpu6050.c ****         return -1;
 1193              		.loc 1 855 8 view .LVU332
 1194 000a 1207     		lsls	r2, r2, #28
 1195 000c 03D4     		bmi	.L85
 1196              	.LVL86:
 1197              	.L87:
 856:Src/mpu6050.c **** 
 1198              		.loc 1 856 16 view .LVU333
 1199 000e 4FF0FF30 		mov	r0, #-1
 1200              	.L84:
 866:Src/mpu6050.c **** 
 1201              		.loc 1 866 1 view .LVU334
 1202 0012 02B0     		add	sp, sp, #8
 1203              	.LCFI14:
 1204              		.cfi_remember_state
 1205              		.cfi_def_cfa_offset 16
 1206              		@ sp needed
 1207 0014 70BD     		pop	{r4, r5, r6, pc}
 1208              	.LVL87:
 1209              	.L85:
 1210              	.LCFI15:
 1211              		.cfi_restore_state
 858:Src/mpu6050.c ****         return -1;
 1212              		.loc 1 858 5 is_stmt 1 view .LVU335
 858:Src/mpu6050.c ****         return -1;
 1213              		.loc 1 858 9 is_stmt 0 view .LVU336
 1214 0016 D3E90010 		ldrd	r1, r0, [r3]
 1215              	.LVL88:
 858:Src/mpu6050.c ****         return -1;
 1216              		.loc 1 858 9 view .LVU337
 1217 001a 0622     		movs	r2, #6
 1218 001c 6B46     		mov	r3, sp
ARM GAS  /tmp/cc39PcX6.s 			page 93


 1219 001e C97B     		ldrb	r1, [r1, #15]	@ zero_extendqisi2
 1220 0020 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1221 0022 FFF7FEFF 		bl	i2c_readBytes
 1222              	.LVL89:
 858:Src/mpu6050.c ****         return -1;
 1223              		.loc 1 858 8 view .LVU338
 1224 0026 0646     		mov	r6, r0
 1225 0028 0028     		cmp	r0, #0
 1226 002a F0D1     		bne	.L87
 860:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1227              		.loc 1 860 5 is_stmt 1 view .LVU339
 860:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1228              		.loc 1 860 13 is_stmt 0 view .LVU340
 1229 002c BDF80030 		ldrh	r3, [sp]
 864:Src/mpu6050.c ****     return 0;
 1230              		.loc 1 864 9 view .LVU341
 1231 0030 2046     		mov	r0, r4
 860:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1232              		.loc 1 860 13 view .LVU342
 1233 0032 5BBA     		rev16	r3, r3
 1234 0034 2B80     		strh	r3, [r5]	@ movhi
 861:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1235              		.loc 1 861 5 is_stmt 1 view .LVU343
 861:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1236              		.loc 1 861 13 is_stmt 0 view .LVU344
 1237 0036 BDF80230 		ldrh	r3, [sp, #2]
 1238 003a 5BBA     		rev16	r3, r3
 1239 003c 6B80     		strh	r3, [r5, #2]	@ movhi
 862:Src/mpu6050.c ****     if (timestamp)
 1240              		.loc 1 862 5 is_stmt 1 view .LVU345
 862:Src/mpu6050.c ****     if (timestamp)
 1241              		.loc 1 862 13 is_stmt 0 view .LVU346
 1242 003e BDF80430 		ldrh	r3, [sp, #4]
 1243 0042 5BBA     		rev16	r3, r3
 1244 0044 AB80     		strh	r3, [r5, #4]	@ movhi
 863:Src/mpu6050.c ****         get_ms(timestamp);
 1245              		.loc 1 863 5 is_stmt 1 view .LVU347
 863:Src/mpu6050.c ****         get_ms(timestamp);
 1246              		.loc 1 863 8 is_stmt 0 view .LVU348
 1247 0046 002C     		cmp	r4, #0
 1248 0048 E3D0     		beq	.L84
 1249              	.LVL90:
 864:Src/mpu6050.c ****     return 0;
 1250              		.loc 1 864 9 is_stmt 1 view .LVU349
 1251 004a FFF7FEFF 		bl	get_tick_count_ms
 1252              	.LVL91:
 865:Src/mpu6050.c **** }
 1253              		.loc 1 865 12 is_stmt 0 view .LVU350
 1254 004e 3046     		mov	r0, r6
 1255 0050 DFE7     		b	.L84
 1256              	.L90:
 1257 0052 00BF     		.align	2
 1258              	.L89:
 1259 0054 00000000 		.word	.LANCHOR0
 1260              		.cfi_endproc
 1261              	.LFE65:
 1263              		.global	__aeabi_i2f
ARM GAS  /tmp/cc39PcX6.s 			page 94


 1264              		.global	__aeabi_fsub
 1265              		.global	__aeabi_fdiv
 1266              		.global	__aeabi_fadd
 1267              		.global	__aeabi_fmul
 1268              		.global	__aeabi_f2iz
 1269              		.section	.text.mpu_get_temperature,"ax",%progbits
 1270              		.align	1
 1271              		.global	mpu_get_temperature
 1272              		.syntax unified
 1273              		.thumb
 1274              		.thumb_func
 1275              		.fpu softvfp
 1277              	mpu_get_temperature:
 1278              	.LVL92:
 1279              	.LFB66:
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1280              		.loc 1 875 1 is_stmt 1 view -0
 1281              		.cfi_startproc
 1282              		@ args = 0, pretend = 0, frame = 8
 1283              		@ frame_needed = 0, uses_anonymous_args = 0
 876:Src/mpu6050.c ****     short raw;
 1284              		.loc 1 876 5 view .LVU352
 877:Src/mpu6050.c **** 
 1285              		.loc 1 877 5 view .LVU353
 879:Src/mpu6050.c ****         return -1;
 1286              		.loc 1 879 5 view .LVU354
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1287              		.loc 1 875 1 is_stmt 0 view .LVU355
 1288 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1289              	.LCFI16:
 1290              		.cfi_def_cfa_offset 32
 1291              		.cfi_offset 4, -20
 1292              		.cfi_offset 5, -16
 1293              		.cfi_offset 6, -12
 1294              		.cfi_offset 7, -8
 1295              		.cfi_offset 14, -4
 879:Src/mpu6050.c ****         return -1;
 1296              		.loc 1 879 22 view .LVU356
 1297 0002 1D4C     		ldr	r4, .L99
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1298              		.loc 1 875 1 view .LVU357
 1299 0004 0646     		mov	r6, r0
 879:Src/mpu6050.c ****         return -1;
 1300              		.loc 1 879 8 view .LVU358
 1301 0006 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 875:Src/mpu6050.c ****     unsigned char tmp[2];
 1302              		.loc 1 875 1 view .LVU359
 1303 0008 0D46     		mov	r5, r1
 879:Src/mpu6050.c ****         return -1;
 1304              		.loc 1 879 8 view .LVU360
 1305 000a 1BB9     		cbnz	r3, .L92
 1306              	.LVL93:
 1307              	.L94:
 880:Src/mpu6050.c **** 
 1308              		.loc 1 880 16 view .LVU361
 1309 000c 4FF0FF30 		mov	r0, #-1
 1310              	.LVL94:
ARM GAS  /tmp/cc39PcX6.s 			page 95


 1311              	.L91:
 890:Src/mpu6050.c **** 
 1312              		.loc 1 890 1 view .LVU362
 1313 0010 03B0     		add	sp, sp, #12
 1314              	.LCFI17:
 1315              		.cfi_remember_state
 1316              		.cfi_def_cfa_offset 20
 1317              		@ sp needed
 1318 0012 F0BD     		pop	{r4, r5, r6, r7, pc}
 1319              	.LVL95:
 1320              	.L92:
 1321              	.LCFI18:
 1322              		.cfi_restore_state
 882:Src/mpu6050.c ****         return -1;
 1323              		.loc 1 882 5 is_stmt 1 view .LVU363
 882:Src/mpu6050.c ****         return -1;
 1324              		.loc 1 882 9 is_stmt 0 view .LVU364
 1325 0014 D4E90010 		ldrd	r1, r0, [r4]
 1326              	.LVL96:
 882:Src/mpu6050.c ****         return -1;
 1327              		.loc 1 882 9 view .LVU365
 1328 0018 0222     		movs	r2, #2
 1329 001a 097C     		ldrb	r1, [r1, #16]	@ zero_extendqisi2
 1330 001c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1331 001e 01AB     		add	r3, sp, #4
 1332 0020 FFF7FEFF 		bl	i2c_readBytes
 1333              	.LVL97:
 882:Src/mpu6050.c ****         return -1;
 1334              		.loc 1 882 8 view .LVU366
 1335 0024 0028     		cmp	r0, #0
 1336 0026 F1D1     		bne	.L94
 884:Src/mpu6050.c ****     if (timestamp)
 1337              		.loc 1 884 5 is_stmt 1 view .LVU367
 1338 0028 BDF80470 		ldrh	r7, [sp, #4]
 1339 002c FFBA     		revsh	r7, r7
 1340              	.LVL98:
 885:Src/mpu6050.c ****         get_ms(timestamp);
 1341              		.loc 1 885 5 view .LVU368
 885:Src/mpu6050.c ****         get_ms(timestamp);
 1342              		.loc 1 885 8 is_stmt 0 view .LVU369
 1343 002e 15B1     		cbz	r5, .L95
 886:Src/mpu6050.c **** 
 1344              		.loc 1 886 9 is_stmt 1 view .LVU370
 1345 0030 2846     		mov	r0, r5
 1346 0032 FFF7FEFF 		bl	get_tick_count_ms
 1347              	.LVL99:
 1348              	.L95:
 888:Src/mpu6050.c ****     return 0;
 1349              		.loc 1 888 5 view .LVU371
 888:Src/mpu6050.c ****     return 0;
 1350              		.loc 1 888 34 is_stmt 0 view .LVU372
 1351 0036 3846     		mov	r0, r7
 1352 0038 FFF7FEFF 		bl	__aeabi_i2f
 1353              	.LVL100:
 888:Src/mpu6050.c ****     return 0;
 1354              		.loc 1 888 45 view .LVU373
 1355 003c 6568     		ldr	r5, [r4, #4]
ARM GAS  /tmp/cc39PcX6.s 			page 96


 1356              	.LVL101:
 888:Src/mpu6050.c ****     return 0;
 1357              		.loc 1 888 34 view .LVU374
 1358 003e 0446     		mov	r4, r0
 888:Src/mpu6050.c ****     return 0;
 1359              		.loc 1 888 36 view .LVU375
 1360 0040 B5F90800 		ldrsh	r0, [r5, #8]
 1361 0044 FFF7FEFF 		bl	__aeabi_i2f
 1362              	.LVL102:
 1363 0048 0146     		mov	r1, r0
 888:Src/mpu6050.c ****     return 0;
 1364              		.loc 1 888 34 view .LVU376
 1365 004a 2046     		mov	r0, r4
 1366 004c FFF7FEFF 		bl	__aeabi_fsub
 1367              	.LVL103:
 1368 0050 0446     		mov	r4, r0
 888:Src/mpu6050.c ****     return 0;
 1369              		.loc 1 888 63 view .LVU377
 1370 0052 E888     		ldrh	r0, [r5, #6]
 1371 0054 FFF7FEFF 		bl	__aeabi_i2f
 1372              	.LVL104:
 1373 0058 0146     		mov	r1, r0
 1374 005a 2046     		mov	r0, r4
 1375 005c FFF7FEFF 		bl	__aeabi_fdiv
 1376              	.LVL105:
 888:Src/mpu6050.c ****     return 0;
 1377              		.loc 1 888 26 view .LVU378
 1378 0060 0649     		ldr	r1, .L99+4
 1379 0062 FFF7FEFF 		bl	__aeabi_fadd
 1380              	.LVL106:
 888:Src/mpu6050.c ****     return 0;
 1381              		.loc 1 888 84 view .LVU379
 1382 0066 4FF08F41 		mov	r1, #1199570944
 1383 006a FFF7FEFF 		bl	__aeabi_fmul
 1384              	.LVL107:
 888:Src/mpu6050.c ****     return 0;
 1385              		.loc 1 888 15 view .LVU380
 1386 006e FFF7FEFF 		bl	__aeabi_f2iz
 1387              	.LVL108:
 1388 0072 3060     		str	r0, [r6]
 889:Src/mpu6050.c **** }
 1389              		.loc 1 889 5 is_stmt 1 view .LVU381
 889:Src/mpu6050.c **** }
 1390              		.loc 1 889 12 is_stmt 0 view .LVU382
 1391 0074 0020     		movs	r0, #0
 1392 0076 CBE7     		b	.L91
 1393              	.L100:
 1394              		.align	2
 1395              	.L99:
 1396 0078 00000000 		.word	.LANCHOR0
 1397 007c 00000C42 		.word	1108082688
 1398              		.cfi_endproc
 1399              	.LFE66:
 1401              		.section	.text.mpu_read_6500_accel_bias,"ax",%progbits
 1402              		.align	1
 1403              		.global	mpu_read_6500_accel_bias
 1404              		.syntax unified
ARM GAS  /tmp/cc39PcX6.s 			page 97


 1405              		.thumb
 1406              		.thumb_func
 1407              		.fpu softvfp
 1409              	mpu_read_6500_accel_bias:
 1410              	.LVL109:
 1411              	.LFB67:
 900:Src/mpu6050.c ****     unsigned char data[6];
 1412              		.loc 1 900 48 is_stmt 1 view -0
 1413              		.cfi_startproc
 1414              		@ args = 0, pretend = 0, frame = 8
 1415              		@ frame_needed = 0, uses_anonymous_args = 0
 901:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
 1416              		.loc 1 901 5 view .LVU384
 902:Src/mpu6050.c ****         return -1;
 1417              		.loc 1 902 5 view .LVU385
 900:Src/mpu6050.c ****     unsigned char data[6];
 1418              		.loc 1 900 48 is_stmt 0 view .LVU386
 1419 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1420              	.LCFI19:
 1421              		.cfi_def_cfa_offset 24
 1422              		.cfi_offset 4, -12
 1423              		.cfi_offset 5, -8
 1424              		.cfi_offset 14, -4
 902:Src/mpu6050.c ****         return -1;
 1425              		.loc 1 902 20 view .LVU387
 1426 0002 184D     		ldr	r5, .L105
 900:Src/mpu6050.c ****     unsigned char data[6];
 1427              		.loc 1 900 48 view .LVU388
 1428 0004 0446     		mov	r4, r0
 902:Src/mpu6050.c ****         return -1;
 1429              		.loc 1 902 9 view .LVU389
 1430 0006 6868     		ldr	r0, [r5, #4]
 1431              	.LVL110:
 902:Src/mpu6050.c ****         return -1;
 1432              		.loc 1 902 9 view .LVU390
 1433 0008 6B46     		mov	r3, sp
 1434 000a 0222     		movs	r2, #2
 1435 000c 7721     		movs	r1, #119
 1436 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1437 0010 FFF7FEFF 		bl	i2c_readBytes
 1438              	.LVL111:
 902:Src/mpu6050.c ****         return -1;
 1439              		.loc 1 902 8 view .LVU391
 1440 0014 18B1     		cbz	r0, .L102
 1441              	.L104:
 903:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
 1442              		.loc 1 903 16 view .LVU392
 1443 0016 4FF0FF30 		mov	r0, #-1
 1444              	.L101:
 912:Src/mpu6050.c **** 
 1445              		.loc 1 912 1 view .LVU393
 1446 001a 03B0     		add	sp, sp, #12
 1447              	.LCFI20:
 1448              		.cfi_remember_state
 1449              		.cfi_def_cfa_offset 12
 1450              		@ sp needed
 1451 001c 30BD     		pop	{r4, r5, pc}
ARM GAS  /tmp/cc39PcX6.s 			page 98


 1452              	.LVL112:
 1453              	.L102:
 1454              	.LCFI21:
 1455              		.cfi_restore_state
 904:Src/mpu6050.c ****         return -1;
 1456              		.loc 1 904 5 is_stmt 1 view .LVU394
 904:Src/mpu6050.c ****         return -1;
 1457              		.loc 1 904 9 is_stmt 0 view .LVU395
 1458 001e 6868     		ldr	r0, [r5, #4]
 1459 0020 0222     		movs	r2, #2
 1460 0022 7A21     		movs	r1, #122
 1461 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1462 0026 0DF10203 		add	r3, sp, #2
 1463 002a FFF7FEFF 		bl	i2c_readBytes
 1464              	.LVL113:
 904:Src/mpu6050.c ****         return -1;
 1465              		.loc 1 904 8 view .LVU396
 1466 002e 0028     		cmp	r0, #0
 1467 0030 F1D1     		bne	.L104
 906:Src/mpu6050.c ****         return -1;
 1468              		.loc 1 906 5 is_stmt 1 view .LVU397
 906:Src/mpu6050.c ****         return -1;
 1469              		.loc 1 906 9 is_stmt 0 view .LVU398
 1470 0032 6868     		ldr	r0, [r5, #4]
 1471 0034 0222     		movs	r2, #2
 1472 0036 7D21     		movs	r1, #125
 1473 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1474 003a 01AB     		add	r3, sp, #4
 1475 003c FFF7FEFF 		bl	i2c_readBytes
 1476              	.LVL114:
 906:Src/mpu6050.c ****         return -1;
 1477              		.loc 1 906 8 view .LVU399
 1478 0040 0028     		cmp	r0, #0
 1479 0042 E8D1     		bne	.L104
 908:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1480              		.loc 1 908 5 is_stmt 1 view .LVU400
 908:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1481              		.loc 1 908 19 is_stmt 0 view .LVU401
 1482 0044 BDF80030 		ldrh	r3, [sp]
 1483 0048 5BBA     		rev16	r3, r3
 1484 004a 9BB2     		uxth	r3, r3
 1485 004c 2360     		str	r3, [r4]
 909:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1486              		.loc 1 909 5 is_stmt 1 view .LVU402
 909:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1487              		.loc 1 909 19 is_stmt 0 view .LVU403
 1488 004e BDF80230 		ldrh	r3, [sp, #2]
 1489 0052 5BBA     		rev16	r3, r3
 1490 0054 9BB2     		uxth	r3, r3
 1491 0056 6360     		str	r3, [r4, #4]
 910:Src/mpu6050.c ****     return 0;
 1492              		.loc 1 910 5 is_stmt 1 view .LVU404
 910:Src/mpu6050.c ****     return 0;
 1493              		.loc 1 910 19 is_stmt 0 view .LVU405
 1494 0058 BDF80430 		ldrh	r3, [sp, #4]
 1495 005c 5BBA     		rev16	r3, r3
 1496 005e 9BB2     		uxth	r3, r3
ARM GAS  /tmp/cc39PcX6.s 			page 99


 1497 0060 A360     		str	r3, [r4, #8]
 911:Src/mpu6050.c **** }
 1498              		.loc 1 911 5 is_stmt 1 view .LVU406
 911:Src/mpu6050.c **** }
 1499              		.loc 1 911 12 is_stmt 0 view .LVU407
 1500 0062 DAE7     		b	.L101
 1501              	.L106:
 1502              		.align	2
 1503              	.L105:
 1504 0064 00000000 		.word	.LANCHOR0
 1505              		.cfi_endproc
 1506              	.LFE67:
 1508              		.section	.text.mpu_read_6050_accel_bias,"ax",%progbits
 1509              		.align	1
 1510              		.global	mpu_read_6050_accel_bias
 1511              		.syntax unified
 1512              		.thumb
 1513              		.thumb_func
 1514              		.fpu softvfp
 1516              	mpu_read_6050_accel_bias:
 1517              	.LVL115:
 1518              	.LFB68:
 922:Src/mpu6050.c ****     unsigned char data[6];
 1519              		.loc 1 922 48 is_stmt 1 view -0
 1520              		.cfi_startproc
 1521              		@ args = 0, pretend = 0, frame = 8
 1522              		@ frame_needed = 0, uses_anonymous_args = 0
 923:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
 1523              		.loc 1 923 5 view .LVU409
 924:Src/mpu6050.c ****         return -1;
 1524              		.loc 1 924 5 view .LVU410
 922:Src/mpu6050.c ****     unsigned char data[6];
 1525              		.loc 1 922 48 is_stmt 0 view .LVU411
 1526 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1527              	.LCFI22:
 1528              		.cfi_def_cfa_offset 24
 1529              		.cfi_offset 4, -12
 1530              		.cfi_offset 5, -8
 1531              		.cfi_offset 14, -4
 924:Src/mpu6050.c ****         return -1;
 1532              		.loc 1 924 20 view .LVU412
 1533 0002 184D     		ldr	r5, .L111
 922:Src/mpu6050.c ****     unsigned char data[6];
 1534              		.loc 1 922 48 view .LVU413
 1535 0004 0446     		mov	r4, r0
 924:Src/mpu6050.c ****         return -1;
 1536              		.loc 1 924 9 view .LVU414
 1537 0006 6868     		ldr	r0, [r5, #4]
 1538              	.LVL116:
 924:Src/mpu6050.c ****         return -1;
 1539              		.loc 1 924 9 view .LVU415
 1540 0008 6B46     		mov	r3, sp
 1541 000a 0222     		movs	r2, #2
 1542 000c 0621     		movs	r1, #6
 1543 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1544 0010 FFF7FEFF 		bl	i2c_readBytes
 1545              	.LVL117:
ARM GAS  /tmp/cc39PcX6.s 			page 100


 924:Src/mpu6050.c ****         return -1;
 1546              		.loc 1 924 8 view .LVU416
 1547 0014 18B1     		cbz	r0, .L108
 1548              	.L110:
 925:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
 1549              		.loc 1 925 16 view .LVU417
 1550 0016 4FF0FF30 		mov	r0, #-1
 1551              	.L107:
 934:Src/mpu6050.c **** 
 1552              		.loc 1 934 1 view .LVU418
 1553 001a 03B0     		add	sp, sp, #12
 1554              	.LCFI23:
 1555              		.cfi_remember_state
 1556              		.cfi_def_cfa_offset 12
 1557              		@ sp needed
 1558 001c 30BD     		pop	{r4, r5, pc}
 1559              	.LVL118:
 1560              	.L108:
 1561              	.LCFI24:
 1562              		.cfi_restore_state
 926:Src/mpu6050.c ****         return -1;
 1563              		.loc 1 926 5 is_stmt 1 view .LVU419
 926:Src/mpu6050.c ****         return -1;
 1564              		.loc 1 926 9 is_stmt 0 view .LVU420
 1565 001e 6868     		ldr	r0, [r5, #4]
 1566 0020 0222     		movs	r2, #2
 1567 0022 0821     		movs	r1, #8
 1568 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1569 0026 0DF10203 		add	r3, sp, #2
 1570 002a FFF7FEFF 		bl	i2c_readBytes
 1571              	.LVL119:
 926:Src/mpu6050.c ****         return -1;
 1572              		.loc 1 926 8 view .LVU421
 1573 002e 0028     		cmp	r0, #0
 1574 0030 F1D1     		bne	.L110
 928:Src/mpu6050.c ****         return -1;
 1575              		.loc 1 928 5 is_stmt 1 view .LVU422
 928:Src/mpu6050.c ****         return -1;
 1576              		.loc 1 928 9 is_stmt 0 view .LVU423
 1577 0032 6868     		ldr	r0, [r5, #4]
 1578 0034 0222     		movs	r2, #2
 1579 0036 0A21     		movs	r1, #10
 1580 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1581 003a 01AB     		add	r3, sp, #4
 1582 003c FFF7FEFF 		bl	i2c_readBytes
 1583              	.LVL120:
 928:Src/mpu6050.c ****         return -1;
 1584              		.loc 1 928 8 view .LVU424
 1585 0040 0028     		cmp	r0, #0
 1586 0042 E8D1     		bne	.L110
 930:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1587              		.loc 1 930 5 is_stmt 1 view .LVU425
 930:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1588              		.loc 1 930 19 is_stmt 0 view .LVU426
 1589 0044 BDF80030 		ldrh	r3, [sp]
 1590 0048 5BBA     		rev16	r3, r3
 1591 004a 9BB2     		uxth	r3, r3
ARM GAS  /tmp/cc39PcX6.s 			page 101


 1592 004c 2360     		str	r3, [r4]
 931:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1593              		.loc 1 931 5 is_stmt 1 view .LVU427
 931:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1594              		.loc 1 931 19 is_stmt 0 view .LVU428
 1595 004e BDF80230 		ldrh	r3, [sp, #2]
 1596 0052 5BBA     		rev16	r3, r3
 1597 0054 9BB2     		uxth	r3, r3
 1598 0056 6360     		str	r3, [r4, #4]
 932:Src/mpu6050.c ****     return 0;
 1599              		.loc 1 932 5 is_stmt 1 view .LVU429
 932:Src/mpu6050.c ****     return 0;
 1600              		.loc 1 932 19 is_stmt 0 view .LVU430
 1601 0058 BDF80430 		ldrh	r3, [sp, #4]
 1602 005c 5BBA     		rev16	r3, r3
 1603 005e 9BB2     		uxth	r3, r3
 1604 0060 A360     		str	r3, [r4, #8]
 933:Src/mpu6050.c **** }
 1605              		.loc 1 933 5 is_stmt 1 view .LVU431
 933:Src/mpu6050.c **** }
 1606              		.loc 1 933 12 is_stmt 0 view .LVU432
 1607 0062 DAE7     		b	.L107
 1608              	.L112:
 1609              		.align	2
 1610              	.L111:
 1611 0064 00000000 		.word	.LANCHOR0
 1612              		.cfi_endproc
 1613              	.LFE68:
 1615              		.section	.text.mpu_read_6500_gyro_bias,"ax",%progbits
 1616              		.align	1
 1617              		.global	mpu_read_6500_gyro_bias
 1618              		.syntax unified
 1619              		.thumb
 1620              		.thumb_func
 1621              		.fpu softvfp
 1623              	mpu_read_6500_gyro_bias:
 1624              	.LVL121:
 1625              	.LFB69:
 936:Src/mpu6050.c ****     unsigned char data[6];
 1626              		.loc 1 936 46 is_stmt 1 view -0
 1627              		.cfi_startproc
 1628              		@ args = 0, pretend = 0, frame = 8
 1629              		@ frame_needed = 0, uses_anonymous_args = 0
 937:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
 1630              		.loc 1 937 5 view .LVU434
 938:Src/mpu6050.c ****         return -1;
 1631              		.loc 1 938 5 view .LVU435
 936:Src/mpu6050.c ****     unsigned char data[6];
 1632              		.loc 1 936 46 is_stmt 0 view .LVU436
 1633 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1634              	.LCFI25:
 1635              		.cfi_def_cfa_offset 24
 1636              		.cfi_offset 4, -12
 1637              		.cfi_offset 5, -8
 1638              		.cfi_offset 14, -4
 938:Src/mpu6050.c ****         return -1;
 1639              		.loc 1 938 20 view .LVU437
ARM GAS  /tmp/cc39PcX6.s 			page 102


 1640 0002 184D     		ldr	r5, .L117
 936:Src/mpu6050.c ****     unsigned char data[6];
 1641              		.loc 1 936 46 view .LVU438
 1642 0004 0446     		mov	r4, r0
 938:Src/mpu6050.c ****         return -1;
 1643              		.loc 1 938 9 view .LVU439
 1644 0006 6868     		ldr	r0, [r5, #4]
 1645              	.LVL122:
 938:Src/mpu6050.c ****         return -1;
 1646              		.loc 1 938 9 view .LVU440
 1647 0008 6B46     		mov	r3, sp
 1648 000a 0222     		movs	r2, #2
 1649 000c 1321     		movs	r1, #19
 1650 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1651 0010 FFF7FEFF 		bl	i2c_readBytes
 1652              	.LVL123:
 938:Src/mpu6050.c ****         return -1;
 1653              		.loc 1 938 8 view .LVU441
 1654 0014 18B1     		cbz	r0, .L114
 1655              	.L116:
 939:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
 1656              		.loc 1 939 16 view .LVU442
 1657 0016 4FF0FF30 		mov	r0, #-1
 1658              	.L113:
 948:Src/mpu6050.c **** 
 1659              		.loc 1 948 1 view .LVU443
 1660 001a 03B0     		add	sp, sp, #12
 1661              	.LCFI26:
 1662              		.cfi_remember_state
 1663              		.cfi_def_cfa_offset 12
 1664              		@ sp needed
 1665 001c 30BD     		pop	{r4, r5, pc}
 1666              	.LVL124:
 1667              	.L114:
 1668              	.LCFI27:
 1669              		.cfi_restore_state
 940:Src/mpu6050.c ****         return -1;
 1670              		.loc 1 940 5 is_stmt 1 view .LVU444
 940:Src/mpu6050.c ****         return -1;
 1671              		.loc 1 940 9 is_stmt 0 view .LVU445
 1672 001e 6868     		ldr	r0, [r5, #4]
 1673 0020 0222     		movs	r2, #2
 1674 0022 1521     		movs	r1, #21
 1675 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1676 0026 0DF10203 		add	r3, sp, #2
 1677 002a FFF7FEFF 		bl	i2c_readBytes
 1678              	.LVL125:
 940:Src/mpu6050.c ****         return -1;
 1679              		.loc 1 940 8 view .LVU446
 1680 002e 0028     		cmp	r0, #0
 1681 0030 F1D1     		bne	.L116
 942:Src/mpu6050.c ****         return -1;
 1682              		.loc 1 942 5 is_stmt 1 view .LVU447
 942:Src/mpu6050.c ****         return -1;
 1683              		.loc 1 942 9 is_stmt 0 view .LVU448
 1684 0032 6868     		ldr	r0, [r5, #4]
 1685 0034 0222     		movs	r2, #2
ARM GAS  /tmp/cc39PcX6.s 			page 103


 1686 0036 1721     		movs	r1, #23
 1687 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1688 003a 01AB     		add	r3, sp, #4
 1689 003c FFF7FEFF 		bl	i2c_readBytes
 1690              	.LVL126:
 942:Src/mpu6050.c ****         return -1;
 1691              		.loc 1 942 8 view .LVU449
 1692 0040 0028     		cmp	r0, #0
 1693 0042 E8D1     		bne	.L116
 944:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 1694              		.loc 1 944 5 is_stmt 1 view .LVU450
 944:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 1695              		.loc 1 944 18 is_stmt 0 view .LVU451
 1696 0044 BDF80030 		ldrh	r3, [sp]
 1697 0048 5BBA     		rev16	r3, r3
 1698 004a 9BB2     		uxth	r3, r3
 1699 004c 2360     		str	r3, [r4]
 945:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 1700              		.loc 1 945 5 is_stmt 1 view .LVU452
 945:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 1701              		.loc 1 945 18 is_stmt 0 view .LVU453
 1702 004e BDF80230 		ldrh	r3, [sp, #2]
 1703 0052 5BBA     		rev16	r3, r3
 1704 0054 9BB2     		uxth	r3, r3
 1705 0056 6360     		str	r3, [r4, #4]
 946:Src/mpu6050.c ****     return 0;
 1706              		.loc 1 946 5 is_stmt 1 view .LVU454
 946:Src/mpu6050.c ****     return 0;
 1707              		.loc 1 946 18 is_stmt 0 view .LVU455
 1708 0058 BDF80430 		ldrh	r3, [sp, #4]
 1709 005c 5BBA     		rev16	r3, r3
 1710 005e 9BB2     		uxth	r3, r3
 1711 0060 A360     		str	r3, [r4, #8]
 947:Src/mpu6050.c **** }
 1712              		.loc 1 947 5 is_stmt 1 view .LVU456
 947:Src/mpu6050.c **** }
 1713              		.loc 1 947 12 is_stmt 0 view .LVU457
 1714 0062 DAE7     		b	.L113
 1715              	.L118:
 1716              		.align	2
 1717              	.L117:
 1718 0064 00000000 		.word	.LANCHOR0
 1719              		.cfi_endproc
 1720              	.LFE69:
 1722              		.section	.text.mpu_set_gyro_bias_reg,"ax",%progbits
 1723              		.align	1
 1724              		.global	mpu_set_gyro_bias_reg
 1725              		.syntax unified
 1726              		.thumb
 1727              		.thumb_func
 1728              		.fpu softvfp
 1730              	mpu_set_gyro_bias_reg:
 1731              	.LVL127:
 1732              	.LFB70:
 959:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1733              		.loc 1 959 1 is_stmt 1 view -0
 1734              		.cfi_startproc
ARM GAS  /tmp/cc39PcX6.s 			page 104


 1735              		@ args = 0, pretend = 0, frame = 8
 1736              		@ frame_needed = 0, uses_anonymous_args = 0
 960:Src/mpu6050.c ****     int i=0;
 1737              		.loc 1 960 5 view .LVU459
 961:Src/mpu6050.c ****     for(i=0;i<3;i++) {
 1738              		.loc 1 961 5 view .LVU460
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1739              		.loc 1 962 5 view .LVU461
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1740              		.loc 1 962 13 view .LVU462
 963:Src/mpu6050.c ****     }
 1741              		.loc 1 963 9 view .LVU463
 959:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1742              		.loc 1 959 1 is_stmt 0 view .LVU464
 1743 0000 13B5     		push	{r0, r1, r4, lr}
 1744              	.LCFI28:
 1745              		.cfi_def_cfa_offset 16
 1746              		.cfi_offset 4, -8
 1747              		.cfi_offset 14, -4
 963:Src/mpu6050.c ****     }
 1748              		.loc 1 963 24 view .LVU465
 1749 0002 4268     		ldr	r2, [r0, #4]
 1750 0004 0168     		ldr	r1, [r0]
 1751 0006 8368     		ldr	r3, [r0, #8]
 1752 0008 4942     		rsbs	r1, r1, #0
 1753 000a 5242     		rsbs	r2, r2, #0
 1754 000c 5B42     		rsbs	r3, r3, #0
 971:Src/mpu6050.c ****         return -1;
 1755              		.loc 1 971 21 view .LVU466
 1756 000e 1A4C     		ldr	r4, .L123
 963:Src/mpu6050.c ****     }
 1757              		.loc 1 963 21 view .LVU467
 1758 0010 0160     		str	r1, [r0]
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1759              		.loc 1 962 17 is_stmt 1 view .LVU468
 1760              	.LVL128:
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1761              		.loc 1 962 13 view .LVU469
 963:Src/mpu6050.c ****     }
 1762              		.loc 1 963 9 view .LVU470
 963:Src/mpu6050.c ****     }
 1763              		.loc 1 963 21 is_stmt 0 view .LVU471
 1764 0012 4260     		str	r2, [r0, #4]
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1765              		.loc 1 962 17 is_stmt 1 view .LVU472
 1766              	.LVL129:
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1767              		.loc 1 962 13 view .LVU473
 963:Src/mpu6050.c ****     }
 1768              		.loc 1 963 9 view .LVU474
 963:Src/mpu6050.c ****     }
 1769              		.loc 1 963 21 is_stmt 0 view .LVU475
 1770 0014 8360     		str	r3, [r0, #8]
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1771              		.loc 1 962 17 is_stmt 1 view .LVU476
 1772              	.LVL130:
 962:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
ARM GAS  /tmp/cc39PcX6.s 			page 105


 1773              		.loc 1 962 13 view .LVU477
 965:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1774              		.loc 1 965 5 view .LVU478
 965:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1775              		.loc 1 965 29 is_stmt 0 view .LVU479
 1776 0016 0812     		asrs	r0, r1, #8
 1777              	.LVL131:
 965:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1778              		.loc 1 965 13 view .LVU480
 1779 0018 8DF80000 		strb	r0, [sp]
 966:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 1780              		.loc 1 966 5 is_stmt 1 view .LVU481
 966:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 1781              		.loc 1 966 13 is_stmt 0 view .LVU482
 1782 001c 8DF80110 		strb	r1, [sp, #1]
 967:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1783              		.loc 1 967 5 is_stmt 1 view .LVU483
 968:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 1784              		.loc 1 968 13 is_stmt 0 view .LVU484
 1785 0020 8DF80320 		strb	r2, [sp, #3]
 967:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1786              		.loc 1 967 29 view .LVU485
 1787 0024 1112     		asrs	r1, r2, #8
 971:Src/mpu6050.c ****         return -1;
 1788              		.loc 1 971 9 view .LVU486
 1789 0026 6068     		ldr	r0, [r4, #4]
 969:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1790              		.loc 1 969 29 view .LVU487
 1791 0028 1A12     		asrs	r2, r3, #8
 967:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1792              		.loc 1 967 13 view .LVU488
 1793 002a 8DF80210 		strb	r1, [sp, #2]
 968:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 1794              		.loc 1 968 5 is_stmt 1 view .LVU489
 969:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1795              		.loc 1 969 5 view .LVU490
 969:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1796              		.loc 1 969 13 is_stmt 0 view .LVU491
 1797 002e 8DF80420 		strb	r2, [sp, #4]
 970:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 1798              		.loc 1 970 5 is_stmt 1 view .LVU492
 970:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 1799              		.loc 1 970 13 is_stmt 0 view .LVU493
 1800 0032 8DF80530 		strb	r3, [sp, #5]
 971:Src/mpu6050.c ****         return -1;
 1801              		.loc 1 971 5 is_stmt 1 view .LVU494
 971:Src/mpu6050.c ****         return -1;
 1802              		.loc 1 971 9 is_stmt 0 view .LVU495
 1803 0036 0222     		movs	r2, #2
 1804 0038 6B46     		mov	r3, sp
 1805 003a 1321     		movs	r1, #19
 1806 003c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1807 003e FFF7FEFF 		bl	i2c_writeBytes
 1808              	.LVL132:
 971:Src/mpu6050.c ****         return -1;
 1809              		.loc 1 971 8 view .LVU496
 1810 0042 18B1     		cbz	r0, .L120
ARM GAS  /tmp/cc39PcX6.s 			page 106


 1811              	.L122:
 972:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
 1812              		.loc 1 972 16 view .LVU497
 1813 0044 4FF0FF30 		mov	r0, #-1
 1814              	.L119:
 978:Src/mpu6050.c **** 
 1815              		.loc 1 978 1 view .LVU498
 1816 0048 02B0     		add	sp, sp, #8
 1817              	.LCFI29:
 1818              		.cfi_remember_state
 1819              		.cfi_def_cfa_offset 8
 1820              		@ sp needed
 1821 004a 10BD     		pop	{r4, pc}
 1822              	.L120:
 1823              	.LCFI30:
 1824              		.cfi_restore_state
 973:Src/mpu6050.c ****         return -1;
 1825              		.loc 1 973 5 is_stmt 1 view .LVU499
 973:Src/mpu6050.c ****         return -1;
 1826              		.loc 1 973 9 is_stmt 0 view .LVU500
 1827 004c 6068     		ldr	r0, [r4, #4]
 1828 004e 0222     		movs	r2, #2
 1829 0050 1521     		movs	r1, #21
 1830 0052 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1831 0054 0DF10203 		add	r3, sp, #2
 1832 0058 FFF7FEFF 		bl	i2c_writeBytes
 1833              	.LVL133:
 973:Src/mpu6050.c ****         return -1;
 1834              		.loc 1 973 8 view .LVU501
 1835 005c 0028     		cmp	r0, #0
 1836 005e F1D1     		bne	.L122
 975:Src/mpu6050.c ****         return -1;
 1837              		.loc 1 975 5 is_stmt 1 view .LVU502
 975:Src/mpu6050.c ****         return -1;
 1838              		.loc 1 975 9 is_stmt 0 view .LVU503
 1839 0060 6068     		ldr	r0, [r4, #4]
 1840 0062 0222     		movs	r2, #2
 1841 0064 1721     		movs	r1, #23
 1842 0066 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1843 0068 01AB     		add	r3, sp, #4
 1844 006a FFF7FEFF 		bl	i2c_writeBytes
 1845              	.LVL134:
 975:Src/mpu6050.c ****         return -1;
 1846              		.loc 1 975 8 view .LVU504
 1847 006e 0038     		subs	r0, r0, #0
 1848 0070 18BF     		it	ne
 1849 0072 0120     		movne	r0, #1
 1850 0074 4042     		rsbs	r0, r0, #0
 1851 0076 E7E7     		b	.L119
 1852              	.L124:
 1853              		.align	2
 1854              	.L123:
 1855 0078 00000000 		.word	.LANCHOR0
 1856              		.cfi_endproc
 1857              	.LFE70:
 1859              		.section	.text.mpu_set_accel_bias_6050_reg,"ax",%progbits
 1860              		.align	1
ARM GAS  /tmp/cc39PcX6.s 			page 107


 1861              		.global	mpu_set_accel_bias_6050_reg
 1862              		.syntax unified
 1863              		.thumb
 1864              		.thumb_func
 1865              		.fpu softvfp
 1867              	mpu_set_accel_bias_6050_reg:
 1868              	.LVL135:
 1869              	.LFB71:
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1870              		.loc 1 988 57 is_stmt 1 view -0
 1871              		.cfi_startproc
 1872              		@ args = 0, pretend = 0, frame = 24
 1873              		@ frame_needed = 0, uses_anonymous_args = 0
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1874              		.loc 1 989 5 view .LVU506
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1875              		.loc 1 988 57 is_stmt 0 view .LVU507
 1876 0000 10B5     		push	{r4, lr}
 1877              	.LCFI31:
 1878              		.cfi_def_cfa_offset 8
 1879              		.cfi_offset 4, -8
 1880              		.cfi_offset 14, -4
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1881              		.loc 1 989 19 view .LVU508
 1882 0002 2A4B     		ldr	r3, .L129
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1883              		.loc 1 988 57 view .LVU509
 1884 0004 0446     		mov	r4, r0
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1885              		.loc 1 989 19 view .LVU510
 1886 0006 1868     		ldr	r0, [r3]	@ unaligned
 1887              	.LVL136:
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1888              		.loc 1 989 19 view .LVU511
 1889 0008 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 988:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1890              		.loc 1 988 57 view .LVU512
 1891 000a 86B0     		sub	sp, sp, #24
 1892              	.LCFI32:
 1893              		.cfi_def_cfa_offset 32
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1894              		.loc 1 989 19 view .LVU513
 1895 000c ADF80830 		strh	r3, [sp, #8]	@ unaligned
 990:Src/mpu6050.c **** 
 1896              		.loc 1 990 5 is_stmt 1 view .LVU514
 990:Src/mpu6050.c **** 
 1897              		.loc 1 990 10 is_stmt 0 view .LVU515
 1898 0010 0023     		movs	r3, #0
 989:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1899              		.loc 1 989 19 view .LVU516
 1900 0012 0190     		str	r0, [sp, #4]
 992:Src/mpu6050.c ****         return -1;
 1901              		.loc 1 992 8 view .LVU517
 1902 0014 03A8     		add	r0, sp, #12
 990:Src/mpu6050.c **** 
 1903              		.loc 1 990 10 view .LVU518
 1904 0016 CDE90333 		strd	r3, r3, [sp, #12]
ARM GAS  /tmp/cc39PcX6.s 			page 108


 1905 001a 0593     		str	r3, [sp, #20]
 992:Src/mpu6050.c ****         return -1;
 1906              		.loc 1 992 5 is_stmt 1 view .LVU519
 992:Src/mpu6050.c ****         return -1;
 1907              		.loc 1 992 8 is_stmt 0 view .LVU520
 1908 001c FFF7FEFF 		bl	mpu_read_6050_accel_bias
 1909              	.LVL137:
 992:Src/mpu6050.c ****         return -1;
 1910              		.loc 1 992 7 view .LVU521
 1911 0020 18B1     		cbz	r0, .L126
 1912              	.LVL138:
 1913              	.L128:
 993:Src/mpu6050.c **** 
 1914              		.loc 1 993 16 view .LVU522
 1915 0022 4FF0FF30 		mov	r0, #-1
 1916              	.L125:
1014:Src/mpu6050.c **** 
 1917              		.loc 1 1014 1 view .LVU523
 1918 0026 06B0     		add	sp, sp, #24
 1919              	.LCFI33:
 1920              		.cfi_remember_state
 1921              		.cfi_def_cfa_offset 8
 1922              		@ sp needed
 1923 0028 10BD     		pop	{r4, pc}
 1924              	.LVL139:
 1925              	.L126:
 1926              	.LCFI34:
 1927              		.cfi_restore_state
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1928              		.loc 1 995 5 is_stmt 1 view .LVU524
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1929              		.loc 1 995 41 is_stmt 0 view .LVU525
 1930 002a 2168     		ldr	r1, [r4]
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1931              		.loc 1 996 41 view .LVU526
 1932 002c 6268     		ldr	r2, [r4, #4]
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1933              		.loc 1 995 41 view .LVU527
 1934 002e 21F00103 		bic	r3, r1, #1
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1935              		.loc 1 995 23 view .LVU528
 1936 0032 0399     		ldr	r1, [sp, #12]
 997:Src/mpu6050.c **** 
 1937              		.loc 1 997 41 view .LVU529
 1938 0034 A068     		ldr	r0, [r4, #8]
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1939              		.loc 1 995 23 view .LVU530
 1940 0036 C91A     		subs	r1, r1, r3
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1941              		.loc 1 996 41 view .LVU531
 1942 0038 22F00103 		bic	r3, r2, #1
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1943              		.loc 1 996 23 view .LVU532
 1944 003c 049A     		ldr	r2, [sp, #16]
 997:Src/mpu6050.c **** 
 1945              		.loc 1 997 41 view .LVU533
 1946 003e 20F00100 		bic	r0, r0, #1
ARM GAS  /tmp/cc39PcX6.s 			page 109


 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1947              		.loc 1 996 23 view .LVU534
 1948 0042 D21A     		subs	r2, r2, r3
 997:Src/mpu6050.c **** 
 1949              		.loc 1 997 23 view .LVU535
 1950 0044 059B     		ldr	r3, [sp, #20]
1006:Src/mpu6050.c ****         return -1;
 1951              		.loc 1 1006 21 view .LVU536
 1952 0046 1A4C     		ldr	r4, .L129+4
 1953              	.LVL140:
 997:Src/mpu6050.c **** 
 1954              		.loc 1 997 23 view .LVU537
 1955 0048 1B1A     		subs	r3, r3, r0
 999:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1956              		.loc 1 999 34 view .LVU538
 1957 004a 0812     		asrs	r0, r1, #8
 995:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1958              		.loc 1 995 23 view .LVU539
 1959 004c 0391     		str	r1, [sp, #12]
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1960              		.loc 1 996 5 is_stmt 1 view .LVU540
 996:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1961              		.loc 1 996 23 is_stmt 0 view .LVU541
 1962 004e 0492     		str	r2, [sp, #16]
 997:Src/mpu6050.c **** 
 1963              		.loc 1 997 5 is_stmt 1 view .LVU542
 999:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1964              		.loc 1 999 13 is_stmt 0 view .LVU543
 1965 0050 8DF80400 		strb	r0, [sp, #4]
1000:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1966              		.loc 1 1000 13 view .LVU544
 1967 0054 8DF80510 		strb	r1, [sp, #5]
1002:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1968              		.loc 1 1002 13 view .LVU545
 1969 0058 8DF80720 		strb	r2, [sp, #7]
1001:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1970              		.loc 1 1001 34 view .LVU546
 1971 005c 1112     		asrs	r1, r2, #8
1006:Src/mpu6050.c ****         return -1;
 1972              		.loc 1 1006 9 view .LVU547
 1973 005e 6068     		ldr	r0, [r4, #4]
1003:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1974              		.loc 1 1003 34 view .LVU548
 1975 0060 1A12     		asrs	r2, r3, #8
 997:Src/mpu6050.c **** 
 1976              		.loc 1 997 23 view .LVU549
 1977 0062 0593     		str	r3, [sp, #20]
 999:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1978              		.loc 1 999 5 is_stmt 1 view .LVU550
1000:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1979              		.loc 1 1000 5 view .LVU551
1001:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1980              		.loc 1 1001 5 view .LVU552
1001:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1981              		.loc 1 1001 13 is_stmt 0 view .LVU553
 1982 0064 8DF80610 		strb	r1, [sp, #6]
1002:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
ARM GAS  /tmp/cc39PcX6.s 			page 110


 1983              		.loc 1 1002 5 is_stmt 1 view .LVU554
1003:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1984              		.loc 1 1003 5 view .LVU555
1003:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1985              		.loc 1 1003 13 is_stmt 0 view .LVU556
 1986 0068 8DF80820 		strb	r2, [sp, #8]
1004:Src/mpu6050.c **** 
 1987              		.loc 1 1004 5 is_stmt 1 view .LVU557
1004:Src/mpu6050.c **** 
 1988              		.loc 1 1004 13 is_stmt 0 view .LVU558
 1989 006c 8DF80930 		strb	r3, [sp, #9]
1006:Src/mpu6050.c ****         return -1;
 1990              		.loc 1 1006 5 is_stmt 1 view .LVU559
1006:Src/mpu6050.c ****         return -1;
 1991              		.loc 1 1006 9 is_stmt 0 view .LVU560
 1992 0070 0222     		movs	r2, #2
 1993 0072 0621     		movs	r1, #6
 1994 0074 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1995 0076 01AB     		add	r3, sp, #4
 1996 0078 FFF7FEFF 		bl	i2c_writeBytes
 1997              	.LVL141:
1006:Src/mpu6050.c ****         return -1;
 1998              		.loc 1 1006 8 view .LVU561
 1999 007c 0028     		cmp	r0, #0
 2000 007e D0D1     		bne	.L128
1008:Src/mpu6050.c ****         return -1;
 2001              		.loc 1 1008 5 is_stmt 1 view .LVU562
1008:Src/mpu6050.c ****         return -1;
 2002              		.loc 1 1008 9 is_stmt 0 view .LVU563
 2003 0080 6068     		ldr	r0, [r4, #4]
 2004 0082 0222     		movs	r2, #2
 2005 0084 0821     		movs	r1, #8
 2006 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2007 0088 0DF10603 		add	r3, sp, #6
 2008 008c FFF7FEFF 		bl	i2c_writeBytes
 2009              	.LVL142:
1008:Src/mpu6050.c ****         return -1;
 2010              		.loc 1 1008 8 view .LVU564
 2011 0090 0028     		cmp	r0, #0
 2012 0092 C6D1     		bne	.L128
1010:Src/mpu6050.c ****         return -1;
 2013              		.loc 1 1010 5 is_stmt 1 view .LVU565
1010:Src/mpu6050.c ****         return -1;
 2014              		.loc 1 1010 9 is_stmt 0 view .LVU566
 2015 0094 6068     		ldr	r0, [r4, #4]
 2016 0096 0222     		movs	r2, #2
 2017 0098 0A21     		movs	r1, #10
 2018 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2019 009c 02AB     		add	r3, sp, #8
 2020 009e FFF7FEFF 		bl	i2c_writeBytes
 2021              	.LVL143:
1010:Src/mpu6050.c ****         return -1;
 2022              		.loc 1 1010 8 view .LVU567
 2023 00a2 0038     		subs	r0, r0, #0
 2024 00a4 18BF     		it	ne
 2025 00a6 0120     		movne	r0, #1
 2026 00a8 4042     		rsbs	r0, r0, #0
ARM GAS  /tmp/cc39PcX6.s 			page 111


 2027 00aa BCE7     		b	.L125
 2028              	.L130:
 2029              		.align	2
 2030              	.L129:
 2031 00ac 00000000 		.word	.LANCHOR1
 2032 00b0 00000000 		.word	.LANCHOR0
 2033              		.cfi_endproc
 2034              	.LFE71:
 2036              		.section	.text.mpu_set_accel_bias_6500_reg,"ax",%progbits
 2037              		.align	1
 2038              		.global	mpu_set_accel_bias_6500_reg
 2039              		.syntax unified
 2040              		.thumb
 2041              		.thumb_func
 2042              		.fpu softvfp
 2044              	mpu_set_accel_bias_6500_reg:
 2045              	.LVL144:
 2046              	.LFB72:
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 2047              		.loc 1 1026 57 is_stmt 1 view -0
 2048              		.cfi_startproc
 2049              		@ args = 0, pretend = 0, frame = 24
 2050              		@ frame_needed = 0, uses_anonymous_args = 0
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 2051              		.loc 1 1027 5 view .LVU569
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 2052              		.loc 1 1026 57 is_stmt 0 view .LVU570
 2053 0000 10B5     		push	{r4, lr}
 2054              	.LCFI35:
 2055              		.cfi_def_cfa_offset 8
 2056              		.cfi_offset 4, -8
 2057              		.cfi_offset 14, -4
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 2058              		.loc 1 1027 19 view .LVU571
 2059 0002 2A4B     		ldr	r3, .L135
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 2060              		.loc 1 1026 57 view .LVU572
 2061 0004 0446     		mov	r4, r0
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 2062              		.loc 1 1027 19 view .LVU573
 2063 0006 1868     		ldr	r0, [r3]	@ unaligned
 2064              	.LVL145:
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 2065              		.loc 1 1027 19 view .LVU574
 2066 0008 9B88     		ldrh	r3, [r3, #4]	@ unaligned
1026:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 2067              		.loc 1 1026 57 view .LVU575
 2068 000a 86B0     		sub	sp, sp, #24
 2069              	.LCFI36:
 2070              		.cfi_def_cfa_offset 32
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 2071              		.loc 1 1027 19 view .LVU576
 2072 000c ADF80830 		strh	r3, [sp, #8]	@ unaligned
1028:Src/mpu6050.c **** 
 2073              		.loc 1 1028 5 is_stmt 1 view .LVU577
1028:Src/mpu6050.c **** 
 2074              		.loc 1 1028 10 is_stmt 0 view .LVU578
ARM GAS  /tmp/cc39PcX6.s 			page 112


 2075 0010 0023     		movs	r3, #0
1027:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 2076              		.loc 1 1027 19 view .LVU579
 2077 0012 0190     		str	r0, [sp, #4]
1030:Src/mpu6050.c ****         return -1;
 2078              		.loc 1 1030 8 view .LVU580
 2079 0014 03A8     		add	r0, sp, #12
1028:Src/mpu6050.c **** 
 2080              		.loc 1 1028 10 view .LVU581
 2081 0016 CDE90333 		strd	r3, r3, [sp, #12]
 2082 001a 0593     		str	r3, [sp, #20]
1030:Src/mpu6050.c ****         return -1;
 2083              		.loc 1 1030 5 is_stmt 1 view .LVU582
1030:Src/mpu6050.c ****         return -1;
 2084              		.loc 1 1030 8 is_stmt 0 view .LVU583
 2085 001c FFF7FEFF 		bl	mpu_read_6500_accel_bias
 2086              	.LVL146:
1030:Src/mpu6050.c ****         return -1;
 2087              		.loc 1 1030 7 view .LVU584
 2088 0020 18B1     		cbz	r0, .L132
 2089              	.LVL147:
 2090              	.L134:
1031:Src/mpu6050.c **** 
 2091              		.loc 1 1031 16 view .LVU585
 2092 0022 4FF0FF30 		mov	r0, #-1
 2093              	.L131:
1053:Src/mpu6050.c **** 
 2094              		.loc 1 1053 1 view .LVU586
 2095 0026 06B0     		add	sp, sp, #24
 2096              	.LCFI37:
 2097              		.cfi_remember_state
 2098              		.cfi_def_cfa_offset 8
 2099              		@ sp needed
 2100 0028 10BD     		pop	{r4, pc}
 2101              	.LVL148:
 2102              	.L132:
 2103              	.LCFI38:
 2104              		.cfi_restore_state
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 2105              		.loc 1 1034 5 is_stmt 1 view .LVU587
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 2106              		.loc 1 1034 41 is_stmt 0 view .LVU588
 2107 002a 2168     		ldr	r1, [r4]
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 2108              		.loc 1 1035 41 view .LVU589
 2109 002c 6268     		ldr	r2, [r4, #4]
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 2110              		.loc 1 1034 41 view .LVU590
 2111 002e 21F00103 		bic	r3, r1, #1
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 2112              		.loc 1 1034 23 view .LVU591
 2113 0032 0399     		ldr	r1, [sp, #12]
1036:Src/mpu6050.c **** 
 2114              		.loc 1 1036 41 view .LVU592
 2115 0034 A068     		ldr	r0, [r4, #8]
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 2116              		.loc 1 1034 23 view .LVU593
ARM GAS  /tmp/cc39PcX6.s 			page 113


 2117 0036 C91A     		subs	r1, r1, r3
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 2118              		.loc 1 1035 41 view .LVU594
 2119 0038 22F00103 		bic	r3, r2, #1
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 2120              		.loc 1 1035 23 view .LVU595
 2121 003c 049A     		ldr	r2, [sp, #16]
1036:Src/mpu6050.c **** 
 2122              		.loc 1 1036 41 view .LVU596
 2123 003e 20F00100 		bic	r0, r0, #1
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 2124              		.loc 1 1035 23 view .LVU597
 2125 0042 D21A     		subs	r2, r2, r3
1036:Src/mpu6050.c **** 
 2126              		.loc 1 1036 23 view .LVU598
 2127 0044 059B     		ldr	r3, [sp, #20]
1045:Src/mpu6050.c ****         return -1;
 2128              		.loc 1 1045 21 view .LVU599
 2129 0046 1A4C     		ldr	r4, .L135+4
 2130              	.LVL149:
1036:Src/mpu6050.c **** 
 2131              		.loc 1 1036 23 view .LVU600
 2132 0048 1B1A     		subs	r3, r3, r0
1038:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 2133              		.loc 1 1038 34 view .LVU601
 2134 004a 0812     		asrs	r0, r1, #8
1034:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 2135              		.loc 1 1034 23 view .LVU602
 2136 004c 0391     		str	r1, [sp, #12]
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 2137              		.loc 1 1035 5 is_stmt 1 view .LVU603
1035:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 2138              		.loc 1 1035 23 is_stmt 0 view .LVU604
 2139 004e 0492     		str	r2, [sp, #16]
1036:Src/mpu6050.c **** 
 2140              		.loc 1 1036 5 is_stmt 1 view .LVU605
1038:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 2141              		.loc 1 1038 13 is_stmt 0 view .LVU606
 2142 0050 8DF80400 		strb	r0, [sp, #4]
1039:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 2143              		.loc 1 1039 13 view .LVU607
 2144 0054 8DF80510 		strb	r1, [sp, #5]
1041:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 2145              		.loc 1 1041 13 view .LVU608
 2146 0058 8DF80720 		strb	r2, [sp, #7]
1040:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 2147              		.loc 1 1040 34 view .LVU609
 2148 005c 1112     		asrs	r1, r2, #8
1045:Src/mpu6050.c ****         return -1;
 2149              		.loc 1 1045 9 view .LVU610
 2150 005e 6068     		ldr	r0, [r4, #4]
1042:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 2151              		.loc 1 1042 34 view .LVU611
 2152 0060 1A12     		asrs	r2, r3, #8
1036:Src/mpu6050.c **** 
 2153              		.loc 1 1036 23 view .LVU612
 2154 0062 0593     		str	r3, [sp, #20]
ARM GAS  /tmp/cc39PcX6.s 			page 114


1038:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 2155              		.loc 1 1038 5 is_stmt 1 view .LVU613
1039:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 2156              		.loc 1 1039 5 view .LVU614
1040:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 2157              		.loc 1 1040 5 view .LVU615
1040:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 2158              		.loc 1 1040 13 is_stmt 0 view .LVU616
 2159 0064 8DF80610 		strb	r1, [sp, #6]
1041:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 2160              		.loc 1 1041 5 is_stmt 1 view .LVU617
1042:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 2161              		.loc 1 1042 5 view .LVU618
1042:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 2162              		.loc 1 1042 13 is_stmt 0 view .LVU619
 2163 0068 8DF80820 		strb	r2, [sp, #8]
1043:Src/mpu6050.c **** 
 2164              		.loc 1 1043 5 is_stmt 1 view .LVU620
1043:Src/mpu6050.c **** 
 2165              		.loc 1 1043 13 is_stmt 0 view .LVU621
 2166 006c 8DF80930 		strb	r3, [sp, #9]
1045:Src/mpu6050.c ****         return -1;
 2167              		.loc 1 1045 5 is_stmt 1 view .LVU622
1045:Src/mpu6050.c ****         return -1;
 2168              		.loc 1 1045 9 is_stmt 0 view .LVU623
 2169 0070 0222     		movs	r2, #2
 2170 0072 7721     		movs	r1, #119
 2171 0074 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2172 0076 01AB     		add	r3, sp, #4
 2173 0078 FFF7FEFF 		bl	i2c_writeBytes
 2174              	.LVL150:
1045:Src/mpu6050.c ****         return -1;
 2175              		.loc 1 1045 8 view .LVU624
 2176 007c 0028     		cmp	r0, #0
 2177 007e D0D1     		bne	.L134
1047:Src/mpu6050.c ****         return -1;
 2178              		.loc 1 1047 5 is_stmt 1 view .LVU625
1047:Src/mpu6050.c ****         return -1;
 2179              		.loc 1 1047 9 is_stmt 0 view .LVU626
 2180 0080 6068     		ldr	r0, [r4, #4]
 2181 0082 0222     		movs	r2, #2
 2182 0084 7A21     		movs	r1, #122
 2183 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2184 0088 0DF10603 		add	r3, sp, #6
 2185 008c FFF7FEFF 		bl	i2c_writeBytes
 2186              	.LVL151:
1047:Src/mpu6050.c ****         return -1;
 2187              		.loc 1 1047 8 view .LVU627
 2188 0090 0028     		cmp	r0, #0
 2189 0092 C6D1     		bne	.L134
1049:Src/mpu6050.c ****         return -1;
 2190              		.loc 1 1049 5 is_stmt 1 view .LVU628
1049:Src/mpu6050.c ****         return -1;
 2191              		.loc 1 1049 9 is_stmt 0 view .LVU629
 2192 0094 6068     		ldr	r0, [r4, #4]
 2193 0096 0222     		movs	r2, #2
 2194 0098 7D21     		movs	r1, #125
ARM GAS  /tmp/cc39PcX6.s 			page 115


 2195 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2196 009c 02AB     		add	r3, sp, #8
 2197 009e FFF7FEFF 		bl	i2c_writeBytes
 2198              	.LVL152:
1049:Src/mpu6050.c ****         return -1;
 2199              		.loc 1 1049 8 view .LVU630
 2200 00a2 0038     		subs	r0, r0, #0
 2201 00a4 18BF     		it	ne
 2202 00a6 0120     		movne	r0, #1
 2203 00a8 4042     		rsbs	r0, r0, #0
 2204 00aa BCE7     		b	.L131
 2205              	.L136:
 2206              		.align	2
 2207              	.L135:
 2208 00ac 00000000 		.word	.LANCHOR1
 2209 00b0 00000000 		.word	.LANCHOR0
 2210              		.cfi_endproc
 2211              	.LFE72:
 2213              		.section	.text.mpu_reset_fifo,"ax",%progbits
 2214              		.align	1
 2215              		.global	mpu_reset_fifo
 2216              		.syntax unified
 2217              		.thumb
 2218              		.thumb_func
 2219              		.fpu softvfp
 2221              	mpu_reset_fifo:
 2222              	.LFB73:
1061:Src/mpu6050.c ****     unsigned char data;
 2223              		.loc 1 1061 1 is_stmt 1 view -0
 2224              		.cfi_startproc
 2225              		@ args = 0, pretend = 0, frame = 8
 2226              		@ frame_needed = 0, uses_anonymous_args = 0
1062:Src/mpu6050.c **** 
 2227              		.loc 1 1062 5 view .LVU632
1064:Src/mpu6050.c ****         return -1;
 2228              		.loc 1 1064 5 view .LVU633
1061:Src/mpu6050.c ****     unsigned char data;
 2229              		.loc 1 1061 1 is_stmt 0 view .LVU634
 2230 0000 13B5     		push	{r0, r1, r4, lr}
 2231              	.LCFI39:
 2232              		.cfi_def_cfa_offset 16
 2233              		.cfi_offset 4, -8
 2234              		.cfi_offset 14, -4
1064:Src/mpu6050.c ****         return -1;
 2235              		.loc 1 1064 22 view .LVU635
 2236 0002 584C     		ldr	r4, .L152
1064:Src/mpu6050.c ****         return -1;
 2237              		.loc 1 1064 8 view .LVU636
 2238 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2239 0006 1BB9     		cbnz	r3, .L138
 2240              	.L140:
1065:Src/mpu6050.c **** 
 2241              		.loc 1 1065 16 view .LVU637
 2242 0008 4FF0FF30 		mov	r0, #-1
 2243              	.L137:
1115:Src/mpu6050.c **** 
 2244              		.loc 1 1115 1 view .LVU638
ARM GAS  /tmp/cc39PcX6.s 			page 116


 2245 000c 02B0     		add	sp, sp, #8
 2246              	.LCFI40:
 2247              		.cfi_remember_state
 2248              		.cfi_def_cfa_offset 8
 2249              		@ sp needed
 2250 000e 10BD     		pop	{r4, pc}
 2251              	.L138:
 2252              	.LCFI41:
 2253              		.cfi_restore_state
1067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2254              		.loc 1 1067 5 is_stmt 1 view .LVU639
1067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2255              		.loc 1 1067 10 is_stmt 0 view .LVU640
 2256 0010 0023     		movs	r3, #0
1068:Src/mpu6050.c ****         return -1;
 2257              		.loc 1 1068 9 view .LVU641
 2258 0012 D4E90010 		ldrd	r1, r0, [r4]
1067:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2259              		.loc 1 1067 10 view .LVU642
 2260 0016 8DF80730 		strb	r3, [sp, #7]
1068:Src/mpu6050.c ****         return -1;
 2261              		.loc 1 1068 5 is_stmt 1 view .LVU643
1068:Src/mpu6050.c ****         return -1;
 2262              		.loc 1 1068 9 is_stmt 0 view .LVU644
 2263 001a 0122     		movs	r2, #1
 2264 001c 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2265 001e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2266 0020 0DF10703 		add	r3, sp, #7
 2267 0024 FFF7FEFF 		bl	i2c_writeBytes
 2268              	.LVL153:
1068:Src/mpu6050.c ****         return -1;
 2269              		.loc 1 1068 8 view .LVU645
 2270 0028 0028     		cmp	r0, #0
 2271 002a EDD1     		bne	.L140
1070:Src/mpu6050.c ****         return -1;
 2272              		.loc 1 1070 5 is_stmt 1 view .LVU646
1070:Src/mpu6050.c ****         return -1;
 2273              		.loc 1 1070 9 is_stmt 0 view .LVU647
 2274 002c D4E90010 		ldrd	r1, r0, [r4]
 2275 0030 0122     		movs	r2, #1
 2276 0032 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 2277 0034 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2278 0036 0DF10703 		add	r3, sp, #7
 2279 003a FFF7FEFF 		bl	i2c_writeBytes
 2280              	.LVL154:
1070:Src/mpu6050.c ****         return -1;
 2281              		.loc 1 1070 8 view .LVU648
 2282 003e 0028     		cmp	r0, #0
 2283 0040 E2D1     		bne	.L140
1072:Src/mpu6050.c ****         return -1;
 2284              		.loc 1 1072 5 is_stmt 1 view .LVU649
1072:Src/mpu6050.c ****         return -1;
 2285              		.loc 1 1072 9 is_stmt 0 view .LVU650
 2286 0042 D4E90010 		ldrd	r1, r0, [r4]
 2287 0046 0122     		movs	r2, #1
 2288 0048 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2289 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
ARM GAS  /tmp/cc39PcX6.s 			page 117


 2290 004c 0DF10703 		add	r3, sp, #7
 2291 0050 FFF7FEFF 		bl	i2c_writeBytes
 2292              	.LVL155:
1072:Src/mpu6050.c ****         return -1;
 2293              		.loc 1 1072 8 view .LVU651
 2294 0054 0028     		cmp	r0, #0
 2295 0056 D7D1     		bne	.L140
1075:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
 2296              		.loc 1 1075 5 is_stmt 1 view .LVU652
1077:Src/mpu6050.c ****             return -1;
 2297              		.loc 1 1077 13 is_stmt 0 view .LVU653
 2298 0058 D4E90030 		ldrd	r3, r0, [r4]
 2299 005c 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
1075:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
 2300              		.loc 1 1075 8 view .LVU654
 2301 005e 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 2302 0062 002B     		cmp	r3, #0
 2303 0064 42D0     		beq	.L141
1076:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2304              		.loc 1 1076 9 is_stmt 1 view .LVU655
1076:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2305              		.loc 1 1076 14 is_stmt 0 view .LVU656
 2306 0066 0C23     		movs	r3, #12
 2307 0068 8DF80730 		strb	r3, [sp, #7]
1077:Src/mpu6050.c ****             return -1;
 2308              		.loc 1 1077 9 is_stmt 1 view .LVU657
1077:Src/mpu6050.c ****             return -1;
 2309              		.loc 1 1077 13 is_stmt 0 view .LVU658
 2310 006c 0122     		movs	r2, #1
 2311 006e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2312 0070 0DF10703 		add	r3, sp, #7
 2313 0074 FFF7FEFF 		bl	i2c_writeBytes
 2314              	.LVL156:
1077:Src/mpu6050.c ****             return -1;
 2315              		.loc 1 1077 12 view .LVU659
 2316 0078 0028     		cmp	r0, #0
 2317 007a C5D1     		bne	.L140
1079:Src/mpu6050.c ****         data = BIT_DMP_EN | BIT_FIFO_EN;
 2318              		.loc 1 1079 9 is_stmt 1 view .LVU660
 2319 007c 3220     		movs	r0, #50
 2320 007e FFF7FEFF 		bl	delay_1ms
 2321              	.LVL157:
1080:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
 2322              		.loc 1 1080 9 view .LVU661
1083:Src/mpu6050.c ****             return -1;
 2323              		.loc 1 1083 13 is_stmt 0 view .LVU662
 2324 0082 D4E90010 		ldrd	r1, r0, [r4]
1080:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
 2325              		.loc 1 1080 14 view .LVU663
 2326 0086 C023     		movs	r3, #192
 2327 0088 8DF80730 		strb	r3, [sp, #7]
1081:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2328              		.loc 1 1081 9 is_stmt 1 view .LVU664
1081:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2329              		.loc 1 1081 12 is_stmt 0 view .LVU665
 2330 008c A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
1083:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 118


 2331              		.loc 1 1083 13 view .LVU666
 2332 008e 0122     		movs	r2, #1
1081:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2333              		.loc 1 1081 12 view .LVU667
 2334 0090 DB07     		lsls	r3, r3, #31
1082:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2335              		.loc 1 1082 13 is_stmt 1 view .LVU668
1082:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2336              		.loc 1 1082 18 is_stmt 0 view .LVU669
 2337 0092 44BF     		itt	mi
 2338 0094 E023     		movmi	r3, #224
 2339 0096 8DF80730 		strbmi	r3, [sp, #7]
1083:Src/mpu6050.c ****             return -1;
 2340              		.loc 1 1083 9 is_stmt 1 view .LVU670
1083:Src/mpu6050.c ****             return -1;
 2341              		.loc 1 1083 13 is_stmt 0 view .LVU671
 2342 009a 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2343 009c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2344 009e 0DF10703 		add	r3, sp, #7
 2345 00a2 FFF7FEFF 		bl	i2c_writeBytes
 2346              	.LVL158:
1083:Src/mpu6050.c ****             return -1;
 2347              		.loc 1 1083 12 view .LVU672
 2348 00a6 0028     		cmp	r0, #0
 2349 00a8 AED1     		bne	.L140
1085:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
 2350              		.loc 1 1085 9 is_stmt 1 view .LVU673
1089:Src/mpu6050.c ****             return -1;
 2351              		.loc 1 1089 13 is_stmt 0 view .LVU674
 2352 00aa D4E90010 		ldrd	r1, r0, [r4]
1085:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
 2353              		.loc 1 1085 24 view .LVU675
 2354 00ae 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
1089:Src/mpu6050.c ****             return -1;
 2355              		.loc 1 1089 13 view .LVU676
 2356 00b0 0122     		movs	r2, #1
1086:Src/mpu6050.c ****         else
 2357              		.loc 1 1086 18 view .LVU677
 2358 00b2 002B     		cmp	r3, #0
 2359 00b4 18BF     		it	ne
 2360 00b6 0223     		movne	r3, #2
 2361 00b8 8DF80730 		strb	r3, [sp, #7]
1089:Src/mpu6050.c ****             return -1;
 2362              		.loc 1 1089 9 is_stmt 1 view .LVU678
1089:Src/mpu6050.c ****             return -1;
 2363              		.loc 1 1089 13 is_stmt 0 view .LVU679
 2364 00bc 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2365 00be 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2366 00c0 0DF10703 		add	r3, sp, #7
 2367 00c4 FFF7FEFF 		bl	i2c_writeBytes
 2368              	.LVL159:
1089:Src/mpu6050.c ****             return -1;
 2369              		.loc 1 1089 12 view .LVU680
 2370 00c8 0028     		cmp	r0, #0
 2371 00ca 9DD1     		bne	.L140
1091:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
 2372              		.loc 1 1091 9 is_stmt 1 view .LVU681
ARM GAS  /tmp/cc39PcX6.s 			page 119


1092:Src/mpu6050.c ****             return -1;
 2373              		.loc 1 1092 13 is_stmt 0 view .LVU682
 2374 00cc 0DF10703 		add	r3, sp, #7
1091:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
 2375              		.loc 1 1091 14 view .LVU683
 2376 00d0 8DF80700 		strb	r0, [sp, #7]
1092:Src/mpu6050.c ****             return -1;
 2377              		.loc 1 1092 9 is_stmt 1 view .LVU684
1092:Src/mpu6050.c ****             return -1;
 2378              		.loc 1 1092 13 is_stmt 0 view .LVU685
 2379 00d4 D4E90010 		ldrd	r1, r0, [r4]
 2380              	.L151:
1111:Src/mpu6050.c ****             return -1;
 2381              		.loc 1 1111 13 view .LVU686
 2382 00d8 0122     		movs	r2, #1
 2383 00da 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 2384 00dc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2385 00de FFF7FEFF 		bl	i2c_writeBytes
 2386              	.LVL160:
1111:Src/mpu6050.c ****             return -1;
 2387              		.loc 1 1111 12 view .LVU687
 2388 00e2 0038     		subs	r0, r0, #0
 2389 00e4 18BF     		it	ne
 2390 00e6 0120     		movne	r0, #1
 2391 00e8 4042     		rsbs	r0, r0, #0
 2392 00ea 8FE7     		b	.L137
 2393              	.L141:
1095:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2394              		.loc 1 1095 9 is_stmt 1 view .LVU688
1095:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2395              		.loc 1 1095 14 is_stmt 0 view .LVU689
 2396 00ec 0423     		movs	r3, #4
 2397 00ee 8DF80730 		strb	r3, [sp, #7]
1096:Src/mpu6050.c ****             return -1;
 2398              		.loc 1 1096 9 is_stmt 1 view .LVU690
1096:Src/mpu6050.c ****             return -1;
 2399              		.loc 1 1096 13 is_stmt 0 view .LVU691
 2400 00f2 0122     		movs	r2, #1
 2401 00f4 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2402 00f6 0DF10703 		add	r3, sp, #7
 2403 00fa FFF7FEFF 		bl	i2c_writeBytes
 2404              	.LVL161:
1096:Src/mpu6050.c ****             return -1;
 2405              		.loc 1 1096 12 view .LVU692
 2406 00fe 0028     		cmp	r0, #0
 2407 0100 82D1     		bne	.L140
1098:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2408              		.loc 1 1098 9 is_stmt 1 view .LVU693
1098:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2409              		.loc 1 1098 12 is_stmt 0 view .LVU694
 2410 0102 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 2411 0104 63BB     		cbnz	r3, .L146
1098:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2412              		.loc 1 1098 37 discriminator 1 view .LVU695
 2413 0106 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
1101:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2414              		.loc 1 1101 18 discriminator 1 view .LVU696
ARM GAS  /tmp/cc39PcX6.s 			page 120


 2415 0108 13F0010F 		tst	r3, #1
 2416 010c 0CBF     		ite	eq
 2417 010e 4023     		moveq	r3, #64
 2418 0110 6023     		movne	r3, #96
 2419              	.L144:
1102:Src/mpu6050.c ****             return -1;
 2420              		.loc 1 1102 13 view .LVU697
 2421 0112 D4E90010 		ldrd	r1, r0, [r4]
 2422 0116 8DF80730 		strb	r3, [sp, #7]
1102:Src/mpu6050.c ****             return -1;
 2423              		.loc 1 1102 9 is_stmt 1 view .LVU698
1102:Src/mpu6050.c ****             return -1;
 2424              		.loc 1 1102 13 is_stmt 0 view .LVU699
 2425 011a 0122     		movs	r2, #1
 2426 011c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2427 011e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2428 0120 0DF10703 		add	r3, sp, #7
 2429 0124 FFF7FEFF 		bl	i2c_writeBytes
 2430              	.LVL162:
1102:Src/mpu6050.c ****             return -1;
 2431              		.loc 1 1102 12 view .LVU700
 2432 0128 0028     		cmp	r0, #0
 2433 012a 7FF46DAF 		bne	.L140
1104:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
 2434              		.loc 1 1104 9 is_stmt 1 view .LVU701
 2435 012e 3220     		movs	r0, #50
 2436 0130 FFF7FEFF 		bl	delay_1ms
 2437              	.LVL163:
1105:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2438              		.loc 1 1105 9 view .LVU702
1109:Src/mpu6050.c ****             return -1;
 2439              		.loc 1 1109 13 is_stmt 0 view .LVU703
 2440 0134 D4E90010 		ldrd	r1, r0, [r4]
1105:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2441              		.loc 1 1105 12 view .LVU704
 2442 0138 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
1109:Src/mpu6050.c ****             return -1;
 2443              		.loc 1 1109 13 view .LVU705
 2444 013a 0122     		movs	r2, #1
1105:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2445              		.loc 1 1105 12 view .LVU706
 2446 013c 003B     		subs	r3, r3, #0
 2447 013e 18BF     		it	ne
 2448 0140 0123     		movne	r3, #1
 2449 0142 8DF80730 		strb	r3, [sp, #7]
1109:Src/mpu6050.c ****             return -1;
 2450              		.loc 1 1109 9 is_stmt 1 view .LVU707
1109:Src/mpu6050.c ****             return -1;
 2451              		.loc 1 1109 13 is_stmt 0 view .LVU708
 2452 0146 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2453 0148 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2454 014a 0DF10703 		add	r3, sp, #7
 2455 014e FFF7FEFF 		bl	i2c_writeBytes
 2456              	.LVL164:
1109:Src/mpu6050.c ****             return -1;
 2457              		.loc 1 1109 12 view .LVU709
 2458 0152 0028     		cmp	r0, #0
ARM GAS  /tmp/cc39PcX6.s 			page 121


 2459 0154 7FF458AF 		bne	.L140
1111:Src/mpu6050.c ****             return -1;
 2460              		.loc 1 1111 9 is_stmt 1 view .LVU710
1111:Src/mpu6050.c ****             return -1;
 2461              		.loc 1 1111 13 is_stmt 0 view .LVU711
 2462 0158 D4E90010 		ldrd	r1, r0, [r4]
 2463 015c 024B     		ldr	r3, .L152+4
 2464 015e BBE7     		b	.L151
 2465              	.L146:
1099:Src/mpu6050.c ****         else
 2466              		.loc 1 1099 18 view .LVU712
 2467 0160 4023     		movs	r3, #64
 2468 0162 D6E7     		b	.L144
 2469              	.L153:
 2470              		.align	2
 2471              	.L152:
 2472 0164 00000000 		.word	.LANCHOR0
 2473 0168 10000000 		.word	.LANCHOR0+16
 2474              		.cfi_endproc
 2475              	.LFE73:
 2477              		.section	.text.mpu_get_gyro_fsr,"ax",%progbits
 2478              		.align	1
 2479              		.global	mpu_get_gyro_fsr
 2480              		.syntax unified
 2481              		.thumb
 2482              		.thumb_func
 2483              		.fpu softvfp
 2485              	mpu_get_gyro_fsr:
 2486              	.LVL165:
 2487              	.LFB74:
1123:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
 2488              		.loc 1 1123 1 is_stmt 1 view -0
 2489              		.cfi_startproc
 2490              		@ args = 0, pretend = 0, frame = 0
 2491              		@ frame_needed = 0, uses_anonymous_args = 0
 2492              		@ link register save eliminated.
1124:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2493              		.loc 1 1124 5 view .LVU714
1124:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2494              		.loc 1 1124 24 is_stmt 0 view .LVU715
 2495 0000 0B4B     		ldr	r3, .L163
1124:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2496              		.loc 1 1124 5 view .LVU716
 2497 0002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2498 0004 032B     		cmp	r3, #3
 2499 0006 10D8     		bhi	.L155
 2500 0008 DFE803F0 		tbb	[pc, r3]
 2501              	.L157:
 2502 000c 02       		.byte	(.L160-.L157)/2
 2503 000d 06       		.byte	(.L159-.L157)/2
 2504 000e 09       		.byte	(.L158-.L157)/2
 2505 000f 0C       		.byte	(.L156-.L157)/2
 2506              		.p2align 1
 2507              	.L160:
1126:Src/mpu6050.c ****         break;
 2508              		.loc 1 1126 9 is_stmt 1 view .LVU717
1126:Src/mpu6050.c ****         break;
ARM GAS  /tmp/cc39PcX6.s 			page 122


 2509              		.loc 1 1126 16 is_stmt 0 view .LVU718
 2510 0010 FA23     		movs	r3, #250
 2511              	.L162:
1138:Src/mpu6050.c ****         break;
 2512              		.loc 1 1138 16 view .LVU719
 2513 0012 0380     		strh	r3, [r0]	@ movhi
1139:Src/mpu6050.c ****     }
 2514              		.loc 1 1139 9 is_stmt 1 view .LVU720
1141:Src/mpu6050.c **** }
 2515              		.loc 1 1141 5 view .LVU721
1142:Src/mpu6050.c **** 
 2516              		.loc 1 1142 1 is_stmt 0 view .LVU722
 2517 0014 0020     		movs	r0, #0
 2518              	.LVL166:
1142:Src/mpu6050.c **** 
 2519              		.loc 1 1142 1 view .LVU723
 2520 0016 7047     		bx	lr
 2521              	.LVL167:
 2522              	.L159:
1129:Src/mpu6050.c ****         break;
 2523              		.loc 1 1129 9 is_stmt 1 view .LVU724
1129:Src/mpu6050.c ****         break;
 2524              		.loc 1 1129 16 is_stmt 0 view .LVU725
 2525 0018 4FF4FA73 		mov	r3, #500
 2526 001c F9E7     		b	.L162
 2527              	.L158:
1132:Src/mpu6050.c ****         break;
 2528              		.loc 1 1132 9 is_stmt 1 view .LVU726
1132:Src/mpu6050.c ****         break;
 2529              		.loc 1 1132 16 is_stmt 0 view .LVU727
 2530 001e 4FF47A73 		mov	r3, #1000
 2531 0022 F6E7     		b	.L162
 2532              	.L156:
1135:Src/mpu6050.c ****         break;
 2533              		.loc 1 1135 9 is_stmt 1 view .LVU728
1135:Src/mpu6050.c ****         break;
 2534              		.loc 1 1135 16 is_stmt 0 view .LVU729
 2535 0024 4FF4FA63 		mov	r3, #2000
 2536 0028 F3E7     		b	.L162
 2537              	.L155:
1138:Src/mpu6050.c ****         break;
 2538              		.loc 1 1138 9 is_stmt 1 view .LVU730
1138:Src/mpu6050.c ****         break;
 2539              		.loc 1 1138 16 is_stmt 0 view .LVU731
 2540 002a 0023     		movs	r3, #0
 2541 002c F1E7     		b	.L162
 2542              	.L164:
 2543 002e 00BF     		.align	2
 2544              	.L163:
 2545 0030 00000000 		.word	.LANCHOR0
 2546              		.cfi_endproc
 2547              	.LFE74:
 2549              		.section	.text.mpu_set_gyro_fsr,"ax",%progbits
 2550              		.align	1
 2551              		.global	mpu_set_gyro_fsr
 2552              		.syntax unified
 2553              		.thumb
ARM GAS  /tmp/cc39PcX6.s 			page 123


 2554              		.thumb_func
 2555              		.fpu softvfp
 2557              	mpu_set_gyro_fsr:
 2558              	.LVL168:
 2559              	.LFB75:
1150:Src/mpu6050.c ****     unsigned char data;
 2560              		.loc 1 1150 1 is_stmt 1 view -0
 2561              		.cfi_startproc
 2562              		@ args = 0, pretend = 0, frame = 8
 2563              		@ frame_needed = 0, uses_anonymous_args = 0
1151:Src/mpu6050.c **** 
 2564              		.loc 1 1151 5 view .LVU733
1153:Src/mpu6050.c ****         return -1;
 2565              		.loc 1 1153 5 view .LVU734
1150:Src/mpu6050.c ****     unsigned char data;
 2566              		.loc 1 1150 1 is_stmt 0 view .LVU735
 2567 0000 13B5     		push	{r0, r1, r4, lr}
 2568              	.LCFI42:
 2569              		.cfi_def_cfa_offset 16
 2570              		.cfi_offset 4, -8
 2571              		.cfi_offset 14, -4
1153:Src/mpu6050.c ****         return -1;
 2572              		.loc 1 1153 22 view .LVU736
 2573 0002 1A4C     		ldr	r4, .L178
1153:Src/mpu6050.c ****         return -1;
 2574              		.loc 1 1153 8 view .LVU737
 2575 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2576 0006 1BB9     		cbnz	r3, .L166
 2577              	.LVL169:
 2578              	.L177:
1156:Src/mpu6050.c ****     case 250:
 2579              		.loc 1 1156 5 view .LVU738
 2580 0008 4FF0FF30 		mov	r0, #-1
 2581              	.L165:
1179:Src/mpu6050.c **** 
 2582              		.loc 1 1179 1 view .LVU739
 2583 000c 02B0     		add	sp, sp, #8
 2584              	.LCFI43:
 2585              		.cfi_remember_state
 2586              		.cfi_def_cfa_offset 8
 2587              		@ sp needed
 2588 000e 10BD     		pop	{r4, pc}
 2589              	.LVL170:
 2590              	.L166:
 2591              	.LCFI44:
 2592              		.cfi_restore_state
1156:Src/mpu6050.c ****     case 250:
 2593              		.loc 1 1156 5 is_stmt 1 view .LVU740
 2594 0010 B0F57A7F 		cmp	r0, #1000
 2595 0014 25D0     		beq	.L168
 2596 0016 06D8     		bhi	.L169
 2597 0018 FA28     		cmp	r0, #250
 2598 001a 09D0     		beq	.L170
 2599 001c B0F5FA7F 		cmp	r0, #500
 2600 0020 F2D1     		bne	.L177
1161:Src/mpu6050.c ****         break;
 2601              		.loc 1 1161 9 view .LVU741
ARM GAS  /tmp/cc39PcX6.s 			page 124


1161:Src/mpu6050.c ****         break;
 2602              		.loc 1 1161 14 is_stmt 0 view .LVU742
 2603 0022 0823     		movs	r3, #8
 2604 0024 05E0     		b	.L176
 2605              	.L169:
1156:Src/mpu6050.c ****     case 250:
 2606              		.loc 1 1156 5 view .LVU743
 2607 0026 B0F5FA6F 		cmp	r0, #2000
 2608 002a EDD1     		bne	.L177
1167:Src/mpu6050.c ****         break;
 2609              		.loc 1 1167 9 is_stmt 1 view .LVU744
1167:Src/mpu6050.c ****         break;
 2610              		.loc 1 1167 14 is_stmt 0 view .LVU745
 2611 002c 1823     		movs	r3, #24
 2612 002e 00E0     		b	.L176
 2613              	.L170:
1158:Src/mpu6050.c ****         break;
 2614              		.loc 1 1158 9 is_stmt 1 view .LVU746
1158:Src/mpu6050.c ****         break;
 2615              		.loc 1 1158 14 is_stmt 0 view .LVU747
 2616 0030 0023     		movs	r3, #0
 2617              	.L176:
1167:Src/mpu6050.c ****         break;
 2618              		.loc 1 1167 14 view .LVU748
 2619 0032 8DF80730 		strb	r3, [sp, #7]
1168:Src/mpu6050.c ****     default:
 2620              		.loc 1 1168 9 is_stmt 1 view .LVU749
1173:Src/mpu6050.c ****         return 0;
 2621              		.loc 1 1173 5 view .LVU750
1173:Src/mpu6050.c ****         return 0;
 2622              		.loc 1 1173 30 is_stmt 0 view .LVU751
 2623 0036 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
1173:Src/mpu6050.c ****         return 0;
 2624              		.loc 1 1173 8 view .LVU752
 2625 003a 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 2626 003c B3EBD20F 		cmp	r3, r2, lsr #3
 2627 0040 11D0     		beq	.L175
1175:Src/mpu6050.c ****         return -1;
 2628              		.loc 1 1175 5 is_stmt 1 view .LVU753
1175:Src/mpu6050.c ****         return -1;
 2629              		.loc 1 1175 9 is_stmt 0 view .LVU754
 2630 0042 D4E90010 		ldrd	r1, r0, [r4]
 2631              	.LVL171:
1175:Src/mpu6050.c ****         return -1;
 2632              		.loc 1 1175 9 view .LVU755
 2633 0046 0122     		movs	r2, #1
 2634 0048 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 2635 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2636 004c 0DF10703 		add	r3, sp, #7
 2637 0050 FFF7FEFF 		bl	i2c_writeBytes
 2638              	.LVL172:
1175:Src/mpu6050.c ****         return -1;
 2639              		.loc 1 1175 8 view .LVU756
 2640 0054 0028     		cmp	r0, #0
 2641 0056 D7D1     		bne	.L177
1177:Src/mpu6050.c ****     return 0;
 2642              		.loc 1 1177 5 is_stmt 1 view .LVU757
ARM GAS  /tmp/cc39PcX6.s 			page 125


1177:Src/mpu6050.c ****     return 0;
 2643              		.loc 1 1177 26 is_stmt 0 view .LVU758
 2644 0058 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2645 005c DB08     		lsrs	r3, r3, #3
 2646 005e 2372     		strb	r3, [r4, #8]
1178:Src/mpu6050.c **** }
 2647              		.loc 1 1178 5 is_stmt 1 view .LVU759
1178:Src/mpu6050.c **** }
 2648              		.loc 1 1178 12 is_stmt 0 view .LVU760
 2649 0060 D4E7     		b	.L165
 2650              	.LVL173:
 2651              	.L168:
1164:Src/mpu6050.c ****         break;
 2652              		.loc 1 1164 9 is_stmt 1 view .LVU761
1164:Src/mpu6050.c ****         break;
 2653              		.loc 1 1164 14 is_stmt 0 view .LVU762
 2654 0062 1023     		movs	r3, #16
 2655 0064 E5E7     		b	.L176
 2656              	.L175:
1174:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
 2657              		.loc 1 1174 16 view .LVU763
 2658 0066 0020     		movs	r0, #0
 2659              	.LVL174:
1174:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
 2660              		.loc 1 1174 16 view .LVU764
 2661 0068 D0E7     		b	.L165
 2662              	.L179:
 2663 006a 00BF     		.align	2
 2664              	.L178:
 2665 006c 00000000 		.word	.LANCHOR0
 2666              		.cfi_endproc
 2667              	.LFE75:
 2669              		.section	.text.mpu_get_accel_fsr,"ax",%progbits
 2670              		.align	1
 2671              		.global	mpu_get_accel_fsr
 2672              		.syntax unified
 2673              		.thumb
 2674              		.thumb_func
 2675              		.fpu softvfp
 2677              	mpu_get_accel_fsr:
 2678              	.LVL175:
 2679              	.LFB76:
1187:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
 2680              		.loc 1 1187 1 is_stmt 1 view -0
 2681              		.cfi_startproc
 2682              		@ args = 0, pretend = 0, frame = 0
 2683              		@ frame_needed = 0, uses_anonymous_args = 0
 2684              		@ link register save eliminated.
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2685              		.loc 1 1188 5 view .LVU766
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2686              		.loc 1 1188 24 is_stmt 0 view .LVU767
 2687 0000 0C4B     		ldr	r3, .L192
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2688              		.loc 1 1188 5 view .LVU768
 2689 0002 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 2690 0004 032A     		cmp	r2, #3
ARM GAS  /tmp/cc39PcX6.s 			page 126


 2691 0006 12D8     		bhi	.L188
 2692 0008 DFE802F0 		tbb	[pc, r2]
 2693              	.L183:
 2694 000c 02       		.byte	(.L186-.L183)/2
 2695 000d 0B       		.byte	(.L185-.L183)/2
 2696 000e 0D       		.byte	(.L184-.L183)/2
 2697 000f 0F       		.byte	(.L182-.L183)/2
 2698              		.p2align 1
 2699              	.L186:
1190:Src/mpu6050.c ****         break;
 2700              		.loc 1 1190 9 is_stmt 1 view .LVU769
1190:Src/mpu6050.c ****         break;
 2701              		.loc 1 1190 16 is_stmt 0 view .LVU770
 2702 0010 0222     		movs	r2, #2
 2703              	.L190:
1199:Src/mpu6050.c ****         break;
 2704              		.loc 1 1199 16 view .LVU771
 2705 0012 0270     		strb	r2, [r0]
1200:Src/mpu6050.c ****     default:
 2706              		.loc 1 1200 9 is_stmt 1 view .LVU772
1204:Src/mpu6050.c ****         fsr[0] <<= 1;
 2707              		.loc 1 1204 5 view .LVU773
1204:Src/mpu6050.c ****         fsr[0] <<= 1;
 2708              		.loc 1 1204 8 is_stmt 0 view .LVU774
 2709 0014 DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 2710 0016 13B1     		cbz	r3, .L191
1205:Src/mpu6050.c ****     return 0;
 2711              		.loc 1 1205 9 is_stmt 1 view .LVU775
1205:Src/mpu6050.c ****     return 0;
 2712              		.loc 1 1205 16 is_stmt 0 view .LVU776
 2713 0018 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 2714 001a 5B00     		lsls	r3, r3, #1
 2715 001c 0370     		strb	r3, [r0]
 2716              	.L191:
1206:Src/mpu6050.c **** }
 2717              		.loc 1 1206 12 view .LVU777
 2718 001e 0020     		movs	r0, #0
 2719              	.LVL176:
1206:Src/mpu6050.c **** }
 2720              		.loc 1 1206 12 view .LVU778
 2721 0020 7047     		bx	lr
 2722              	.LVL177:
 2723              	.L185:
1193:Src/mpu6050.c ****         break;
 2724              		.loc 1 1193 9 is_stmt 1 view .LVU779
1193:Src/mpu6050.c ****         break;
 2725              		.loc 1 1193 16 is_stmt 0 view .LVU780
 2726 0022 0422     		movs	r2, #4
 2727 0024 F5E7     		b	.L190
 2728              	.L184:
1196:Src/mpu6050.c ****         break;
 2729              		.loc 1 1196 9 is_stmt 1 view .LVU781
1196:Src/mpu6050.c ****         break;
 2730              		.loc 1 1196 16 is_stmt 0 view .LVU782
 2731 0026 0822     		movs	r2, #8
 2732 0028 F3E7     		b	.L190
 2733              	.L182:
ARM GAS  /tmp/cc39PcX6.s 			page 127


1199:Src/mpu6050.c ****         break;
 2734              		.loc 1 1199 9 is_stmt 1 view .LVU783
1199:Src/mpu6050.c ****         break;
 2735              		.loc 1 1199 16 is_stmt 0 view .LVU784
 2736 002a 1022     		movs	r2, #16
 2737 002c F1E7     		b	.L190
 2738              	.L188:
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2739              		.loc 1 1188 5 view .LVU785
 2740 002e 4FF0FF30 		mov	r0, #-1
 2741              	.LVL178:
1188:Src/mpu6050.c ****     case INV_FSR_2G:
 2742              		.loc 1 1188 5 view .LVU786
 2743 0032 7047     		bx	lr
 2744              	.L193:
 2745              		.align	2
 2746              	.L192:
 2747 0034 00000000 		.word	.LANCHOR0
 2748              		.cfi_endproc
 2749              	.LFE76:
 2751              		.section	.text.mpu_set_accel_fsr,"ax",%progbits
 2752              		.align	1
 2753              		.global	mpu_set_accel_fsr
 2754              		.syntax unified
 2755              		.thumb
 2756              		.thumb_func
 2757              		.fpu softvfp
 2759              	mpu_set_accel_fsr:
 2760              	.LVL179:
 2761              	.LFB77:
1215:Src/mpu6050.c ****     unsigned char data;
 2762              		.loc 1 1215 1 is_stmt 1 view -0
 2763              		.cfi_startproc
 2764              		@ args = 0, pretend = 0, frame = 8
 2765              		@ frame_needed = 0, uses_anonymous_args = 0
1216:Src/mpu6050.c **** 
 2766              		.loc 1 1216 5 view .LVU788
1218:Src/mpu6050.c ****         return -1;
 2767              		.loc 1 1218 5 view .LVU789
1215:Src/mpu6050.c ****     unsigned char data;
 2768              		.loc 1 1215 1 is_stmt 0 view .LVU790
 2769 0000 13B5     		push	{r0, r1, r4, lr}
 2770              	.LCFI45:
 2771              		.cfi_def_cfa_offset 16
 2772              		.cfi_offset 4, -8
 2773              		.cfi_offset 14, -4
1218:Src/mpu6050.c ****         return -1;
 2774              		.loc 1 1218 22 view .LVU791
 2775 0002 184C     		ldr	r4, .L207
1218:Src/mpu6050.c ****         return -1;
 2776              		.loc 1 1218 8 view .LVU792
 2777 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2778 0006 1BB9     		cbnz	r3, .L195
 2779              	.LVL180:
 2780              	.L206:
1221:Src/mpu6050.c ****     case 2:
 2781              		.loc 1 1221 5 view .LVU793
ARM GAS  /tmp/cc39PcX6.s 			page 128


 2782 0008 4FF0FF30 		mov	r0, #-1
 2783              	.L194:
1244:Src/mpu6050.c **** 
 2784              		.loc 1 1244 1 view .LVU794
 2785 000c 02B0     		add	sp, sp, #8
 2786              	.LCFI46:
 2787              		.cfi_remember_state
 2788              		.cfi_def_cfa_offset 8
 2789              		@ sp needed
 2790 000e 10BD     		pop	{r4, pc}
 2791              	.LVL181:
 2792              	.L195:
 2793              	.LCFI47:
 2794              		.cfi_restore_state
1221:Src/mpu6050.c ****     case 2:
 2795              		.loc 1 1221 5 is_stmt 1 view .LVU795
 2796 0010 0828     		cmp	r0, #8
 2797 0012 23D0     		beq	.L197
 2798 0014 05D8     		bhi	.L198
 2799 0016 0228     		cmp	r0, #2
 2800 0018 07D0     		beq	.L199
 2801 001a 0428     		cmp	r0, #4
 2802 001c F4D1     		bne	.L206
1226:Src/mpu6050.c ****         break;
 2803              		.loc 1 1226 9 view .LVU796
1226:Src/mpu6050.c ****         break;
 2804              		.loc 1 1226 14 is_stmt 0 view .LVU797
 2805 001e 0823     		movs	r3, #8
 2806 0020 04E0     		b	.L205
 2807              	.L198:
1221:Src/mpu6050.c ****     case 2:
 2808              		.loc 1 1221 5 view .LVU798
 2809 0022 1028     		cmp	r0, #16
 2810 0024 F0D1     		bne	.L206
1232:Src/mpu6050.c ****         break;
 2811              		.loc 1 1232 9 is_stmt 1 view .LVU799
1232:Src/mpu6050.c ****         break;
 2812              		.loc 1 1232 14 is_stmt 0 view .LVU800
 2813 0026 1823     		movs	r3, #24
 2814 0028 00E0     		b	.L205
 2815              	.L199:
1223:Src/mpu6050.c ****         break;
 2816              		.loc 1 1223 9 is_stmt 1 view .LVU801
1223:Src/mpu6050.c ****         break;
 2817              		.loc 1 1223 14 is_stmt 0 view .LVU802
 2818 002a 0023     		movs	r3, #0
 2819              	.L205:
1232:Src/mpu6050.c ****         break;
 2820              		.loc 1 1232 14 view .LVU803
 2821 002c 8DF80730 		strb	r3, [sp, #7]
1233:Src/mpu6050.c ****     default:
 2822              		.loc 1 1233 9 is_stmt 1 view .LVU804
1238:Src/mpu6050.c ****         return 0;
 2823              		.loc 1 1238 5 view .LVU805
1238:Src/mpu6050.c ****         return 0;
 2824              		.loc 1 1238 31 is_stmt 0 view .LVU806
 2825 0030 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
ARM GAS  /tmp/cc39PcX6.s 			page 129


1238:Src/mpu6050.c ****         return 0;
 2826              		.loc 1 1238 8 view .LVU807
 2827 0034 637A     		ldrb	r3, [r4, #9]	@ zero_extendqisi2
 2828 0036 B3EBD20F 		cmp	r3, r2, lsr #3
 2829 003a 11D0     		beq	.L204
1240:Src/mpu6050.c ****         return -1;
 2830              		.loc 1 1240 5 is_stmt 1 view .LVU808
1240:Src/mpu6050.c ****         return -1;
 2831              		.loc 1 1240 9 is_stmt 0 view .LVU809
 2832 003c D4E90010 		ldrd	r1, r0, [r4]
 2833              	.LVL182:
1240:Src/mpu6050.c ****         return -1;
 2834              		.loc 1 1240 9 view .LVU810
 2835 0040 0122     		movs	r2, #1
 2836 0042 C979     		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 2837 0044 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2838 0046 0DF10703 		add	r3, sp, #7
 2839 004a FFF7FEFF 		bl	i2c_writeBytes
 2840              	.LVL183:
1240:Src/mpu6050.c ****         return -1;
 2841              		.loc 1 1240 8 view .LVU811
 2842 004e 0028     		cmp	r0, #0
 2843 0050 DAD1     		bne	.L206
1242:Src/mpu6050.c ****     return 0;
 2844              		.loc 1 1242 5 is_stmt 1 view .LVU812
1242:Src/mpu6050.c ****     return 0;
 2845              		.loc 1 1242 27 is_stmt 0 view .LVU813
 2846 0052 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2847 0056 DB08     		lsrs	r3, r3, #3
 2848 0058 6372     		strb	r3, [r4, #9]
1243:Src/mpu6050.c **** }
 2849              		.loc 1 1243 5 is_stmt 1 view .LVU814
1243:Src/mpu6050.c **** }
 2850              		.loc 1 1243 12 is_stmt 0 view .LVU815
 2851 005a D7E7     		b	.L194
 2852              	.LVL184:
 2853              	.L197:
1229:Src/mpu6050.c ****         break;
 2854              		.loc 1 1229 9 is_stmt 1 view .LVU816
1229:Src/mpu6050.c ****         break;
 2855              		.loc 1 1229 14 is_stmt 0 view .LVU817
 2856 005c 1023     		movs	r3, #16
 2857 005e E5E7     		b	.L205
 2858              	.L204:
1239:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
 2859              		.loc 1 1239 16 view .LVU818
 2860 0060 0020     		movs	r0, #0
 2861              	.LVL185:
1239:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
 2862              		.loc 1 1239 16 view .LVU819
 2863 0062 D3E7     		b	.L194
 2864              	.L208:
 2865              		.align	2
 2866              	.L207:
 2867 0064 00000000 		.word	.LANCHOR0
 2868              		.cfi_endproc
 2869              	.LFE77:
ARM GAS  /tmp/cc39PcX6.s 			page 130


 2871              		.section	.text.mpu_get_lpf,"ax",%progbits
 2872              		.align	1
 2873              		.global	mpu_get_lpf
 2874              		.syntax unified
 2875              		.thumb
 2876              		.thumb_func
 2877              		.fpu softvfp
 2879              	mpu_get_lpf:
 2880              	.LVL186:
 2881              	.LFB78:
1252:Src/mpu6050.c ****     switch (st.chip_cfg.lpf) {
 2882              		.loc 1 1252 1 is_stmt 1 view -0
 2883              		.cfi_startproc
 2884              		@ args = 0, pretend = 0, frame = 0
 2885              		@ frame_needed = 0, uses_anonymous_args = 0
 2886              		@ link register save eliminated.
1253:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2887              		.loc 1 1253 5 view .LVU821
1253:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2888              		.loc 1 1253 24 is_stmt 0 view .LVU822
 2889 0000 0C4B     		ldr	r3, .L220
1253:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2890              		.loc 1 1253 5 view .LVU823
 2891 0002 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 2892 0004 013B     		subs	r3, r3, #1
 2893 0006 052B     		cmp	r3, #5
 2894 0008 12D8     		bhi	.L210
 2895 000a DFE803F0 		tbb	[pc, r3]
 2896              	.L212:
 2897 000e 03       		.byte	(.L217-.L212)/2
 2898 000f 07       		.byte	(.L216-.L212)/2
 2899 0010 09       		.byte	(.L215-.L212)/2
 2900 0011 0B       		.byte	(.L214-.L212)/2
 2901 0012 0D       		.byte	(.L213-.L212)/2
 2902 0013 0F       		.byte	(.L211-.L212)/2
 2903              		.p2align 1
 2904              	.L217:
1255:Src/mpu6050.c ****         break;
 2905              		.loc 1 1255 9 is_stmt 1 view .LVU824
1255:Src/mpu6050.c ****         break;
 2906              		.loc 1 1255 16 is_stmt 0 view .LVU825
 2907 0014 BC23     		movs	r3, #188
 2908              	.L219:
1275:Src/mpu6050.c ****         break;
 2909              		.loc 1 1275 16 view .LVU826
 2910 0016 0380     		strh	r3, [r0]	@ movhi
1276:Src/mpu6050.c ****     }
 2911              		.loc 1 1276 9 is_stmt 1 view .LVU827
1278:Src/mpu6050.c **** }
 2912              		.loc 1 1278 5 view .LVU828
1279:Src/mpu6050.c **** 
 2913              		.loc 1 1279 1 is_stmt 0 view .LVU829
 2914 0018 0020     		movs	r0, #0
 2915              	.LVL187:
1279:Src/mpu6050.c **** 
 2916              		.loc 1 1279 1 view .LVU830
 2917 001a 7047     		bx	lr
ARM GAS  /tmp/cc39PcX6.s 			page 131


 2918              	.LVL188:
 2919              	.L216:
1258:Src/mpu6050.c ****         break;
 2920              		.loc 1 1258 9 is_stmt 1 view .LVU831
1258:Src/mpu6050.c ****         break;
 2921              		.loc 1 1258 16 is_stmt 0 view .LVU832
 2922 001c 6223     		movs	r3, #98
 2923 001e FAE7     		b	.L219
 2924              	.L215:
1261:Src/mpu6050.c ****         break;
 2925              		.loc 1 1261 9 is_stmt 1 view .LVU833
1261:Src/mpu6050.c ****         break;
 2926              		.loc 1 1261 16 is_stmt 0 view .LVU834
 2927 0020 2A23     		movs	r3, #42
 2928 0022 F8E7     		b	.L219
 2929              	.L214:
1264:Src/mpu6050.c ****         break;
 2930              		.loc 1 1264 9 is_stmt 1 view .LVU835
1264:Src/mpu6050.c ****         break;
 2931              		.loc 1 1264 16 is_stmt 0 view .LVU836
 2932 0024 1423     		movs	r3, #20
 2933 0026 F6E7     		b	.L219
 2934              	.L213:
1267:Src/mpu6050.c ****         break;
 2935              		.loc 1 1267 9 is_stmt 1 view .LVU837
1267:Src/mpu6050.c ****         break;
 2936              		.loc 1 1267 16 is_stmt 0 view .LVU838
 2937 0028 0A23     		movs	r3, #10
 2938 002a F4E7     		b	.L219
 2939              	.L211:
1270:Src/mpu6050.c ****         break;
 2940              		.loc 1 1270 9 is_stmt 1 view .LVU839
1270:Src/mpu6050.c ****         break;
 2941              		.loc 1 1270 16 is_stmt 0 view .LVU840
 2942 002c 0523     		movs	r3, #5
 2943 002e F2E7     		b	.L219
 2944              	.L210:
1275:Src/mpu6050.c ****         break;
 2945              		.loc 1 1275 9 is_stmt 1 view .LVU841
1275:Src/mpu6050.c ****         break;
 2946              		.loc 1 1275 16 is_stmt 0 view .LVU842
 2947 0030 0023     		movs	r3, #0
 2948 0032 F0E7     		b	.L219
 2949              	.L221:
 2950              		.align	2
 2951              	.L220:
 2952 0034 00000000 		.word	.LANCHOR0
 2953              		.cfi_endproc
 2954              	.LFE78:
 2956              		.section	.text.mpu_set_lpf,"ax",%progbits
 2957              		.align	1
 2958              		.global	mpu_set_lpf
 2959              		.syntax unified
 2960              		.thumb
 2961              		.thumb_func
 2962              		.fpu softvfp
 2964              	mpu_set_lpf:
ARM GAS  /tmp/cc39PcX6.s 			page 132


 2965              	.LVL189:
 2966              	.LFB79:
1288:Src/mpu6050.c ****     unsigned char data;
 2967              		.loc 1 1288 1 is_stmt 1 view -0
 2968              		.cfi_startproc
 2969              		@ args = 0, pretend = 0, frame = 8
 2970              		@ frame_needed = 0, uses_anonymous_args = 0
1289:Src/mpu6050.c **** 
 2971              		.loc 1 1289 5 view .LVU844
1291:Src/mpu6050.c ****         return -1;
 2972              		.loc 1 1291 5 view .LVU845
1288:Src/mpu6050.c ****     unsigned char data;
 2973              		.loc 1 1288 1 is_stmt 0 view .LVU846
 2974 0000 13B5     		push	{r0, r1, r4, lr}
 2975              	.LCFI48:
 2976              		.cfi_def_cfa_offset 16
 2977              		.cfi_offset 4, -8
 2978              		.cfi_offset 14, -4
1291:Src/mpu6050.c ****         return -1;
 2979              		.loc 1 1291 22 view .LVU847
 2980 0002 194C     		ldr	r4, .L234
1291:Src/mpu6050.c ****         return -1;
 2981              		.loc 1 1291 8 view .LVU848
 2982 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2983 0006 1BB9     		cbnz	r3, .L223
 2984              	.LVL190:
 2985              	.L231:
1292:Src/mpu6050.c **** 
 2986              		.loc 1 1292 16 view .LVU849
 2987 0008 4FF0FF30 		mov	r0, #-1
 2988              	.L222:
1313:Src/mpu6050.c **** 
 2989              		.loc 1 1313 1 view .LVU850
 2990 000c 02B0     		add	sp, sp, #8
 2991              	.LCFI49:
 2992              		.cfi_remember_state
 2993              		.cfi_def_cfa_offset 8
 2994              		@ sp needed
 2995 000e 10BD     		pop	{r4, pc}
 2996              	.LVL191:
 2997              	.L223:
 2998              	.LCFI50:
 2999              		.cfi_restore_state
1294:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
 3000              		.loc 1 1294 5 is_stmt 1 view .LVU851
1294:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
 3001              		.loc 1 1294 8 is_stmt 0 view .LVU852
 3002 0010 BB28     		cmp	r0, #187
 3003 0012 16D9     		bls	.L225
1295:Src/mpu6050.c ****     else if (lpf >= 98)
 3004              		.loc 1 1295 9 is_stmt 1 view .LVU853
1295:Src/mpu6050.c ****     else if (lpf >= 98)
 3005              		.loc 1 1295 14 is_stmt 0 view .LVU854
 3006 0014 0123     		movs	r3, #1
 3007              	.L233:
1305:Src/mpu6050.c **** 
 3008              		.loc 1 1305 14 view .LVU855
ARM GAS  /tmp/cc39PcX6.s 			page 133


 3009 0016 8DF80730 		strb	r3, [sp, #7]
1307:Src/mpu6050.c ****         return 0;
 3010              		.loc 1 1307 5 is_stmt 1 view .LVU856
1307:Src/mpu6050.c ****         return 0;
 3011              		.loc 1 1307 8 is_stmt 0 view .LVU857
 3012 001a E27A     		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 3013 001c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 3014 0020 9A42     		cmp	r2, r3
 3015 0022 1FD0     		beq	.L232
1309:Src/mpu6050.c ****         return -1;
 3016              		.loc 1 1309 5 is_stmt 1 view .LVU858
1309:Src/mpu6050.c ****         return -1;
 3017              		.loc 1 1309 9 is_stmt 0 view .LVU859
 3018 0024 D4E90010 		ldrd	r1, r0, [r4]
 3019              	.LVL192:
1309:Src/mpu6050.c ****         return -1;
 3020              		.loc 1 1309 9 view .LVU860
 3021 0028 0122     		movs	r2, #1
 3022 002a 8978     		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 3023 002c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3024 002e 0DF10703 		add	r3, sp, #7
 3025 0032 FFF7FEFF 		bl	i2c_writeBytes
 3026              	.LVL193:
1309:Src/mpu6050.c ****         return -1;
 3027              		.loc 1 1309 8 view .LVU861
 3028 0036 0028     		cmp	r0, #0
 3029 0038 E6D1     		bne	.L231
1311:Src/mpu6050.c ****     return 0;
 3030              		.loc 1 1311 5 is_stmt 1 view .LVU862
1311:Src/mpu6050.c ****     return 0;
 3031              		.loc 1 1311 21 is_stmt 0 view .LVU863
 3032 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 3033 003e E372     		strb	r3, [r4, #11]
1312:Src/mpu6050.c **** }
 3034              		.loc 1 1312 5 is_stmt 1 view .LVU864
1312:Src/mpu6050.c **** }
 3035              		.loc 1 1312 12 is_stmt 0 view .LVU865
 3036 0040 E4E7     		b	.L222
 3037              	.LVL194:
 3038              	.L225:
1296:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
 3039              		.loc 1 1296 10 is_stmt 1 view .LVU866
1296:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
 3040              		.loc 1 1296 13 is_stmt 0 view .LVU867
 3041 0042 6128     		cmp	r0, #97
 3042 0044 01D9     		bls	.L227
1297:Src/mpu6050.c ****     else if (lpf >= 42)
 3043              		.loc 1 1297 9 is_stmt 1 view .LVU868
1297:Src/mpu6050.c ****     else if (lpf >= 42)
 3044              		.loc 1 1297 14 is_stmt 0 view .LVU869
 3045 0046 0223     		movs	r3, #2
 3046 0048 E5E7     		b	.L233
 3047              	.L227:
1298:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
 3048              		.loc 1 1298 10 is_stmt 1 view .LVU870
1298:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
 3049              		.loc 1 1298 13 is_stmt 0 view .LVU871
ARM GAS  /tmp/cc39PcX6.s 			page 134


 3050 004a 2928     		cmp	r0, #41
 3051 004c 01D9     		bls	.L228
1299:Src/mpu6050.c ****     else if (lpf >= 20)
 3052              		.loc 1 1299 9 is_stmt 1 view .LVU872
1299:Src/mpu6050.c ****     else if (lpf >= 20)
 3053              		.loc 1 1299 14 is_stmt 0 view .LVU873
 3054 004e 0323     		movs	r3, #3
 3055 0050 E1E7     		b	.L233
 3056              	.L228:
1300:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
 3057              		.loc 1 1300 10 is_stmt 1 view .LVU874
1300:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
 3058              		.loc 1 1300 13 is_stmt 0 view .LVU875
 3059 0052 1328     		cmp	r0, #19
 3060 0054 01D9     		bls	.L229
1301:Src/mpu6050.c ****     else if (lpf >= 10)
 3061              		.loc 1 1301 9 is_stmt 1 view .LVU876
1301:Src/mpu6050.c ****     else if (lpf >= 10)
 3062              		.loc 1 1301 14 is_stmt 0 view .LVU877
 3063 0056 0423     		movs	r3, #4
 3064 0058 DDE7     		b	.L233
 3065              	.L229:
1302:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
 3066              		.loc 1 1302 10 is_stmt 1 view .LVU878
1302:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
 3067              		.loc 1 1302 13 is_stmt 0 view .LVU879
 3068 005a 0928     		cmp	r0, #9
1303:Src/mpu6050.c ****     else
 3069              		.loc 1 1303 9 is_stmt 1 view .LVU880
1303:Src/mpu6050.c ****     else
 3070              		.loc 1 1303 14 is_stmt 0 view .LVU881
 3071 005c 8CBF     		ite	hi
 3072 005e 0523     		movhi	r3, #5
1305:Src/mpu6050.c **** 
 3073              		.loc 1 1305 9 is_stmt 1 view .LVU882
1305:Src/mpu6050.c **** 
 3074              		.loc 1 1305 14 is_stmt 0 view .LVU883
 3075 0060 0623     		movls	r3, #6
 3076 0062 D8E7     		b	.L233
 3077              	.L232:
1308:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
 3078              		.loc 1 1308 16 view .LVU884
 3079 0064 0020     		movs	r0, #0
 3080              	.LVL195:
1308:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
 3081              		.loc 1 1308 16 view .LVU885
 3082 0066 D1E7     		b	.L222
 3083              	.L235:
 3084              		.align	2
 3085              	.L234:
 3086 0068 00000000 		.word	.LANCHOR0
 3087              		.cfi_endproc
 3088              	.LFE79:
 3090              		.section	.text.mpu_get_sample_rate,"ax",%progbits
 3091              		.align	1
 3092              		.global	mpu_get_sample_rate
 3093              		.syntax unified
ARM GAS  /tmp/cc39PcX6.s 			page 135


 3094              		.thumb
 3095              		.thumb_func
 3096              		.fpu softvfp
 3098              	mpu_get_sample_rate:
 3099              	.LVL196:
 3100              	.LFB80:
1321:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
 3101              		.loc 1 1321 1 is_stmt 1 view -0
 3102              		.cfi_startproc
 3103              		@ args = 0, pretend = 0, frame = 0
 3104              		@ frame_needed = 0, uses_anonymous_args = 0
 3105              		@ link register save eliminated.
1322:Src/mpu6050.c ****         return -1;
 3106              		.loc 1 1322 5 view .LVU887
1322:Src/mpu6050.c ****         return -1;
 3107              		.loc 1 1322 20 is_stmt 0 view .LVU888
 3108 0000 054A     		ldr	r2, .L239
1321:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
 3109              		.loc 1 1321 1 view .LVU889
 3110 0002 0346     		mov	r3, r0
1322:Src/mpu6050.c ****         return -1;
 3111              		.loc 1 1322 8 view .LVU890
 3112 0004 92F82400 		ldrb	r0, [r2, #36]	@ zero_extendqisi2
 3113              	.LVL197:
1322:Src/mpu6050.c ****         return -1;
 3114              		.loc 1 1322 8 view .LVU891
 3115 0008 10B9     		cbnz	r0, .L238
1325:Src/mpu6050.c ****     return 0;
 3116              		.loc 1 1325 9 is_stmt 1 view .LVU892
1325:Src/mpu6050.c ****     return 0;
 3117              		.loc 1 1325 30 is_stmt 0 view .LVU893
 3118 000a D289     		ldrh	r2, [r2, #14]
1325:Src/mpu6050.c ****     return 0;
 3119              		.loc 1 1325 17 view .LVU894
 3120 000c 1A80     		strh	r2, [r3]	@ movhi
1326:Src/mpu6050.c **** }
 3121              		.loc 1 1326 5 is_stmt 1 view .LVU895
1326:Src/mpu6050.c **** }
 3122              		.loc 1 1326 12 is_stmt 0 view .LVU896
 3123 000e 7047     		bx	lr
 3124              	.L238:
1323:Src/mpu6050.c ****     else
 3125              		.loc 1 1323 16 view .LVU897
 3126 0010 4FF0FF30 		mov	r0, #-1
1327:Src/mpu6050.c **** 
 3127              		.loc 1 1327 1 view .LVU898
 3128 0014 7047     		bx	lr
 3129              	.L240:
 3130 0016 00BF     		.align	2
 3131              	.L239:
 3132 0018 00000000 		.word	.LANCHOR0
 3133              		.cfi_endproc
 3134              	.LFE80:
 3136              		.section	.text.mpu_get_compass_sample_rate,"ax",%progbits
 3137              		.align	1
 3138              		.global	mpu_get_compass_sample_rate
 3139              		.syntax unified
ARM GAS  /tmp/cc39PcX6.s 			page 136


 3140              		.thumb
 3141              		.thumb_func
 3142              		.fpu softvfp
 3144              	mpu_get_compass_sample_rate:
 3145              	.LVL198:
 3146              	.LFB82:
1383:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 3147              		.loc 1 1383 1 is_stmt 1 view -0
 3148              		.cfi_startproc
 3149              		@ args = 0, pretend = 0, frame = 0
 3150              		@ frame_needed = 0, uses_anonymous_args = 0
 3151              		@ link register save eliminated.
1388:Src/mpu6050.c ****     return -1;
 3152              		.loc 1 1388 5 view .LVU900
1388:Src/mpu6050.c ****     return -1;
 3153              		.loc 1 1388 13 is_stmt 0 view .LVU901
 3154 0000 0023     		movs	r3, #0
 3155 0002 0380     		strh	r3, [r0]	@ movhi
1389:Src/mpu6050.c **** #endif
 3156              		.loc 1 1389 5 is_stmt 1 view .LVU902
1391:Src/mpu6050.c **** 
 3157              		.loc 1 1391 1 is_stmt 0 view .LVU903
 3158 0004 4FF0FF30 		mov	r0, #-1
 3159              	.LVL199:
1391:Src/mpu6050.c **** 
 3160              		.loc 1 1391 1 view .LVU904
 3161 0008 7047     		bx	lr
 3162              		.cfi_endproc
 3163              	.LFE82:
 3165              		.section	.text.mpu_set_compass_sample_rate,"ax",%progbits
 3166              		.align	1
 3167              		.global	mpu_set_compass_sample_rate
 3168              		.syntax unified
 3169              		.thumb
 3170              		.thumb_func
 3171              		.fpu softvfp
 3173              	mpu_set_compass_sample_rate:
 3174              	.LVL200:
 3175              	.LFB83:
1405:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 3176              		.loc 1 1405 1 is_stmt 1 view -0
 3177              		.cfi_startproc
 3178              		@ args = 0, pretend = 0, frame = 0
 3179              		@ frame_needed = 0, uses_anonymous_args = 0
 3180              		@ link register save eliminated.
1417:Src/mpu6050.c **** #endif
 3181              		.loc 1 1417 5 view .LVU906
1419:Src/mpu6050.c **** 
 3182              		.loc 1 1419 1 is_stmt 0 view .LVU907
 3183 0000 4FF0FF30 		mov	r0, #-1
 3184              	.LVL201:
1419:Src/mpu6050.c **** 
 3185              		.loc 1 1419 1 view .LVU908
 3186 0004 7047     		bx	lr
 3187              		.cfi_endproc
 3188              	.LFE83:
 3190              		.section	.text.mpu_get_gyro_sens,"ax",%progbits
ARM GAS  /tmp/cc39PcX6.s 			page 137


 3191              		.align	1
 3192              		.global	mpu_get_gyro_sens
 3193              		.syntax unified
 3194              		.thumb
 3195              		.thumb_func
 3196              		.fpu softvfp
 3198              	mpu_get_gyro_sens:
 3199              	.LVL202:
 3200              	.LFB84:
1427:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
 3201              		.loc 1 1427 1 is_stmt 1 view -0
 3202              		.cfi_startproc
 3203              		@ args = 0, pretend = 0, frame = 0
 3204              		@ frame_needed = 0, uses_anonymous_args = 0
 3205              		@ link register save eliminated.
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3206              		.loc 1 1428 5 view .LVU910
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3207              		.loc 1 1428 24 is_stmt 0 view .LVU911
 3208 0000 0A4B     		ldr	r3, .L252
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3209              		.loc 1 1428 5 view .LVU912
 3210 0002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3211 0004 032B     		cmp	r3, #3
 3212 0006 0DD8     		bhi	.L250
 3213 0008 DFE803F0 		tbb	[pc, r3]
 3214              	.L246:
 3215 000c 02       		.byte	(.L249-.L246)/2
 3216 000d 06       		.byte	(.L248-.L246)/2
 3217 000e 08       		.byte	(.L247-.L246)/2
 3218 000f 0A       		.byte	(.L245-.L246)/2
 3219              		.p2align 1
 3220              	.L249:
1430:Src/mpu6050.c ****         break;
 3221              		.loc 1 1430 9 is_stmt 1 view .LVU913
1430:Src/mpu6050.c ****         break;
 3222              		.loc 1 1430 17 is_stmt 0 view .LVU914
 3223 0010 074B     		ldr	r3, .L252+4
 3224              	.L251:
1433:Src/mpu6050.c ****         break;
 3225              		.loc 1 1433 17 view .LVU915
 3226 0012 0360     		str	r3, [r0]	@ float
1434:Src/mpu6050.c ****     case INV_FSR_1000DPS:
 3227              		.loc 1 1434 9 is_stmt 1 view .LVU916
1444:Src/mpu6050.c **** }
 3228              		.loc 1 1444 12 is_stmt 0 view .LVU917
 3229 0014 0020     		movs	r0, #0
 3230              	.LVL203:
1434:Src/mpu6050.c ****     case INV_FSR_1000DPS:
 3231              		.loc 1 1434 9 view .LVU918
 3232 0016 7047     		bx	lr
 3233              	.LVL204:
 3234              	.L248:
1433:Src/mpu6050.c ****         break;
 3235              		.loc 1 1433 9 is_stmt 1 view .LVU919
1433:Src/mpu6050.c ****         break;
 3236              		.loc 1 1433 17 is_stmt 0 view .LVU920
ARM GAS  /tmp/cc39PcX6.s 			page 138


 3237 0018 064B     		ldr	r3, .L252+8
 3238 001a FAE7     		b	.L251
 3239              	.L247:
1436:Src/mpu6050.c ****         break;
 3240              		.loc 1 1436 9 is_stmt 1 view .LVU921
1436:Src/mpu6050.c ****         break;
 3241              		.loc 1 1436 17 is_stmt 0 view .LVU922
 3242 001c 064B     		ldr	r3, .L252+12
 3243 001e F8E7     		b	.L251
 3244              	.L245:
1439:Src/mpu6050.c ****         break;
 3245              		.loc 1 1439 9 is_stmt 1 view .LVU923
1439:Src/mpu6050.c ****         break;
 3246              		.loc 1 1439 17 is_stmt 0 view .LVU924
 3247 0020 064B     		ldr	r3, .L252+16
 3248 0022 F6E7     		b	.L251
 3249              	.L250:
1428:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3250              		.loc 1 1428 5 view .LVU925
 3251 0024 4FF0FF30 		mov	r0, #-1
 3252              	.LVL205:
1445:Src/mpu6050.c **** 
 3253              		.loc 1 1445 1 view .LVU926
 3254 0028 7047     		bx	lr
 3255              	.L253:
 3256 002a 00BF     		.align	2
 3257              	.L252:
 3258 002c 00000000 		.word	.LANCHOR0
 3259 0030 00000343 		.word	1124270080
 3260 0034 00008342 		.word	1115881472
 3261 0038 33330342 		.word	1107505971
 3262 003c 33338341 		.word	1099117363
 3263              		.cfi_endproc
 3264              	.LFE84:
 3266              		.section	.text.mpu_get_accel_sens,"ax",%progbits
 3267              		.align	1
 3268              		.global	mpu_get_accel_sens
 3269              		.syntax unified
 3270              		.thumb
 3271              		.thumb_func
 3272              		.fpu softvfp
 3274              	mpu_get_accel_sens:
 3275              	.LVL206:
 3276              	.LFB85:
1453:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
 3277              		.loc 1 1453 1 is_stmt 1 view -0
 3278              		.cfi_startproc
 3279              		@ args = 0, pretend = 0, frame = 0
 3280              		@ frame_needed = 0, uses_anonymous_args = 0
 3281              		@ link register save eliminated.
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3282              		.loc 1 1454 5 view .LVU928
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3283              		.loc 1 1454 24 is_stmt 0 view .LVU929
 3284 0000 0E4B     		ldr	r3, .L266
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3285              		.loc 1 1454 5 view .LVU930
ARM GAS  /tmp/cc39PcX6.s 			page 139


 3286 0002 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 3287 0004 032A     		cmp	r2, #3
 3288 0006 16D8     		bhi	.L262
 3289 0008 DFE802F0 		tbb	[pc, r2]
 3290              	.L257:
 3291 000c 02       		.byte	(.L260-.L257)/2
 3292 000d 0C       		.byte	(.L259-.L257)/2
 3293 000e 0F       		.byte	(.L258-.L257)/2
 3294 000f 12       		.byte	(.L256-.L257)/2
 3295              		.p2align 1
 3296              	.L260:
1456:Src/mpu6050.c ****         break;
 3297              		.loc 1 1456 9 is_stmt 1 view .LVU931
1456:Src/mpu6050.c ****         break;
 3298              		.loc 1 1456 17 is_stmt 0 view .LVU932
 3299 0010 4FF48042 		mov	r2, #16384
 3300              	.L264:
1465:Src/mpu6050.c ****         break;
 3301              		.loc 1 1465 17 view .LVU933
 3302 0014 0280     		strh	r2, [r0]	@ movhi
1466:Src/mpu6050.c ****     default:
 3303              		.loc 1 1466 9 is_stmt 1 view .LVU934
1470:Src/mpu6050.c ****         sens[0] >>= 1;
 3304              		.loc 1 1470 5 view .LVU935
1470:Src/mpu6050.c ****         sens[0] >>= 1;
 3305              		.loc 1 1470 8 is_stmt 0 view .LVU936
 3306 0016 DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 3307 0018 13B1     		cbz	r3, .L265
1471:Src/mpu6050.c ****     return 0;
 3308              		.loc 1 1471 9 is_stmt 1 view .LVU937
1471:Src/mpu6050.c ****     return 0;
 3309              		.loc 1 1471 17 is_stmt 0 view .LVU938
 3310 001a 0388     		ldrh	r3, [r0]
 3311 001c 5B08     		lsrs	r3, r3, #1
 3312 001e 0380     		strh	r3, [r0]	@ movhi
 3313              	.L265:
1472:Src/mpu6050.c **** }
 3314              		.loc 1 1472 12 view .LVU939
 3315 0020 0020     		movs	r0, #0
 3316              	.LVL207:
1472:Src/mpu6050.c **** }
 3317              		.loc 1 1472 12 view .LVU940
 3318 0022 7047     		bx	lr
 3319              	.LVL208:
 3320              	.L259:
1459:Src/mpu6050.c ****         break;
 3321              		.loc 1 1459 9 is_stmt 1 view .LVU941
1459:Src/mpu6050.c ****         break;
 3322              		.loc 1 1459 17 is_stmt 0 view .LVU942
 3323 0024 4FF40052 		mov	r2, #8192
 3324 0028 F4E7     		b	.L264
 3325              	.L258:
1462:Src/mpu6050.c ****         break;
 3326              		.loc 1 1462 9 is_stmt 1 view .LVU943
1462:Src/mpu6050.c ****         break;
 3327              		.loc 1 1462 17 is_stmt 0 view .LVU944
 3328 002a 4FF48052 		mov	r2, #4096
ARM GAS  /tmp/cc39PcX6.s 			page 140


 3329 002e F1E7     		b	.L264
 3330              	.L256:
1465:Src/mpu6050.c ****         break;
 3331              		.loc 1 1465 9 is_stmt 1 view .LVU945
1465:Src/mpu6050.c ****         break;
 3332              		.loc 1 1465 17 is_stmt 0 view .LVU946
 3333 0030 4FF40062 		mov	r2, #2048
 3334 0034 EEE7     		b	.L264
 3335              	.L262:
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3336              		.loc 1 1454 5 view .LVU947
 3337 0036 4FF0FF30 		mov	r0, #-1
 3338              	.LVL209:
1454:Src/mpu6050.c ****     case INV_FSR_2G:
 3339              		.loc 1 1454 5 view .LVU948
 3340 003a 7047     		bx	lr
 3341              	.L267:
 3342              		.align	2
 3343              	.L266:
 3344 003c 00000000 		.word	.LANCHOR0
 3345              		.cfi_endproc
 3346              	.LFE85:
 3348              		.section	.text.mpu_get_fifo_config,"ax",%progbits
 3349              		.align	1
 3350              		.global	mpu_get_fifo_config
 3351              		.syntax unified
 3352              		.thumb
 3353              		.thumb_func
 3354              		.fpu softvfp
 3356              	mpu_get_fifo_config:
 3357              	.LVL210:
 3358              	.LFB86:
1485:Src/mpu6050.c ****     sensors[0] = st.chip_cfg.fifo_enable;
 3359              		.loc 1 1485 1 is_stmt 1 view -0
 3360              		.cfi_startproc
 3361              		@ args = 0, pretend = 0, frame = 0
 3362              		@ frame_needed = 0, uses_anonymous_args = 0
 3363              		@ link register save eliminated.
1486:Src/mpu6050.c ****     return 0;
 3364              		.loc 1 1486 5 view .LVU950
1486:Src/mpu6050.c ****     return 0;
 3365              		.loc 1 1486 29 is_stmt 0 view .LVU951
 3366 0000 024B     		ldr	r3, .L269
 3367 0002 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
1486:Src/mpu6050.c ****     return 0;
 3368              		.loc 1 1486 16 view .LVU952
 3369 0004 0370     		strb	r3, [r0]
1487:Src/mpu6050.c **** }
 3370              		.loc 1 1487 5 is_stmt 1 view .LVU953
1488:Src/mpu6050.c **** 
 3371              		.loc 1 1488 1 is_stmt 0 view .LVU954
 3372 0006 0020     		movs	r0, #0
 3373              	.LVL211:
1488:Src/mpu6050.c **** 
 3374              		.loc 1 1488 1 view .LVU955
 3375 0008 7047     		bx	lr
 3376              	.L270:
ARM GAS  /tmp/cc39PcX6.s 			page 141


 3377 000a 00BF     		.align	2
 3378              	.L269:
 3379 000c 00000000 		.word	.LANCHOR0
 3380              		.cfi_endproc
 3381              	.LFE86:
 3383              		.section	.text.mpu_configure_fifo,"ax",%progbits
 3384              		.align	1
 3385              		.global	mpu_configure_fifo
 3386              		.syntax unified
 3387              		.thumb
 3388              		.thumb_func
 3389              		.fpu softvfp
 3391              	mpu_configure_fifo:
 3392              	.LVL212:
 3393              	.LFB87:
1500:Src/mpu6050.c ****     unsigned char prev;
 3394              		.loc 1 1500 1 is_stmt 1 view -0
 3395              		.cfi_startproc
 3396              		@ args = 0, pretend = 0, frame = 0
 3397              		@ frame_needed = 0, uses_anonymous_args = 0
1501:Src/mpu6050.c ****     int result = 0;
 3398              		.loc 1 1501 5 view .LVU957
1502:Src/mpu6050.c **** 
 3399              		.loc 1 1502 5 view .LVU958
1505:Src/mpu6050.c **** 
 3400              		.loc 1 1505 5 view .LVU959
1507:Src/mpu6050.c ****         return 0;
 3401              		.loc 1 1507 5 view .LVU960
1500:Src/mpu6050.c ****     unsigned char prev;
 3402              		.loc 1 1500 1 is_stmt 0 view .LVU961
 3403 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3404              	.LCFI51:
 3405              		.cfi_def_cfa_offset 24
 3406              		.cfi_offset 3, -24
 3407              		.cfi_offset 4, -20
 3408              		.cfi_offset 5, -16
 3409              		.cfi_offset 6, -12
 3410              		.cfi_offset 7, -8
 3411              		.cfi_offset 14, -4
1507:Src/mpu6050.c ****         return 0;
 3412              		.loc 1 1507 20 view .LVU962
 3413 0002 114E     		ldr	r6, .L280
1507:Src/mpu6050.c ****         return 0;
 3414              		.loc 1 1507 8 view .LVU963
 3415 0004 96F82430 		ldrb	r3, [r6, #36]	@ zero_extendqisi2
 3416 0008 E3B9     		cbnz	r3, .L275
1510:Src/mpu6050.c ****             return -1;
 3417              		.loc 1 1510 9 is_stmt 1 view .LVU964
1510:Src/mpu6050.c ****             return -1;
 3418              		.loc 1 1510 26 is_stmt 0 view .LVU965
 3419 000a B47A     		ldrb	r4, [r6, #10]	@ zero_extendqisi2
1510:Src/mpu6050.c ****             return -1;
 3420              		.loc 1 1510 12 view .LVU966
 3421 000c 9CB1     		cbz	r4, .L276
1505:Src/mpu6050.c **** 
 3422              		.loc 1 1505 13 view .LVU967
 3423 000e 00F0FE05 		and	r5, r0, #254
ARM GAS  /tmp/cc39PcX6.s 			page 142


1512:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
 3424              		.loc 1 1512 9 is_stmt 1 view .LVU968
1513:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3425              		.loc 1 1513 33 is_stmt 0 view .LVU969
 3426 0012 2C40     		ands	r4, r4, r5
1521:Src/mpu6050.c ****             set_int_enable(1);
 3427              		.loc 1 1521 21 view .LVU970
 3428 0014 307D     		ldrb	r0, [r6, #20]	@ zero_extendqisi2
 3429              	.LVL213:
1512:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
 3430              		.loc 1 1512 14 view .LVU971
 3431 0016 377C     		ldrb	r7, [r6, #16]	@ zero_extendqisi2
 3432              	.LVL214:
1513:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3433              		.loc 1 1513 9 is_stmt 1 view .LVU972
1513:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3434              		.loc 1 1513 33 is_stmt 0 view .LVU973
 3435 0018 3474     		strb	r4, [r6, #16]
1514:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
 3436              		.loc 1 1514 9 is_stmt 1 view .LVU974
1514:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
 3437              		.loc 1 1514 12 is_stmt 0 view .LVU975
 3438 001a 641B     		subs	r4, r4, r5
 3439 001c 18BF     		it	ne
 3440 001e 4FF0FF34 		movne	r4, #-1
 3441              	.LVL215:
1521:Src/mpu6050.c ****             set_int_enable(1);
 3442              		.loc 1 1521 9 is_stmt 1 view .LVU976
1521:Src/mpu6050.c ****             set_int_enable(1);
 3443              		.loc 1 1521 21 is_stmt 0 view .LVU977
 3444 0022 2843     		orrs	r0, r0, r5
 3445 0024 0AD0     		beq	.L273
1522:Src/mpu6050.c ****         else
 3446              		.loc 1 1522 13 is_stmt 1 view .LVU978
 3447 0026 0120     		movs	r0, #1
 3448 0028 FFF7FEFF 		bl	set_int_enable.isra.0
 3449              	.LVL216:
1525:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3450              		.loc 1 1525 9 view .LVU979
1525:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3451              		.loc 1 1525 12 is_stmt 0 view .LVU980
 3452 002c 45B1     		cbz	r5, .L271
1526:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3453              		.loc 1 1526 13 is_stmt 1 view .LVU981
1526:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3454              		.loc 1 1526 17 is_stmt 0 view .LVU982
 3455 002e FFF7FEFF 		bl	mpu_reset_fifo
 3456              	.LVL217:
1526:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3457              		.loc 1 1526 16 view .LVU983
 3458 0032 28B1     		cbz	r0, .L271
1527:Src/mpu6050.c ****                 return -1;
 3459              		.loc 1 1527 17 is_stmt 1 view .LVU984
1527:Src/mpu6050.c ****                 return -1;
 3460              		.loc 1 1527 41 is_stmt 0 view .LVU985
 3461 0034 3774     		strb	r7, [r6, #16]
1528:Src/mpu6050.c ****             }
ARM GAS  /tmp/cc39PcX6.s 			page 143


 3462              		.loc 1 1528 17 is_stmt 1 view .LVU986
 3463              	.LVL218:
 3464              	.L276:
1511:Src/mpu6050.c ****         prev = st.chip_cfg.fifo_enable;
 3465              		.loc 1 1511 20 is_stmt 0 view .LVU987
 3466 0036 4FF0FF34 		mov	r4, #-1
 3467 003a 01E0     		b	.L271
 3468              	.LVL219:
 3469              	.L273:
1524:Src/mpu6050.c ****         if (sensors) {
 3470              		.loc 1 1524 13 is_stmt 1 view .LVU988
 3471 003c FFF7FEFF 		bl	set_int_enable.isra.0
 3472              	.LVL220:
1525:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3473              		.loc 1 1525 9 view .LVU989
 3474              	.L271:
1534:Src/mpu6050.c **** 
 3475              		.loc 1 1534 1 is_stmt 0 view .LVU990
 3476 0040 2046     		mov	r0, r4
 3477 0042 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3478              	.LVL221:
 3479              	.L275:
1508:Src/mpu6050.c ****     else {
 3480              		.loc 1 1508 16 view .LVU991
 3481 0044 0024     		movs	r4, #0
 3482 0046 FBE7     		b	.L271
 3483              	.L281:
 3484              		.align	2
 3485              	.L280:
 3486 0048 00000000 		.word	.LANCHOR0
 3487              		.cfi_endproc
 3488              	.LFE87:
 3490              		.section	.text.mpu_get_power_state,"ax",%progbits
 3491              		.align	1
 3492              		.global	mpu_get_power_state
 3493              		.syntax unified
 3494              		.thumb
 3495              		.thumb_func
 3496              		.fpu softvfp
 3498              	mpu_get_power_state:
 3499              	.LVL222:
 3500              	.LFB88:
1542:Src/mpu6050.c ****     if (st.chip_cfg.sensors)
 3501              		.loc 1 1542 1 is_stmt 1 view -0
 3502              		.cfi_startproc
 3503              		@ args = 0, pretend = 0, frame = 0
 3504              		@ frame_needed = 0, uses_anonymous_args = 0
 3505              		@ link register save eliminated.
1543:Src/mpu6050.c ****         power_on[0] = 1;
 3506              		.loc 1 1543 5 view .LVU993
1543:Src/mpu6050.c ****         power_on[0] = 1;
 3507              		.loc 1 1543 20 is_stmt 0 view .LVU994
 3508 0000 034B     		ldr	r3, .L283
1543:Src/mpu6050.c ****         power_on[0] = 1;
 3509              		.loc 1 1543 8 view .LVU995
 3510 0002 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 3511 0004 003B     		subs	r3, r3, #0
ARM GAS  /tmp/cc39PcX6.s 			page 144


 3512 0006 18BF     		it	ne
 3513 0008 0123     		movne	r3, #1
 3514 000a 0370     		strb	r3, [r0]
1547:Src/mpu6050.c **** }
 3515              		.loc 1 1547 5 is_stmt 1 view .LVU996
1548:Src/mpu6050.c **** 
 3516              		.loc 1 1548 1 is_stmt 0 view .LVU997
 3517 000c 0020     		movs	r0, #0
 3518              	.LVL223:
1548:Src/mpu6050.c **** 
 3519              		.loc 1 1548 1 view .LVU998
 3520 000e 7047     		bx	lr
 3521              	.L284:
 3522              		.align	2
 3523              	.L283:
 3524 0010 00000000 		.word	.LANCHOR0
 3525              		.cfi_endproc
 3526              	.LFE88:
 3528              		.section	.text.mpu_get_int_status,"ax",%progbits
 3529              		.align	1
 3530              		.global	mpu_get_int_status
 3531              		.syntax unified
 3532              		.thumb
 3533              		.thumb_func
 3534              		.fpu softvfp
 3536              	mpu_get_int_status:
 3537              	.LVL224:
 3538              	.LFB90:
1638:Src/mpu6050.c ****     unsigned char tmp[2];
 3539              		.loc 1 1638 1 is_stmt 1 view -0
 3540              		.cfi_startproc
 3541              		@ args = 0, pretend = 0, frame = 8
 3542              		@ frame_needed = 0, uses_anonymous_args = 0
1639:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3543              		.loc 1 1639 5 view .LVU1000
1640:Src/mpu6050.c ****         return -1;
 3544              		.loc 1 1640 5 view .LVU1001
1638:Src/mpu6050.c ****     unsigned char tmp[2];
 3545              		.loc 1 1638 1 is_stmt 0 view .LVU1002
 3546 0000 13B5     		push	{r0, r1, r4, lr}
 3547              	.LCFI52:
 3548              		.cfi_def_cfa_offset 16
 3549              		.cfi_offset 4, -8
 3550              		.cfi_offset 14, -4
1640:Src/mpu6050.c ****         return -1;
 3551              		.loc 1 1640 21 view .LVU1003
 3552 0002 0B4B     		ldr	r3, .L289
1638:Src/mpu6050.c ****     unsigned char tmp[2];
 3553              		.loc 1 1638 1 view .LVU1004
 3554 0004 0446     		mov	r4, r0
1640:Src/mpu6050.c ****         return -1;
 3555              		.loc 1 1640 8 view .LVU1005
 3556 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 3557 0008 1AB9     		cbnz	r2, .L286
 3558              	.LVL225:
 3559              	.L288:
1641:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
ARM GAS  /tmp/cc39PcX6.s 			page 145


 3560              		.loc 1 1641 16 view .LVU1006
 3561 000a 4FF0FF30 		mov	r0, #-1
 3562              	.L285:
1646:Src/mpu6050.c **** 
 3563              		.loc 1 1646 1 view .LVU1007
 3564 000e 02B0     		add	sp, sp, #8
 3565              	.LCFI53:
 3566              		.cfi_remember_state
 3567              		.cfi_def_cfa_offset 8
 3568              		@ sp needed
 3569 0010 10BD     		pop	{r4, pc}
 3570              	.LVL226:
 3571              	.L286:
 3572              	.LCFI54:
 3573              		.cfi_restore_state
1642:Src/mpu6050.c ****         return -1;
 3574              		.loc 1 1642 5 is_stmt 1 view .LVU1008
1642:Src/mpu6050.c ****         return -1;
 3575              		.loc 1 1642 9 is_stmt 0 view .LVU1009
 3576 0012 D3E90010 		ldrd	r1, r0, [r3]
 3577              	.LVL227:
1642:Src/mpu6050.c ****         return -1;
 3578              		.loc 1 1642 9 view .LVU1010
 3579 0016 0222     		movs	r2, #2
 3580 0018 897C     		ldrb	r1, [r1, #18]	@ zero_extendqisi2
 3581 001a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3582 001c 01AB     		add	r3, sp, #4
 3583 001e FFF7FEFF 		bl	i2c_readBytes
 3584              	.LVL228:
1642:Src/mpu6050.c ****         return -1;
 3585              		.loc 1 1642 8 view .LVU1011
 3586 0022 0028     		cmp	r0, #0
 3587 0024 F1D1     		bne	.L288
1644:Src/mpu6050.c ****     return 0;
 3588              		.loc 1 1644 5 is_stmt 1 view .LVU1012
1644:Src/mpu6050.c ****     return 0;
 3589              		.loc 1 1644 15 is_stmt 0 view .LVU1013
 3590 0026 BDF80430 		ldrh	r3, [sp, #4]
 3591 002a 5BBA     		rev16	r3, r3
 3592 002c 2380     		strh	r3, [r4]	@ movhi
1645:Src/mpu6050.c **** }
 3593              		.loc 1 1645 5 is_stmt 1 view .LVU1014
1645:Src/mpu6050.c **** }
 3594              		.loc 1 1645 12 is_stmt 0 view .LVU1015
 3595 002e EEE7     		b	.L285
 3596              	.L290:
 3597              		.align	2
 3598              	.L289:
 3599 0030 00000000 		.word	.LANCHOR0
 3600              		.cfi_endproc
 3601              	.LFE90:
 3603              		.section	.text.mpu_read_fifo,"ax",%progbits
 3604              		.align	1
 3605              		.global	mpu_read_fifo
 3606              		.syntax unified
 3607              		.thumb
 3608              		.thumb_func
ARM GAS  /tmp/cc39PcX6.s 			page 146


 3609              		.fpu softvfp
 3611              	mpu_read_fifo:
 3612              	.LVL229:
 3613              	.LFB91:
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3614              		.loc 1 1668 1 is_stmt 1 view -0
 3615              		.cfi_startproc
 3616              		@ args = 4, pretend = 0, frame = 16
 3617              		@ frame_needed = 0, uses_anonymous_args = 0
1670:Src/mpu6050.c ****     unsigned char packet_size = 0;
 3618              		.loc 1 1670 5 view .LVU1017
1671:Src/mpu6050.c ****     unsigned short fifo_count, index = 0;
 3619              		.loc 1 1671 5 view .LVU1018
1672:Src/mpu6050.c **** 
 3620              		.loc 1 1672 5 view .LVU1019
1674:Src/mpu6050.c ****         return -1;
 3621              		.loc 1 1674 5 view .LVU1020
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3622              		.loc 1 1668 1 is_stmt 0 view .LVU1021
 3623 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3624              	.LCFI55:
 3625              		.cfi_def_cfa_offset 36
 3626              		.cfi_offset 4, -36
 3627              		.cfi_offset 5, -32
 3628              		.cfi_offset 6, -28
 3629              		.cfi_offset 7, -24
 3630              		.cfi_offset 8, -20
 3631              		.cfi_offset 9, -16
 3632              		.cfi_offset 10, -12
 3633              		.cfi_offset 11, -8
 3634              		.cfi_offset 14, -4
1674:Src/mpu6050.c ****         return -1;
 3635              		.loc 1 1674 20 view .LVU1022
 3636 0004 654D     		ldr	r5, .L342
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3637              		.loc 1 1668 1 view .LVU1023
 3638 0006 1E46     		mov	r6, r3
1674:Src/mpu6050.c ****         return -1;
 3639              		.loc 1 1674 8 view .LVU1024
 3640 0008 95F82430 		ldrb	r3, [r5, #36]	@ zero_extendqisi2
 3641              	.LVL230:
1668:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3642              		.loc 1 1668 1 view .LVU1025
 3643 000c 0746     		mov	r7, r0
 3644 000e 8946     		mov	r9, r1
 3645 0010 9246     		mov	r10, r2
 3646 0012 85B0     		sub	sp, sp, #20
 3647              	.LCFI56:
 3648              		.cfi_def_cfa_offset 56
1674:Src/mpu6050.c ****         return -1;
 3649              		.loc 1 1674 8 view .LVU1026
 3650 0014 23B1     		cbz	r3, .L292
 3651              	.LVL231:
 3652              	.L294:
1675:Src/mpu6050.c **** 
 3653              		.loc 1 1675 16 view .LVU1027
 3654 0016 4FF0FF30 		mov	r0, #-1
ARM GAS  /tmp/cc39PcX6.s 			page 147


 3655              	.LVL232:
 3656              	.L291:
1740:Src/mpu6050.c **** 
 3657              		.loc 1 1740 1 view .LVU1028
 3658 001a 05B0     		add	sp, sp, #20
 3659              	.LCFI57:
 3660              		.cfi_remember_state
 3661              		.cfi_def_cfa_offset 36
 3662              		@ sp needed
 3663 001c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3664              	.LVL233:
 3665              	.L292:
 3666              	.LCFI58:
 3667              		.cfi_restore_state
1677:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3668              		.loc 1 1677 5 is_stmt 1 view .LVU1029
1677:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3669              		.loc 1 1677 16 is_stmt 0 view .LVU1030
 3670 0020 3370     		strb	r3, [r6]
1678:Src/mpu6050.c ****         return -1;
 3671              		.loc 1 1678 5 is_stmt 1 view .LVU1031
1678:Src/mpu6050.c ****         return -1;
 3672              		.loc 1 1678 8 is_stmt 0 view .LVU1032
 3673 0022 AB7A     		ldrb	r3, [r5, #10]	@ zero_extendqisi2
 3674 0024 002B     		cmp	r3, #0
 3675 0026 F6D0     		beq	.L294
1680:Src/mpu6050.c ****         return -1;
 3676              		.loc 1 1680 5 is_stmt 1 view .LVU1033
1680:Src/mpu6050.c ****         return -1;
 3677              		.loc 1 1680 21 is_stmt 0 view .LVU1034
 3678 0028 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
1680:Src/mpu6050.c ****         return -1;
 3679              		.loc 1 1680 8 view .LVU1035
 3680 002a 002B     		cmp	r3, #0
 3681 002c F3D0     		beq	.L294
1683:Src/mpu6050.c ****         packet_size += 2;
 3682              		.loc 1 1683 5 is_stmt 1 view .LVU1036
1684:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
 3683              		.loc 1 1684 21 is_stmt 0 view .LVU1037
 3684 002e 13F04004 		ands	r4, r3, #64
 3685 0032 18BF     		it	ne
 3686 0034 0224     		movne	r4, #2
 3687              	.LVL234:
1685:Src/mpu6050.c ****         packet_size += 2;
 3688              		.loc 1 1685 5 is_stmt 1 view .LVU1038
1685:Src/mpu6050.c ****         packet_size += 2;
 3689              		.loc 1 1685 8 is_stmt 0 view .LVU1039
 3690 0036 9806     		lsls	r0, r3, #26
 3691              	.LVL235:
1686:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
 3692              		.loc 1 1686 9 is_stmt 1 view .LVU1040
1686:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
 3693              		.loc 1 1686 21 is_stmt 0 view .LVU1041
 3694 0038 48BF     		it	mi
 3695 003a 0234     		addmi	r4, r4, #2
 3696              	.LVL236:
1687:Src/mpu6050.c ****         packet_size += 2;
ARM GAS  /tmp/cc39PcX6.s 			page 148


 3697              		.loc 1 1687 5 is_stmt 1 view .LVU1042
1687:Src/mpu6050.c ****         packet_size += 2;
 3698              		.loc 1 1687 8 is_stmt 0 view .LVU1043
 3699 003c D906     		lsls	r1, r3, #27
 3700              	.LVL237:
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3701              		.loc 1 1688 9 is_stmt 1 view .LVU1044
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3702              		.loc 1 1688 21 is_stmt 0 view .LVU1045
 3703 003e 44BF     		itt	mi
 3704 0040 0234     		addmi	r4, r4, #2
 3705              	.LVL238:
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3706              		.loc 1 1688 21 view .LVU1046
 3707 0042 E4B2     		uxtbmi	r4, r4
 3708              	.LVL239:
1689:Src/mpu6050.c ****         packet_size += 6;
 3709              		.loc 1 1689 5 is_stmt 1 view .LVU1047
1689:Src/mpu6050.c ****         packet_size += 6;
 3710              		.loc 1 1689 8 is_stmt 0 view .LVU1048
 3711 0044 1A07     		lsls	r2, r3, #28
 3712              	.LVL240:
1690:Src/mpu6050.c **** 
 3713              		.loc 1 1690 9 is_stmt 1 view .LVU1049
1690:Src/mpu6050.c **** 
 3714              		.loc 1 1690 21 is_stmt 0 view .LVU1050
 3715 0046 48BF     		it	mi
 3716 0048 0634     		addmi	r4, r4, #6
 3717              	.LVL241:
1692:Src/mpu6050.c ****         return -1;
 3718              		.loc 1 1692 9 view .LVU1051
 3719 004a D5E90010 		ldrd	r1, r0, [r5]
 3720 004e 4FF00202 		mov	r2, #2
 3721 0052 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 3722 0054 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3723 0056 01AB     		add	r3, sp, #4
 3724              	.LVL242:
1690:Src/mpu6050.c **** 
 3725              		.loc 1 1690 21 view .LVU1052
 3726 0058 48BF     		it	mi
 3727 005a E4B2     		uxtbmi	r4, r4
 3728              	.LVL243:
1692:Src/mpu6050.c ****         return -1;
 3729              		.loc 1 1692 5 is_stmt 1 view .LVU1053
1692:Src/mpu6050.c ****         return -1;
 3730              		.loc 1 1692 9 is_stmt 0 view .LVU1054
 3731 005c FFF7FEFF 		bl	i2c_readBytes
 3732              	.LVL244:
1692:Src/mpu6050.c ****         return -1;
 3733              		.loc 1 1692 8 view .LVU1055
 3734 0060 0028     		cmp	r0, #0
 3735 0062 D8D1     		bne	.L294
1694:Src/mpu6050.c ****     if (fifo_count < packet_size)
 3736              		.loc 1 1694 5 is_stmt 1 view .LVU1056
 3737 0064 BDF80430 		ldrh	r3, [sp, #4]
1695:Src/mpu6050.c ****         return 0;
 3738              		.loc 1 1695 20 is_stmt 0 view .LVU1057
ARM GAS  /tmp/cc39PcX6.s 			page 149


 3739 0068 1FFA84F8 		uxth	r8, r4
 3740 006c 5BBA     		rev16	r3, r3
 3741 006e 1FFA83FB 		uxth	fp, r3
 3742              	.LVL245:
1695:Src/mpu6050.c ****         return 0;
 3743              		.loc 1 1695 5 is_stmt 1 view .LVU1058
1695:Src/mpu6050.c ****         return 0;
 3744              		.loc 1 1695 8 is_stmt 0 view .LVU1059
 3745 0072 D845     		cmp	r8, fp
 3746 0074 01D9     		bls	.L299
 3747              	.LVL246:
 3748              	.L341:
1736:Src/mpu6050.c ****     }
 3749              		.loc 1 1736 9 is_stmt 1 view .LVU1060
1739:Src/mpu6050.c **** }
 3750              		.loc 1 1739 12 is_stmt 0 view .LVU1061
 3751 0076 0020     		movs	r0, #0
1739:Src/mpu6050.c **** }
 3752              		.loc 1 1739 12 view .LVU1062
 3753 0078 CFE7     		b	.L291
 3754              	.LVL247:
 3755              	.L299:
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3756              		.loc 1 1700 5 is_stmt 1 view .LVU1063
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3757              		.loc 1 1700 25 is_stmt 0 view .LVU1064
 3758 007a 6868     		ldr	r0, [r5, #4]
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3759              		.loc 1 1700 20 view .LVU1065
 3760 007c 4388     		ldrh	r3, [r0, #2]
 3761              	.LVL248:
1700:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3762              		.loc 1 1700 8 view .LVU1066
 3763 007e BBEB530F 		cmp	fp, r3, lsr #1
 3764 0082 11D9     		bls	.L300
1702:Src/mpu6050.c ****             return -1;
 3765              		.loc 1 1702 9 is_stmt 1 view .LVU1067
1702:Src/mpu6050.c ****             return -1;
 3766              		.loc 1 1702 13 is_stmt 0 view .LVU1068
 3767 0084 2968     		ldr	r1, [r5]
 3768 0086 0122     		movs	r2, #1
 3769 0088 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 3770 008a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3771 008c 01AB     		add	r3, sp, #4
 3772 008e FFF7FEFF 		bl	i2c_readBytes
 3773              	.LVL249:
1702:Src/mpu6050.c ****             return -1;
 3774              		.loc 1 1702 12 view .LVU1069
 3775 0092 0028     		cmp	r0, #0
 3776 0094 BFD1     		bne	.L294
1704:Src/mpu6050.c ****             mpu_reset_fifo();
 3777              		.loc 1 1704 9 is_stmt 1 view .LVU1070
1704:Src/mpu6050.c ****             mpu_reset_fifo();
 3778              		.loc 1 1704 12 is_stmt 0 view .LVU1071
 3779 0096 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3780 009a DB06     		lsls	r3, r3, #27
 3781 009c 04D5     		bpl	.L300
ARM GAS  /tmp/cc39PcX6.s 			page 150


1705:Src/mpu6050.c ****             return -2;
 3782              		.loc 1 1705 13 is_stmt 1 view .LVU1072
 3783 009e FFF7FEFF 		bl	mpu_reset_fifo
 3784              	.LVL250:
1706:Src/mpu6050.c ****         }
 3785              		.loc 1 1706 13 view .LVU1073
1706:Src/mpu6050.c ****         }
 3786              		.loc 1 1706 20 is_stmt 0 view .LVU1074
 3787 00a2 6FF00100 		mvn	r0, #1
 3788 00a6 B8E7     		b	.L291
 3789              	.L300:
1709:Src/mpu6050.c **** 
 3790              		.loc 1 1709 5 is_stmt 1 view .LVU1075
 3791 00a8 5046     		mov	r0, r10
 3792 00aa FFF7FEFF 		bl	get_tick_count_ms
 3793              	.LVL251:
1711:Src/mpu6050.c ****         return -1;
 3794              		.loc 1 1711 5 view .LVU1076
1711:Src/mpu6050.c ****         return -1;
 3795              		.loc 1 1711 9 is_stmt 0 view .LVU1077
 3796 00ae D5E90010 		ldrd	r1, r0, [r5]
 3797 00b2 2246     		mov	r2, r4
 3798 00b4 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 3799 00b6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3800 00b8 01AB     		add	r3, sp, #4
 3801 00ba FFF7FEFF 		bl	i2c_readBytes
 3802              	.LVL252:
1711:Src/mpu6050.c ****         return -1;
 3803              		.loc 1 1711 8 view .LVU1078
 3804 00be 0028     		cmp	r0, #0
 3805 00c0 A9D1     		bne	.L294
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3806              		.loc 1 1713 5 is_stmt 1 view .LVU1079
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3807              		.loc 1 1713 26 is_stmt 0 view .LVU1080
 3808 00c2 BBFBF4F3 		udiv	r3, fp, r4
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3809              		.loc 1 1713 13 view .LVU1081
 3810 00c6 0E9A     		ldr	r2, [sp, #56]
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3811              		.loc 1 1713 40 view .LVU1082
 3812 00c8 013B     		subs	r3, r3, #1
1713:Src/mpu6050.c ****     sensors[0] = 0;
 3813              		.loc 1 1713 13 view .LVU1083
 3814 00ca 1370     		strb	r3, [r2]
1714:Src/mpu6050.c **** 
 3815              		.loc 1 1714 5 is_stmt 1 view .LVU1084
1714:Src/mpu6050.c **** 
 3816              		.loc 1 1714 16 is_stmt 0 view .LVU1085
 3817 00cc 3070     		strb	r0, [r6]
1716:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3818              		.loc 1 1716 5 is_stmt 1 view .LVU1086
1716:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3819              		.loc 1 1716 8 is_stmt 0 view .LVU1087
 3820 00ce 002C     		cmp	r4, #0
 3821 00d0 D1D0     		beq	.L341
1716:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
ARM GAS  /tmp/cc39PcX6.s 			page 151


 3822              		.loc 1 1716 32 discriminator 1 view .LVU1088
 3823 00d2 2A7C     		ldrb	r2, [r5, #16]	@ zero_extendqisi2
 3824 00d4 12F00802 		ands	r2, r2, #8
 3825 00d8 16D0     		beq	.L302
1717:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3826              		.loc 1 1717 9 is_stmt 1 view .LVU1089
1717:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3827              		.loc 1 1717 18 is_stmt 0 view .LVU1090
 3828 00da BDF80430 		ldrh	r3, [sp, #4]
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3829              		.loc 1 1723 8 view .LVU1091
 3830 00de B8F1060F 		cmp	r8, #6
1717:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3831              		.loc 1 1717 18 view .LVU1092
 3832 00e2 5BBA     		rev16	r3, r3
 3833 00e4 A9F80030 		strh	r3, [r9]	@ movhi
1718:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
 3834              		.loc 1 1718 9 is_stmt 1 view .LVU1093
1718:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
 3835              		.loc 1 1718 18 is_stmt 0 view .LVU1094
 3836 00e8 BDF80630 		ldrh	r3, [sp, #6]
 3837 00ec 5BBA     		rev16	r3, r3
 3838 00ee A9F80230 		strh	r3, [r9, #2]	@ movhi
1719:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
 3839              		.loc 1 1719 9 is_stmt 1 view .LVU1095
1719:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
 3840              		.loc 1 1719 18 is_stmt 0 view .LVU1096
 3841 00f2 BDF80830 		ldrh	r3, [sp, #8]
 3842 00f6 5BBA     		rev16	r3, r3
 3843 00f8 A9F80430 		strh	r3, [r9, #4]	@ movhi
1720:Src/mpu6050.c ****         index += 6;
 3844              		.loc 1 1720 9 is_stmt 1 view .LVU1097
1720:Src/mpu6050.c ****         index += 6;
 3845              		.loc 1 1720 20 is_stmt 0 view .LVU1098
 3846 00fc 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3847 00fe 43F00803 		orr	r3, r3, #8
 3848 0102 3370     		strb	r3, [r6]
1721:Src/mpu6050.c ****     }
 3849              		.loc 1 1721 9 is_stmt 1 view .LVU1099
 3850              	.LVL253:
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3851              		.loc 1 1723 5 view .LVU1100
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3852              		.loc 1 1723 8 is_stmt 0 view .LVU1101
 3853 0104 B7D0     		beq	.L341
1721:Src/mpu6050.c ****     }
 3854              		.loc 1 1721 15 view .LVU1102
 3855 0106 0622     		movs	r2, #6
 3856              	.LVL254:
 3857              	.L302:
1723:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3858              		.loc 1 1723 32 discriminator 1 view .LVU1103
 3859 0108 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3860 010a 5806     		lsls	r0, r3, #25
 3861 010c 15D5     		bpl	.L303
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3862              		.loc 1 1724 9 is_stmt 1 view .LVU1104
ARM GAS  /tmp/cc39PcX6.s 			page 152


1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3863              		.loc 1 1724 24 is_stmt 0 view .LVU1105
 3864 010e 02F11003 		add	r3, r2, #16
 3865 0112 6B44     		add	r3, sp, r3
 3866 0114 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3867              		.loc 1 1724 52 view .LVU1106
 3868 0118 531C     		adds	r3, r2, #1
 3869 011a 9BB2     		uxth	r3, r3
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3870              		.loc 1 1724 46 view .LVU1107
 3871 011c 1033     		adds	r3, r3, #16
 3872 011e 6B44     		add	r3, sp, r3
 3873 0120 13F80C3C 		ldrb	r3, [r3, #-12]	@ zero_extendqisi2
1726:Src/mpu6050.c ****     }
 3874              		.loc 1 1726 15 view .LVU1108
 3875 0124 0232     		adds	r2, r2, #2
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3876              		.loc 1 1724 40 view .LVU1109
 3877 0126 43EA0123 		orr	r3, r3, r1, lsl #8
1724:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3878              		.loc 1 1724 17 view .LVU1110
 3879 012a 3B80     		strh	r3, [r7]	@ movhi
1725:Src/mpu6050.c ****         index += 2;
 3880              		.loc 1 1725 9 is_stmt 1 view .LVU1111
1725:Src/mpu6050.c ****         index += 2;
 3881              		.loc 1 1725 20 is_stmt 0 view .LVU1112
 3882 012c 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
1726:Src/mpu6050.c ****     }
 3883              		.loc 1 1726 15 view .LVU1113
 3884 012e 92B2     		uxth	r2, r2
1725:Src/mpu6050.c ****         index += 2;
 3885              		.loc 1 1725 20 view .LVU1114
 3886 0130 43F04003 		orr	r3, r3, #64
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3887              		.loc 1 1728 8 view .LVU1115
 3888 0134 9045     		cmp	r8, r2
1725:Src/mpu6050.c ****         index += 2;
 3889              		.loc 1 1725 20 view .LVU1116
 3890 0136 3370     		strb	r3, [r6]
1726:Src/mpu6050.c ****     }
 3891              		.loc 1 1726 9 is_stmt 1 view .LVU1117
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3892              		.loc 1 1728 5 view .LVU1118
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3893              		.loc 1 1728 8 is_stmt 0 view .LVU1119
 3894 0138 9DD0     		beq	.L341
 3895              	.L303:
1728:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3896              		.loc 1 1728 32 discriminator 1 view .LVU1120
 3897 013a 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3898 013c 9906     		lsls	r1, r3, #26
 3899 013e 15D5     		bpl	.L304
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3900              		.loc 1 1729 9 is_stmt 1 view .LVU1121
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3901              		.loc 1 1729 24 is_stmt 0 view .LVU1122
ARM GAS  /tmp/cc39PcX6.s 			page 153


 3902 0140 02F11003 		add	r3, r2, #16
 3903 0144 6B44     		add	r3, sp, r3
 3904 0146 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3905              		.loc 1 1729 52 view .LVU1123
 3906 014a 531C     		adds	r3, r2, #1
 3907 014c 9BB2     		uxth	r3, r3
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3908              		.loc 1 1729 46 view .LVU1124
 3909 014e 1033     		adds	r3, r3, #16
 3910 0150 6B44     		add	r3, sp, r3
 3911 0152 13F80C3C 		ldrb	r3, [r3, #-12]	@ zero_extendqisi2
1731:Src/mpu6050.c ****     }
 3912              		.loc 1 1731 15 view .LVU1125
 3913 0156 0232     		adds	r2, r2, #2
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3914              		.loc 1 1729 40 view .LVU1126
 3915 0158 43EA0123 		orr	r3, r3, r1, lsl #8
1729:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3916              		.loc 1 1729 17 view .LVU1127
 3917 015c 7B80     		strh	r3, [r7, #2]	@ movhi
1730:Src/mpu6050.c ****         index += 2;
 3918              		.loc 1 1730 9 is_stmt 1 view .LVU1128
1730:Src/mpu6050.c ****         index += 2;
 3919              		.loc 1 1730 20 is_stmt 0 view .LVU1129
 3920 015e 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
1731:Src/mpu6050.c ****     }
 3921              		.loc 1 1731 15 view .LVU1130
 3922 0160 92B2     		uxth	r2, r2
1730:Src/mpu6050.c ****         index += 2;
 3923              		.loc 1 1730 20 view .LVU1131
 3924 0162 43F02003 		orr	r3, r3, #32
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3925              		.loc 1 1733 8 view .LVU1132
 3926 0166 9045     		cmp	r8, r2
1730:Src/mpu6050.c ****         index += 2;
 3927              		.loc 1 1730 20 view .LVU1133
 3928 0168 3370     		strb	r3, [r6]
1731:Src/mpu6050.c ****     }
 3929              		.loc 1 1731 9 is_stmt 1 view .LVU1134
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3930              		.loc 1 1733 5 view .LVU1135
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3931              		.loc 1 1733 8 is_stmt 0 view .LVU1136
 3932 016a 84D0     		beq	.L341
 3933              	.L304:
1733:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3934              		.loc 1 1733 32 discriminator 1 view .LVU1137
 3935 016c 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3936 016e DB06     		lsls	r3, r3, #27
 3937 0170 81D5     		bpl	.L341
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3938              		.loc 1 1734 9 is_stmt 1 view .LVU1138
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3939              		.loc 1 1734 24 is_stmt 0 view .LVU1139
 3940 0172 02F11003 		add	r3, r2, #16
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
ARM GAS  /tmp/cc39PcX6.s 			page 154


 3941              		.loc 1 1734 52 view .LVU1140
 3942 0176 0132     		adds	r2, r2, #1
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3943              		.loc 1 1734 24 view .LVU1141
 3944 0178 6B44     		add	r3, sp, r3
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3945              		.loc 1 1734 52 view .LVU1142
 3946 017a 92B2     		uxth	r2, r2
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3947              		.loc 1 1734 24 view .LVU1143
 3948 017c 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3949              		.loc 1 1734 46 view .LVU1144
 3950 0180 02F11003 		add	r3, r2, #16
 3951 0184 0DEB0302 		add	r2, sp, r3
 3952 0188 12F80C3C 		ldrb	r3, [r2, #-12]	@ zero_extendqisi2
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3953              		.loc 1 1734 40 view .LVU1145
 3954 018c 43EA0123 		orr	r3, r3, r1, lsl #8
1734:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3955              		.loc 1 1734 17 view .LVU1146
 3956 0190 BB80     		strh	r3, [r7, #4]	@ movhi
1735:Src/mpu6050.c ****         index += 2;
 3957              		.loc 1 1735 9 is_stmt 1 view .LVU1147
1735:Src/mpu6050.c ****         index += 2;
 3958              		.loc 1 1735 20 is_stmt 0 view .LVU1148
 3959 0192 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3960 0194 43F01003 		orr	r3, r3, #16
 3961 0198 3370     		strb	r3, [r6]
 3962 019a 6CE7     		b	.L341
 3963              	.L343:
 3964              		.align	2
 3965              	.L342:
 3966 019c 00000000 		.word	.LANCHOR0
 3967              		.cfi_endproc
 3968              	.LFE91:
 3970              		.section	.text.mpu_read_fifo_stream,"ax",%progbits
 3971              		.align	1
 3972              		.global	mpu_read_fifo_stream
 3973              		.syntax unified
 3974              		.thumb
 3975              		.thumb_func
 3976              		.fpu softvfp
 3978              	mpu_read_fifo_stream:
 3979              	.LVL255:
 3980              	.LFB92:
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 3981              		.loc 1 1751 1 is_stmt 1 view -0
 3982              		.cfi_startproc
 3983              		@ args = 0, pretend = 0, frame = 8
 3984              		@ frame_needed = 0, uses_anonymous_args = 0
1752:Src/mpu6050.c ****     unsigned short fifo_count;
 3985              		.loc 1 1752 5 view .LVU1150
1753:Src/mpu6050.c ****     if (!st.chip_cfg.dmp_on)
 3986              		.loc 1 1753 5 view .LVU1151
1754:Src/mpu6050.c ****         return -1;
 3987              		.loc 1 1754 5 view .LVU1152
ARM GAS  /tmp/cc39PcX6.s 			page 155


1751:Src/mpu6050.c ****     unsigned char tmp[2];
 3988              		.loc 1 1751 1 is_stmt 0 view .LVU1153
 3989 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 3990              	.LCFI59:
 3991              		.cfi_def_cfa_offset 32
 3992              		.cfi_offset 4, -24
 3993              		.cfi_offset 5, -20
 3994              		.cfi_offset 6, -16
 3995              		.cfi_offset 7, -12
 3996              		.cfi_offset 8, -8
 3997              		.cfi_offset 14, -4
1754:Src/mpu6050.c ****         return -1;
 3998              		.loc 1 1754 21 view .LVU1154
 3999 0004 234F     		ldr	r7, .L357
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 4000              		.loc 1 1751 1 view .LVU1155
 4001 0006 0646     		mov	r6, r0
1754:Src/mpu6050.c ****         return -1;
 4002              		.loc 1 1754 8 view .LVU1156
 4003 0008 97F82430 		ldrb	r3, [r7, #36]	@ zero_extendqisi2
1751:Src/mpu6050.c ****     unsigned char tmp[2];
 4004              		.loc 1 1751 1 view .LVU1157
 4005 000c 8846     		mov	r8, r1
 4006 000e 1546     		mov	r5, r2
1754:Src/mpu6050.c ****         return -1;
 4007              		.loc 1 1754 8 view .LVU1158
 4008 0010 23B9     		cbnz	r3, .L345
 4009              	.LVL256:
 4010              	.L356:
1764:Src/mpu6050.c ****     }
 4011              		.loc 1 1764 9 is_stmt 1 view .LVU1159
1764:Src/mpu6050.c ****     }
 4012              		.loc 1 1764 16 is_stmt 0 view .LVU1160
 4013 0012 4FF0FF30 		mov	r0, #-1
 4014              	.L344:
1780:Src/mpu6050.c **** 
 4015              		.loc 1 1780 1 view .LVU1161
 4016 0016 02B0     		add	sp, sp, #8
 4017              	.LCFI60:
 4018              		.cfi_remember_state
 4019              		.cfi_def_cfa_offset 24
 4020              		@ sp needed
 4021 0018 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 4022              	.LVL257:
 4023              	.L345:
 4024              	.LCFI61:
 4025              		.cfi_restore_state
1756:Src/mpu6050.c ****         return -1;
 4026              		.loc 1 1756 5 is_stmt 1 view .LVU1162
1756:Src/mpu6050.c ****         return -1;
 4027              		.loc 1 1756 8 is_stmt 0 view .LVU1163
 4028 001c BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 4029 001e 002B     		cmp	r3, #0
 4030 0020 F7D0     		beq	.L356
1759:Src/mpu6050.c ****         return -1;
 4031              		.loc 1 1759 5 is_stmt 1 view .LVU1164
1759:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 156


 4032              		.loc 1 1759 9 is_stmt 0 view .LVU1165
 4033 0022 D7E90010 		ldrd	r1, r0, [r7]
 4034              	.LVL258:
1759:Src/mpu6050.c ****         return -1;
 4035              		.loc 1 1759 9 view .LVU1166
 4036 0026 0222     		movs	r2, #2
 4037              	.LVL259:
1759:Src/mpu6050.c ****         return -1;
 4038              		.loc 1 1759 9 view .LVU1167
 4039 0028 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 4040 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4041 002c 01AB     		add	r3, sp, #4
 4042 002e FFF7FEFF 		bl	i2c_readBytes
 4043              	.LVL260:
1759:Src/mpu6050.c ****         return -1;
 4044              		.loc 1 1759 8 view .LVU1168
 4045 0032 0028     		cmp	r0, #0
 4046 0034 EDD1     		bne	.L356
1761:Src/mpu6050.c ****     if (fifo_count < length) {
 4047              		.loc 1 1761 5 is_stmt 1 view .LVU1169
 4048 0036 BDF80440 		ldrh	r4, [sp, #4]
 4049 003a 62BA     		rev16	r2, r4
 4050 003c 94B2     		uxth	r4, r2
 4051              	.LVL261:
1762:Src/mpu6050.c ****         more[0] = 0;
 4052              		.loc 1 1762 5 view .LVU1170
1762:Src/mpu6050.c ****         more[0] = 0;
 4053              		.loc 1 1762 8 is_stmt 0 view .LVU1171
 4054 003e A642     		cmp	r6, r4
 4055 0040 01D9     		bls	.L348
1763:Src/mpu6050.c ****         return -1;
 4056              		.loc 1 1763 9 is_stmt 1 view .LVU1172
1763:Src/mpu6050.c ****         return -1;
 4057              		.loc 1 1763 17 is_stmt 0 view .LVU1173
 4058 0042 2870     		strb	r0, [r5]
 4059 0044 E5E7     		b	.L356
 4060              	.L348:
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 4061              		.loc 1 1766 5 is_stmt 1 view .LVU1174
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 4062              		.loc 1 1766 25 is_stmt 0 view .LVU1175
 4063 0046 7868     		ldr	r0, [r7, #4]
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 4064              		.loc 1 1766 20 view .LVU1176
 4065 0048 4388     		ldrh	r3, [r0, #2]
1766:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 4066              		.loc 1 1766 8 view .LVU1177
 4067 004a B4EB530F 		cmp	r4, r3, lsr #1
 4068 004e 11D9     		bls	.L349
1768:Src/mpu6050.c ****             return -1;
 4069              		.loc 1 1768 9 is_stmt 1 view .LVU1178
1768:Src/mpu6050.c ****             return -1;
 4070              		.loc 1 1768 13 is_stmt 0 view .LVU1179
 4071 0050 3968     		ldr	r1, [r7]
 4072 0052 0122     		movs	r2, #1
 4073              	.LVL262:
1768:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 157


 4074              		.loc 1 1768 13 view .LVU1180
 4075 0054 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 4076 0056 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4077 0058 01AB     		add	r3, sp, #4
 4078 005a FFF7FEFF 		bl	i2c_readBytes
 4079              	.LVL263:
1768:Src/mpu6050.c ****             return -1;
 4080              		.loc 1 1768 12 view .LVU1181
 4081 005e 0028     		cmp	r0, #0
 4082 0060 D7D1     		bne	.L356
1770:Src/mpu6050.c ****             mpu_reset_fifo();
 4083              		.loc 1 1770 9 is_stmt 1 view .LVU1182
1770:Src/mpu6050.c ****             mpu_reset_fifo();
 4084              		.loc 1 1770 12 is_stmt 0 view .LVU1183
 4085 0062 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 4086 0066 DB06     		lsls	r3, r3, #27
 4087 0068 04D5     		bpl	.L349
1771:Src/mpu6050.c ****             return -2;
 4088              		.loc 1 1771 13 is_stmt 1 view .LVU1184
 4089 006a FFF7FEFF 		bl	mpu_reset_fifo
 4090              	.LVL264:
1772:Src/mpu6050.c ****         }
 4091              		.loc 1 1772 13 view .LVU1185
1772:Src/mpu6050.c ****         }
 4092              		.loc 1 1772 20 is_stmt 0 view .LVU1186
 4093 006e 6FF00100 		mvn	r0, #1
 4094 0072 D0E7     		b	.L344
 4095              	.L349:
1776:Src/mpu6050.c ****         return -1;
 4096              		.loc 1 1776 5 is_stmt 1 view .LVU1187
1776:Src/mpu6050.c ****         return -1;
 4097              		.loc 1 1776 9 is_stmt 0 view .LVU1188
 4098 0074 D7E90010 		ldrd	r1, r0, [r7]
 4099 0078 4346     		mov	r3, r8
 4100 007a 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 4101 007c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4102 007e F2B2     		uxtb	r2, r6
 4103 0080 FFF7FEFF 		bl	i2c_readBytes
 4104              	.LVL265:
1776:Src/mpu6050.c ****         return -1;
 4105              		.loc 1 1776 8 view .LVU1189
 4106 0084 0028     		cmp	r0, #0
 4107 0086 C4D1     		bne	.L356
1778:Src/mpu6050.c ****     return 0;
 4108              		.loc 1 1778 5 is_stmt 1 view .LVU1190
1778:Src/mpu6050.c ****     return 0;
 4109              		.loc 1 1778 35 is_stmt 0 view .LVU1191
 4110 0088 B4FBF6F4 		udiv	r4, r4, r6
 4111              	.LVL266:
1778:Src/mpu6050.c ****     return 0;
 4112              		.loc 1 1778 35 view .LVU1192
 4113 008c 013C     		subs	r4, r4, #1
1778:Src/mpu6050.c ****     return 0;
 4114              		.loc 1 1778 13 view .LVU1193
 4115 008e 2C70     		strb	r4, [r5]
1779:Src/mpu6050.c **** }
 4116              		.loc 1 1779 5 is_stmt 1 view .LVU1194
ARM GAS  /tmp/cc39PcX6.s 			page 158


1779:Src/mpu6050.c **** }
 4117              		.loc 1 1779 12 is_stmt 0 view .LVU1195
 4118 0090 C1E7     		b	.L344
 4119              	.L358:
 4120 0092 00BF     		.align	2
 4121              	.L357:
 4122 0094 00000000 		.word	.LANCHOR0
 4123              		.cfi_endproc
 4124              	.LFE92:
 4126              		.section	.text.mpu_set_bypass,"ax",%progbits
 4127              		.align	1
 4128              		.global	mpu_set_bypass
 4129              		.syntax unified
 4130              		.thumb
 4131              		.thumb_func
 4132              		.fpu softvfp
 4134              	mpu_set_bypass:
 4135              	.LVL267:
 4136              	.LFB93:
1788:Src/mpu6050.c ****     unsigned char tmp;
 4137              		.loc 1 1788 1 is_stmt 1 view -0
 4138              		.cfi_startproc
 4139              		@ args = 0, pretend = 0, frame = 8
 4140              		@ frame_needed = 0, uses_anonymous_args = 0
1789:Src/mpu6050.c **** 
 4141              		.loc 1 1789 5 view .LVU1197
1791:Src/mpu6050.c ****         return 0;
 4142              		.loc 1 1791 5 view .LVU1198
1788:Src/mpu6050.c ****     unsigned char tmp;
 4143              		.loc 1 1788 1 is_stmt 0 view .LVU1199
 4144 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4145              	.LCFI62:
 4146              		.cfi_def_cfa_offset 24
 4147              		.cfi_offset 4, -12
 4148              		.cfi_offset 5, -8
 4149              		.cfi_offset 14, -4
1791:Src/mpu6050.c ****         return 0;
 4150              		.loc 1 1791 20 view .LVU1200
 4151 0002 384C     		ldr	r4, .L383
1788:Src/mpu6050.c ****     unsigned char tmp;
 4152              		.loc 1 1788 1 view .LVU1201
 4153 0004 0546     		mov	r5, r0
1791:Src/mpu6050.c ****         return 0;
 4154              		.loc 1 1791 8 view .LVU1202
 4155 0006 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 4156 0008 8342     		cmp	r3, r0
 4157 000a 69D0     		beq	.L371
1794:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4158              		.loc 1 1794 5 is_stmt 1 view .LVU1203
1795:Src/mpu6050.c ****             return -1;
 4159              		.loc 1 1795 13 is_stmt 0 view .LVU1204
 4160 000c 6368     		ldr	r3, [r4, #4]
 4161 000e 0122     		movs	r2, #1
 4162 0010 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 4163              	.LVL268:
1795:Src/mpu6050.c ****             return -1;
 4164              		.loc 1 1795 13 view .LVU1205
ARM GAS  /tmp/cc39PcX6.s 			page 159


 4165 0012 2368     		ldr	r3, [r4]
 4166 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 4167 0016 0DF10703 		add	r3, sp, #7
1794:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4168              		.loc 1 1794 8 view .LVU1206
 4169 001a 6DB3     		cbz	r5, .L361
1795:Src/mpu6050.c ****             return -1;
 4170              		.loc 1 1795 9 is_stmt 1 view .LVU1207
1795:Src/mpu6050.c ****             return -1;
 4171              		.loc 1 1795 13 is_stmt 0 view .LVU1208
 4172 001c FFF7FEFF 		bl	i2c_readBytes
 4173              	.LVL269:
1795:Src/mpu6050.c ****             return -1;
 4174              		.loc 1 1795 12 view .LVU1209
 4175 0020 18B1     		cbz	r0, .L362
 4176              	.L363:
1796:Src/mpu6050.c ****         tmp &= ~BIT_AUX_IF_EN;
 4177              		.loc 1 1796 20 view .LVU1210
 4178 0022 4FF0FF30 		mov	r0, #-1
 4179              	.L359:
1830:Src/mpu6050.c **** 
 4180              		.loc 1 1830 1 view .LVU1211
 4181 0026 03B0     		add	sp, sp, #12
 4182              	.LCFI63:
 4183              		.cfi_remember_state
 4184              		.cfi_def_cfa_offset 12
 4185              		@ sp needed
 4186 0028 30BD     		pop	{r4, r5, pc}
 4187              	.L362:
 4188              	.LCFI64:
 4189              		.cfi_restore_state
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4190              		.loc 1 1797 9 is_stmt 1 view .LVU1212
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4191              		.loc 1 1797 13 is_stmt 0 view .LVU1213
 4192 002a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1798:Src/mpu6050.c ****             return -1;
 4193              		.loc 1 1798 13 view .LVU1214
 4194 002e D4E90010 		ldrd	r1, r0, [r4]
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4195              		.loc 1 1797 13 view .LVU1215
 4196 0032 23F02003 		bic	r3, r3, #32
 4197 0036 8DF80730 		strb	r3, [sp, #7]
1798:Src/mpu6050.c ****             return -1;
 4198              		.loc 1 1798 9 is_stmt 1 view .LVU1216
1798:Src/mpu6050.c ****             return -1;
 4199              		.loc 1 1798 13 is_stmt 0 view .LVU1217
 4200 003a 0122     		movs	r2, #1
 4201 003c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 4202 003e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4203 0040 0DF10703 		add	r3, sp, #7
 4204 0044 FFF7FEFF 		bl	i2c_writeBytes
 4205              	.LVL270:
1798:Src/mpu6050.c ****             return -1;
 4206              		.loc 1 1798 12 view .LVU1218
 4207 0048 0028     		cmp	r0, #0
 4208 004a EAD1     		bne	.L363
ARM GAS  /tmp/cc39PcX6.s 			page 160


1800:Src/mpu6050.c ****         tmp = BIT_BYPASS_EN;
 4209              		.loc 1 1800 9 is_stmt 1 view .LVU1219
 4210 004c 0320     		movs	r0, #3
 4211 004e FFF7FEFF 		bl	delay_1ms
 4212              	.LVL271:
1801:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4213              		.loc 1 1801 9 view .LVU1220
1801:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4214              		.loc 1 1801 13 is_stmt 0 view .LVU1221
 4215 0052 0223     		movs	r3, #2
 4216 0054 8DF80730 		strb	r3, [sp, #7]
1802:Src/mpu6050.c ****             tmp |= BIT_ACTL;
 4217              		.loc 1 1802 9 is_stmt 1 view .LVU1222
1802:Src/mpu6050.c ****             tmp |= BIT_ACTL;
 4218              		.loc 1 1802 12 is_stmt 0 view .LVU1223
 4219 0058 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 4220 005c 13B1     		cbz	r3, .L364
1803:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
 4221              		.loc 1 1803 13 is_stmt 1 view .LVU1224
1803:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
 4222              		.loc 1 1803 17 is_stmt 0 view .LVU1225
 4223 005e 8223     		movs	r3, #130
 4224 0060 8DF80730 		strb	r3, [sp, #7]
 4225              	.L364:
1804:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4226              		.loc 1 1804 9 is_stmt 1 view .LVU1226
1804:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4227              		.loc 1 1804 12 is_stmt 0 view .LVU1227
 4228 0064 94F82330 		ldrb	r3, [r4, #35]	@ zero_extendqisi2
 4229 0068 73B3     		cbz	r3, .L369
1805:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4230              		.loc 1 1805 13 is_stmt 1 view .LVU1228
1805:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4231              		.loc 1 1805 17 is_stmt 0 view .LVU1229
 4232 006a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4233              	.L382:
1824:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4234              		.loc 1 1824 13 is_stmt 1 view .LVU1230
1824:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4235              		.loc 1 1824 17 is_stmt 0 view .LVU1231
 4236 006e 43F03003 		orr	r3, r3, #48
 4237 0072 8DF80730 		strb	r3, [sp, #7]
 4238 0076 27E0     		b	.L369
 4239              	.L361:
1810:Src/mpu6050.c ****             return -1;
 4240              		.loc 1 1810 9 is_stmt 1 view .LVU1232
1810:Src/mpu6050.c ****             return -1;
 4241              		.loc 1 1810 13 is_stmt 0 view .LVU1233
 4242 0078 FFF7FEFF 		bl	i2c_readBytes
 4243              	.LVL272:
1810:Src/mpu6050.c ****             return -1;
 4244              		.loc 1 1810 12 view .LVU1234
 4245 007c 0028     		cmp	r0, #0
 4246 007e D0D1     		bne	.L363
1812:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4247              		.loc 1 1812 9 is_stmt 1 view .LVU1235
1816:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 161


 4248              		.loc 1 1816 13 is_stmt 0 view .LVU1236
 4249 0080 D4E90010 		ldrd	r1, r0, [r4]
1812:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4250              		.loc 1 1812 12 view .LVU1237
 4251 0084 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
1797:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4252              		.loc 1 1797 13 view .LVU1238
 4253 0086 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1812:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4254              		.loc 1 1812 12 view .LVU1239
 4255 008a D207     		lsls	r2, r2, #31
1813:Src/mpu6050.c ****         else
 4256              		.loc 1 1813 13 is_stmt 1 view .LVU1240
1813:Src/mpu6050.c ****         else
 4257              		.loc 1 1813 17 is_stmt 0 view .LVU1241
 4258 008c 4CBF     		ite	mi
 4259 008e 43F02003 		orrmi	r3, r3, #32
1815:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4260              		.loc 1 1815 13 is_stmt 1 view .LVU1242
1815:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4261              		.loc 1 1815 17 is_stmt 0 view .LVU1243
 4262 0092 03F0DF03 		andpl	r3, r3, #223
 4263 0096 8DF80730 		strb	r3, [sp, #7]
1816:Src/mpu6050.c ****             return -1;
 4264              		.loc 1 1816 9 is_stmt 1 view .LVU1244
1816:Src/mpu6050.c ****             return -1;
 4265              		.loc 1 1816 13 is_stmt 0 view .LVU1245
 4266 009a 0122     		movs	r2, #1
 4267 009c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 4268 009e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4269 00a0 0DF10703 		add	r3, sp, #7
 4270 00a4 FFF7FEFF 		bl	i2c_writeBytes
 4271              	.LVL273:
1816:Src/mpu6050.c ****             return -1;
 4272              		.loc 1 1816 12 view .LVU1246
 4273 00a8 0028     		cmp	r0, #0
 4274 00aa BAD1     		bne	.L363
1818:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4275              		.loc 1 1818 9 is_stmt 1 view .LVU1247
 4276 00ac 0320     		movs	r0, #3
 4277 00ae FFF7FEFF 		bl	delay_1ms
 4278              	.LVL274:
1819:Src/mpu6050.c ****             tmp = BIT_ACTL;
 4279              		.loc 1 1819 9 view .LVU1248
1819:Src/mpu6050.c ****             tmp = BIT_ACTL;
 4280              		.loc 1 1819 24 is_stmt 0 view .LVU1249
 4281 00b2 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
1823:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4282              		.loc 1 1823 12 view .LVU1250
 4283 00b6 94F82320 		ldrb	r2, [r4, #35]	@ zero_extendqisi2
1820:Src/mpu6050.c ****         else
 4284              		.loc 1 1820 17 view .LVU1251
 4285 00ba 002B     		cmp	r3, #0
 4286 00bc 18BF     		it	ne
 4287 00be 8023     		movne	r3, #128
 4288 00c0 8DF80730 		strb	r3, [sp, #7]
1823:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
ARM GAS  /tmp/cc39PcX6.s 			page 162


 4289              		.loc 1 1823 9 is_stmt 1 view .LVU1252
1823:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4290              		.loc 1 1823 12 is_stmt 0 view .LVU1253
 4291 00c4 002A     		cmp	r2, #0
 4292 00c6 D2D1     		bne	.L382
 4293              	.L369:
1825:Src/mpu6050.c ****             return -1;
 4294              		.loc 1 1825 9 is_stmt 1 view .LVU1254
1825:Src/mpu6050.c ****             return -1;
 4295              		.loc 1 1825 13 is_stmt 0 view .LVU1255
 4296 00c8 D4E90010 		ldrd	r1, r0, [r4]
 4297 00cc 0122     		movs	r2, #1
 4298 00ce C97D     		ldrb	r1, [r1, #23]	@ zero_extendqisi2
 4299 00d0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4300 00d2 0DF10703 		add	r3, sp, #7
 4301 00d6 FFF7FEFF 		bl	i2c_writeBytes
 4302              	.LVL275:
1825:Src/mpu6050.c ****             return -1;
 4303              		.loc 1 1825 12 view .LVU1256
 4304 00da 0028     		cmp	r0, #0
 4305 00dc A1D1     		bne	.L363
1828:Src/mpu6050.c ****     return 0;
 4306              		.loc 1 1828 5 is_stmt 1 view .LVU1257
1828:Src/mpu6050.c ****     return 0;
 4307              		.loc 1 1828 29 is_stmt 0 view .LVU1258
 4308 00de A574     		strb	r5, [r4, #18]
1829:Src/mpu6050.c **** }
 4309              		.loc 1 1829 5 is_stmt 1 view .LVU1259
 4310              	.L371:
1792:Src/mpu6050.c **** 
 4311              		.loc 1 1792 16 is_stmt 0 view .LVU1260
 4312 00e0 0020     		movs	r0, #0
 4313 00e2 A0E7     		b	.L359
 4314              	.L384:
 4315              		.align	2
 4316              	.L383:
 4317 00e4 00000000 		.word	.LANCHOR0
 4318              		.cfi_endproc
 4319              	.LFE93:
 4321              		.section	.text.mpu_set_int_level,"ax",%progbits
 4322              		.align	1
 4323              		.global	mpu_set_int_level
 4324              		.syntax unified
 4325              		.thumb
 4326              		.thumb_func
 4327              		.fpu softvfp
 4329              	mpu_set_int_level:
 4330              	.LVL276:
 4331              	.LFB94:
1838:Src/mpu6050.c ****     st.chip_cfg.active_low_int = active_low;
 4332              		.loc 1 1838 1 is_stmt 1 view -0
 4333              		.cfi_startproc
 4334              		@ args = 0, pretend = 0, frame = 0
 4335              		@ frame_needed = 0, uses_anonymous_args = 0
 4336              		@ link register save eliminated.
1839:Src/mpu6050.c ****     return 0;
 4337              		.loc 1 1839 5 view .LVU1262
ARM GAS  /tmp/cc39PcX6.s 			page 163


1839:Src/mpu6050.c ****     return 0;
 4338              		.loc 1 1839 32 is_stmt 0 view .LVU1263
 4339 0000 024B     		ldr	r3, .L386
 4340 0002 83F82200 		strb	r0, [r3, #34]
1840:Src/mpu6050.c **** }
 4341              		.loc 1 1840 5 is_stmt 1 view .LVU1264
1841:Src/mpu6050.c **** 
 4342              		.loc 1 1841 1 is_stmt 0 view .LVU1265
 4343 0006 0020     		movs	r0, #0
 4344              	.LVL277:
1841:Src/mpu6050.c **** 
 4345              		.loc 1 1841 1 view .LVU1266
 4346 0008 7047     		bx	lr
 4347              	.L387:
 4348 000a 00BF     		.align	2
 4349              	.L386:
 4350 000c 00000000 		.word	.LANCHOR0
 4351              		.cfi_endproc
 4352              	.LFE94:
 4354              		.section	.text.mpu_set_int_latched,"ax",%progbits
 4355              		.align	1
 4356              		.global	mpu_set_int_latched
 4357              		.syntax unified
 4358              		.thumb
 4359              		.thumb_func
 4360              		.fpu softvfp
 4362              	mpu_set_int_latched:
 4363              	.LVL278:
 4364              	.LFB95:
1850:Src/mpu6050.c ****     unsigned char tmp;
 4365              		.loc 1 1850 1 is_stmt 1 view -0
 4366              		.cfi_startproc
 4367              		@ args = 0, pretend = 0, frame = 8
 4368              		@ frame_needed = 0, uses_anonymous_args = 0
1851:Src/mpu6050.c ****     if (st.chip_cfg.latched_int == enable)
 4369              		.loc 1 1851 5 view .LVU1268
1852:Src/mpu6050.c ****         return 0;
 4370              		.loc 1 1852 5 view .LVU1269
1850:Src/mpu6050.c ****     unsigned char tmp;
 4371              		.loc 1 1850 1 is_stmt 0 view .LVU1270
 4372 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4373              	.LCFI65:
 4374              		.cfi_def_cfa_offset 24
 4375              		.cfi_offset 4, -12
 4376              		.cfi_offset 5, -8
 4377              		.cfi_offset 14, -4
1852:Src/mpu6050.c ****         return 0;
 4378              		.loc 1 1852 20 view .LVU1271
 4379 0002 174C     		ldr	r4, .L402
1850:Src/mpu6050.c ****     unsigned char tmp;
 4380              		.loc 1 1850 1 view .LVU1272
 4381 0004 0546     		mov	r5, r0
1852:Src/mpu6050.c ****         return 0;
 4382              		.loc 1 1852 8 view .LVU1273
 4383 0006 94F82330 		ldrb	r3, [r4, #35]	@ zero_extendqisi2
 4384 000a 8342     		cmp	r3, r0
 4385 000c 22D0     		beq	.L393
ARM GAS  /tmp/cc39PcX6.s 			page 164


1855:Src/mpu6050.c ****         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4386              		.loc 1 1855 5 is_stmt 1 view .LVU1274
1856:Src/mpu6050.c ****     else
 4387              		.loc 1 1856 13 is_stmt 0 view .LVU1275
 4388 000e 0028     		cmp	r0, #0
 4389 0010 0CBF     		ite	eq
 4390 0012 0023     		moveq	r3, #0
 4391 0014 3023     		movne	r3, #48
1859:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4392              		.loc 1 1859 8 view .LVU1276
 4393 0016 A27C     		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 4394 0018 8DF80730 		strb	r3, [sp, #7]
1859:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4395              		.loc 1 1859 5 is_stmt 1 view .LVU1277
1859:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4396              		.loc 1 1859 8 is_stmt 0 view .LVU1278
 4397 001c 1AB1     		cbz	r2, .L391
1860:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
 4398              		.loc 1 1860 9 is_stmt 1 view .LVU1279
1860:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
 4399              		.loc 1 1860 13 is_stmt 0 view .LVU1280
 4400 001e 43F00203 		orr	r3, r3, #2
 4401 0022 8DF80730 		strb	r3, [sp, #7]
 4402              	.L391:
1861:Src/mpu6050.c ****         tmp |= BIT_ACTL;
 4403              		.loc 1 1861 5 is_stmt 1 view .LVU1281
1861:Src/mpu6050.c ****         tmp |= BIT_ACTL;
 4404              		.loc 1 1861 8 is_stmt 0 view .LVU1282
 4405 0026 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 4406 002a 2BB1     		cbz	r3, .L392
1862:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4407              		.loc 1 1862 9 is_stmt 1 view .LVU1283
1862:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4408              		.loc 1 1862 13 is_stmt 0 view .LVU1284
 4409 002c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4410 0030 63F07F03 		orn	r3, r3, #127
 4411 0034 8DF80730 		strb	r3, [sp, #7]
 4412              	.L392:
1863:Src/mpu6050.c ****         return -1;
 4413              		.loc 1 1863 5 is_stmt 1 view .LVU1285
1863:Src/mpu6050.c ****         return -1;
 4414              		.loc 1 1863 9 is_stmt 0 view .LVU1286
 4415 0038 D4E90010 		ldrd	r1, r0, [r4]
 4416              	.LVL279:
1863:Src/mpu6050.c ****         return -1;
 4417              		.loc 1 1863 9 view .LVU1287
 4418 003c 0122     		movs	r2, #1
 4419 003e C97D     		ldrb	r1, [r1, #23]	@ zero_extendqisi2
 4420 0040 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4421 0042 0DF10703 		add	r3, sp, #7
 4422 0046 FFF7FEFF 		bl	i2c_writeBytes
 4423              	.LVL280:
1863:Src/mpu6050.c ****         return -1;
 4424              		.loc 1 1863 8 view .LVU1288
 4425 004a 28B9     		cbnz	r0, .L395
1865:Src/mpu6050.c ****     return 0;
 4426              		.loc 1 1865 5 is_stmt 1 view .LVU1289
ARM GAS  /tmp/cc39PcX6.s 			page 165


1865:Src/mpu6050.c ****     return 0;
 4427              		.loc 1 1865 29 is_stmt 0 view .LVU1290
 4428 004c 84F82350 		strb	r5, [r4, #35]
1866:Src/mpu6050.c **** }
 4429              		.loc 1 1866 5 is_stmt 1 view .LVU1291
 4430              	.L388:
1867:Src/mpu6050.c **** 
 4431              		.loc 1 1867 1 is_stmt 0 view .LVU1292
 4432 0050 03B0     		add	sp, sp, #12
 4433              	.LCFI66:
 4434              		.cfi_remember_state
 4435              		.cfi_def_cfa_offset 12
 4436              		@ sp needed
 4437 0052 30BD     		pop	{r4, r5, pc}
 4438              	.LVL281:
 4439              	.L393:
 4440              	.LCFI67:
 4441              		.cfi_restore_state
1853:Src/mpu6050.c **** 
 4442              		.loc 1 1853 16 view .LVU1293
 4443 0054 0020     		movs	r0, #0
 4444              	.LVL282:
1853:Src/mpu6050.c **** 
 4445              		.loc 1 1853 16 view .LVU1294
 4446 0056 FBE7     		b	.L388
 4447              	.L395:
1864:Src/mpu6050.c ****     st.chip_cfg.latched_int = enable;
 4448              		.loc 1 1864 16 view .LVU1295
 4449 0058 4FF0FF30 		mov	r0, #-1
 4450 005c F8E7     		b	.L388
 4451              	.L403:
 4452 005e 00BF     		.align	2
 4453              	.L402:
 4454 0060 00000000 		.word	.LANCHOR0
 4455              		.cfi_endproc
 4456              	.LFE95:
 4458              		.section	.text.mpu_lp_accel_mode,"ax",%progbits
 4459              		.align	1
 4460              		.global	mpu_lp_accel_mode
 4461              		.syntax unified
 4462              		.thumb
 4463              		.thumb_func
 4464              		.fpu softvfp
 4466              	mpu_lp_accel_mode:
 4467              	.LVL283:
 4468              	.LFB63:
 745:Src/mpu6050.c ****     unsigned char tmp[2];
 4469              		.loc 1 745 1 is_stmt 1 view -0
 4470              		.cfi_startproc
 4471              		@ args = 0, pretend = 0, frame = 8
 4472              		@ frame_needed = 0, uses_anonymous_args = 0
 746:Src/mpu6050.c **** 
 4473              		.loc 1 746 5 view .LVU1297
 748:Src/mpu6050.c ****         return -1;
 4474              		.loc 1 748 5 view .LVU1298
 748:Src/mpu6050.c ****         return -1;
 4475              		.loc 1 748 8 is_stmt 0 view .LVU1299
ARM GAS  /tmp/cc39PcX6.s 			page 166


 4476 0000 2828     		cmp	r0, #40
 745:Src/mpu6050.c ****     unsigned char tmp[2];
 4477              		.loc 1 745 1 view .LVU1300
 4478 0002 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4479              	.LCFI68:
 4480              		.cfi_def_cfa_offset 24
 4481              		.cfi_offset 4, -12
 4482              		.cfi_offset 5, -8
 4483              		.cfi_offset 14, -4
 745:Src/mpu6050.c ****     unsigned char tmp[2];
 4484              		.loc 1 745 1 view .LVU1301
 4485 0004 0446     		mov	r4, r0
 748:Src/mpu6050.c ****         return -1;
 4486              		.loc 1 748 8 view .LVU1302
 4487 0006 03D9     		bls	.L405
 4488              	.LVL284:
 4489              	.L408:
 749:Src/mpu6050.c **** 
 4490              		.loc 1 749 16 view .LVU1303
 4491 0008 4FF0FF30 		mov	r0, #-1
 4492              	.L404:
 820:Src/mpu6050.c **** 
 4493              		.loc 1 820 1 view .LVU1304
 4494 000c 03B0     		add	sp, sp, #12
 4495              	.LCFI69:
 4496              		.cfi_remember_state
 4497              		.cfi_def_cfa_offset 12
 4498              		@ sp needed
 4499 000e 30BD     		pop	{r4, r5, pc}
 4500              	.LVL285:
 4501              	.L405:
 4502              	.LCFI70:
 4503              		.cfi_restore_state
 751:Src/mpu6050.c ****         mpu_set_int_latched(0);
 4504              		.loc 1 751 5 is_stmt 1 view .LVU1305
 4505 0010 264D     		ldr	r5, .L415
 751:Src/mpu6050.c ****         mpu_set_int_latched(0);
 4506              		.loc 1 751 8 is_stmt 0 view .LVU1306
 4507 0012 90B9     		cbnz	r0, .L407
 752:Src/mpu6050.c ****         tmp[0] = 0;
 4508              		.loc 1 752 9 is_stmt 1 view .LVU1307
 4509 0014 FFF7FEFF 		bl	mpu_set_int_latched
 4510              	.LVL286:
 753:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 4511              		.loc 1 753 9 view .LVU1308
 755:Src/mpu6050.c ****             return -1;
 4512              		.loc 1 755 13 is_stmt 0 view .LVU1309
 4513 0018 D5E90010 		ldrd	r1, r0, [r5]
 754:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4514              		.loc 1 754 16 view .LVU1310
 4515 001c 0723     		movs	r3, #7
 753:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 4516              		.loc 1 753 16 view .LVU1311
 4517 001e 8DF80440 		strb	r4, [sp, #4]
 754:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4518              		.loc 1 754 9 is_stmt 1 view .LVU1312
 754:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
ARM GAS  /tmp/cc39PcX6.s 			page 167


 4519              		.loc 1 754 16 is_stmt 0 view .LVU1313
 4520 0022 8DF80530 		strb	r3, [sp, #5]
 755:Src/mpu6050.c ****             return -1;
 4521              		.loc 1 755 9 is_stmt 1 view .LVU1314
 755:Src/mpu6050.c ****             return -1;
 4522              		.loc 1 755 13 is_stmt 0 view .LVU1315
 4523 0026 0222     		movs	r2, #2
 4524 0028 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4525 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4526 002c 01AB     		add	r3, sp, #4
 4527 002e FFF7FEFF 		bl	i2c_writeBytes
 4528              	.LVL287:
 755:Src/mpu6050.c ****             return -1;
 4529              		.loc 1 755 12 view .LVU1316
 4530 0032 0028     		cmp	r0, #0
 4531 0034 E8D1     		bne	.L408
 757:Src/mpu6050.c ****         return 0;
 4532              		.loc 1 757 9 is_stmt 1 view .LVU1317
 757:Src/mpu6050.c ****         return 0;
 4533              		.loc 1 757 35 is_stmt 0 view .LVU1318
 4534 0036 2875     		strb	r0, [r5, #20]
 758:Src/mpu6050.c ****     }
 4535              		.loc 1 758 9 is_stmt 1 view .LVU1319
 758:Src/mpu6050.c ****     }
 4536              		.loc 1 758 16 is_stmt 0 view .LVU1320
 4537 0038 E8E7     		b	.L404
 4538              	.LVL288:
 4539              	.L407:
 767:Src/mpu6050.c **** #if defined MPU6050
 4540              		.loc 1 767 5 is_stmt 1 view .LVU1321
 4541 003a 0120     		movs	r0, #1
 4542              	.LVL289:
 767:Src/mpu6050.c **** #if defined MPU6050
 4543              		.loc 1 767 5 is_stmt 0 view .LVU1322
 4544 003c FFF7FEFF 		bl	mpu_set_int_latched
 4545              	.LVL290:
 769:Src/mpu6050.c ****     if (rate == 1) {
 4546              		.loc 1 769 5 is_stmt 1 view .LVU1323
 769:Src/mpu6050.c ****     if (rate == 1) {
 4547              		.loc 1 769 12 is_stmt 0 view .LVU1324
 4548 0040 2023     		movs	r3, #32
 770:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4549              		.loc 1 770 8 view .LVU1325
 4550 0042 012C     		cmp	r4, #1
 769:Src/mpu6050.c ****     if (rate == 1) {
 4551              		.loc 1 769 12 view .LVU1326
 4552 0044 8DF80430 		strb	r3, [sp, #4]
 770:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4553              		.loc 1 770 5 is_stmt 1 view .LVU1327
 770:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4554              		.loc 1 770 8 is_stmt 0 view .LVU1328
 4555 0048 20D1     		bne	.L409
 771:Src/mpu6050.c ****         mpu_set_lpf(5);
 4556              		.loc 1 771 9 is_stmt 1 view .LVU1329
 771:Src/mpu6050.c ****         mpu_set_lpf(5);
 4557              		.loc 1 771 16 is_stmt 0 view .LVU1330
 4558 004a 0023     		movs	r3, #0
ARM GAS  /tmp/cc39PcX6.s 			page 168


 4559              	.L414:
 775:Src/mpu6050.c ****     } else if (rate <= 20) {
 4560              		.loc 1 775 9 view .LVU1331
 4561 004c 0520     		movs	r0, #5
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 4562              		.loc 1 774 16 view .LVU1332
 4563 004e 8DF80530 		strb	r3, [sp, #5]
 775:Src/mpu6050.c ****     } else if (rate <= 20) {
 4564              		.loc 1 775 9 is_stmt 1 view .LVU1333
 4565              	.L413:
 781:Src/mpu6050.c ****     }
 4566              		.loc 1 781 9 is_stmt 0 view .LVU1334
 4567 0052 FFF7FEFF 		bl	mpu_set_lpf
 4568              	.LVL291:
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4569              		.loc 1 783 5 is_stmt 1 view .LVU1335
 784:Src/mpu6050.c ****         return -1;
 4570              		.loc 1 784 9 is_stmt 0 view .LVU1336
 4571 0056 D5E90010 		ldrd	r1, r0, [r5]
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4572              		.loc 1 783 18 view .LVU1337
 4573 005a 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 784:Src/mpu6050.c ****         return -1;
 4574              		.loc 1 784 9 view .LVU1338
 4575 005e 0222     		movs	r2, #2
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4576              		.loc 1 783 22 view .LVU1339
 4577 0060 9B01     		lsls	r3, r3, #6
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4578              		.loc 1 783 28 view .LVU1340
 4579 0062 43F00703 		orr	r3, r3, #7
 783:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4580              		.loc 1 783 12 view .LVU1341
 4581 0066 8DF80530 		strb	r3, [sp, #5]
 784:Src/mpu6050.c ****         return -1;
 4582              		.loc 1 784 5 is_stmt 1 view .LVU1342
 784:Src/mpu6050.c ****         return -1;
 4583              		.loc 1 784 9 is_stmt 0 view .LVU1343
 4584 006a 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4585 006c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4586 006e 01AB     		add	r3, sp, #4
 4587 0070 FFF7FEFF 		bl	i2c_writeBytes
 4588              	.LVL292:
 784:Src/mpu6050.c ****         return -1;
 4589              		.loc 1 784 8 view .LVU1344
 4590 0074 0446     		mov	r4, r0
 4591 0076 0028     		cmp	r0, #0
 4592 0078 C6D1     		bne	.L408
 814:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 4593              		.loc 1 814 5 is_stmt 1 view .LVU1345
 814:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 4594              		.loc 1 814 25 is_stmt 0 view .LVU1346
 4595 007a 0823     		movs	r3, #8
 4596 007c AB72     		strb	r3, [r5, #10]
 815:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 4597              		.loc 1 815 5 is_stmt 1 view .LVU1347
 816:Src/mpu6050.c ****     mpu_configure_fifo(0);
ARM GAS  /tmp/cc39PcX6.s 			page 169


 4598              		.loc 1 816 31 is_stmt 0 view .LVU1348
 4599 007e 0123     		movs	r3, #1
 815:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 4600              		.loc 1 815 25 view .LVU1349
 4601 0080 2873     		strb	r0, [r5, #12]
 816:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4602              		.loc 1 816 5 is_stmt 1 view .LVU1350
 816:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4603              		.loc 1 816 31 is_stmt 0 view .LVU1351
 4604 0082 2B75     		strb	r3, [r5, #20]
 817:Src/mpu6050.c **** 
 4605              		.loc 1 817 5 is_stmt 1 view .LVU1352
 4606 0084 FFF7FEFF 		bl	mpu_configure_fifo
 4607              	.LVL293:
 819:Src/mpu6050.c **** }
 4608              		.loc 1 819 5 view .LVU1353
 819:Src/mpu6050.c **** }
 4609              		.loc 1 819 12 is_stmt 0 view .LVU1354
 4610 0088 2046     		mov	r0, r4
 4611 008a BFE7     		b	.L404
 4612              	.L409:
 773:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 4613              		.loc 1 773 12 is_stmt 1 view .LVU1355
 773:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 4614              		.loc 1 773 15 is_stmt 0 view .LVU1356
 4615 008c 052C     		cmp	r4, #5
 4616 008e 01D8     		bhi	.L411
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 4617              		.loc 1 774 9 is_stmt 1 view .LVU1357
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 4618              		.loc 1 774 16 is_stmt 0 view .LVU1358
 4619 0090 0123     		movs	r3, #1
 4620 0092 DBE7     		b	.L414
 4621              	.L411:
 776:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 4622              		.loc 1 776 12 is_stmt 1 view .LVU1359
 776:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 4623              		.loc 1 776 15 is_stmt 0 view .LVU1360
 4624 0094 142C     		cmp	r4, #20
 777:Src/mpu6050.c ****         mpu_set_lpf(10);
 4625              		.loc 1 777 9 is_stmt 1 view .LVU1361
 777:Src/mpu6050.c ****         mpu_set_lpf(10);
 4626              		.loc 1 777 16 is_stmt 0 view .LVU1362
 4627 0096 95BF     		itete	ls
 4628 0098 0223     		movls	r3, #2
 780:Src/mpu6050.c ****         mpu_set_lpf(20);
 4629              		.loc 1 780 16 view .LVU1363
 4630 009a 0323     		movhi	r3, #3
 778:Src/mpu6050.c ****     } else {
 4631              		.loc 1 778 9 view .LVU1364
 4632 009c 0A20     		movls	r0, #10
 781:Src/mpu6050.c ****     }
 4633              		.loc 1 781 9 view .LVU1365
 4634 009e 1420     		movhi	r0, #20
 777:Src/mpu6050.c ****         mpu_set_lpf(10);
 4635              		.loc 1 777 16 view .LVU1366
 4636 00a0 94BF     		ite	ls
ARM GAS  /tmp/cc39PcX6.s 			page 170


 4637 00a2 8DF80530 		strbls	r3, [sp, #5]
 778:Src/mpu6050.c ****     } else {
 4638              		.loc 1 778 9 is_stmt 1 view .LVU1367
 780:Src/mpu6050.c ****         mpu_set_lpf(20);
 4639              		.loc 1 780 9 view .LVU1368
 780:Src/mpu6050.c ****         mpu_set_lpf(20);
 4640              		.loc 1 780 16 is_stmt 0 view .LVU1369
 4641 00a6 8DF80530 		strbhi	r3, [sp, #5]
 781:Src/mpu6050.c ****     }
 4642              		.loc 1 781 9 is_stmt 1 view .LVU1370
 4643 00aa D2E7     		b	.L413
 4644              	.L416:
 4645              		.align	2
 4646              	.L415:
 4647 00ac 00000000 		.word	.LANCHOR0
 4648              		.cfi_endproc
 4649              	.LFE63:
 4651              		.section	.text.mpu_set_sample_rate,"ax",%progbits
 4652              		.align	1
 4653              		.global	mpu_set_sample_rate
 4654              		.syntax unified
 4655              		.thumb
 4656              		.thumb_func
 4657              		.fpu softvfp
 4659              	mpu_set_sample_rate:
 4660              	.LVL294:
 4661              	.LFB81:
1336:Src/mpu6050.c ****     unsigned char data;
 4662              		.loc 1 1336 1 view -0
 4663              		.cfi_startproc
 4664              		@ args = 0, pretend = 0, frame = 8
 4665              		@ frame_needed = 0, uses_anonymous_args = 0
1337:Src/mpu6050.c **** 
 4666              		.loc 1 1337 5 view .LVU1372
1339:Src/mpu6050.c ****         return -1;
 4667              		.loc 1 1339 5 view .LVU1373
1336:Src/mpu6050.c ****     unsigned char data;
 4668              		.loc 1 1336 1 is_stmt 0 view .LVU1374
 4669 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 4670              	.LCFI71:
 4671              		.cfi_def_cfa_offset 32
 4672              		.cfi_offset 4, -20
 4673              		.cfi_offset 5, -16
 4674              		.cfi_offset 6, -12
 4675              		.cfi_offset 7, -8
 4676              		.cfi_offset 14, -4
1339:Src/mpu6050.c ****         return -1;
 4677              		.loc 1 1339 22 view .LVU1375
 4678 0002 1E4E     		ldr	r6, .L427
1336:Src/mpu6050.c ****     unsigned char data;
 4679              		.loc 1 1336 1 view .LVU1376
 4680 0004 0546     		mov	r5, r0
1339:Src/mpu6050.c ****         return -1;
 4681              		.loc 1 1339 8 view .LVU1377
 4682 0006 B37A     		ldrb	r3, [r6, #10]	@ zero_extendqisi2
 4683 0008 1BB9     		cbnz	r3, .L418
 4684              	.LVL295:
ARM GAS  /tmp/cc39PcX6.s 			page 171


 4685              	.L420:
1340:Src/mpu6050.c **** 
 4686              		.loc 1 1340 16 view .LVU1378
 4687 000a 4FF0FF30 		mov	r0, #-1
 4688              	.L417:
1375:Src/mpu6050.c **** 
 4689              		.loc 1 1375 1 view .LVU1379
 4690 000e 03B0     		add	sp, sp, #12
 4691              	.LCFI72:
 4692              		.cfi_remember_state
 4693              		.cfi_def_cfa_offset 20
 4694              		@ sp needed
 4695 0010 F0BD     		pop	{r4, r5, r6, r7, pc}
 4696              	.LVL296:
 4697              	.L418:
 4698              	.LCFI73:
 4699              		.cfi_restore_state
1342:Src/mpu6050.c ****         return -1;
 4700              		.loc 1 1342 5 is_stmt 1 view .LVU1380
1342:Src/mpu6050.c ****         return -1;
 4701              		.loc 1 1342 8 is_stmt 0 view .LVU1381
 4702 0012 96F82440 		ldrb	r4, [r6, #36]	@ zero_extendqisi2
 4703 0016 002C     		cmp	r4, #0
 4704 0018 F7D1     		bne	.L420
1345:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
 4705              		.loc 1 1345 9 is_stmt 1 view .LVU1382
1345:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
 4706              		.loc 1 1345 12 is_stmt 0 view .LVU1383
 4707 001a 337D     		ldrb	r3, [r6, #20]	@ zero_extendqisi2
 4708 001c 4BB1     		cbz	r3, .L421
1346:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
 4709              		.loc 1 1346 13 is_stmt 1 view .LVU1384
1346:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
 4710              		.loc 1 1346 16 is_stmt 0 view .LVU1385
 4711 001e 431E     		subs	r3, r0, #1
 4712 0020 272B     		cmp	r3, #39
 4713 0022 03D8     		bhi	.L422
1348:Src/mpu6050.c ****                 return 0;
 4714              		.loc 1 1348 17 is_stmt 1 view .LVU1386
 4715 0024 FFF7FEFF 		bl	mpu_lp_accel_mode
 4716              	.LVL297:
1349:Src/mpu6050.c ****             }
 4717              		.loc 1 1349 17 view .LVU1387
 4718              	.L426:
1373:Src/mpu6050.c ****     }
 4719              		.loc 1 1373 9 view .LVU1388
1373:Src/mpu6050.c ****     }
 4720              		.loc 1 1373 16 is_stmt 0 view .LVU1389
 4721 0028 2046     		mov	r0, r4
 4722 002a F0E7     		b	.L417
 4723              	.LVL298:
 4724              	.L422:
1354:Src/mpu6050.c ****         }
 4725              		.loc 1 1354 13 is_stmt 1 view .LVU1390
 4726 002c 2046     		mov	r0, r4
 4727              	.LVL299:
1354:Src/mpu6050.c ****         }
ARM GAS  /tmp/cc39PcX6.s 			page 172


 4728              		.loc 1 1354 13 is_stmt 0 view .LVU1391
 4729 002e FFF7FEFF 		bl	mpu_lp_accel_mode
 4730              	.LVL300:
 4731              	.L421:
1356:Src/mpu6050.c ****             rate = 4;
 4732              		.loc 1 1356 9 is_stmt 1 view .LVU1392
1362:Src/mpu6050.c ****             return -1;
 4733              		.loc 1 1362 13 is_stmt 0 view .LVU1393
 4734 0032 D6E90010 		ldrd	r1, r0, [r6]
 4735 0036 B5F57A7F 		cmp	r5, #1000
 4736 003a 28BF     		it	cs
 4737 003c 4FF47A75 		movcs	r5, #1000
 4738              	.LVL301:
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4739              		.loc 1 1361 9 is_stmt 1 view .LVU1394
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4740              		.loc 1 1361 21 is_stmt 0 view .LVU1395
 4741 0040 042D     		cmp	r5, #4
 4742 0042 38BF     		it	cc
 4743 0044 0425     		movcc	r5, #4
 4744              	.LVL302:
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4745              		.loc 1 1361 21 view .LVU1396
 4746 0046 4FF47A77 		mov	r7, #1000
 4747 004a B7FBF5F5 		udiv	r5, r7, r5
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4748              		.loc 1 1361 28 view .LVU1397
 4749 004e 013D     		subs	r5, r5, #1
1361:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4750              		.loc 1 1361 14 view .LVU1398
 4751 0050 8DF80750 		strb	r5, [sp, #7]
1362:Src/mpu6050.c ****             return -1;
 4752              		.loc 1 1362 9 is_stmt 1 view .LVU1399
1362:Src/mpu6050.c ****             return -1;
 4753              		.loc 1 1362 13 is_stmt 0 view .LVU1400
 4754 0054 0122     		movs	r2, #1
 4755 0056 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4756 0058 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4757 005a 0DF10703 		add	r3, sp, #7
 4758 005e FFF7FEFF 		bl	i2c_writeBytes
 4759              	.LVL303:
1362:Src/mpu6050.c ****             return -1;
 4760              		.loc 1 1362 12 view .LVU1401
 4761 0062 0446     		mov	r4, r0
 4762 0064 0028     		cmp	r0, #0
 4763 0066 D0D1     		bne	.L420
1365:Src/mpu6050.c **** 
 4764              		.loc 1 1365 9 is_stmt 1 view .LVU1402
1365:Src/mpu6050.c **** 
 4765              		.loc 1 1365 45 is_stmt 0 view .LVU1403
 4766 0068 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 4767 006c 0130     		adds	r0, r0, #1
1365:Src/mpu6050.c **** 
 4768              		.loc 1 1365 33 view .LVU1404
 4769 006e B7FBF0F0 		udiv	r0, r7, r0
 4770 0072 F081     		strh	r0, [r6, #14]	@ movhi
1372:Src/mpu6050.c ****         return 0;
ARM GAS  /tmp/cc39PcX6.s 			page 173


 4771              		.loc 1 1372 9 is_stmt 1 view .LVU1405
 4772 0074 4008     		lsrs	r0, r0, #1
 4773 0076 FFF7FEFF 		bl	mpu_set_lpf
 4774              	.LVL304:
 4775 007a D5E7     		b	.L426
 4776              	.L428:
 4777              		.align	2
 4778              	.L427:
 4779 007c 00000000 		.word	.LANCHOR0
 4780              		.cfi_endproc
 4781              	.LFE81:
 4783              		.section	.text.mpu_set_sensors,"ax",%progbits
 4784              		.align	1
 4785              		.global	mpu_set_sensors
 4786              		.syntax unified
 4787              		.thumb
 4788              		.thumb_func
 4789              		.fpu softvfp
 4791              	mpu_set_sensors:
 4792              	.LVL305:
 4793              	.LFB89:
1561:Src/mpu6050.c ****     unsigned char data;
 4794              		.loc 1 1561 1 view -0
 4795              		.cfi_startproc
 4796              		@ args = 0, pretend = 0, frame = 8
 4797              		@ frame_needed = 0, uses_anonymous_args = 0
1562:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4798              		.loc 1 1562 5 view .LVU1407
1567:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4799              		.loc 1 1567 5 view .LVU1408
1567:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4800              		.loc 1 1567 8 is_stmt 0 view .LVU1409
 4801 0000 10F07003 		ands	r3, r0, #112
1561:Src/mpu6050.c ****     unsigned char data;
 4802              		.loc 1 1561 1 view .LVU1410
 4803 0004 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4804              	.LCFI74:
 4805              		.cfi_def_cfa_offset 24
 4806              		.cfi_offset 4, -12
 4807              		.cfi_offset 5, -8
 4808              		.cfi_offset 14, -4
1561:Src/mpu6050.c ****     unsigned char data;
 4809              		.loc 1 1561 1 view .LVU1411
 4810 0006 0446     		mov	r4, r0
1567:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4811              		.loc 1 1567 8 view .LVU1412
 4812 0008 13D0     		beq	.L430
1568:Src/mpu6050.c ****     else if (sensors)
 4813              		.loc 1 1568 9 is_stmt 1 view .LVU1413
1568:Src/mpu6050.c ****     else if (sensors)
 4814              		.loc 1 1568 14 is_stmt 0 view .LVU1414
 4815 000a 0123     		movs	r3, #1
 4816              	.L445:
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4817              		.loc 1 1573 34 view .LVU1415
 4818 000c 2B4D     		ldr	r5, .L446
1572:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
ARM GAS  /tmp/cc39PcX6.s 			page 174


 4819              		.loc 1 1572 14 view .LVU1416
 4820 000e 8DF80730 		strb	r3, [sp, #7]
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4821              		.loc 1 1573 5 is_stmt 1 view .LVU1417
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4822              		.loc 1 1573 9 is_stmt 0 view .LVU1418
 4823 0012 D5E90010 		ldrd	r1, r0, [r5]
 4824              	.LVL306:
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4825              		.loc 1 1573 9 view .LVU1419
 4826 0016 0122     		movs	r2, #1
 4827 0018 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4828 001a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4829 001c 0DF10703 		add	r3, sp, #7
 4830 0020 FFF7FEFF 		bl	i2c_writeBytes
 4831              	.LVL307:
1573:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4832              		.loc 1 1573 8 view .LVU1420
 4833 0024 48B1     		cbz	r0, .L433
 4834              	.L440:
1574:Src/mpu6050.c ****         return -1;
 4835              		.loc 1 1574 9 is_stmt 1 view .LVU1421
1574:Src/mpu6050.c ****         return -1;
 4836              		.loc 1 1574 29 is_stmt 0 view .LVU1422
 4837 0026 0023     		movs	r3, #0
1575:Src/mpu6050.c ****     }
 4838              		.loc 1 1575 16 view .LVU1423
 4839 0028 4FF0FF30 		mov	r0, #-1
1574:Src/mpu6050.c ****         return -1;
 4840              		.loc 1 1574 29 view .LVU1424
 4841 002c AB72     		strb	r3, [r5, #10]
1575:Src/mpu6050.c ****     }
 4842              		.loc 1 1575 9 is_stmt 1 view .LVU1425
 4843              	.L429:
1630:Src/mpu6050.c **** 
 4844              		.loc 1 1630 1 is_stmt 0 view .LVU1426
 4845 002e 03B0     		add	sp, sp, #12
 4846              	.LCFI75:
 4847              		.cfi_remember_state
 4848              		.cfi_def_cfa_offset 12
 4849              		@ sp needed
 4850 0030 30BD     		pop	{r4, r5, pc}
 4851              	.LVL308:
 4852              	.L430:
 4853              	.LCFI76:
 4854              		.cfi_restore_state
1569:Src/mpu6050.c ****         data = 0;
 4855              		.loc 1 1569 10 is_stmt 1 view .LVU1427
1569:Src/mpu6050.c ****         data = 0;
 4856              		.loc 1 1569 13 is_stmt 0 view .LVU1428
 4857 0032 0028     		cmp	r0, #0
 4858 0034 EAD1     		bne	.L445
1572:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4859              		.loc 1 1572 9 is_stmt 1 view .LVU1429
1572:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4860              		.loc 1 1572 14 is_stmt 0 view .LVU1430
 4861 0036 4023     		movs	r3, #64
ARM GAS  /tmp/cc39PcX6.s 			page 175


 4862 0038 E8E7     		b	.L445
 4863              	.LVL309:
 4864              	.L433:
1577:Src/mpu6050.c **** 
 4865              		.loc 1 1577 5 is_stmt 1 view .LVU1431
1577:Src/mpu6050.c **** 
 4866              		.loc 1 1577 32 is_stmt 0 view .LVU1432
 4867 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4868 003e 23F04003 		bic	r3, r3, #64
1577:Src/mpu6050.c **** 
 4869              		.loc 1 1577 25 view .LVU1433
 4870 0042 2B73     		strb	r3, [r5, #12]
1579:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
 4871              		.loc 1 1579 5 is_stmt 1 view .LVU1434
1580:Src/mpu6050.c ****         data |= BIT_STBY_XG;
 4872              		.loc 1 1580 5 view .LVU1435
1580:Src/mpu6050.c ****         data |= BIT_STBY_XG;
 4873              		.loc 1 1580 8 is_stmt 0 view .LVU1436
 4874 0044 6306     		lsls	r3, r4, #25
1581:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4875              		.loc 1 1581 14 view .LVU1437
 4876 0046 56BF     		itet	pl
 4877 0048 0423     		movpl	r3, #4
1579:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
 4878              		.loc 1 1579 10 view .LVU1438
 4879 004a 8DF80700 		strbmi	r0, [sp, #7]
1581:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4880              		.loc 1 1581 9 is_stmt 1 view .LVU1439
1581:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4881              		.loc 1 1581 14 is_stmt 0 view .LVU1440
 4882 004e 8DF80730 		strbpl	r3, [sp, #7]
1582:Src/mpu6050.c ****         data |= BIT_STBY_YG;
 4883              		.loc 1 1582 5 is_stmt 1 view .LVU1441
1582:Src/mpu6050.c ****         data |= BIT_STBY_YG;
 4884              		.loc 1 1582 8 is_stmt 0 view .LVU1442
 4885 0052 A106     		lsls	r1, r4, #26
1583:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4886              		.loc 1 1583 9 is_stmt 1 view .LVU1443
1583:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4887              		.loc 1 1583 14 is_stmt 0 view .LVU1444
 4888 0054 58BF     		it	pl
 4889 0056 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4890              		.loc 1 1588 9 view .LVU1445
 4891 005a D5E90010 		ldrd	r1, r0, [r5]
1583:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4892              		.loc 1 1583 14 view .LVU1446
 4893 005e 5CBF     		itt	pl
 4894 0060 43F00203 		orrpl	r3, r3, #2
 4895 0064 8DF80730 		strbpl	r3, [sp, #7]
1584:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
 4896              		.loc 1 1584 5 is_stmt 1 view .LVU1447
1584:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
 4897              		.loc 1 1584 8 is_stmt 0 view .LVU1448
 4898 0068 E206     		lsls	r2, r4, #27
1585:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4899              		.loc 1 1585 9 is_stmt 1 view .LVU1449
ARM GAS  /tmp/cc39PcX6.s 			page 176


1585:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4900              		.loc 1 1585 14 is_stmt 0 view .LVU1450
 4901 006a 58BF     		it	pl
 4902 006c 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4903              		.loc 1 1588 9 view .LVU1451
 4904 0070 4FF00102 		mov	r2, #1
1585:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4905              		.loc 1 1585 14 view .LVU1452
 4906 0074 5CBF     		itt	pl
 4907 0076 43F00103 		orrpl	r3, r3, #1
 4908 007a 8DF80730 		strbpl	r3, [sp, #7]
1586:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
 4909              		.loc 1 1586 5 is_stmt 1 view .LVU1453
1586:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
 4910              		.loc 1 1586 8 is_stmt 0 view .LVU1454
 4911 007e 2307     		lsls	r3, r4, #28
1587:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4912              		.loc 1 1587 9 is_stmt 1 view .LVU1455
1587:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4913              		.loc 1 1587 14 is_stmt 0 view .LVU1456
 4914 0080 58BF     		it	pl
 4915 0082 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4916              		.loc 1 1588 9 view .LVU1457
 4917 0086 897D     		ldrb	r1, [r1, #22]	@ zero_extendqisi2
1587:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4918              		.loc 1 1587 14 view .LVU1458
 4919 0088 5CBF     		itt	pl
 4920 008a 43F03803 		orrpl	r3, r3, #56
 4921 008e 8DF80730 		strbpl	r3, [sp, #7]
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4922              		.loc 1 1588 5 is_stmt 1 view .LVU1459
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4923              		.loc 1 1588 9 is_stmt 0 view .LVU1460
 4924 0092 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4925 0094 0DF10703 		add	r3, sp, #7
 4926 0098 FFF7FEFF 		bl	i2c_writeBytes
 4927              	.LVL310:
1588:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4928              		.loc 1 1588 8 view .LVU1461
 4929 009c 0028     		cmp	r0, #0
 4930 009e C2D1     		bne	.L440
1593:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
 4931              		.loc 1 1593 5 is_stmt 1 view .LVU1462
1593:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
 4932              		.loc 1 1593 8 is_stmt 0 view .LVU1463
 4933 00a0 14F0F70F 		tst	r4, #247
 4934 00a4 01D0     		beq	.L441
1595:Src/mpu6050.c **** 
 4935              		.loc 1 1595 9 is_stmt 1 view .LVU1464
 4936 00a6 FFF7FEFF 		bl	mpu_set_int_latched
 4937              	.LVL311:
 4938              	.L441:
1626:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4939              		.loc 1 1626 5 view .LVU1465
1626:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
ARM GAS  /tmp/cc39PcX6.s 			page 177


 4940              		.loc 1 1626 25 is_stmt 0 view .LVU1466
 4941 00aa AC72     		strb	r4, [r5, #10]
1627:Src/mpu6050.c ****     delay_ms(50);
 4942              		.loc 1 1627 5 is_stmt 1 view .LVU1467
1627:Src/mpu6050.c ****     delay_ms(50);
 4943              		.loc 1 1627 31 is_stmt 0 view .LVU1468
 4944 00ac 0024     		movs	r4, #0
1628:Src/mpu6050.c ****     return 0;
 4945              		.loc 1 1628 5 view .LVU1469
 4946 00ae 3220     		movs	r0, #50
1627:Src/mpu6050.c ****     delay_ms(50);
 4947              		.loc 1 1627 31 view .LVU1470
 4948 00b0 2C75     		strb	r4, [r5, #20]
1628:Src/mpu6050.c ****     return 0;
 4949              		.loc 1 1628 5 is_stmt 1 view .LVU1471
 4950 00b2 FFF7FEFF 		bl	delay_1ms
 4951              	.LVL312:
1629:Src/mpu6050.c **** }
 4952              		.loc 1 1629 5 view .LVU1472
1629:Src/mpu6050.c **** }
 4953              		.loc 1 1629 12 is_stmt 0 view .LVU1473
 4954 00b6 2046     		mov	r0, r4
 4955 00b8 B9E7     		b	.L429
 4956              	.L447:
 4957 00ba 00BF     		.align	2
 4958              	.L446:
 4959 00bc 00000000 		.word	.LANCHOR0
 4960              		.cfi_endproc
 4961              	.LFE89:
 4963              		.section	.text.mpu_init,"ax",%progbits
 4964              		.align	1
 4965              		.global	mpu_init
 4966              		.syntax unified
 4967              		.thumb
 4968              		.thumb_func
 4969              		.fpu softvfp
 4971              	mpu_init:
 4972              	.LFB62:
 656:Src/mpu6050.c ****     unsigned char data[6];
 4973              		.loc 1 656 1 is_stmt 1 view -0
 4974              		.cfi_startproc
 4975              		@ args = 0, pretend = 0, frame = 8
 4976              		@ frame_needed = 0, uses_anonymous_args = 0
 657:Src/mpu6050.c **** 
 4977              		.loc 1 657 5 view .LVU1475
 660:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4978              		.loc 1 660 5 view .LVU1476
 660:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4979              		.loc 1 660 13 is_stmt 0 view .LVU1477
 4980 0000 8023     		movs	r3, #128
 656:Src/mpu6050.c ****     unsigned char data[6];
 4981              		.loc 1 656 1 view .LVU1478
 4982 0002 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4983              	.LCFI77:
 4984              		.cfi_def_cfa_offset 24
 4985              		.cfi_offset 4, -12
 4986              		.cfi_offset 5, -8
ARM GAS  /tmp/cc39PcX6.s 			page 178


 4987              		.cfi_offset 14, -4
 661:Src/mpu6050.c ****         return -1;
 4988              		.loc 1 661 34 view .LVU1479
 4989 0004 2A4C     		ldr	r4, .L452
 660:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4990              		.loc 1 660 13 view .LVU1480
 4991 0006 8DF80030 		strb	r3, [sp]
 661:Src/mpu6050.c ****         return -1;
 4992              		.loc 1 661 5 is_stmt 1 view .LVU1481
 661:Src/mpu6050.c ****         return -1;
 4993              		.loc 1 661 9 is_stmt 0 view .LVU1482
 4994 000a D4E90010 		ldrd	r1, r0, [r4]
 4995 000e 6B46     		mov	r3, sp
 4996 0010 0122     		movs	r2, #1
 4997 0012 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4998 0014 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4999 0016 FFF7FEFF 		bl	i2c_writeBytes
 5000              	.LVL313:
 661:Src/mpu6050.c ****         return -1;
 5001              		.loc 1 661 8 view .LVU1483
 5002 001a 0546     		mov	r5, r0
 5003 001c 20B1     		cbz	r0, .L449
 5004              	.L451:
 662:Src/mpu6050.c ****     delay_ms(100);
 5005              		.loc 1 662 16 view .LVU1484
 5006 001e 4FF0FF34 		mov	r4, #-1
 5007              	.L448:
 727:Src/mpu6050.c **** 
 5008              		.loc 1 727 1 view .LVU1485
 5009 0022 2046     		mov	r0, r4
 5010 0024 03B0     		add	sp, sp, #12
 5011              	.LCFI78:
 5012              		.cfi_remember_state
 5013              		.cfi_def_cfa_offset 12
 5014              		@ sp needed
 5015 0026 30BD     		pop	{r4, r5, pc}
 5016              	.L449:
 5017              	.LCFI79:
 5018              		.cfi_restore_state
 663:Src/mpu6050.c **** 
 5019              		.loc 1 663 5 is_stmt 1 view .LVU1486
 5020 0028 6420     		movs	r0, #100
 5021 002a FFF7FEFF 		bl	delay_1ms
 5022              	.LVL314:
 666:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 5023              		.loc 1 666 5 view .LVU1487
 667:Src/mpu6050.c ****         return -1;
 5024              		.loc 1 667 9 is_stmt 0 view .LVU1488
 5025 002e D4E90010 		ldrd	r1, r0, [r4]
 666:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 5026              		.loc 1 666 13 view .LVU1489
 5027 0032 8DF80050 		strb	r5, [sp]
 667:Src/mpu6050.c ****         return -1;
 5028              		.loc 1 667 5 is_stmt 1 view .LVU1490
 667:Src/mpu6050.c ****         return -1;
 5029              		.loc 1 667 9 is_stmt 0 view .LVU1491
 5030 0036 6B46     		mov	r3, sp
ARM GAS  /tmp/cc39PcX6.s 			page 179


 5031 0038 0122     		movs	r2, #1
 5032 003a 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 5033 003c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5034 003e FFF7FEFF 		bl	i2c_writeBytes
 5035              	.LVL315:
 667:Src/mpu6050.c ****         return -1;
 5036              		.loc 1 667 8 view .LVU1492
 5037 0042 0028     		cmp	r0, #0
 5038 0044 EBD1     		bne	.L451
 670:Src/mpu6050.c **** 
 5039              		.loc 1 670 4 is_stmt 1 view .LVU1493
 682:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 5040              		.loc 1 682 5 view .LVU1494
 683:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5041              		.loc 1 683 5 view .LVU1495
 684:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 5042              		.loc 1 684 5 view .LVU1496
 685:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 5043              		.loc 1 685 5 view .LVU1497
 686:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 5044              		.loc 1 686 5 view .LVU1498
 686:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 5045              		.loc 1 686 29 is_stmt 0 view .LVU1499
 5046 0046 4FF6FF73 		movw	r3, #65535
 5047 004a E381     		strh	r3, [r4, #14]	@ movhi
 687:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 5048              		.loc 1 687 5 is_stmt 1 view .LVU1500
 687:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 5049              		.loc 1 687 29 is_stmt 0 view .LVU1501
 5050 004c 2374     		strb	r3, [r4, #16]
 688:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 5051              		.loc 1 688 5 is_stmt 1 view .LVU1502
 693:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 5052              		.loc 1 693 5 view .LVU1503
 683:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5053              		.loc 1 683 26 is_stmt 0 view .LVU1504
 5054 004e 4FF0FF33 		mov	r3, #-1
 688:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 5055              		.loc 1 688 29 view .LVU1505
 5056 0052 FF22     		movs	r2, #255
 683:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5057              		.loc 1 683 26 view .LVU1506
 5058 0054 A360     		str	r3, [r4, #8]
 693:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 5059              		.loc 1 693 25 view .LVU1507
 5060 0056 0123     		movs	r3, #1
 698:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 5061              		.loc 1 698 31 view .LVU1508
 5062 0058 A082     		strh	r0, [r4, #20]	@ movhi
 699:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 5063              		.loc 1 699 5 view .LVU1509
 5064 005a C4F81600 		str	r0, [r4, #22]	@ unaligned
 5065 005e C4F81A00 		str	r0, [r4, #26]	@ unaligned
 5066 0062 C4F81E00 		str	r0, [r4, #30]	@ unaligned
 700:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 5067              		.loc 1 700 24 view .LVU1510
 5068 0066 6062     		str	r0, [r4, #36]
ARM GAS  /tmp/cc39PcX6.s 			page 180


 688:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 5069              		.loc 1 688 29 view .LVU1511
 5070 0068 6282     		strh	r2, [r4, #18]	@ movhi
 704:Src/mpu6050.c ****         return -1;
 5071              		.loc 1 704 9 view .LVU1512
 5072 006a 4FF4FA60 		mov	r0, #2000
 695:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 5073              		.loc 1 695 32 view .LVU1513
 5074 006e 6384     		strh	r3, [r4, #34]	@ movhi
 693:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 5075              		.loc 1 693 25 view .LVU1514
 5076 0070 2373     		strb	r3, [r4, #12]
 695:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 5077              		.loc 1 695 5 is_stmt 1 view .LVU1515
 696:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 5078              		.loc 1 696 5 view .LVU1516
 697:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 5079              		.loc 1 697 5 view .LVU1517
 698:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 5080              		.loc 1 698 5 view .LVU1518
 699:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 5081              		.loc 1 699 5 view .LVU1519
 700:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 5082              		.loc 1 700 5 view .LVU1520
 701:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = 0;
 5083              		.loc 1 701 5 view .LVU1521
 702:Src/mpu6050.c **** 
 5084              		.loc 1 702 5 view .LVU1522
 704:Src/mpu6050.c ****         return -1;
 5085              		.loc 1 704 5 view .LVU1523
 704:Src/mpu6050.c ****         return -1;
 5086              		.loc 1 704 9 is_stmt 0 view .LVU1524
 5087 0072 FFF7FEFF 		bl	mpu_set_gyro_fsr
 5088              	.LVL316:
 704:Src/mpu6050.c ****         return -1;
 5089              		.loc 1 704 8 view .LVU1525
 5090 0076 0028     		cmp	r0, #0
 5091 0078 D1D1     		bne	.L451
 706:Src/mpu6050.c ****         return -1;
 5092              		.loc 1 706 5 is_stmt 1 view .LVU1526
 706:Src/mpu6050.c ****         return -1;
 5093              		.loc 1 706 9 is_stmt 0 view .LVU1527
 5094 007a 0220     		movs	r0, #2
 5095 007c FFF7FEFF 		bl	mpu_set_accel_fsr
 5096              	.LVL317:
 706:Src/mpu6050.c ****         return -1;
 5097              		.loc 1 706 8 view .LVU1528
 5098 0080 0028     		cmp	r0, #0
 5099 0082 CCD1     		bne	.L451
 708:Src/mpu6050.c ****         return -1;
 5100              		.loc 1 708 5 is_stmt 1 view .LVU1529
 708:Src/mpu6050.c ****         return -1;
 5101              		.loc 1 708 9 is_stmt 0 view .LVU1530
 5102 0084 2A20     		movs	r0, #42
 5103 0086 FFF7FEFF 		bl	mpu_set_lpf
 5104              	.LVL318:
 708:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/cc39PcX6.s 			page 181


 5105              		.loc 1 708 8 view .LVU1531
 5106 008a 0028     		cmp	r0, #0
 5107 008c C7D1     		bne	.L451
 710:Src/mpu6050.c ****         return -1;
 5108              		.loc 1 710 5 is_stmt 1 view .LVU1532
 710:Src/mpu6050.c ****         return -1;
 5109              		.loc 1 710 9 is_stmt 0 view .LVU1533
 5110 008e 3220     		movs	r0, #50
 5111 0090 FFF7FEFF 		bl	mpu_set_sample_rate
 5112              	.LVL319:
 710:Src/mpu6050.c ****         return -1;
 5113              		.loc 1 710 8 view .LVU1534
 5114 0094 0028     		cmp	r0, #0
 5115 0096 C2D1     		bne	.L451
 712:Src/mpu6050.c ****         return -1;
 5116              		.loc 1 712 5 is_stmt 1 view .LVU1535
 712:Src/mpu6050.c ****         return -1;
 5117              		.loc 1 712 9 is_stmt 0 view .LVU1536
 5118 0098 FFF7FEFF 		bl	mpu_configure_fifo
 5119              	.LVL320:
 712:Src/mpu6050.c ****         return -1;
 5120              		.loc 1 712 8 view .LVU1537
 5121 009c 0028     		cmp	r0, #0
 5122 009e BED1     		bne	.L451
 721:Src/mpu6050.c ****         return -1;
 5123              		.loc 1 721 5 is_stmt 1 view .LVU1538
 721:Src/mpu6050.c ****         return -1;
 5124              		.loc 1 721 9 is_stmt 0 view .LVU1539
 5125 00a0 FFF7FEFF 		bl	mpu_set_bypass
 5126              	.LVL321:
 721:Src/mpu6050.c ****         return -1;
 5127              		.loc 1 721 8 view .LVU1540
 5128 00a4 0446     		mov	r4, r0
 5129 00a6 0028     		cmp	r0, #0
 5130 00a8 B9D1     		bne	.L451
 725:Src/mpu6050.c ****     return 0;
 5131              		.loc 1 725 5 is_stmt 1 view .LVU1541
 5132 00aa FFF7FEFF 		bl	mpu_set_sensors
 5133              	.LVL322:
 726:Src/mpu6050.c **** }
 5134              		.loc 1 726 5 view .LVU1542
 726:Src/mpu6050.c **** }
 5135              		.loc 1 726 12 is_stmt 0 view .LVU1543
 5136 00ae B8E7     		b	.L448
 5137              	.L453:
 5138              		.align	2
 5139              	.L452:
 5140 00b0 00000000 		.word	.LANCHOR0
 5141              		.cfi_endproc
 5142              	.LFE62:
 5144              		.section	.text.mpu_write_mem,"ax",%progbits
 5145              		.align	1
 5146              		.global	mpu_write_mem
 5147              		.syntax unified
 5148              		.thumb
 5149              		.thumb_func
 5150              		.fpu softvfp
ARM GAS  /tmp/cc39PcX6.s 			page 182


 5152              	mpu_write_mem:
 5153              	.LVL323:
 5154              	.LFB101:
2719:Src/mpu6050.c ****     unsigned char tmp[2];
 5155              		.loc 1 2719 1 is_stmt 1 view -0
 5156              		.cfi_startproc
 5157              		@ args = 0, pretend = 0, frame = 8
 5158              		@ frame_needed = 0, uses_anonymous_args = 0
2720:Src/mpu6050.c **** 
 5159              		.loc 1 2720 5 view .LVU1545
2722:Src/mpu6050.c ****         return -1;
 5160              		.loc 1 2722 5 view .LVU1546
2719:Src/mpu6050.c ****     unsigned char tmp[2];
 5161              		.loc 1 2719 1 is_stmt 0 view .LVU1547
 5162 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 5163              	.LCFI80:
 5164              		.cfi_def_cfa_offset 32
 5165              		.cfi_offset 4, -20
 5166              		.cfi_offset 5, -16
 5167              		.cfi_offset 6, -12
 5168              		.cfi_offset 7, -8
 5169              		.cfi_offset 14, -4
2719:Src/mpu6050.c ****     unsigned char tmp[2];
 5170              		.loc 1 2719 1 view .LVU1548
 5171 0002 0D46     		mov	r5, r1
2722:Src/mpu6050.c ****         return -1;
 5172              		.loc 1 2722 8 view .LVU1549
 5173 0004 1646     		mov	r6, r2
 5174 0006 1AB9     		cbnz	r2, .L455
 5175              	.LVL324:
 5176              	.L457:
2723:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5177              		.loc 1 2723 16 view .LVU1550
 5178 0008 4FF0FF30 		mov	r0, #-1
 5179              	.L454:
2739:Src/mpu6050.c **** 
 5180              		.loc 1 2739 1 view .LVU1551
 5181 000c 03B0     		add	sp, sp, #12
 5182              	.LCFI81:
 5183              		.cfi_remember_state
 5184              		.cfi_def_cfa_offset 20
 5185              		@ sp needed
 5186 000e F0BD     		pop	{r4, r5, r6, r7, pc}
 5187              	.LVL325:
 5188              	.L455:
 5189              	.LCFI82:
 5190              		.cfi_restore_state
2724:Src/mpu6050.c ****         return -1;
 5191              		.loc 1 2724 5 is_stmt 1 view .LVU1552
2724:Src/mpu6050.c ****         return -1;
 5192              		.loc 1 2724 21 is_stmt 0 view .LVU1553
 5193 0010 124C     		ldr	r4, .L461
2724:Src/mpu6050.c ****         return -1;
 5194              		.loc 1 2724 8 view .LVU1554
 5195 0012 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 5196 0014 002B     		cmp	r3, #0
 5197 0016 F7D0     		beq	.L457
ARM GAS  /tmp/cc39PcX6.s 			page 183


2727:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5198              		.loc 1 2727 5 is_stmt 1 view .LVU1555
2731:Src/mpu6050.c ****         return -1;
 5199              		.loc 1 2731 29 is_stmt 0 view .LVU1556
 5200 0018 6768     		ldr	r7, [r4, #4]
2727:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5201              		.loc 1 2727 14 view .LVU1557
 5202 001a 030A     		lsrs	r3, r0, #8
 5203 001c 8DF80430 		strb	r3, [sp, #4]
2728:Src/mpu6050.c **** 
 5204              		.loc 1 2728 5 is_stmt 1 view .LVU1558
2728:Src/mpu6050.c **** 
 5205              		.loc 1 2728 14 is_stmt 0 view .LVU1559
 5206 0020 C0B2     		uxtb	r0, r0
 5207              	.LVL326:
2731:Src/mpu6050.c ****         return -1;
 5208              		.loc 1 2731 32 view .LVU1560
 5209 0022 7B89     		ldrh	r3, [r7, #10]
2728:Src/mpu6050.c **** 
 5210              		.loc 1 2728 12 view .LVU1561
 5211 0024 8DF80500 		strb	r0, [sp, #5]
2731:Src/mpu6050.c ****         return -1;
 5212              		.loc 1 2731 5 is_stmt 1 view .LVU1562
2731:Src/mpu6050.c ****         return -1;
 5213              		.loc 1 2731 16 is_stmt 0 view .LVU1563
 5214 0028 0844     		add	r0, r0, r1
2731:Src/mpu6050.c ****         return -1;
 5215              		.loc 1 2731 8 view .LVU1564
 5216 002a 9842     		cmp	r0, r3
 5217 002c ECDC     		bgt	.L457
2734:Src/mpu6050.c ****         return -1;
 5218              		.loc 1 2734 5 is_stmt 1 view .LVU1565
2734:Src/mpu6050.c ****         return -1;
 5219              		.loc 1 2734 9 is_stmt 0 view .LVU1566
 5220 002e 2168     		ldr	r1, [r4]
 5221              	.LVL327:
2734:Src/mpu6050.c ****         return -1;
 5222              		.loc 1 2734 9 view .LVU1567
 5223 0030 0222     		movs	r2, #2
 5224              	.LVL328:
2734:Src/mpu6050.c ****         return -1;
 5225              		.loc 1 2734 9 view .LVU1568
 5226 0032 C97E     		ldrb	r1, [r1, #27]	@ zero_extendqisi2
 5227 0034 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5228 0036 01AB     		add	r3, sp, #4
 5229 0038 FFF7FEFF 		bl	i2c_writeBytes
 5230              	.LVL329:
2734:Src/mpu6050.c ****         return -1;
 5231              		.loc 1 2734 8 view .LVU1569
 5232 003c 0028     		cmp	r0, #0
 5233 003e E3D1     		bne	.L457
2736:Src/mpu6050.c ****         return -1;
 5234              		.loc 1 2736 5 is_stmt 1 view .LVU1570
2736:Src/mpu6050.c ****         return -1;
 5235              		.loc 1 2736 9 is_stmt 0 view .LVU1571
 5236 0040 D4E90010 		ldrd	r1, r0, [r4]
 5237 0044 3346     		mov	r3, r6
ARM GAS  /tmp/cc39PcX6.s 			page 184


 5238 0046 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 5239 0048 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5240 004a EAB2     		uxtb	r2, r5
 5241 004c FFF7FEFF 		bl	i2c_writeBytes
 5242              	.LVL330:
2736:Src/mpu6050.c ****         return -1;
 5243              		.loc 1 2736 8 view .LVU1572
 5244 0050 0038     		subs	r0, r0, #0
 5245 0052 18BF     		it	ne
 5246 0054 0120     		movne	r0, #1
 5247 0056 4042     		rsbs	r0, r0, #0
 5248 0058 D8E7     		b	.L454
 5249              	.L462:
 5250 005a 00BF     		.align	2
 5251              	.L461:
 5252 005c 00000000 		.word	.LANCHOR0
 5253              		.cfi_endproc
 5254              	.LFE101:
 5256              		.section	.text.mpu_read_mem,"ax",%progbits
 5257              		.align	1
 5258              		.global	mpu_read_mem
 5259              		.syntax unified
 5260              		.thumb
 5261              		.thumb_func
 5262              		.fpu softvfp
 5264              	mpu_read_mem:
 5265              	.LVL331:
 5266              	.LFB102:
2752:Src/mpu6050.c ****     unsigned char tmp[2];
 5267              		.loc 1 2752 1 is_stmt 1 view -0
 5268              		.cfi_startproc
 5269              		@ args = 0, pretend = 0, frame = 8
 5270              		@ frame_needed = 0, uses_anonymous_args = 0
2753:Src/mpu6050.c **** 
 5271              		.loc 1 2753 5 view .LVU1574
2755:Src/mpu6050.c ****         return -1;
 5272              		.loc 1 2755 5 view .LVU1575
2752:Src/mpu6050.c ****     unsigned char tmp[2];
 5273              		.loc 1 2752 1 is_stmt 0 view .LVU1576
 5274 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 5275              	.LCFI83:
 5276              		.cfi_def_cfa_offset 32
 5277              		.cfi_offset 4, -20
 5278              		.cfi_offset 5, -16
 5279              		.cfi_offset 6, -12
 5280              		.cfi_offset 7, -8
 5281              		.cfi_offset 14, -4
2752:Src/mpu6050.c ****     unsigned char tmp[2];
 5282              		.loc 1 2752 1 view .LVU1577
 5283 0002 0D46     		mov	r5, r1
2755:Src/mpu6050.c ****         return -1;
 5284              		.loc 1 2755 8 view .LVU1578
 5285 0004 1646     		mov	r6, r2
 5286 0006 1AB9     		cbnz	r2, .L464
 5287              	.LVL332:
 5288              	.L466:
2756:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
ARM GAS  /tmp/cc39PcX6.s 			page 185


 5289              		.loc 1 2756 16 view .LVU1579
 5290 0008 4FF0FF30 		mov	r0, #-1
 5291              	.L463:
2772:Src/mpu6050.c **** 
 5292              		.loc 1 2772 1 view .LVU1580
 5293 000c 03B0     		add	sp, sp, #12
 5294              	.LCFI84:
 5295              		.cfi_remember_state
 5296              		.cfi_def_cfa_offset 20
 5297              		@ sp needed
 5298 000e F0BD     		pop	{r4, r5, r6, r7, pc}
 5299              	.LVL333:
 5300              	.L464:
 5301              	.LCFI85:
 5302              		.cfi_restore_state
2757:Src/mpu6050.c ****         return -1;
 5303              		.loc 1 2757 5 is_stmt 1 view .LVU1581
2757:Src/mpu6050.c ****         return -1;
 5304              		.loc 1 2757 21 is_stmt 0 view .LVU1582
 5305 0010 124C     		ldr	r4, .L470
2757:Src/mpu6050.c ****         return -1;
 5306              		.loc 1 2757 8 view .LVU1583
 5307 0012 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 5308 0014 002B     		cmp	r3, #0
 5309 0016 F7D0     		beq	.L466
2760:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5310              		.loc 1 2760 5 is_stmt 1 view .LVU1584
2764:Src/mpu6050.c ****         return -1;
 5311              		.loc 1 2764 29 is_stmt 0 view .LVU1585
 5312 0018 6768     		ldr	r7, [r4, #4]
2760:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5313              		.loc 1 2760 14 view .LVU1586
 5314 001a 030A     		lsrs	r3, r0, #8
 5315 001c 8DF80430 		strb	r3, [sp, #4]
2761:Src/mpu6050.c **** 
 5316              		.loc 1 2761 5 is_stmt 1 view .LVU1587
2761:Src/mpu6050.c **** 
 5317              		.loc 1 2761 14 is_stmt 0 view .LVU1588
 5318 0020 C0B2     		uxtb	r0, r0
 5319              	.LVL334:
2764:Src/mpu6050.c ****         return -1;
 5320              		.loc 1 2764 32 view .LVU1589
 5321 0022 7B89     		ldrh	r3, [r7, #10]
2761:Src/mpu6050.c **** 
 5322              		.loc 1 2761 12 view .LVU1590
 5323 0024 8DF80500 		strb	r0, [sp, #5]
2764:Src/mpu6050.c ****         return -1;
 5324              		.loc 1 2764 5 is_stmt 1 view .LVU1591
2764:Src/mpu6050.c ****         return -1;
 5325              		.loc 1 2764 16 is_stmt 0 view .LVU1592
 5326 0028 0844     		add	r0, r0, r1
2764:Src/mpu6050.c ****         return -1;
 5327              		.loc 1 2764 8 view .LVU1593
 5328 002a 9842     		cmp	r0, r3
 5329 002c ECDC     		bgt	.L466
2767:Src/mpu6050.c ****         return -1;
 5330              		.loc 1 2767 5 is_stmt 1 view .LVU1594
ARM GAS  /tmp/cc39PcX6.s 			page 186


2767:Src/mpu6050.c ****         return -1;
 5331              		.loc 1 2767 9 is_stmt 0 view .LVU1595
 5332 002e 2168     		ldr	r1, [r4]
 5333              	.LVL335:
2767:Src/mpu6050.c ****         return -1;
 5334              		.loc 1 2767 9 view .LVU1596
 5335 0030 0222     		movs	r2, #2
 5336              	.LVL336:
2767:Src/mpu6050.c ****         return -1;
 5337              		.loc 1 2767 9 view .LVU1597
 5338 0032 C97E     		ldrb	r1, [r1, #27]	@ zero_extendqisi2
 5339 0034 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5340 0036 01AB     		add	r3, sp, #4
 5341 0038 FFF7FEFF 		bl	i2c_writeBytes
 5342              	.LVL337:
2767:Src/mpu6050.c ****         return -1;
 5343              		.loc 1 2767 8 view .LVU1598
 5344 003c 0028     		cmp	r0, #0
 5345 003e E3D1     		bne	.L466
2769:Src/mpu6050.c ****         return -1;
 5346              		.loc 1 2769 5 is_stmt 1 view .LVU1599
2769:Src/mpu6050.c ****         return -1;
 5347              		.loc 1 2769 9 is_stmt 0 view .LVU1600
 5348 0040 D4E90010 		ldrd	r1, r0, [r4]
 5349 0044 3346     		mov	r3, r6
 5350 0046 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 5351 0048 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5352 004a EAB2     		uxtb	r2, r5
 5353 004c FFF7FEFF 		bl	i2c_readBytes
 5354              	.LVL338:
2769:Src/mpu6050.c ****         return -1;
 5355              		.loc 1 2769 8 view .LVU1601
 5356 0050 0038     		subs	r0, r0, #0
 5357 0052 18BF     		it	ne
 5358 0054 0120     		movne	r0, #1
 5359 0056 4042     		rsbs	r0, r0, #0
 5360 0058 D8E7     		b	.L463
 5361              	.L471:
 5362 005a 00BF     		.align	2
 5363              	.L470:
 5364 005c 00000000 		.word	.LANCHOR0
 5365              		.cfi_endproc
 5366              	.LFE102:
 5368              		.section	.text.mpu_load_firmware,"ax",%progbits
 5369              		.align	1
 5370              		.global	mpu_load_firmware
 5371              		.syntax unified
 5372              		.thumb
 5373              		.thumb_func
 5374              		.fpu softvfp
 5376              	mpu_load_firmware:
 5377              	.LVL339:
 5378              	.LFB103:
2784:Src/mpu6050.c ****     unsigned short ii;
 5379              		.loc 1 2784 1 is_stmt 1 view -0
 5380              		.cfi_startproc
 5381              		@ args = 0, pretend = 0, frame = 32
ARM GAS  /tmp/cc39PcX6.s 			page 187


 5382              		@ frame_needed = 0, uses_anonymous_args = 0
2785:Src/mpu6050.c ****     unsigned short this_write;
 5383              		.loc 1 2785 5 view .LVU1603
2786:Src/mpu6050.c ****     /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
 5384              		.loc 1 2786 5 view .LVU1604
2789:Src/mpu6050.c **** 
 5385              		.loc 1 2789 5 view .LVU1605
2791:Src/mpu6050.c ****         /* DMP should only be loaded once. */
 5386              		.loc 1 2791 5 view .LVU1606
2784:Src/mpu6050.c ****     unsigned short ii;
 5387              		.loc 1 2784 1 is_stmt 0 view .LVU1607
 5388 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5389              	.LCFI86:
 5390              		.cfi_def_cfa_offset 36
 5391              		.cfi_offset 4, -36
 5392              		.cfi_offset 5, -32
 5393              		.cfi_offset 6, -28
 5394              		.cfi_offset 7, -24
 5395              		.cfi_offset 8, -20
 5396              		.cfi_offset 9, -16
 5397              		.cfi_offset 10, -12
 5398              		.cfi_offset 11, -8
 5399              		.cfi_offset 14, -4
2791:Src/mpu6050.c ****         /* DMP should only be loaded once. */
 5400              		.loc 1 2791 20 view .LVU1608
 5401 0004 254D     		ldr	r5, .L482
2784:Src/mpu6050.c ****     unsigned short ii;
 5402              		.loc 1 2784 1 view .LVU1609
 5403 0006 89B0     		sub	sp, sp, #36
 5404              	.LCFI87:
 5405              		.cfi_def_cfa_offset 72
2791:Src/mpu6050.c ****         /* DMP should only be loaded once. */
 5406              		.loc 1 2791 8 view .LVU1610
 5407 0008 95F82540 		ldrb	r4, [r5, #37]	@ zero_extendqisi2
2784:Src/mpu6050.c ****     unsigned short ii;
 5408              		.loc 1 2784 1 view .LVU1611
 5409 000c 8146     		mov	r9, r0
 5410 000e 8A46     		mov	r10, r1
 5411 0010 1746     		mov	r7, r2
 5412 0012 0193     		str	r3, [sp, #4]
2791:Src/mpu6050.c ****         /* DMP should only be loaded once. */
 5413              		.loc 1 2791 8 view .LVU1612
 5414 0014 24B1     		cbz	r4, .L473
 5415              	.LVL340:
 5416              	.L475:
2793:Src/mpu6050.c **** 
 5417              		.loc 1 2793 16 view .LVU1613
 5418 0016 4FF0FF30 		mov	r0, #-1
 5419              	.L472:
2816:Src/mpu6050.c **** 
 5420              		.loc 1 2816 1 view .LVU1614
 5421 001a 09B0     		add	sp, sp, #36
 5422              	.LCFI88:
 5423              		.cfi_remember_state
 5424              		.cfi_def_cfa_offset 36
 5425              		@ sp needed
 5426 001c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
ARM GAS  /tmp/cc39PcX6.s 			page 188


 5427              	.LVL341:
 5428              	.L473:
 5429              	.LCFI89:
 5430              		.cfi_restore_state
2795:Src/mpu6050.c ****         return -1;
 5431              		.loc 1 2795 5 is_stmt 1 view .LVU1615
2795:Src/mpu6050.c ****         return -1;
 5432              		.loc 1 2795 8 is_stmt 0 view .LVU1616
 5433 0020 0029     		cmp	r1, #0
 5434 0022 F8D0     		beq	.L475
 5435              	.LVL342:
 5436              	.L476:
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5437              		.loc 1 2797 18 is_stmt 1 discriminator 1 view .LVU1617
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5438              		.loc 1 2797 5 is_stmt 0 discriminator 1 view .LVU1618
 5439 0024 4C45     		cmp	r4, r9
 5440 0026 14D3     		bcc	.L477
2808:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
 5441              		.loc 1 2808 5 is_stmt 1 view .LVU1619
2808:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
 5442              		.loc 1 2808 12 is_stmt 0 view .LVU1620
 5443 0028 3B0A     		lsrs	r3, r7, #8
 5444 002a 8DF80C30 		strb	r3, [sp, #12]
2809:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
 5445              		.loc 1 2809 5 is_stmt 1 view .LVU1621
2809:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
 5446              		.loc 1 2809 12 is_stmt 0 view .LVU1622
 5447 002e 8DF80D70 		strb	r7, [sp, #13]
2810:Src/mpu6050.c ****         return -1;
 5448              		.loc 1 2810 5 is_stmt 1 view .LVU1623
2810:Src/mpu6050.c ****         return -1;
 5449              		.loc 1 2810 9 is_stmt 0 view .LVU1624
 5450 0032 D5E90010 		ldrd	r1, r0, [r5]
 5451 0036 0222     		movs	r2, #2
 5452 0038 497F     		ldrb	r1, [r1, #29]	@ zero_extendqisi2
 5453 003a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5454 003c 03AB     		add	r3, sp, #12
 5455 003e FFF7FEFF 		bl	i2c_writeBytes
 5456              	.LVL343:
2810:Src/mpu6050.c ****         return -1;
 5457              		.loc 1 2810 8 view .LVU1625
 5458 0042 0028     		cmp	r0, #0
 5459 0044 E7D1     		bne	.L475
2813:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
 5460              		.loc 1 2813 5 is_stmt 1 view .LVU1626
2813:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
 5461              		.loc 1 2813 28 is_stmt 0 view .LVU1627
 5462 0046 0123     		movs	r3, #1
 5463 0048 85F82530 		strb	r3, [r5, #37]
2814:Src/mpu6050.c ****     return 0;
 5464              		.loc 1 2814 5 is_stmt 1 view .LVU1628
2814:Src/mpu6050.c ****     return 0;
 5465              		.loc 1 2814 33 is_stmt 0 view .LVU1629
 5466 004c 019B     		ldr	r3, [sp, #4]
 5467 004e EB84     		strh	r3, [r5, #38]	@ movhi
2815:Src/mpu6050.c **** }
ARM GAS  /tmp/cc39PcX6.s 			page 189


 5468              		.loc 1 2815 5 is_stmt 1 view .LVU1630
2815:Src/mpu6050.c **** }
 5469              		.loc 1 2815 12 is_stmt 0 view .LVU1631
 5470 0050 E3E7     		b	.L472
 5471              	.L477:
2798:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5472              		.loc 1 2798 9 is_stmt 1 view .LVU1632
2798:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5473              		.loc 1 2798 22 is_stmt 0 view .LVU1633
 5474 0052 A9EB040B 		sub	fp, r9, r4
 5475 0056 BBF1100F 		cmp	fp, #16
 5476 005a A8BF     		it	ge
 5477 005c 4FF0100B 		movge	fp, #16
2799:Src/mpu6050.c ****             return -1;
 5478              		.loc 1 2799 59 view .LVU1634
 5479 0060 0AEB0408 		add	r8, r10, r4
2798:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5480              		.loc 1 2798 20 view .LVU1635
 5481 0064 1FFA8BF6 		uxth	r6, fp
 5482              	.LVL344:
2799:Src/mpu6050.c ****             return -1;
 5483              		.loc 1 2799 9 is_stmt 1 view .LVU1636
2799:Src/mpu6050.c ****             return -1;
 5484              		.loc 1 2799 13 is_stmt 0 view .LVU1637
 5485 0068 4246     		mov	r2, r8
 5486 006a 3146     		mov	r1, r6
 5487 006c 2046     		mov	r0, r4
 5488 006e FFF7FEFF 		bl	mpu_write_mem
 5489              	.LVL345:
2799:Src/mpu6050.c ****             return -1;
 5490              		.loc 1 2799 12 view .LVU1638
 5491 0072 0028     		cmp	r0, #0
 5492 0074 CFD1     		bne	.L475
2801:Src/mpu6050.c ****             return -1;
 5493              		.loc 1 2801 9 is_stmt 1 view .LVU1639
2801:Src/mpu6050.c ****             return -1;
 5494              		.loc 1 2801 13 is_stmt 0 view .LVU1640
 5495 0076 3146     		mov	r1, r6
 5496 0078 2046     		mov	r0, r4
 5497 007a 04AA     		add	r2, sp, #16
 5498 007c FFF7FEFF 		bl	mpu_read_mem
 5499              	.LVL346:
2801:Src/mpu6050.c ****             return -1;
 5500              		.loc 1 2801 12 view .LVU1641
 5501 0080 0028     		cmp	r0, #0
 5502 0082 C8D1     		bne	.L475
2803:Src/mpu6050.c ****             return -2;
 5503              		.loc 1 2803 9 is_stmt 1 view .LVU1642
2803:Src/mpu6050.c ****             return -2;
 5504              		.loc 1 2803 13 is_stmt 0 view .LVU1643
 5505 0084 3246     		mov	r2, r6
 5506 0086 4046     		mov	r0, r8
 5507 0088 04A9     		add	r1, sp, #16
 5508 008a FFF7FEFF 		bl	memcmp
 5509              	.LVL347:
2803:Src/mpu6050.c ****             return -2;
 5510              		.loc 1 2803 12 view .LVU1644
ARM GAS  /tmp/cc39PcX6.s 			page 190


 5511 008e 10B9     		cbnz	r0, .L478
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5512              		.loc 1 2797 31 is_stmt 1 discriminator 2 view .LVU1645
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5513              		.loc 1 2797 34 is_stmt 0 discriminator 2 view .LVU1646
 5514 0090 3444     		add	r4, r4, r6
 5515              	.LVL348:
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5516              		.loc 1 2797 34 discriminator 2 view .LVU1647
 5517 0092 A4B2     		uxth	r4, r4
 5518              	.LVL349:
2797:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5519              		.loc 1 2797 34 discriminator 2 view .LVU1648
 5520 0094 C6E7     		b	.L476
 5521              	.L478:
2804:Src/mpu6050.c ****     }
 5522              		.loc 1 2804 20 view .LVU1649
 5523 0096 6FF00100 		mvn	r0, #1
 5524 009a BEE7     		b	.L472
 5525              	.L483:
 5526              		.align	2
 5527              	.L482:
 5528 009c 00000000 		.word	.LANCHOR0
 5529              		.cfi_endproc
 5530              	.LFE103:
 5532              		.section	.text.mpu_set_dmp_state,"ax",%progbits
 5533              		.align	1
 5534              		.global	mpu_set_dmp_state
 5535              		.syntax unified
 5536              		.thumb
 5537              		.thumb_func
 5538              		.fpu softvfp
 5540              	mpu_set_dmp_state:
 5541              	.LVL350:
 5542              	.LFB104:
2824:Src/mpu6050.c ****     unsigned char tmp;
 5543              		.loc 1 2824 1 is_stmt 1 view -0
 5544              		.cfi_startproc
 5545              		@ args = 0, pretend = 0, frame = 8
 5546              		@ frame_needed = 0, uses_anonymous_args = 0
2825:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on == enable)
 5547              		.loc 1 2825 5 view .LVU1651
2826:Src/mpu6050.c ****         return 0;
 5548              		.loc 1 2826 5 view .LVU1652
2824:Src/mpu6050.c ****     unsigned char tmp;
 5549              		.loc 1 2824 1 is_stmt 0 view .LVU1653
 5550 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 5551              	.LCFI90:
 5552              		.cfi_def_cfa_offset 24
 5553              		.cfi_offset 4, -12
 5554              		.cfi_offset 5, -8
 5555              		.cfi_offset 14, -4
2826:Src/mpu6050.c ****         return 0;
 5556              		.loc 1 2826 20 view .LVU1654
 5557 0002 1D4D     		ldr	r5, .L490
2824:Src/mpu6050.c ****     unsigned char tmp;
 5558              		.loc 1 2824 1 view .LVU1655
ARM GAS  /tmp/cc39PcX6.s 			page 191


 5559 0004 0446     		mov	r4, r0
2826:Src/mpu6050.c ****         return 0;
 5560              		.loc 1 2826 8 view .LVU1656
 5561 0006 95F82430 		ldrb	r3, [r5, #36]	@ zero_extendqisi2
 5562 000a 8342     		cmp	r3, r0
 5563 000c 1ED0     		beq	.L487
2829:Src/mpu6050.c ****         if (!st.chip_cfg.dmp_loaded)
 5564              		.loc 1 2829 5 is_stmt 1 view .LVU1657
2829:Src/mpu6050.c ****         if (!st.chip_cfg.dmp_loaded)
 5565              		.loc 1 2829 8 is_stmt 0 view .LVU1658
 5566 000e 00B3     		cbz	r0, .L486
2830:Src/mpu6050.c ****             return -1;
 5567              		.loc 1 2830 9 is_stmt 1 view .LVU1659
2830:Src/mpu6050.c ****             return -1;
 5568              		.loc 1 2830 12 is_stmt 0 view .LVU1660
 5569 0010 95F82530 		ldrb	r3, [r5, #37]	@ zero_extendqisi2
 5570 0014 6BB3     		cbz	r3, .L488
 5571              	.LBB10:
 5572              	.LBI10:
2823:Src/mpu6050.c **** {
 5573              		.loc 1 2823 5 is_stmt 1 view .LVU1661
 5574              	.LVL351:
 5575              	.LBB11:
2833:Src/mpu6050.c ****         /* Disable bypass mode. */
 5576              		.loc 1 2833 9 view .LVU1662
2839:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5577              		.loc 1 2839 13 is_stmt 0 view .LVU1663
 5578 0016 0024     		movs	r4, #0
2833:Src/mpu6050.c ****         /* Disable bypass mode. */
 5579              		.loc 1 2833 9 view .LVU1664
 5580 0018 0020     		movs	r0, #0
 5581              	.LVL352:
2833:Src/mpu6050.c ****         /* Disable bypass mode. */
 5582              		.loc 1 2833 9 view .LVU1665
 5583 001a FFF7FEFF 		bl	set_int_enable.isra.0
 5584              	.LVL353:
2835:Src/mpu6050.c ****         /* Keep constant sample rate, FIFO rate controlled by DMP. */
 5585              		.loc 1 2835 9 is_stmt 1 view .LVU1666
 5586 001e 0020     		movs	r0, #0
 5587 0020 FFF7FEFF 		bl	mpu_set_bypass
 5588              	.LVL354:
2837:Src/mpu6050.c ****         /* Remove FIFO elements. */
 5589              		.loc 1 2837 9 view .LVU1667
 5590 0024 E88C     		ldrh	r0, [r5, #38]
 5591 0026 FFF7FEFF 		bl	mpu_set_sample_rate
 5592              	.LVL355:
2839:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5593              		.loc 1 2839 9 view .LVU1668
2840:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 1;
 5594              		.loc 1 2840 9 is_stmt 0 view .LVU1669
 5595 002a 6868     		ldr	r0, [r5, #4]
2839:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5596              		.loc 1 2839 13 view .LVU1670
 5597 002c 8DF80740 		strb	r4, [sp, #7]
2840:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 1;
 5598              		.loc 1 2840 9 is_stmt 1 view .LVU1671
 5599 0030 0122     		movs	r2, #1
ARM GAS  /tmp/cc39PcX6.s 			page 192


 5600 0032 2321     		movs	r1, #35
 5601 0034 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5602 0036 0DF10703 		add	r3, sp, #7
 5603 003a FFF7FEFF 		bl	i2c_writeBytes
 5604              	.LVL356:
2841:Src/mpu6050.c ****         /* Enable DMP interrupt. */
 5605              		.loc 1 2841 9 view .LVU1672
2841:Src/mpu6050.c ****         /* Enable DMP interrupt. */
 5606              		.loc 1 2841 28 is_stmt 0 view .LVU1673
 5607 003e 0120     		movs	r0, #1
 5608 0040 85F82400 		strb	r0, [r5, #36]
2843:Src/mpu6050.c ****         mpu_reset_fifo();
 5609              		.loc 1 2843 9 is_stmt 1 view .LVU1674
 5610 0044 FFF7FEFF 		bl	set_int_enable.isra.0
 5611              	.LVL357:
2844:Src/mpu6050.c ****     } else {
 5612              		.loc 1 2844 9 view .LVU1675
 5613              	.L489:
2844:Src/mpu6050.c ****     } else {
 5614              		.loc 1 2844 9 is_stmt 0 view .LVU1676
 5615              	.LBE11:
 5616              	.LBE10:
2852:Src/mpu6050.c ****     }
 5617              		.loc 1 2852 9 is_stmt 1 view .LVU1677
 5618 0048 FFF7FEFF 		bl	mpu_reset_fifo
 5619              	.LVL358:
 5620              	.L487:
2827:Src/mpu6050.c **** 
 5621              		.loc 1 2827 16 is_stmt 0 view .LVU1678
 5622 004c 0020     		movs	r0, #0
 5623              	.L484:
2855:Src/mpu6050.c **** 
 5624              		.loc 1 2855 1 view .LVU1679
 5625 004e 03B0     		add	sp, sp, #12
 5626              	.LCFI91:
 5627              		.cfi_remember_state
 5628              		.cfi_def_cfa_offset 12
 5629              		@ sp needed
 5630 0050 30BD     		pop	{r4, r5, pc}
 5631              	.LVL359:
 5632              	.L486:
 5633              	.LCFI92:
 5634              		.cfi_restore_state
2847:Src/mpu6050.c ****         /* Restore FIFO settings. */
 5635              		.loc 1 2847 9 is_stmt 1 view .LVU1680
 5636 0052 FFF7FEFF 		bl	set_int_enable.isra.0
 5637              	.LVL360:
2849:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5638              		.loc 1 2849 9 view .LVU1681
2849:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5639              		.loc 1 2849 13 is_stmt 0 view .LVU1682
 5640 0056 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
2850:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
 5641              		.loc 1 2850 9 view .LVU1683
 5642 0058 6868     		ldr	r0, [r5, #4]
2849:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5643              		.loc 1 2849 13 view .LVU1684
ARM GAS  /tmp/cc39PcX6.s 			page 193


 5644 005a 8DF80730 		strb	r3, [sp, #7]
2850:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
 5645              		.loc 1 2850 9 is_stmt 1 view .LVU1685
 5646 005e 0122     		movs	r2, #1
 5647 0060 2321     		movs	r1, #35
 5648 0062 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5649 0064 0DF10703 		add	r3, sp, #7
 5650 0068 FFF7FEFF 		bl	i2c_writeBytes
 5651              	.LVL361:
2851:Src/mpu6050.c ****         mpu_reset_fifo();
 5652              		.loc 1 2851 9 view .LVU1686
2851:Src/mpu6050.c ****         mpu_reset_fifo();
 5653              		.loc 1 2851 28 is_stmt 0 view .LVU1687
 5654 006c 85F82440 		strb	r4, [r5, #36]
 5655 0070 EAE7     		b	.L489
 5656              	.LVL362:
 5657              	.L488:
2831:Src/mpu6050.c ****         /* Disable data ready interrupt. */
 5658              		.loc 1 2831 20 view .LVU1688
 5659 0072 4FF0FF30 		mov	r0, #-1
 5660              	.LVL363:
2831:Src/mpu6050.c ****         /* Disable data ready interrupt. */
 5661              		.loc 1 2831 20 view .LVU1689
 5662 0076 EAE7     		b	.L484
 5663              	.L491:
 5664              		.align	2
 5665              	.L490:
 5666 0078 00000000 		.word	.LANCHOR0
 5667              		.cfi_endproc
 5668              	.LFE104:
 5670              		.global	__aeabi_fcmpeq
 5671              		.global	__aeabi_fcmpgt
 5672              		.global	__aeabi_fcmplt
 5673              		.section	.text.mpu_run_self_test,"ax",%progbits
 5674              		.align	1
 5675              		.global	mpu_run_self_test
 5676              		.syntax unified
 5677              		.thumb
 5678              		.thumb_func
 5679              		.fpu softvfp
 5681              	mpu_run_self_test:
 5682              	.LVL364:
 5683              	.LFB100:
2614:Src/mpu6050.c **** #ifdef MPU6050
 5684              		.loc 1 2614 1 is_stmt 1 view -0
 5685              		.cfi_startproc
 5686              		@ args = 0, pretend = 0, frame = 80
 5687              		@ frame_needed = 0, uses_anonymous_args = 0
2616:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
 5688              		.loc 1 2616 5 view .LVU1691
2617:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
 5689              		.loc 1 2617 5 view .LVU1692
2618:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 5690              		.loc 1 2618 5 view .LVU1693
2622:Src/mpu6050.c **** #endif
 5691              		.loc 1 2622 5 view .LVU1694
2624:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
ARM GAS  /tmp/cc39PcX6.s 			page 194


 5692              		.loc 1 2624 5 view .LVU1695
2625:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
 5693              		.loc 1 2625 5 view .LVU1696
2626:Src/mpu6050.c ****     unsigned char dmp_was_on;
 5694              		.loc 1 2626 5 view .LVU1697
2627:Src/mpu6050.c **** 
 5695              		.loc 1 2627 5 view .LVU1698
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5696              		.loc 1 2629 5 view .LVU1699
2614:Src/mpu6050.c **** #ifdef MPU6050
 5697              		.loc 1 2614 1 is_stmt 0 view .LVU1700
 5698 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5699              	.LCFI93:
 5700              		.cfi_def_cfa_offset 36
 5701              		.cfi_offset 4, -36
 5702              		.cfi_offset 5, -32
 5703              		.cfi_offset 6, -28
 5704              		.cfi_offset 7, -24
 5705              		.cfi_offset 8, -20
 5706              		.cfi_offset 9, -16
 5707              		.cfi_offset 10, -12
 5708              		.cfi_offset 11, -8
 5709              		.cfi_offset 14, -4
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5710              		.loc 1 2629 20 view .LVU1701
 5711 0004 B94C     		ldr	r4, .L556
2614:Src/mpu6050.c **** #ifdef MPU6050
 5712              		.loc 1 2614 1 view .LVU1702
 5713 0006 95B0     		sub	sp, sp, #84
 5714              	.LCFI94:
 5715              		.cfi_def_cfa_offset 120
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5716              		.loc 1 2629 20 view .LVU1703
 5717 0008 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
2614:Src/mpu6050.c **** #ifdef MPU6050
 5718              		.loc 1 2614 1 view .LVU1704
 5719 000c 0746     		mov	r7, r0
 5720 000e 8846     		mov	r8, r1
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5721              		.loc 1 2629 20 view .LVU1705
 5722 0010 0093     		str	r3, [sp]
2629:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5723              		.loc 1 2629 8 view .LVU1706
 5724 0012 23B1     		cbz	r3, .L493
2630:Src/mpu6050.c ****         dmp_was_on = 1;
 5725              		.loc 1 2630 9 is_stmt 1 view .LVU1707
 5726 0014 0020     		movs	r0, #0
 5727              	.LVL365:
2630:Src/mpu6050.c ****         dmp_was_on = 1;
 5728              		.loc 1 2630 9 is_stmt 0 view .LVU1708
 5729 0016 FFF7FEFF 		bl	mpu_set_dmp_state
 5730              	.LVL366:
2631:Src/mpu6050.c ****     } else
 5731              		.loc 1 2631 9 is_stmt 1 view .LVU1709
2631:Src/mpu6050.c ****     } else
 5732              		.loc 1 2631 20 is_stmt 0 view .LVU1710
 5733 001a 0123     		movs	r3, #1
ARM GAS  /tmp/cc39PcX6.s 			page 195


 5734 001c 0093     		str	r3, [sp]
 5735              	.LVL367:
 5736              	.L493:
2636:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
 5737              		.loc 1 2636 5 is_stmt 1 view .LVU1711
 5738 001e 0DF11E00 		add	r0, sp, #30
 5739 0022 FFF7FEFF 		bl	mpu_get_gyro_fsr
 5740              	.LVL368:
2637:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
 5741              		.loc 1 2637 5 view .LVU1712
 5742 0026 0DF11D00 		add	r0, sp, #29
 5743 002a FFF7FEFF 		bl	mpu_get_accel_fsr
 5744              	.LVL369:
2638:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
 5745              		.loc 1 2638 5 view .LVU1713
 5746 002e 0DF12200 		add	r0, sp, #34
 5747 0032 FFF7FEFF 		bl	mpu_get_lpf
 5748              	.LVL370:
2639:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
 5749              		.loc 1 2639 5 view .LVU1714
 5750 0036 08A8     		add	r0, sp, #32
 5751 0038 FFF7FEFF 		bl	mpu_get_sample_rate
 5752              	.LVL371:
2640:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5753              		.loc 1 2640 5 view .LVU1715
2640:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5754              		.loc 1 2640 16 is_stmt 0 view .LVU1716
 5755 003c A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
2646:Src/mpu6050.c ****             break;
 5756              		.loc 1 2646 14 view .LVU1717
 5757 003e 0022     		movs	r2, #0
2640:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5758              		.loc 1 2640 16 view .LVU1718
 5759 0040 0393     		str	r3, [sp, #12]
 5760              	.LVL372:
2641:Src/mpu6050.c **** 
 5761              		.loc 1 2641 5 is_stmt 1 view .LVU1719
 5762              	.LBB20:
 5763              	.LBI20:
1484:Src/mpu6050.c **** {
 5764              		.loc 1 1484 5 view .LVU1720
 5765              	.LBB21:
1486:Src/mpu6050.c ****     return 0;
 5766              		.loc 1 1486 5 view .LVU1721
1486:Src/mpu6050.c ****     return 0;
 5767              		.loc 1 1486 29 is_stmt 0 view .LVU1722
 5768 0042 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 5769              	.LBE21:
 5770              	.LBE20:
2646:Src/mpu6050.c ****             break;
 5771              		.loc 1 2646 14 view .LVU1723
 5772 0044 4146     		mov	r1, r8
 5773 0046 3846     		mov	r0, r7
 5774              	.LBB23:
 5775              	.LBB22:
1486:Src/mpu6050.c ****     return 0;
 5776              		.loc 1 1486 29 view .LVU1724
ARM GAS  /tmp/cc39PcX6.s 			page 196


 5777 0048 0493     		str	r3, [sp, #16]
 5778              	.LVL373:
1487:Src/mpu6050.c **** }
 5779              		.loc 1 1487 5 is_stmt 1 view .LVU1725
1487:Src/mpu6050.c **** }
 5780              		.loc 1 1487 5 is_stmt 0 view .LVU1726
 5781              	.LBE22:
 5782              	.LBE23:
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5783              		.loc 1 2645 5 is_stmt 1 view .LVU1727
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5784              		.loc 1 2645 18 view .LVU1728
2646:Src/mpu6050.c ****             break;
 5785              		.loc 1 2646 9 view .LVU1729
2646:Src/mpu6050.c ****             break;
 5786              		.loc 1 2646 14 is_stmt 0 view .LVU1730
 5787 004a FFF7FEFF 		bl	get_st_biases
 5788              	.LVL374:
2646:Src/mpu6050.c ****             break;
 5789              		.loc 1 2646 12 view .LVU1731
 5790 004e 0028     		cmp	r0, #0
 5791 0050 40F08B80 		bne	.L494
 5792              	.LVL375:
 5793              	.L497:
2655:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5794              		.loc 1 2655 18 is_stmt 1 view .LVU1732
2656:Src/mpu6050.c ****             break;
 5795              		.loc 1 2656 9 view .LVU1733
2656:Src/mpu6050.c ****             break;
 5796              		.loc 1 2656 14 is_stmt 0 view .LVU1734
 5797 0054 0122     		movs	r2, #1
 5798 0056 0EA9     		add	r1, sp, #56
 5799 0058 0BA8     		add	r0, sp, #44
 5800 005a FFF7FEFF 		bl	get_st_biases
 5801              	.LVL376:
2656:Src/mpu6050.c ****             break;
 5802              		.loc 1 2656 12 view .LVU1735
 5803 005e 0028     		cmp	r0, #0
 5804 0060 40F0B480 		bne	.L548
 5805              	.LVL377:
 5806              	.L495:
2663:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5807              		.loc 1 2663 5 is_stmt 1 view .LVU1736
 5808              	.LBB24:
 5809              	.LBI24:
1895:Src/mpu6050.c **** {
 5810              		.loc 1 1895 12 view .LVU1737
 5811              	.LBB25:
1897:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
 5812              		.loc 1 1897 5 view .LVU1738
1898:Src/mpu6050.c **** 
 5813              		.loc 1 1898 5 view .LVU1739
1900:Src/mpu6050.c ****     for(jj = 0; jj < 3; jj++) {
 5814              		.loc 1 1900 5 view .LVU1740
 5815              	.LBB26:
 5816              	.LBI26:
1870:Src/mpu6050.c **** {
ARM GAS  /tmp/cc39PcX6.s 			page 197


 5817              		.loc 1 1870 12 view .LVU1741
 5818              	.LBB27:
1872:Src/mpu6050.c **** 
 5819              		.loc 1 1872 5 view .LVU1742
1874:Src/mpu6050.c ****         return 0x07;
 5820              		.loc 1 1874 5 view .LVU1743
1874:Src/mpu6050.c ****         return 0x07;
 5821              		.loc 1 1874 9 is_stmt 0 view .LVU1744
 5822 0064 6068     		ldr	r0, [r4, #4]
 5823 0066 0422     		movs	r2, #4
 5824 0068 0D21     		movs	r1, #13
 5825 006a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5826 006c 0AAB     		add	r3, sp, #40
 5827 006e FFF7FEFF 		bl	i2c_readBytes
 5828              	.LVL378:
1874:Src/mpu6050.c ****         return 0x07;
 5829              		.loc 1 1874 8 view .LVU1745
 5830 0072 0546     		mov	r5, r0
 5831 0074 0028     		cmp	r0, #0
 5832 0076 00F0B180 		beq	.L549
 5833              	.L499:
 5834              	.LVL379:
1874:Src/mpu6050.c ****         return 0x07;
 5835              		.loc 1 1874 8 view .LVU1746
 5836              	.LBE27:
 5837              	.LBE26:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5838              		.loc 1 1901 17 is_stmt 1 view .LVU1747
1897:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
 5839              		.loc 1 1897 13 is_stmt 0 view .LVU1748
 5840 007a 0026     		movs	r6, #0
1909:Src/mpu6050.c ****     }
 5841              		.loc 1 1909 25 view .LVU1749
 5842 007c 4FF00109 		mov	r9, #1
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5843              		.loc 1 1901 12 view .LVU1750
 5844 0080 3546     		mov	r5, r6
 5845 0082 0EAB     		add	r3, sp, #56
 5846              	.LVL380:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5847              		.loc 1 1901 12 view .LVU1751
 5848 0084 0293     		str	r3, [sp, #8]
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5849              		.loc 1 1905 16 view .LVU1752
 5850 0086 DFF868B2 		ldr	fp, .L556+4
 5851 008a 11AB     		add	r3, sp, #68
 5852              	.LVL381:
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5853              		.loc 1 1905 16 view .LVU1753
 5854 008c 0193     		str	r3, [sp, #4]
 5855              	.LVL382:
 5856              	.L502:
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5857              		.loc 1 1902 9 is_stmt 1 view .LVU1754
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5858              		.loc 1 1902 56 is_stmt 0 view .LVU1755
 5859 008e 029A     		ldr	r2, [sp, #8]
ARM GAS  /tmp/cc39PcX6.s 			page 198


1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5860              		.loc 1 1902 47 view .LVU1756
 5861 0090 58F82500 		ldr	r0, [r8, r5, lsl #2]
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5862              		.loc 1 1902 56 view .LVU1757
 5863 0094 52F8043B 		ldr	r3, [r2], #4
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5864              		.loc 1 1902 47 view .LVU1758
 5865 0098 C01A     		subs	r0, r0, r3
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5866              		.loc 1 1902 62 view .LVU1759
 5867 009a 0028     		cmp	r0, #0
 5868 009c B8BF     		it	lt
 5869 009e 4042     		rsblt	r0, r0, #0
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5870              		.loc 1 1902 56 view .LVU1760
 5871 00a0 0292     		str	r2, [sp, #8]
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5872              		.loc 1 1902 62 view .LVU1761
 5873 00a2 FFF7FEFF 		bl	__aeabi_i2f
 5874              	.LVL383:
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5875              		.loc 1 1902 23 view .LVU1762
 5876 00a6 4FF05E51 		mov	r1, #931135488
 5877 00aa FFF7FEFF 		bl	__aeabi_fmul
 5878              	.LVL384:
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5879              		.loc 1 1903 21 view .LVU1763
 5880 00ae 019B     		ldr	r3, [sp, #4]
1902:Src/mpu6050.c ****         if (st_shift[jj]) {
 5881              		.loc 1 1902 23 view .LVU1764
 5882 00b0 8246     		mov	r10, r0
 5883              	.LVL385:
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5884              		.loc 1 1903 9 is_stmt 1 view .LVU1765
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5885              		.loc 1 1903 21 is_stmt 0 view .LVU1766
 5886 00b2 53F8042B 		ldr	r2, [r3], #4	@ float
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5887              		.loc 1 1903 12 view .LVU1767
 5888 00b6 0021     		movs	r1, #0
 5889 00b8 1046     		mov	r0, r2
 5890              	.LVL386:
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5891              		.loc 1 1903 21 view .LVU1768
 5892 00ba 0193     		str	r3, [sp, #4]
1903:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5893              		.loc 1 1903 12 view .LVU1769
 5894 00bc 0592     		str	r2, [sp, #20]
 5895 00be FFF7FEFF 		bl	__aeabi_fcmpeq
 5896              	.LVL387:
 5897 00c2 0028     		cmp	r0, #0
 5898 00c4 40F0D280 		bne	.L550
1904:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5899              		.loc 1 1904 13 is_stmt 1 view .LVU1770
 5900              	.LVL388:
1905:Src/mpu6050.c ****                 result |= 1 << jj;
ARM GAS  /tmp/cc39PcX6.s 			page 199


 5901              		.loc 1 1905 13 view .LVU1771
1904:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5902              		.loc 1 1904 42 is_stmt 0 view .LVU1772
 5903 00c8 059A     		ldr	r2, [sp, #20]
 5904 00ca 5046     		mov	r0, r10
 5905 00cc 1146     		mov	r1, r2
 5906 00ce FFF7FEFF 		bl	__aeabi_fdiv
 5907              	.LVL389:
1904:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5908              		.loc 1 1904 26 view .LVU1773
 5909 00d2 4FF07E51 		mov	r1, #1065353216
 5910 00d6 FFF7FEFF 		bl	__aeabi_fsub
 5911              	.LVL390:
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5912              		.loc 1 1905 16 view .LVU1774
 5913 00da 5946     		mov	r1, fp
1905:Src/mpu6050.c ****                 result |= 1 << jj;
 5914              		.loc 1 1905 17 view .LVU1775
 5915 00dc 20F00040 		bic	r0, r0, #-2147483648
 5916              	.LVL391:
 5917              	.L553:
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 5918              		.loc 1 1907 49 view .LVU1776
 5919 00e0 FFF7FEFF 		bl	__aeabi_fcmpgt
 5920              	.LVL392:
 5921 00e4 10B1     		cbz	r0, .L510
 5922              	.L512:
1909:Src/mpu6050.c ****     }
 5923              		.loc 1 1909 13 is_stmt 1 view .LVU1777
1909:Src/mpu6050.c ****     }
 5924              		.loc 1 1909 25 is_stmt 0 view .LVU1778
 5925 00e6 09FA05F3 		lsl	r3, r9, r5
1909:Src/mpu6050.c ****     }
 5926              		.loc 1 1909 20 view .LVU1779
 5927 00ea 1E43     		orrs	r6, r6, r3
 5928              	.LVL393:
 5929              	.L510:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5930              		.loc 1 1901 25 is_stmt 1 view .LVU1780
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5931              		.loc 1 1901 27 is_stmt 0 view .LVU1781
 5932 00ec 0135     		adds	r5, r5, #1
 5933              	.LVL394:
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5934              		.loc 1 1901 17 is_stmt 1 view .LVU1782
1901:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5935              		.loc 1 1901 5 is_stmt 0 view .LVU1783
 5936 00ee 032D     		cmp	r5, #3
 5937 00f0 CDD1     		bne	.L502
1912:Src/mpu6050.c **** }
 5938              		.loc 1 1912 5 is_stmt 1 view .LVU1784
 5939              	.LVL395:
1912:Src/mpu6050.c **** }
 5940              		.loc 1 1912 5 is_stmt 0 view .LVU1785
 5941              	.LBE25:
 5942              	.LBE24:
 5943              	.LBB31:
ARM GAS  /tmp/cc39PcX6.s 			page 200


 5944              	.LBB32:
1921:Src/mpu6050.c ****         return 0x07;
 5945              		.loc 1 1921 9 view .LVU1786
 5946 00f2 6068     		ldr	r0, [r4, #4]
 5947              	.LBE32:
 5948              	.LBE31:
2663:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5949              		.loc 1 2663 18 view .LVU1787
 5950 00f4 F3B2     		uxtb	r3, r6
 5951              	.LBB37:
 5952              	.LBB33:
1921:Src/mpu6050.c ****         return 0x07;
 5953              		.loc 1 1921 9 view .LVU1788
 5954 00f6 2A46     		mov	r2, r5
 5955              	.LBE33:
 5956              	.LBE37:
2663:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5957              		.loc 1 2663 18 view .LVU1789
 5958 00f8 0193     		str	r3, [sp, #4]
 5959              	.LVL396:
2664:Src/mpu6050.c **** 
 5960              		.loc 1 2664 5 is_stmt 1 view .LVU1790
 5961              	.LBB38:
 5962              	.LBI31:
1915:Src/mpu6050.c **** {
 5963              		.loc 1 1915 12 view .LVU1791
 5964              	.LBB34:
1917:Src/mpu6050.c ****     unsigned char tmp[3];
 5965              		.loc 1 1917 5 view .LVU1792
1918:Src/mpu6050.c ****     float st_shift, st_shift_cust, st_shift_var;
 5966              		.loc 1 1918 5 view .LVU1793
1919:Src/mpu6050.c **** 
 5967              		.loc 1 1919 5 view .LVU1794
1921:Src/mpu6050.c ****         return 0x07;
 5968              		.loc 1 1921 5 view .LVU1795
1921:Src/mpu6050.c ****         return 0x07;
 5969              		.loc 1 1921 9 is_stmt 0 view .LVU1796
 5970 00fa 0D21     		movs	r1, #13
 5971 00fc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5972 00fe 11AB     		add	r3, sp, #68
 5973 0100 FFF7FEFF 		bl	i2c_readBytes
 5974              	.LVL397:
1921:Src/mpu6050.c ****         return 0x07;
 5975              		.loc 1 1921 8 view .LVU1797
 5976 0104 0546     		mov	r5, r0
 5977 0106 0028     		cmp	r0, #0
 5978 0108 40F0ED80 		bne	.L525
1924:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5979              		.loc 1 1924 5 is_stmt 1 view .LVU1798
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5980              		.loc 1 1928 13 is_stmt 0 view .LVU1799
 5981 010c 0646     		mov	r6, r0
1939:Src/mpu6050.c ****     }
 5982              		.loc 1 1939 25 view .LVU1800
 5983 010e 4FF00109 		mov	r9, #1
1924:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5984              		.loc 1 1924 12 view .LVU1801
ARM GAS  /tmp/cc39PcX6.s 			page 201


 5985 0112 9DF84430 		ldrb	r3, [sp, #68]	@ zero_extendqisi2
 5986 0116 0DF12C0A 		add	r10, sp, #44
 5987              	.LVL398:
1924:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5988              		.loc 1 1924 12 view .LVU1802
 5989 011a 03F01F03 		and	r3, r3, #31
 5990 011e 8DF84430 		strb	r3, [sp, #68]
1925:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5991              		.loc 1 1925 5 is_stmt 1 view .LVU1803
1925:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5992              		.loc 1 1925 12 is_stmt 0 view .LVU1804
 5993 0122 9DF84530 		ldrb	r3, [sp, #69]	@ zero_extendqisi2
 5994 0126 0DF14408 		add	r8, sp, #68
 5995              	.LVL399:
1925:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5996              		.loc 1 1925 12 view .LVU1805
 5997 012a 03F01F03 		and	r3, r3, #31
 5998 012e 8DF84530 		strb	r3, [sp, #69]
1926:Src/mpu6050.c **** 
 5999              		.loc 1 1926 5 is_stmt 1 view .LVU1806
1926:Src/mpu6050.c **** 
 6000              		.loc 1 1926 12 is_stmt 0 view .LVU1807
 6001 0132 9DF84630 		ldrb	r3, [sp, #70]	@ zero_extendqisi2
 6002 0136 03F01F03 		and	r3, r3, #31
 6003 013a 8DF84630 		strb	r3, [sp, #70]
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6004              		.loc 1 1928 5 is_stmt 1 view .LVU1808
 6005              	.LVL400:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6006              		.loc 1 1928 18 view .LVU1809
 6007              	.L522:
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 6008              		.loc 1 1929 9 view .LVU1810
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 6009              		.loc 1 1929 56 is_stmt 0 view .LVU1811
 6010 013e 5AF8043B 		ldr	r3, [r10], #4
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 6011              		.loc 1 1929 47 view .LVU1812
 6012 0142 57F82600 		ldr	r0, [r7, r6, lsl #2]
 6013 0146 C01A     		subs	r0, r0, r3
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 6014              		.loc 1 1929 62 view .LVU1813
 6015 0148 0028     		cmp	r0, #0
 6016 014a B8BF     		it	lt
 6017 014c 4042     		rsblt	r0, r0, #0
 6018 014e FFF7FEFF 		bl	__aeabi_i2f
 6019              	.LVL401:
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 6020              		.loc 1 1929 23 view .LVU1814
 6021 0152 4FF05E51 		mov	r1, #931135488
 6022 0156 FFF7FEFF 		bl	__aeabi_fmul
 6023              	.LVL402:
1930:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 6024              		.loc 1 1930 16 view .LVU1815
 6025 015a 18F8013B 		ldrb	r3, [r8], #1	@ zero_extendqisi2
1929:Src/mpu6050.c ****         if (tmp[jj]) {
 6026              		.loc 1 1929 23 view .LVU1816
ARM GAS  /tmp/cc39PcX6.s 			page 202


 6027 015e 8346     		mov	fp, r0
 6028              	.LVL403:
1930:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 6029              		.loc 1 1930 9 is_stmt 1 view .LVU1817
1930:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 6030              		.loc 1 1930 12 is_stmt 0 view .LVU1818
 6031 0160 002B     		cmp	r3, #0
 6032 0162 00F0B880 		beq	.L551
1931:Src/mpu6050.c ****             while (--tmp[jj])
 6033              		.loc 1 1931 22 view .LVU1819
 6034 0166 6348     		ldr	r0, .L556+8
 6035              	.LVL404:
1931:Src/mpu6050.c ****             while (--tmp[jj])
 6036              		.loc 1 1931 22 view .LVU1820
 6037 0168 8FE0     		b	.L515
 6038              	.LVL405:
 6039              	.L494:
1931:Src/mpu6050.c ****             while (--tmp[jj])
 6040              		.loc 1 1931 22 view .LVU1821
 6041              	.LBE34:
 6042              	.LBE38:
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 6043              		.loc 1 2645 30 is_stmt 1 view .LVU1822
2645:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 6044              		.loc 1 2645 18 view .LVU1823
2646:Src/mpu6050.c ****             break;
 6045              		.loc 1 2646 9 view .LVU1824
2646:Src/mpu6050.c ****             break;
 6046              		.loc 1 2646 14 is_stmt 0 view .LVU1825
 6047 016a 0022     		movs	r2, #0
 6048 016c 4146     		mov	r1, r8
 6049 016e 3846     		mov	r0, r7
 6050 0170 FFF7FEFF 		bl	get_st_biases
 6051              	.LVL406:
2646:Src/mpu6050.c ****             break;
 6052              		.loc 1 2646 12 view .LVU1826
 6053 0174 0028     		cmp	r0, #0
 6054 0176 3FF46DAF 		beq	.L497
 6055              	.L501:
2652:Src/mpu6050.c ****         goto restore;
 6056              		.loc 1 2652 16 view .LVU1827
 6057 017a 0025     		movs	r5, #0
 6058              	.LVL407:
 6059              	.L498:
2688:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6060              		.loc 1 2688 5 is_stmt 1 view .LVU1828
2689:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 6061              		.loc 1 2689 5 view .LVU1829
2690:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 6062              		.loc 1 2690 5 view .LVU1830
2691:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6063              		.loc 1 2691 5 view .LVU1831
2691:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6064              		.loc 1 2691 29 is_stmt 0 view .LVU1832
 6065 017c 4FF6FF73 		movw	r3, #65535
2694:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 6066              		.loc 1 2694 25 view .LVU1833
ARM GAS  /tmp/cc39PcX6.s 			page 203


 6067 0180 0126     		movs	r6, #1
2691:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6068              		.loc 1 2691 29 view .LVU1834
 6069 0182 E381     		strh	r3, [r4, #14]	@ movhi
2692:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 6070              		.loc 1 2692 5 is_stmt 1 view .LVU1835
2693:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6071              		.loc 1 2693 5 view .LVU1836
2693:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6072              		.loc 1 2693 29 is_stmt 0 view .LVU1837
 6073 0184 2374     		strb	r3, [r4, #16]
2694:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 6074              		.loc 1 2694 5 is_stmt 1 view .LVU1838
2688:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6075              		.loc 1 2688 26 is_stmt 0 view .LVU1839
 6076 0186 4FF0FF33 		mov	r3, #-1
2695:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
 6077              		.loc 1 2695 5 view .LVU1840
 6078 018a BDF81E00 		ldrh	r0, [sp, #30]
2688:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6079              		.loc 1 2688 26 view .LVU1841
 6080 018e A360     		str	r3, [r4, #8]
2694:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 6081              		.loc 1 2694 25 view .LVU1842
 6082 0190 2673     		strb	r6, [r4, #12]
2695:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
 6083              		.loc 1 2695 5 is_stmt 1 view .LVU1843
 6084 0192 FFF7FEFF 		bl	mpu_set_gyro_fsr
 6085              	.LVL408:
2696:Src/mpu6050.c ****     mpu_set_lpf(lpf);
 6086              		.loc 1 2696 5 view .LVU1844
 6087 0196 9DF81D00 		ldrb	r0, [sp, #29]	@ zero_extendqisi2
 6088 019a FFF7FEFF 		bl	mpu_set_accel_fsr
 6089              	.LVL409:
2697:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
 6090              		.loc 1 2697 5 view .LVU1845
 6091 019e BDF82200 		ldrh	r0, [sp, #34]
 6092 01a2 FFF7FEFF 		bl	mpu_set_lpf
 6093              	.LVL410:
2698:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
 6094              		.loc 1 2698 5 view .LVU1846
 6095 01a6 BDF82000 		ldrh	r0, [sp, #32]
 6096 01aa FFF7FEFF 		bl	mpu_set_sample_rate
 6097              	.LVL411:
2699:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
 6098              		.loc 1 2699 5 view .LVU1847
 6099 01ae 0398     		ldr	r0, [sp, #12]
 6100 01b0 FFF7FEFF 		bl	mpu_set_sensors
 6101              	.LVL412:
2700:Src/mpu6050.c **** 
 6102              		.loc 1 2700 5 view .LVU1848
 6103 01b4 0498     		ldr	r0, [sp, #16]
 6104 01b6 FFF7FEFF 		bl	mpu_configure_fifo
 6105              	.LVL413:
2702:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 6106              		.loc 1 2702 5 view .LVU1849
2702:Src/mpu6050.c ****         mpu_set_dmp_state(1);
ARM GAS  /tmp/cc39PcX6.s 			page 204


 6107              		.loc 1 2702 8 is_stmt 0 view .LVU1850
 6108 01ba 009B     		ldr	r3, [sp]
 6109 01bc 13B1     		cbz	r3, .L492
2703:Src/mpu6050.c **** 
 6110              		.loc 1 2703 9 is_stmt 1 view .LVU1851
 6111 01be 3046     		mov	r0, r6
 6112 01c0 FFF7FEFF 		bl	mpu_set_dmp_state
 6113              	.LVL414:
2705:Src/mpu6050.c **** }
 6114              		.loc 1 2705 5 view .LVU1852
 6115              	.L492:
2706:Src/mpu6050.c **** 
 6116              		.loc 1 2706 1 is_stmt 0 view .LVU1853
 6117 01c4 2846     		mov	r0, r5
 6118 01c6 15B0     		add	sp, sp, #84
 6119              	.LCFI95:
 6120              		.cfi_remember_state
 6121              		.cfi_def_cfa_offset 36
 6122              	.LVL415:
2706:Src/mpu6050.c **** 
 6123              		.loc 1 2706 1 view .LVU1854
 6124              		@ sp needed
 6125 01c8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 6126              	.LVL416:
 6127              	.L548:
 6128              	.LCFI96:
 6129              		.cfi_restore_state
2655:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 6130              		.loc 1 2655 30 is_stmt 1 view .LVU1855
2655:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 6131              		.loc 1 2655 18 view .LVU1856
2656:Src/mpu6050.c ****             break;
 6132              		.loc 1 2656 9 view .LVU1857
2656:Src/mpu6050.c ****             break;
 6133              		.loc 1 2656 14 is_stmt 0 view .LVU1858
 6134 01cc 0122     		movs	r2, #1
 6135 01ce 0EA9     		add	r1, sp, #56
 6136 01d0 0BA8     		add	r0, sp, #44
 6137 01d2 FFF7FEFF 		bl	get_st_biases
 6138              	.LVL417:
2656:Src/mpu6050.c ****             break;
 6139              		.loc 1 2656 12 view .LVU1859
 6140 01d6 0028     		cmp	r0, #0
 6141 01d8 CFD1     		bne	.L501
 6142 01da 43E7     		b	.L495
 6143              	.LVL418:
 6144              	.L549:
 6145              	.LBB39:
 6146              	.LBB30:
 6147              	.LBB29:
 6148              	.LBB28:
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6149              		.loc 1 1877 5 is_stmt 1 view .LVU1860
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6150              		.loc 1 1877 38 is_stmt 0 view .LVU1861
 6151 01dc 9DF82830 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
ARM GAS  /tmp/cc39PcX6.s 			page 205


 6152              		.loc 1 1877 51 view .LVU1862
 6153 01e0 9DF82B10 		ldrb	r1, [sp, #43]	@ zero_extendqisi2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6154              		.loc 1 1877 38 view .LVU1863
 6155 01e4 DB10     		asrs	r3, r3, #3
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6156              		.loc 1 1877 63 view .LVU1864
 6157 01e6 C1F30112 		ubfx	r2, r1, #4, #2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6158              		.loc 1 1877 38 view .LVU1865
 6159 01ea 03F01C03 		and	r3, r3, #28
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6160              		.loc 1 1877 44 view .LVU1866
 6161 01ee 1343     		orrs	r3, r3, r2
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6162              		.loc 1 1878 38 view .LVU1867
 6163 01f0 9DF82920 		ldrb	r2, [sp, #41]	@ zero_extendqisi2
1877:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6164              		.loc 1 1877 19 view .LVU1868
 6165 01f4 8DF82430 		strb	r3, [sp, #36]
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6166              		.loc 1 1878 5 is_stmt 1 view .LVU1869
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6167              		.loc 1 1878 38 is_stmt 0 view .LVU1870
 6168 01f8 D210     		asrs	r2, r2, #3
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6169              		.loc 1 1878 63 view .LVU1871
 6170 01fa C1F38103 		ubfx	r3, r1, #2, #2
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6171              		.loc 1 1878 38 view .LVU1872
 6172 01fe 02F01C02 		and	r2, r2, #28
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6173              		.loc 1 1878 44 view .LVU1873
 6174 0202 1A43     		orrs	r2, r2, r3
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6175              		.loc 1 1879 38 view .LVU1874
 6176 0204 9DF82A30 		ldrb	r3, [sp, #42]	@ zero_extendqisi2
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6177              		.loc 1 1879 54 view .LVU1875
 6178 0208 01F00301 		and	r1, r1, #3
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6179              		.loc 1 1879 38 view .LVU1876
 6180 020c DB10     		asrs	r3, r3, #3
 6181 020e 03F01C03 		and	r3, r3, #28
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6182              		.loc 1 1879 44 view .LVU1877
 6183 0212 0B43     		orrs	r3, r3, r1
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6184              		.loc 1 1879 19 view .LVU1878
 6185 0214 8DF82630 		strb	r3, [sp, #38]
1882:Src/mpu6050.c ****             continue;
 6186              		.loc 1 1882 26 view .LVU1879
 6187 0218 0023     		movs	r3, #0
1888:Src/mpu6050.c ****         while (--shift_code[ii])
 6188              		.loc 1 1888 22 view .LVU1880
 6189 021a DFF8DCB0 		ldr	fp, .L556+12
1890:Src/mpu6050.c ****     }
ARM GAS  /tmp/cc39PcX6.s 			page 206


 6190              		.loc 1 1890 26 view .LVU1881
 6191 021e 3749     		ldr	r1, .L556+16
1878:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6192              		.loc 1 1878 19 view .LVU1882
 6193 0220 8DF82520 		strb	r2, [sp, #37]
1879:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6194              		.loc 1 1879 5 is_stmt 1 view .LVU1883
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6195              		.loc 1 1880 5 view .LVU1884
 6196              	.LVL419:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6197              		.loc 1 1880 18 view .LVU1885
 6198 0224 0DF1240A 		add	r10, sp, #36
 6199 0228 0DF14409 		add	r9, sp, #68
 6200              	.LVL420:
 6201              	.L507:
1881:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6202              		.loc 1 1881 9 view .LVU1886
1881:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6203              		.loc 1 1881 24 is_stmt 0 view .LVU1887
 6204 022c 1AF8016B 		ldrb	r6, [r10], #1	@ zero_extendqisi2
1881:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6205              		.loc 1 1881 12 view .LVU1888
 6206 0230 46B9     		cbnz	r6, .L503
1882:Src/mpu6050.c ****             continue;
 6207              		.loc 1 1882 13 is_stmt 1 view .LVU1889
1882:Src/mpu6050.c ****             continue;
 6208              		.loc 1 1882 26 is_stmt 0 view .LVU1890
 6209 0232 C9F80030 		str	r3, [r9]	@ float
1883:Src/mpu6050.c ****         }
 6210              		.loc 1 1883 13 is_stmt 1 view .LVU1891
 6211              	.L504:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6212              		.loc 1 1880 26 view .LVU1892
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6213              		.loc 1 1880 28 is_stmt 0 view .LVU1893
 6214 0236 0135     		adds	r5, r5, #1
 6215              	.LVL421:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6216              		.loc 1 1880 28 view .LVU1894
 6217 0238 EDB2     		uxtb	r5, r5
 6218              	.LVL422:
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6219              		.loc 1 1880 18 is_stmt 1 view .LVU1895
1880:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6220              		.loc 1 1880 5 is_stmt 0 view .LVU1896
 6221 023a 032D     		cmp	r5, #3
 6222 023c 09F10409 		add	r9, r9, #4
 6223 0240 F4D1     		bne	.L507
 6224 0242 1AE7     		b	.L499
 6225              	.L503:
1888:Src/mpu6050.c ****         while (--shift_code[ii])
 6226              		.loc 1 1888 9 is_stmt 1 view .LVU1897
1888:Src/mpu6050.c ****         while (--shift_code[ii])
 6227              		.loc 1 1888 22 is_stmt 0 view .LVU1898
 6228 0244 C9F800B0 		str	fp, [r9]	@ float
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
ARM GAS  /tmp/cc39PcX6.s 			page 207


 6229              		.loc 1 1889 9 is_stmt 1 view .LVU1899
 6230              	.L505:
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6231              		.loc 1 1889 15 view .LVU1900
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6232              		.loc 1 1889 16 is_stmt 0 view .LVU1901
 6233 0248 013E     		subs	r6, r6, #1
1889:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6234              		.loc 1 1889 15 view .LVU1902
 6235 024a 16F0FF06 		ands	r6, r6, #255
 6236 024e 02D1     		bne	.L506
 6237 0250 0AF8016C 		strb	r6, [r10, #-1]
 6238 0254 EFE7     		b	.L504
 6239              	.L506:
1890:Src/mpu6050.c ****     }
 6240              		.loc 1 1890 26 view .LVU1903
 6241 0256 D9F80000 		ldr	r0, [r9]	@ float
 6242 025a CDE90113 		strd	r1, r3, [sp, #4]
 6243 025e FFF7FEFF 		bl	__aeabi_fmul
 6244              	.LVL423:
 6245 0262 DDE90113 		ldrd	r1, r3, [sp, #4]
 6246 0266 C9F80000 		str	r0, [r9]	@ float
 6247 026a EDE7     		b	.L505
 6248              	.LVL424:
 6249              	.L550:
1890:Src/mpu6050.c ****     }
 6250              		.loc 1 1890 26 view .LVU1904
 6251              	.LBE28:
 6252              	.LBE29:
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6253              		.loc 1 1907 16 is_stmt 1 view .LVU1905
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6254              		.loc 1 1907 19 is_stmt 0 view .LVU1906
 6255 026c 5046     		mov	r0, r10
 6256 026e 2449     		ldr	r1, .L556+20
 6257 0270 FFF7FEFF 		bl	__aeabi_fcmplt
 6258              	.LVL425:
 6259 0274 0028     		cmp	r0, #0
 6260 0276 7FF436AF 		bne	.L512
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6261              		.loc 1 1907 49 view .LVU1907
 6262 027a 5046     		mov	r0, r10
 6263 027c 2149     		ldr	r1, .L556+24
 6264 027e 2FE7     		b	.L553
 6265              	.LVL426:
 6266              	.L517:
1907:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6267              		.loc 1 1907 49 view .LVU1908
 6268              	.LBE30:
 6269              	.LBE39:
 6270              	.LBB40:
 6271              	.LBB35:
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6272              		.loc 1 1933 26 view .LVU1909
 6273 0280 2149     		ldr	r1, .L556+28
 6274 0282 0293     		str	r3, [sp, #8]
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
ARM GAS  /tmp/cc39PcX6.s 			page 208


 6275              		.loc 1 1933 17 is_stmt 1 view .LVU1910
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6276              		.loc 1 1933 26 is_stmt 0 view .LVU1911
 6277 0284 FFF7FEFF 		bl	__aeabi_fmul
 6278              	.LVL427:
1933:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6279              		.loc 1 1933 26 view .LVU1912
 6280 0288 029B     		ldr	r3, [sp, #8]
 6281              	.LVL428:
 6282              	.L515:
1932:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6283              		.loc 1 1932 19 is_stmt 1 view .LVU1913
1932:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6284              		.loc 1 1932 20 is_stmt 0 view .LVU1914
 6285 028a 013B     		subs	r3, r3, #1
1932:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6286              		.loc 1 1932 19 view .LVU1915
 6287 028c 13F0FF03 		ands	r3, r3, #255
 6288 0290 F6D1     		bne	.L517
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6289              		.loc 1 1934 42 view .LVU1916
 6290 0292 0146     		mov	r1, r0
 6291 0294 08F8013C 		strb	r3, [r8, #-1]
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6292              		.loc 1 1934 13 is_stmt 1 view .LVU1917
 6293              	.LVL429:
1935:Src/mpu6050.c ****                 result |= 1 << jj;
 6294              		.loc 1 1935 13 view .LVU1918
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6295              		.loc 1 1934 42 is_stmt 0 view .LVU1919
 6296 0298 5846     		mov	r0, fp
 6297              	.LVL430:
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6298              		.loc 1 1934 42 view .LVU1920
 6299 029a FFF7FEFF 		bl	__aeabi_fdiv
 6300              	.LVL431:
1934:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6301              		.loc 1 1934 26 view .LVU1921
 6302 029e 4FF07E51 		mov	r1, #1065353216
 6303 02a2 FFF7FEFF 		bl	__aeabi_fsub
 6304              	.LVL432:
1935:Src/mpu6050.c ****                 result |= 1 << jj;
 6305              		.loc 1 1935 16 view .LVU1922
 6306 02a6 1249     		ldr	r1, .L556+4
1935:Src/mpu6050.c ****                 result |= 1 << jj;
 6307              		.loc 1 1935 17 view .LVU1923
 6308 02a8 20F00040 		bic	r0, r0, #-2147483648
 6309              	.L555:
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6310              		.loc 1 1937 51 view .LVU1924
 6311 02ac FFF7FEFF 		bl	__aeabi_fcmpgt
 6312              	.LVL433:
 6313 02b0 10B1     		cbz	r0, .L518
 6314              	.L520:
1939:Src/mpu6050.c ****     }
 6315              		.loc 1 1939 13 is_stmt 1 view .LVU1925
1939:Src/mpu6050.c ****     }
ARM GAS  /tmp/cc39PcX6.s 			page 209


 6316              		.loc 1 1939 25 is_stmt 0 view .LVU1926
 6317 02b2 09FA06F3 		lsl	r3, r9, r6
1939:Src/mpu6050.c ****     }
 6318              		.loc 1 1939 20 view .LVU1927
 6319 02b6 1D43     		orrs	r5, r5, r3
 6320              	.LVL434:
 6321              	.L518:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6322              		.loc 1 1928 26 is_stmt 1 view .LVU1928
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6323              		.loc 1 1928 28 is_stmt 0 view .LVU1929
 6324 02b8 0136     		adds	r6, r6, #1
 6325              	.LVL435:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6326              		.loc 1 1928 18 is_stmt 1 view .LVU1930
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6327              		.loc 1 1928 5 is_stmt 0 view .LVU1931
 6328 02ba 032E     		cmp	r6, #3
 6329 02bc 7FF43FAF 		bne	.L522
 6330              	.LVL436:
 6331              	.L514:
1928:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6332              		.loc 1 1928 5 view .LVU1932
 6333              	.LBE35:
 6334              	.LBE40:
2666:Src/mpu6050.c ****     if (!gyro_result)
 6335              		.loc 1 2666 5 is_stmt 1 view .LVU1933
2667:Src/mpu6050.c ****         result |= 0x01;
 6336              		.loc 1 2667 5 view .LVU1934
2667:Src/mpu6050.c ****         result |= 0x01;
 6337              		.loc 1 2667 8 is_stmt 0 view .LVU1935
 6338 02c0 EDB2     		uxtb	r5, r5
2667:Src/mpu6050.c ****         result |= 0x01;
 6339              		.loc 1 2667 8 view .LVU1936
 6340 02c2 B5FA85F5 		clz	r5, r5
 6341              	.LVL437:
2669:Src/mpu6050.c ****         result |= 0x02;
 6342              		.loc 1 2669 8 view .LVU1937
 6343 02c6 019B     		ldr	r3, [sp, #4]
2667:Src/mpu6050.c ****         result |= 0x01;
 6344              		.loc 1 2667 8 view .LVU1938
 6345 02c8 6D09     		lsrs	r5, r5, #5
 6346              	.LVL438:
2669:Src/mpu6050.c ****         result |= 0x02;
 6347              		.loc 1 2669 5 is_stmt 1 view .LVU1939
2669:Src/mpu6050.c ****         result |= 0x02;
 6348              		.loc 1 2669 8 is_stmt 0 view .LVU1940
 6349 02ca 0BB9     		cbnz	r3, .L523
2670:Src/mpu6050.c **** 
 6350              		.loc 1 2670 9 is_stmt 1 view .LVU1941
2670:Src/mpu6050.c **** 
 6351              		.loc 1 2670 16 is_stmt 0 view .LVU1942
 6352 02cc 45F00205 		orr	r5, r5, #2
 6353              	.LVL439:
 6354              	.L523:
2677:Src/mpu6050.c **** #endif
 6355              		.loc 1 2677 9 is_stmt 1 view .LVU1943
ARM GAS  /tmp/cc39PcX6.s 			page 210


2677:Src/mpu6050.c **** #endif
 6356              		.loc 1 2677 16 is_stmt 0 view .LVU1944
 6357 02d0 45F00405 		orr	r5, r5, #4
 6358              	.LVL440:
2677:Src/mpu6050.c **** #endif
 6359              		.loc 1 2677 16 view .LVU1945
 6360 02d4 52E7     		b	.L498
 6361              	.LVL441:
 6362              	.L551:
 6363              	.LBB41:
 6364              	.LBB36:
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6365              		.loc 1 1937 16 is_stmt 1 view .LVU1946
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6366              		.loc 1 1937 19 is_stmt 0 view .LVU1947
 6367 02d6 0D49     		ldr	r1, .L556+32
 6368 02d8 FFF7FEFF 		bl	__aeabi_fcmplt
 6369              	.LVL442:
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6370              		.loc 1 1937 19 view .LVU1948
 6371 02dc 0028     		cmp	r0, #0
 6372 02de E8D1     		bne	.L520
1937:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6373              		.loc 1 1937 51 view .LVU1949
 6374 02e0 5846     		mov	r0, fp
 6375 02e2 0B49     		ldr	r1, .L556+36
 6376 02e4 E2E7     		b	.L555
 6377              	.LVL443:
 6378              	.L525:
1922:Src/mpu6050.c **** 
 6379              		.loc 1 1922 16 view .LVU1950
 6380 02e6 0725     		movs	r5, #7
 6381 02e8 EAE7     		b	.L514
 6382              	.L557:
 6383 02ea 00BF     		.align	2
 6384              	.L556:
 6385 02ec 00000000 		.word	.LANCHOR0
 6386 02f0 295C0F3E 		.word	1041194025
 6387 02f4 0000C841 		.word	1103626240
 6388 02f8 7B14AE3E 		.word	1051595899
 6389 02fc 1D5A843F 		.word	1065638429
 6390 0300 9A99993E 		.word	1050253722
 6391 0304 3333733F 		.word	1064514355
 6392 0308 54E3853F 		.word	1065739092
 6393 030c 00002041 		.word	1092616192
 6394 0310 0000D242 		.word	1121058816
 6395              	.LBE36:
 6396              	.LBE41:
 6397              		.cfi_endproc
 6398              	.LFE100:
 6400              		.section	.text.mpu_get_dmp_state,"ax",%progbits
 6401              		.align	1
 6402              		.global	mpu_get_dmp_state
 6403              		.syntax unified
 6404              		.thumb
 6405              		.thumb_func
 6406              		.fpu softvfp
ARM GAS  /tmp/cc39PcX6.s 			page 211


 6408              	mpu_get_dmp_state:
 6409              	.LVL444:
 6410              	.LFB105:
2863:Src/mpu6050.c ****     enabled[0] = st.chip_cfg.dmp_on;
 6411              		.loc 1 2863 1 is_stmt 1 view -0
 6412              		.cfi_startproc
 6413              		@ args = 0, pretend = 0, frame = 0
 6414              		@ frame_needed = 0, uses_anonymous_args = 0
 6415              		@ link register save eliminated.
2864:Src/mpu6050.c ****     return 0;
 6416              		.loc 1 2864 5 view .LVU1952
2864:Src/mpu6050.c ****     return 0;
 6417              		.loc 1 2864 29 is_stmt 0 view .LVU1953
 6418 0000 024B     		ldr	r3, .L559
 6419 0002 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
2864:Src/mpu6050.c ****     return 0;
 6420              		.loc 1 2864 16 view .LVU1954
 6421 0006 0370     		strb	r3, [r0]
2865:Src/mpu6050.c **** }
 6422              		.loc 1 2865 5 is_stmt 1 view .LVU1955
2866:Src/mpu6050.c **** 
 6423              		.loc 1 2866 1 is_stmt 0 view .LVU1956
 6424 0008 0020     		movs	r0, #0
 6425              	.LVL445:
2866:Src/mpu6050.c **** 
 6426              		.loc 1 2866 1 view .LVU1957
 6427 000a 7047     		bx	lr
 6428              	.L560:
 6429              		.align	2
 6430              	.L559:
 6431 000c 00000000 		.word	.LANCHOR0
 6432              		.cfi_endproc
 6433              	.LFE105:
 6435              		.section	.text.mpu_get_compass_reg,"ax",%progbits
 6436              		.align	1
 6437              		.global	mpu_get_compass_reg
 6438              		.syntax unified
 6439              		.thumb
 6440              		.thumb_func
 6441              		.fpu softvfp
 6443              	mpu_get_compass_reg:
 6444              	.LVL446:
 6445              	.LFB106:
2981:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 6446              		.loc 1 2981 1 is_stmt 1 view -0
 6447              		.cfi_startproc
 6448              		@ args = 0, pretend = 0, frame = 0
 6449              		@ frame_needed = 0, uses_anonymous_args = 0
 6450              		@ link register save eliminated.
3024:Src/mpu6050.c **** #endif
 6451              		.loc 1 3024 5 view .LVU1959
3026:Src/mpu6050.c **** 
 6452              		.loc 1 3026 1 is_stmt 0 view .LVU1960
 6453 0000 4FF0FF30 		mov	r0, #-1
 6454              	.LVL447:
3026:Src/mpu6050.c **** 
 6455              		.loc 1 3026 1 view .LVU1961
ARM GAS  /tmp/cc39PcX6.s 			page 212


 6456 0004 7047     		bx	lr
 6457              		.cfi_endproc
 6458              	.LFE106:
 6460              		.section	.text.mpu_get_compass_fsr,"ax",%progbits
 6461              		.align	1
 6462              		.global	mpu_get_compass_fsr
 6463              		.syntax unified
 6464              		.thumb
 6465              		.thumb_func
 6466              		.fpu softvfp
 6468              	mpu_get_compass_fsr:
 6469              	.LVL448:
 6470              	.LFB107:
3034:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 6471              		.loc 1 3034 1 is_stmt 1 view -0
 6472              		.cfi_startproc
 6473              		@ args = 0, pretend = 0, frame = 0
 6474              		@ frame_needed = 0, uses_anonymous_args = 0
 6475              		@ link register save eliminated.
3039:Src/mpu6050.c **** #endif
 6476              		.loc 1 3039 5 view .LVU1963
3041:Src/mpu6050.c **** 
 6477              		.loc 1 3041 1 is_stmt 0 view .LVU1964
 6478 0000 4FF0FF30 		mov	r0, #-1
 6479              	.LVL449:
3041:Src/mpu6050.c **** 
 6480              		.loc 1 3041 1 view .LVU1965
 6481 0004 7047     		bx	lr
 6482              		.cfi_endproc
 6483              	.LFE107:
 6485              		.section	.text.mpu_lp_motion_interrupt,"ax",%progbits
 6486              		.align	1
 6487              		.global	mpu_lp_motion_interrupt
 6488              		.syntax unified
 6489              		.thumb
 6490              		.thumb_func
 6491              		.fpu softvfp
 6493              	mpu_lp_motion_interrupt:
 6494              	.LVL450:
 6495              	.LFB108:
3082:Src/mpu6050.c **** 
 6496              		.loc 1 3082 1 is_stmt 1 view -0
 6497              		.cfi_startproc
 6498              		@ args = 0, pretend = 0, frame = 0
 6499              		@ frame_needed = 0, uses_anonymous_args = 0
3087:Src/mpu6050.c **** #if defined MPU6500
 6500              		.loc 1 3087 5 view .LVU1967
3082:Src/mpu6050.c **** 
 6501              		.loc 1 3082 1 is_stmt 0 view .LVU1968
 6502 0000 38B5     		push	{r3, r4, r5, lr}
 6503              	.LCFI97:
 6504              		.cfi_def_cfa_offset 16
 6505              		.cfi_offset 3, -16
 6506              		.cfi_offset 4, -12
 6507              		.cfi_offset 5, -8
 6508              		.cfi_offset 14, -4
3087:Src/mpu6050.c **** #if defined MPU6500
ARM GAS  /tmp/cc39PcX6.s 			page 213


 6509              		.loc 1 3087 8 view .LVU1969
 6510 0002 002A     		cmp	r2, #0
 6511 0004 3FD0     		beq	.L564
3100:Src/mpu6050.c ****             /* Minimum duration must be 1ms. */
 6512              		.loc 1 3100 9 is_stmt 1 view .LVU1970
 6513              	.LVL451:
3112:Src/mpu6050.c ****             /* Store current settings for later. */
 6514              		.loc 1 3112 9 view .LVU1971
3112:Src/mpu6050.c ****             /* Store current settings for later. */
 6515              		.loc 1 3112 25 is_stmt 0 view .LVU1972
 6516 0006 254C     		ldr	r4, .L575
3112:Src/mpu6050.c ****             /* Store current settings for later. */
 6517              		.loc 1 3112 12 view .LVU1973
 6518 0008 607D     		ldrb	r0, [r4, #21]	@ zero_extendqisi2
 6519              	.LVL452:
3112:Src/mpu6050.c ****             /* Store current settings for later. */
 6520              		.loc 1 3112 12 view .LVU1974
 6521 000a B8B9     		cbnz	r0, .L565
3114:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
 6522              		.loc 1 3114 13 is_stmt 1 view .LVU1975
3114:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
 6523              		.loc 1 3114 16 is_stmt 0 view .LVU1976
 6524 000c 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 6525 0010 13B1     		cbz	r3, .L566
3115:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 1;
 6526              		.loc 1 3115 17 is_stmt 1 view .LVU1977
 6527 0012 FFF7FEFF 		bl	mpu_set_dmp_state
 6528              	.LVL453:
3116:Src/mpu6050.c ****             } else
 6529              		.loc 1 3116 17 view .LVU1978
3116:Src/mpu6050.c ****             } else
 6530              		.loc 1 3116 42 is_stmt 0 view .LVU1979
 6531 0016 0123     		movs	r3, #1
 6532              	.L566:
3118:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
 6533              		.loc 1 3118 17 is_stmt 1 view .LVU1980
3119:Src/mpu6050.c ****             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
 6534              		.loc 1 3119 13 is_stmt 0 view .LVU1981
 6535 0018 2148     		ldr	r0, .L575+4
3118:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
 6536              		.loc 1 3118 42 view .LVU1982
 6537 001a 84F82030 		strb	r3, [r4, #32]
3119:Src/mpu6050.c ****             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
 6538              		.loc 1 3119 13 is_stmt 1 view .LVU1983
 6539 001e FFF7FEFF 		bl	mpu_get_gyro_fsr
 6540              	.LVL454:
3120:Src/mpu6050.c ****             mpu_get_lpf(&st.chip_cfg.cache.lpf);
 6541              		.loc 1 3120 13 view .LVU1984
 6542 0022 2048     		ldr	r0, .L575+8
 6543 0024 FFF7FEFF 		bl	mpu_get_accel_fsr
 6544              	.LVL455:
3121:Src/mpu6050.c ****             mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
 6545              		.loc 1 3121 13 view .LVU1985
 6546 0028 1F48     		ldr	r0, .L575+12
 6547 002a FFF7FEFF 		bl	mpu_get_lpf
 6548              	.LVL456:
3122:Src/mpu6050.c ****             st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
ARM GAS  /tmp/cc39PcX6.s 			page 214


 6549              		.loc 1 3122 13 view .LVU1986
 6550 002e 1F48     		ldr	r0, .L575+16
 6551 0030 FFF7FEFF 		bl	mpu_get_sample_rate
 6552              	.LVL457:
3123:Src/mpu6050.c ****             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
 6553              		.loc 1 3123 13 view .LVU1987
3123:Src/mpu6050.c ****             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
 6554              		.loc 1 3123 42 is_stmt 0 view .LVU1988
 6555 0034 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 6556 0036 A377     		strb	r3, [r4, #30]
3124:Src/mpu6050.c ****         }
 6557              		.loc 1 3124 13 is_stmt 1 view .LVU1989
 6558              	.LVL458:
 6559              	.LBB42:
 6560              	.LBI42:
1484:Src/mpu6050.c **** {
 6561              		.loc 1 1484 5 view .LVU1990
 6562              	.LBB43:
1486:Src/mpu6050.c ****     return 0;
 6563              		.loc 1 1486 5 view .LVU1991
1486:Src/mpu6050.c ****     return 0;
 6564              		.loc 1 1486 16 is_stmt 0 view .LVU1992
 6565 0038 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 6566 003a E377     		strb	r3, [r4, #31]
1487:Src/mpu6050.c **** }
 6567              		.loc 1 1487 5 is_stmt 1 view .LVU1993
 6568              	.LVL459:
 6569              	.L565:
1487:Src/mpu6050.c **** }
 6570              		.loc 1 1487 5 is_stmt 0 view .LVU1994
 6571              	.LBE43:
 6572              	.LBE42:
3198:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6573              		.loc 1 3198 5 is_stmt 1 view .LVU1995
3199:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 6574              		.loc 1 3199 5 view .LVU1996
3200:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 6575              		.loc 1 3200 5 view .LVU1997
3201:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6576              		.loc 1 3201 5 view .LVU1998
3201:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6577              		.loc 1 3201 29 is_stmt 0 view .LVU1999
 6578 003c 4FF6FF73 		movw	r3, #65535
 6579 0040 164C     		ldr	r4, .L575
3204:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6580              		.loc 1 3204 25 view .LVU2000
 6581 0042 0125     		movs	r5, #1
3201:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6582              		.loc 1 3201 29 view .LVU2001
 6583 0044 E381     		strh	r3, [r4, #14]	@ movhi
3202:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 6584              		.loc 1 3202 5 is_stmt 1 view .LVU2002
3203:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6585              		.loc 1 3203 5 view .LVU2003
3203:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6586              		.loc 1 3203 29 is_stmt 0 view .LVU2004
 6587 0046 2374     		strb	r3, [r4, #16]
ARM GAS  /tmp/cc39PcX6.s 			page 215


3204:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6588              		.loc 1 3204 5 is_stmt 1 view .LVU2005
3198:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6589              		.loc 1 3198 26 is_stmt 0 view .LVU2006
 6590 0048 4FF0FF33 		mov	r3, #-1
3205:Src/mpu6050.c ****     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
 6591              		.loc 1 3205 5 view .LVU2007
 6592 004c A07F     		ldrb	r0, [r4, #30]	@ zero_extendqisi2
3198:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6593              		.loc 1 3198 26 view .LVU2008
 6594 004e A360     		str	r3, [r4, #8]
3204:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6595              		.loc 1 3204 25 view .LVU2009
 6596 0050 2573     		strb	r5, [r4, #12]
3205:Src/mpu6050.c ****     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
 6597              		.loc 1 3205 5 is_stmt 1 view .LVU2010
 6598 0052 FFF7FEFF 		bl	mpu_set_sensors
 6599              	.LVL460:
3206:Src/mpu6050.c ****     mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
 6600              		.loc 1 3206 5 view .LVU2011
 6601 0056 E08A     		ldrh	r0, [r4, #22]
 6602 0058 FFF7FEFF 		bl	mpu_set_gyro_fsr
 6603              	.LVL461:
3207:Src/mpu6050.c ****     mpu_set_lpf(st.chip_cfg.cache.lpf);
 6604              		.loc 1 3207 5 view .LVU2012
 6605 005c 207E     		ldrb	r0, [r4, #24]	@ zero_extendqisi2
 6606 005e FFF7FEFF 		bl	mpu_set_accel_fsr
 6607              	.LVL462:
3208:Src/mpu6050.c ****     mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
 6608              		.loc 1 3208 5 view .LVU2013
 6609 0062 608B     		ldrh	r0, [r4, #26]
 6610 0064 FFF7FEFF 		bl	mpu_set_lpf
 6611              	.LVL463:
3209:Src/mpu6050.c ****     mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
 6612              		.loc 1 3209 5 view .LVU2014
 6613 0068 A08B     		ldrh	r0, [r4, #28]
 6614 006a FFF7FEFF 		bl	mpu_set_sample_rate
 6615              	.LVL464:
3210:Src/mpu6050.c **** 
 6616              		.loc 1 3210 5 view .LVU2015
 6617 006e E07F     		ldrb	r0, [r4, #31]	@ zero_extendqisi2
 6618 0070 FFF7FEFF 		bl	mpu_configure_fifo
 6619              	.LVL465:
3212:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 6620              		.loc 1 3212 5 view .LVU2016
3212:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 6621              		.loc 1 3212 8 is_stmt 0 view .LVU2017
 6622 0074 94F82030 		ldrb	r3, [r4, #32]	@ zero_extendqisi2
 6623 0078 13B1     		cbz	r3, .L570
3213:Src/mpu6050.c **** 
 6624              		.loc 1 3213 9 is_stmt 1 view .LVU2018
 6625 007a 2846     		mov	r0, r5
 6626 007c FFF7FEFF 		bl	mpu_set_dmp_state
 6627              	.LVL466:
 6628              	.L570:
3222:Src/mpu6050.c ****     return 0;
 6629              		.loc 1 3222 5 view .LVU2019
ARM GAS  /tmp/cc39PcX6.s 			page 216


3222:Src/mpu6050.c ****     return 0;
 6630              		.loc 1 3222 33 is_stmt 0 view .LVU2020
 6631 0080 0020     		movs	r0, #0
 6632 0082 6075     		strb	r0, [r4, #21]
3223:Src/mpu6050.c **** }
 6633              		.loc 1 3223 5 is_stmt 1 view .LVU2021
3223:Src/mpu6050.c **** }
 6634              		.loc 1 3223 12 is_stmt 0 view .LVU2022
 6635 0084 09E0     		b	.L563
 6636              	.LVL467:
 6637              	.L564:
3223:Src/mpu6050.c **** }
 6638              		.loc 1 3223 12 view .LVU2023
 6639 0086 064B     		ldr	r3, .L575+4
 6640              	.LVL468:
 6641              	.L568:
 6642              	.LBB44:
3190:Src/mpu6050.c ****                 goto lp_int_restore;
 6643              		.loc 1 3190 13 is_stmt 1 view .LVU2024
3190:Src/mpu6050.c ****                 goto lp_int_restore;
 6644              		.loc 1 3190 26 is_stmt 0 view .LVU2025
 6645 0088 13F8011B 		ldrb	r1, [r3], #1	@ zero_extendqisi2
3190:Src/mpu6050.c ****                 goto lp_int_restore;
 6646              		.loc 1 3190 16 view .LVU2026
 6647 008c 0029     		cmp	r1, #0
 6648 008e D5D1     		bne	.L565
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6649              		.loc 1 3189 54 is_stmt 1 discriminator 2 view .LVU2027
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6650              		.loc 1 3189 56 is_stmt 0 discriminator 2 view .LVU2028
 6651 0090 0132     		adds	r2, r2, #1
 6652              	.LVL469:
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6653              		.loc 1 3189 22 is_stmt 1 discriminator 2 view .LVU2029
3189:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6654              		.loc 1 3189 9 is_stmt 0 discriminator 2 view .LVU2030
 6655 0092 0C2A     		cmp	r2, #12
 6656 0094 F8D1     		bne	.L568
3194:Src/mpu6050.c ****     }
 6657              		.loc 1 3194 16 view .LVU2031
 6658 0096 4FF0FF30 		mov	r0, #-1
 6659              	.LVL470:
 6660              	.L563:
3194:Src/mpu6050.c ****     }
 6661              		.loc 1 3194 16 view .LVU2032
 6662              	.LBE44:
3224:Src/mpu6050.c **** 
 6663              		.loc 1 3224 1 view .LVU2033
 6664 009a 38BD     		pop	{r3, r4, r5, pc}
 6665              	.L576:
 6666              		.align	2
 6667              	.L575:
 6668 009c 00000000 		.word	.LANCHOR0
 6669 00a0 16000000 		.word	.LANCHOR0+22
 6670 00a4 18000000 		.word	.LANCHOR0+24
 6671 00a8 1A000000 		.word	.LANCHOR0+26
 6672 00ac 1C000000 		.word	.LANCHOR0+28
ARM GAS  /tmp/cc39PcX6.s 			page 217


 6673              		.cfi_endproc
 6674              	.LFE108:
 6676              		.section	.rodata.mpu_start_self_test.str1.1,"aMS",%progbits,1
 6677              	.LC11:
 6678 0000 50617373 		.ascii	"Passed!\015\012\000"
 6678      6564210D 
 6678      0A00
 6679              	.LC12:
 6680 000a 4779726F 		.ascii	"Gyro failed\015\012\000"
 6680      20666169 
 6680      6C65640D 
 6680      0A00
 6681              	.LC13:
 6682 0018 41636365 		.ascii	"Accel failed\015\012\000"
 6682      6C206661 
 6682      696C6564 
 6682      0D0A00
 6683              	.LC14:
 6684 0027 436F6D70 		.ascii	"Compass failed\015\012\000"
 6684      61737320 
 6684      6661696C 
 6684      65640D0A 
 6684      00
 6685              		.section	.text.mpu_start_self_test,"ax",%progbits
 6686              		.align	1
 6687              		.global	mpu_start_self_test
 6688              		.syntax unified
 6689              		.thumb
 6690              		.thumb_func
 6691              		.fpu softvfp
 6693              	mpu_start_self_test:
 6694              	.LFB109:
3231:Src/mpu6050.c ****     int result;
 6695              		.loc 1 3231 1 is_stmt 1 view -0
 6696              		.cfi_startproc
 6697              		@ args = 0, pretend = 0, frame = 24
 6698              		@ frame_needed = 0, uses_anonymous_args = 0
3232:Src/mpu6050.c ****     long gyro[3], accel[3];
 6699              		.loc 1 3232 5 view .LVU2035
3233:Src/mpu6050.c **** 
 6700              		.loc 1 3233 5 view .LVU2036
3238:Src/mpu6050.c **** #endif
 6701              		.loc 1 3238 5 view .LVU2037
3231:Src/mpu6050.c ****     int result;
 6702              		.loc 1 3231 1 is_stmt 0 view .LVU2038
 6703 0000 10B5     		push	{r4, lr}
 6704              	.LCFI98:
 6705              		.cfi_def_cfa_offset 8
 6706              		.cfi_offset 4, -8
 6707              		.cfi_offset 14, -4
 6708 0002 86B0     		sub	sp, sp, #24
 6709              	.LCFI99:
 6710              		.cfi_def_cfa_offset 32
3238:Src/mpu6050.c **** #endif
 6711              		.loc 1 3238 14 view .LVU2039
 6712 0004 6846     		mov	r0, sp
 6713 0006 03A9     		add	r1, sp, #12
ARM GAS  /tmp/cc39PcX6.s 			page 218


 6714 0008 FFF7FEFF 		bl	mpu_run_self_test
 6715              	.LVL471:
3250:Src/mpu6050.c ****         consoleLog("Passed!\r\n");
 6716              		.loc 1 3250 8 view .LVU2040
 6717 000c 0728     		cmp	r0, #7
3238:Src/mpu6050.c **** #endif
 6718              		.loc 1 3238 14 view .LVU2041
 6719 000e 0446     		mov	r4, r0
 6720              	.LVL472:
3250:Src/mpu6050.c ****         consoleLog("Passed!\r\n");
 6721              		.loc 1 3250 5 is_stmt 1 view .LVU2042
3250:Src/mpu6050.c ****         consoleLog("Passed!\r\n");
 6722              		.loc 1 3250 8 is_stmt 0 view .LVU2043
 6723 0010 04D1     		bne	.L578
3251:Src/mpu6050.c ****         /* Test passed. We can trust the gyro data here, so now we need to update calibrated data*/
 6724              		.loc 1 3251 9 is_stmt 1 view .LVU2044
 6725 0012 0948     		ldr	r0, .L583
 6726              	.LVL473:
 6727              	.L582:
3283:Src/mpu6050.c ****      }
 6728              		.loc 1 3283 13 is_stmt 0 view .LVU2045
 6729 0014 FFF7FEFF 		bl	consoleLog
 6730              	.LVL474:
 6731              	.L577:
3286:Src/mpu6050.c **** 
 6732              		.loc 1 3286 1 view .LVU2046
 6733 0018 06B0     		add	sp, sp, #24
 6734              	.LCFI100:
 6735              		.cfi_remember_state
 6736              		.cfi_def_cfa_offset 8
 6737              		@ sp needed
 6738 001a 10BD     		pop	{r4, pc}
 6739              	.LVL475:
 6740              	.L578:
 6741              	.LCFI101:
 6742              		.cfi_restore_state
3278:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
 6743              		.loc 1 3278 9 is_stmt 1 view .LVU2047
3278:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
 6744              		.loc 1 3278 12 is_stmt 0 view .LVU2048
 6745 001c C107     		lsls	r1, r0, #31
 6746 001e 02D4     		bmi	.L580
3279:Src/mpu6050.c ****         if (!(result & 0x2))
 6747              		.loc 1 3279 13 is_stmt 1 view .LVU2049
 6748 0020 0648     		ldr	r0, .L583+4
 6749              	.LVL476:
3279:Src/mpu6050.c ****         if (!(result & 0x2))
 6750              		.loc 1 3279 13 is_stmt 0 view .LVU2050
 6751 0022 FFF7FEFF 		bl	consoleLog
 6752              	.LVL477:
 6753              	.L580:
3280:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
 6754              		.loc 1 3280 9 is_stmt 1 view .LVU2051
3280:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
 6755              		.loc 1 3280 12 is_stmt 0 view .LVU2052
 6756 0026 A207     		lsls	r2, r4, #30
 6757 0028 02D4     		bmi	.L581
ARM GAS  /tmp/cc39PcX6.s 			page 219


3281:Src/mpu6050.c ****         if (!(result & 0x4))
 6758              		.loc 1 3281 13 is_stmt 1 view .LVU2053
 6759 002a 0548     		ldr	r0, .L583+8
 6760 002c FFF7FEFF 		bl	consoleLog
 6761              	.LVL478:
 6762              	.L581:
3282:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6763              		.loc 1 3282 9 view .LVU2054
3282:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6764              		.loc 1 3282 12 is_stmt 0 view .LVU2055
 6765 0030 6307     		lsls	r3, r4, #29
 6766 0032 F1D4     		bmi	.L577
3283:Src/mpu6050.c ****      }
 6767              		.loc 1 3283 13 is_stmt 1 view .LVU2056
 6768 0034 0348     		ldr	r0, .L583+12
 6769 0036 EDE7     		b	.L582
 6770              	.L584:
 6771              		.align	2
 6772              	.L583:
 6773 0038 00000000 		.word	.LC11
 6774 003c 0A000000 		.word	.LC12
 6775 0040 18000000 		.word	.LC13
 6776 0044 27000000 		.word	.LC14
 6777              		.cfi_endproc
 6778              	.LFE109:
 6780              		.section	.rodata.mpu_setup_gyro.str1.1,"aMS",%progbits,1
 6781              	.LC15:
 6782 0000 41636365 		.ascii	"Accel ON\015\012\000"
 6782      6C204F4E 
 6782      0D0A00
 6783              	.LC16:
 6784 000b 41636365 		.ascii	"Accel OFF\015\012\000"
 6784      6C204F46 
 6784      460D0A00 
 6785              	.LC17:
 6786 0017 4779726F 		.ascii	"Gyro ON\015\012\000"
 6786      204F4E0D 
 6786      0A00
 6787              	.LC18:
 6788 0021 4779726F 		.ascii	"Gyro OFF\015\012\000"
 6788      204F4646 
 6788      0D0A00
 6789              		.section	.text.mpu_setup_gyro,"ax",%progbits
 6790              		.align	1
 6791              		.global	mpu_setup_gyro
 6792              		.syntax unified
 6793              		.thumb
 6794              		.thumb_func
 6795              		.fpu softvfp
 6797              	mpu_setup_gyro:
 6798              	.LFB110:
3308:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
 6799              		.loc 1 3308 1 view -0
 6800              		.cfi_startproc
 6801              		@ args = 0, pretend = 0, frame = 8
 6802              		@ frame_needed = 0, uses_anonymous_args = 0
3309:Src/mpu6050.c ****     if (hal.sensors & ACCEL_ON) {
ARM GAS  /tmp/cc39PcX6.s 			page 220


 6803              		.loc 1 3309 5 view .LVU2058
 6804              	.LVL479:
3310:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6805              		.loc 1 3310 5 view .LVU2059
3308:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
 6806              		.loc 1 3308 1 is_stmt 0 view .LVU2060
 6807 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 6808              	.LCFI102:
 6809              		.cfi_def_cfa_offset 24
 6810              		.cfi_offset 4, -16
 6811              		.cfi_offset 5, -12
 6812              		.cfi_offset 6, -8
 6813              		.cfi_offset 14, -4
3310:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6814              		.loc 1 3310 12 view .LVU2061
 6815 0002 134E     		ldr	r6, .L595
 6816 0004 7478     		ldrb	r4, [r6, #1]	@ zero_extendqisi2
3310:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6817              		.loc 1 3310 8 view .LVU2062
 6818 0006 14F00104 		ands	r4, r4, #1
 6819 000a 1DD0     		beq	.L586
3311:Src/mpu6050.c ****         consoleLog("Accel ON\r\n");
 6820              		.loc 1 3311 9 is_stmt 1 view .LVU2063
 6821              	.LVL480:
3312:Src/mpu6050.c ****     } else {
 6822              		.loc 1 3312 9 view .LVU2064
 6823 000c 1148     		ldr	r0, .L595+4
 6824 000e FFF7FEFF 		bl	consoleLog
 6825              	.LVL481:
3311:Src/mpu6050.c ****         consoleLog("Accel ON\r\n");
 6826              		.loc 1 3311 14 is_stmt 0 view .LVU2065
 6827 0012 0824     		movs	r4, #8
 6828              	.LVL482:
 6829              	.L587:
3316:Src/mpu6050.c ****         mask |= INV_XYZ_GYRO;
 6830              		.loc 1 3316 5 is_stmt 1 view .LVU2066
 6831 0014 7578     		ldrb	r5, [r6, #1]	@ zero_extendqisi2
3316:Src/mpu6050.c ****         mask |= INV_XYZ_GYRO;
 6832              		.loc 1 3316 8 is_stmt 0 view .LVU2067
 6833 0016 15F00205 		ands	r5, r5, #2
3317:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
 6834              		.loc 1 3317 9 is_stmt 1 view .LVU2068
3317:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
 6835              		.loc 1 3317 14 is_stmt 0 view .LVU2069
 6836 001a 1BBF     		ittet	ne
 6837 001c 44F07004 		orrne	r4, r4, #112
 6838              	.LVL483:
3318:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6839              		.loc 1 3318 9 is_stmt 1 view .LVU2070
3319:Src/mpu6050.c ****     } else {
 6840              		.loc 1 3319 9 is_stmt 0 view .LVU2071
 6841 0020 0D48     		ldrne	r0, .L595+8
3321:Src/mpu6050.c ****     }
 6842              		.loc 1 3321 9 view .LVU2072
 6843 0022 0E48     		ldreq	r0, .L595+12
3318:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6844              		.loc 1 3318 31 view .LVU2073
ARM GAS  /tmp/cc39PcX6.s 			page 221


 6845 0024 3578     		ldrbne	r5, [r6]	@ zero_extendqisi2
 6846              	.LVL484:
3319:Src/mpu6050.c ****     } else {
 6847              		.loc 1 3319 9 is_stmt 1 view .LVU2074
3321:Src/mpu6050.c ****     }
 6848              		.loc 1 3321 9 view .LVU2075
 6849 0026 FFF7FEFF 		bl	consoleLog
 6850              	.LVL485:
3333:Src/mpu6050.c ****     mpu_configure_fifo(mask);
 6851              		.loc 1 3333 5 view .LVU2076
 6852 002a 2046     		mov	r0, r4
 6853 002c FFF7FEFF 		bl	mpu_set_sensors
 6854              	.LVL486:
3334:Src/mpu6050.c ****     if (lp_accel_was_on) {
 6855              		.loc 1 3334 5 view .LVU2077
 6856 0030 2046     		mov	r0, r4
 6857 0032 FFF7FEFF 		bl	mpu_configure_fifo
 6858              	.LVL487:
3335:Src/mpu6050.c ****         unsigned short rate;
 6859              		.loc 1 3335 5 view .LVU2078
3335:Src/mpu6050.c ****         unsigned short rate;
 6860              		.loc 1 3335 8 is_stmt 0 view .LVU2079
 6861 0036 2DB1     		cbz	r5, .L585
 6862              	.LBB45:
3336:Src/mpu6050.c ****         hal.lp_accel_mode = 0;
 6863              		.loc 1 3336 9 is_stmt 1 view .LVU2080
3337:Src/mpu6050.c ****         /* Switching out of LP accel, notify MPL of new accel sampling rate. */
 6864              		.loc 1 3337 9 view .LVU2081
3337:Src/mpu6050.c ****         /* Switching out of LP accel, notify MPL of new accel sampling rate. */
 6865              		.loc 1 3337 27 is_stmt 0 view .LVU2082
 6866 0038 0023     		movs	r3, #0
3339:Src/mpu6050.c ****     }
 6867              		.loc 1 3339 9 view .LVU2083
 6868 003a 0DF10600 		add	r0, sp, #6
3337:Src/mpu6050.c ****         /* Switching out of LP accel, notify MPL of new accel sampling rate. */
 6869              		.loc 1 3337 27 view .LVU2084
 6870 003e 3370     		strb	r3, [r6]
3339:Src/mpu6050.c ****     }
 6871              		.loc 1 3339 9 is_stmt 1 view .LVU2085
 6872 0040 FFF7FEFF 		bl	mpu_get_sample_rate
 6873              	.LVL488:
 6874              	.L585:
 6875              	.LBE45:
3341:Src/mpu6050.c **** 
 6876              		.loc 1 3341 1 is_stmt 0 view .LVU2086
 6877 0044 02B0     		add	sp, sp, #8
 6878              	.LCFI103:
 6879              		.cfi_remember_state
 6880              		.cfi_def_cfa_offset 16
 6881              		@ sp needed
 6882 0046 70BD     		pop	{r4, r5, r6, pc}
 6883              	.LVL489:
 6884              	.L586:
 6885              	.LCFI104:
 6886              		.cfi_restore_state
3314:Src/mpu6050.c ****     }
 6887              		.loc 1 3314 9 is_stmt 1 view .LVU2087
ARM GAS  /tmp/cc39PcX6.s 			page 222


 6888 0048 0548     		ldr	r0, .L595+16
 6889 004a FFF7FEFF 		bl	consoleLog
 6890              	.LVL490:
 6891 004e E1E7     		b	.L587
 6892              	.L596:
 6893              		.align	2
 6894              	.L595:
 6895 0050 00000000 		.word	.LANCHOR2
 6896 0054 00000000 		.word	.LC15
 6897 0058 17000000 		.word	.LC17
 6898 005c 21000000 		.word	.LC18
 6899 0060 0B000000 		.word	.LC16
 6900              		.cfi_endproc
 6901              	.LFE110:
 6903              		.section	.text.inv_row_2_scale,"ax",%progbits
 6904              		.align	1
 6905              		.global	inv_row_2_scale
 6906              		.syntax unified
 6907              		.thumb
 6908              		.thumb_func
 6909              		.fpu softvfp
 6911              	inv_row_2_scale:
 6912              	.LVL491:
 6913              	.LFB111:
3344:Src/mpu6050.c ****     unsigned short b;
 6914              		.loc 1 3344 1 view -0
 6915              		.cfi_startproc
 6916              		@ args = 0, pretend = 0, frame = 0
 6917              		@ frame_needed = 0, uses_anonymous_args = 0
 6918              		@ link register save eliminated.
3345:Src/mpu6050.c **** 
 6919              		.loc 1 3345 5 view .LVU2089
3347:Src/mpu6050.c ****         b = 0;
 6920              		.loc 1 3347 5 view .LVU2090
3347:Src/mpu6050.c ****         b = 0;
 6921              		.loc 1 3347 12 is_stmt 0 view .LVU2091
 6922 0000 90F90030 		ldrsb	r3, [r0]
3347:Src/mpu6050.c ****         b = 0;
 6923              		.loc 1 3347 8 view .LVU2092
 6924 0004 002B     		cmp	r3, #0
 6925 0006 0CDC     		bgt	.L599
3349:Src/mpu6050.c ****         b = 4;
 6926              		.loc 1 3349 10 is_stmt 1 view .LVU2093
3349:Src/mpu6050.c ****         b = 4;
 6927              		.loc 1 3349 13 is_stmt 0 view .LVU2094
 6928 0008 0DD1     		bne	.L600
3351:Src/mpu6050.c ****         b = 1;
 6929              		.loc 1 3351 10 is_stmt 1 view .LVU2095
3351:Src/mpu6050.c ****         b = 1;
 6930              		.loc 1 3351 17 is_stmt 0 view .LVU2096
 6931 000a 90F90130 		ldrsb	r3, [r0, #1]
3351:Src/mpu6050.c ****         b = 1;
 6932              		.loc 1 3351 13 view .LVU2097
 6933 000e 002B     		cmp	r3, #0
 6934 0010 0BDC     		bgt	.L601
3353:Src/mpu6050.c ****         b = 5;
 6935              		.loc 1 3353 10 is_stmt 1 view .LVU2098
ARM GAS  /tmp/cc39PcX6.s 			page 223


3353:Src/mpu6050.c ****         b = 5;
 6936              		.loc 1 3353 13 is_stmt 0 view .LVU2099
 6937 0012 0CD1     		bne	.L602
 6938              	.LVL492:
 6939              	.LBB48:
 6940              	.LBI48:
3343:Src/mpu6050.c **** {
 6941              		.loc 1 3343 16 is_stmt 1 view .LVU2100
 6942              	.LBB49:
3355:Src/mpu6050.c ****         b = 2;
 6943              		.loc 1 3355 10 view .LVU2101
3355:Src/mpu6050.c ****         b = 2;
 6944              		.loc 1 3355 17 is_stmt 0 view .LVU2102
 6945 0014 90F90230 		ldrsb	r3, [r0, #2]
3355:Src/mpu6050.c ****         b = 2;
 6946              		.loc 1 3355 13 view .LVU2103
 6947 0018 002B     		cmp	r3, #0
 6948 001a 0ADC     		bgt	.L603
3357:Src/mpu6050.c ****         b = 6;
 6949              		.loc 1 3357 10 is_stmt 1 view .LVU2104
3357:Src/mpu6050.c ****         b = 6;
 6950              		.loc 1 3357 13 is_stmt 0 view .LVU2105
 6951 001c 0BD1     		bne	.L604
3360:Src/mpu6050.c ****     return b;
 6952              		.loc 1 3360 11 view .LVU2106
 6953 001e 0720     		movs	r0, #7
 6954              	.LVL493:
3360:Src/mpu6050.c ****     return b;
 6955              		.loc 1 3360 11 view .LVU2107
 6956 0020 7047     		bx	lr
 6957              	.LVL494:
 6958              	.L599:
3360:Src/mpu6050.c ****     return b;
 6959              		.loc 1 3360 11 view .LVU2108
 6960              	.LBE49:
 6961              	.LBE48:
3348:Src/mpu6050.c ****     else if (row[0] < 0)
 6962              		.loc 1 3348 11 view .LVU2109
 6963 0022 0020     		movs	r0, #0
 6964              	.LVL495:
3348:Src/mpu6050.c ****     else if (row[0] < 0)
 6965              		.loc 1 3348 11 view .LVU2110
 6966 0024 7047     		bx	lr
 6967              	.LVL496:
 6968              	.L600:
3350:Src/mpu6050.c ****     else if (row[1] > 0)
 6969              		.loc 1 3350 11 view .LVU2111
 6970 0026 0420     		movs	r0, #4
 6971              	.LVL497:
3350:Src/mpu6050.c ****     else if (row[1] > 0)
 6972              		.loc 1 3350 11 view .LVU2112
 6973 0028 7047     		bx	lr
 6974              	.LVL498:
 6975              	.L601:
3352:Src/mpu6050.c ****     else if (row[1] < 0)
 6976              		.loc 1 3352 11 view .LVU2113
 6977 002a 0120     		movs	r0, #1
ARM GAS  /tmp/cc39PcX6.s 			page 224


 6978              	.LVL499:
3352:Src/mpu6050.c ****     else if (row[1] < 0)
 6979              		.loc 1 3352 11 view .LVU2114
 6980 002c 7047     		bx	lr
 6981              	.LVL500:
 6982              	.L602:
3354:Src/mpu6050.c ****     else if (row[2] > 0)
 6983              		.loc 1 3354 11 view .LVU2115
 6984 002e 0520     		movs	r0, #5
 6985              	.LVL501:
3354:Src/mpu6050.c ****     else if (row[2] > 0)
 6986              		.loc 1 3354 11 view .LVU2116
 6987 0030 7047     		bx	lr
 6988              	.LVL502:
 6989              	.L603:
 6990              	.LBB51:
 6991              	.LBB50:
3356:Src/mpu6050.c ****     else if (row[2] < 0)
 6992              		.loc 1 3356 11 view .LVU2117
 6993 0032 0220     		movs	r0, #2
 6994              	.LVL503:
3356:Src/mpu6050.c ****     else if (row[2] < 0)
 6995              		.loc 1 3356 11 view .LVU2118
 6996 0034 7047     		bx	lr
 6997              	.LVL504:
 6998              	.L604:
3358:Src/mpu6050.c ****     else
 6999              		.loc 1 3358 11 view .LVU2119
 7000 0036 0620     		movs	r0, #6
 7001              	.LVL505:
3358:Src/mpu6050.c ****     else
 7002              		.loc 1 3358 11 view .LVU2120
 7003              	.LBE50:
 7004              	.LBE51:
3361:Src/mpu6050.c **** }
 7005              		.loc 1 3361 5 is_stmt 1 view .LVU2121
3362:Src/mpu6050.c **** 
 7006              		.loc 1 3362 1 is_stmt 0 view .LVU2122
 7007 0038 7047     		bx	lr
 7008              		.cfi_endproc
 7009              	.LFE111:
 7011              		.section	.text.inv_orientation_matrix_to_scalar,"ax",%progbits
 7012              		.align	1
 7013              		.global	inv_orientation_matrix_to_scalar
 7014              		.syntax unified
 7015              		.thumb
 7016              		.thumb_func
 7017              		.fpu softvfp
 7019              	inv_orientation_matrix_to_scalar:
 7020              	.LVL506:
 7021              	.LFB112:
3368:Src/mpu6050.c ****     unsigned short scalar;
 7022              		.loc 1 3368 1 is_stmt 1 view -0
 7023              		.cfi_startproc
 7024              		@ args = 0, pretend = 0, frame = 0
 7025              		@ frame_needed = 0, uses_anonymous_args = 0
3369:Src/mpu6050.c ****     scalar  = inv_row_2_scale(mtx);
ARM GAS  /tmp/cc39PcX6.s 			page 225


 7026              		.loc 1 3369 5 view .LVU2124
3370:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 3) << 3;
 7027              		.loc 1 3370 5 view .LVU2125
3368:Src/mpu6050.c ****     unsigned short scalar;
 7028              		.loc 1 3368 1 is_stmt 0 view .LVU2126
 7029 0000 10B5     		push	{r4, lr}
 7030              	.LCFI105:
 7031              		.cfi_def_cfa_offset 8
 7032              		.cfi_offset 4, -8
 7033              		.cfi_offset 14, -4
3368:Src/mpu6050.c ****     unsigned short scalar;
 7034              		.loc 1 3368 1 view .LVU2127
 7035 0002 0246     		mov	r2, r0
3370:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 3) << 3;
 7036              		.loc 1 3370 15 view .LVU2128
 7037 0004 FFF7FEFF 		bl	inv_row_2_scale
 7038              	.LVL507:
3370:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 3) << 3;
 7039              		.loc 1 3370 15 view .LVU2129
 7040 0008 0146     		mov	r1, r0
 7041              	.LVL508:
3371:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 6) << 6;
 7042              		.loc 1 3371 5 is_stmt 1 view .LVU2130
3371:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 6) << 6;
 7043              		.loc 1 3371 15 is_stmt 0 view .LVU2131
 7044 000a D01C     		adds	r0, r2, #3
 7045 000c FFF7FEFF 		bl	inv_row_2_scale
 7046              	.LVL509:
 7047 0010 0446     		mov	r4, r0
 7048              	.LVL510:
3372:Src/mpu6050.c **** 
 7049              		.loc 1 3372 5 is_stmt 1 view .LVU2132
3372:Src/mpu6050.c **** 
 7050              		.loc 1 3372 15 is_stmt 0 view .LVU2133
 7051 0012 901D     		adds	r0, r2, #6
 7052 0014 FFF7FEFF 		bl	inv_row_2_scale
 7053              	.LVL511:
3372:Src/mpu6050.c **** 
 7054              		.loc 1 3372 40 view .LVU2134
 7055 0018 8301     		lsls	r3, r0, #6
3372:Src/mpu6050.c **** 
 7056              		.loc 1 3372 12 view .LVU2135
 7057 001a 43EAC403 		orr	r3, r3, r4, lsl #3
 7058 001e 43EA0100 		orr	r0, r3, r1
 7059              	.LVL512:
3374:Src/mpu6050.c **** }
 7060              		.loc 1 3374 5 is_stmt 1 view .LVU2136
3375:Src/mpu6050.c **** 
 7061              		.loc 1 3375 1 is_stmt 0 view .LVU2137
 7062 0022 80B2     		uxth	r0, r0
3375:Src/mpu6050.c **** 
 7063              		.loc 1 3375 1 view .LVU2138
 7064 0024 10BD     		pop	{r4, pc}
 7065              		.cfi_endproc
 7066              	.LFE112:
 7068              		.section	.rodata.mpu_config.str1.1,"aMS",%progbits,1
 7069              	.LC19:
ARM GAS  /tmp/cc39PcX6.s 			page 226


 7070 0000 436F6E66 		.ascii	"Configuring MPU6050... \000"
 7070      69677572 
 7070      696E6720 
 7070      4D505536 
 7070      3035302E 
 7071              	.LC20:
 7072 0018 4641494C 		.ascii	"FAIL (MPU)\015\012\000"
 7072      20284D50 
 7072      55290D0A 
 7072      00
 7073              	.LC21:
 7074 0025 20777269 		.ascii	" writing DMP... \000"
 7074      74696E67 
 7074      20444D50 
 7074      2E2E2E20 
 7074      00
 7075              	.LC22:
 7076 0036 20464149 		.ascii	" FAIL (DMP)\015\012\000"
 7076      4C202844 
 7076      4D50290D 
 7076      0A00
 7077              	.LC23:
 7078 0044 204F4B0D 		.ascii	" OK\015\012\000"
 7078      0A00
 7079              		.section	.text.mpu_config,"ax",%progbits
 7080              		.align	1
 7081              		.global	mpu_config
 7082              		.syntax unified
 7083              		.thumb
 7084              		.thumb_func
 7085              		.fpu softvfp
 7087              	mpu_config:
 7088              	.LFB113:
3384:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
 7089              		.loc 1 3384 1 is_stmt 1 view -0
 7090              		.cfi_startproc
 7091              		@ args = 0, pretend = 0, frame = 0
 7092              		@ frame_needed = 0, uses_anonymous_args = 0
3385:Src/mpu6050.c **** 
 7093              		.loc 1 3385 5 view .LVU2140
3384:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
 7094              		.loc 1 3384 1 is_stmt 0 view .LVU2141
 7095 0000 38B5     		push	{r3, r4, r5, lr}
 7096              	.LCFI106:
 7097              		.cfi_def_cfa_offset 16
 7098              		.cfi_offset 3, -16
 7099              		.cfi_offset 4, -12
 7100              		.cfi_offset 5, -8
 7101              		.cfi_offset 14, -4
3385:Src/mpu6050.c **** 
 7102              		.loc 1 3385 5 view .LVU2142
 7103 0002 2148     		ldr	r0, .L611
 7104 0004 FFF7FEFF 		bl	consoleLog
 7105              	.LVL513:
3387:Src/mpu6050.c ****         consoleLog("FAIL (MPU)\r\n");
 7106              		.loc 1 3387 5 is_stmt 1 view .LVU2143
3387:Src/mpu6050.c ****         consoleLog("FAIL (MPU)\r\n");
ARM GAS  /tmp/cc39PcX6.s 			page 227


 7107              		.loc 1 3387 8 is_stmt 0 view .LVU2144
 7108 0008 FFF7FEFF 		bl	mpu_init
 7109              	.LVL514:
3387:Src/mpu6050.c ****         consoleLog("FAIL (MPU)\r\n");
 7110              		.loc 1 3387 7 view .LVU2145
 7111 000c 0546     		mov	r5, r0
 7112 000e 30B1     		cbz	r0, .L607
3388:Src/mpu6050.c ****         return -1;
 7113              		.loc 1 3388 9 is_stmt 1 view .LVU2146
 7114 0010 1E48     		ldr	r0, .L611+4
 7115              	.L610:
3445:Src/mpu6050.c ****             return -1;
 7116              		.loc 1 3445 13 is_stmt 0 view .LVU2147
 7117 0012 FFF7FEFF 		bl	consoleLog
 7118              	.LVL515:
3446:Src/mpu6050.c ****         }
 7119              		.loc 1 3446 13 is_stmt 1 view .LVU2148
3446:Src/mpu6050.c ****         }
 7120              		.loc 1 3446 20 is_stmt 0 view .LVU2149
 7121 0016 4FF0FF35 		mov	r5, #-1
 7122              	.L606:
3474:Src/mpu6050.c **** 
 7123              		.loc 1 3474 1 view .LVU2150
 7124 001a 2846     		mov	r0, r5
 7125 001c 38BD     		pop	{r3, r4, r5, pc}
 7126              	.L607:
3394:Src/mpu6050.c **** 
 7127              		.loc 1 3394 5 is_stmt 1 view .LVU2151
 7128 001e 7820     		movs	r0, #120
 7129 0020 FFF7FEFF 		bl	mpu_set_sensors
 7130              	.LVL516:
3397:Src/mpu6050.c ****     mpu_set_sample_rate(MPU_DEFAULT_HZ);
 7131              		.loc 1 3397 5 view .LVU2152
 7132 0024 7820     		movs	r0, #120
 7133 0026 FFF7FEFF 		bl	mpu_configure_fifo
 7134              	.LVL517:
3398:Src/mpu6050.c **** 
 7135              		.loc 1 3398 5 view .LVU2153
 7136 002a 1420     		movs	r0, #20
 7137 002c FFF7FEFF 		bl	mpu_set_sample_rate
 7138              	.LVL518:
3406:Src/mpu6050.c ****     hal.dmp_on              = 0;
 7139              		.loc 1 3406 5 view .LVU2154
3406:Src/mpu6050.c ****     hal.dmp_on              = 0;
 7140              		.loc 1 3406 29 is_stmt 0 view .LVU2155
 7141 0030 0323     		movs	r3, #3
 7142 0032 174C     		ldr	r4, .L611+8
3443:Src/mpu6050.c ****         if (dmp_load_motion_driver_firmware()) {
 7143              		.loc 1 3443 9 view .LVU2156
 7144 0034 1748     		ldr	r0, .L611+12
3410:Src/mpu6050.c **** 
 7145              		.loc 1 3410 29 view .LVU2157
 7146 0036 C4E90355 		strd	r5, r5, [r4, #12]
3406:Src/mpu6050.c ****     hal.dmp_on              = 0;
 7147              		.loc 1 3406 29 view .LVU2158
 7148 003a 6370     		strb	r3, [r4, #1]
3407:Src/mpu6050.c ****     hal.report              = 0;
ARM GAS  /tmp/cc39PcX6.s 			page 228


 7149              		.loc 1 3407 5 is_stmt 1 view .LVU2159
3407:Src/mpu6050.c ****     hal.report              = 0;
 7150              		.loc 1 3407 29 is_stmt 0 view .LVU2160
 7151 003c A570     		strb	r5, [r4, #2]
3408:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
 7152              		.loc 1 3408 5 is_stmt 1 view .LVU2161
3408:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
 7153              		.loc 1 3408 29 is_stmt 0 view .LVU2162
 7154 003e 6561     		str	r5, [r4, #20]
3409:Src/mpu6050.c ****     hal.next_temp_ms        = 0;
 7155              		.loc 1 3409 5 is_stmt 1 view .LVU2163
3443:Src/mpu6050.c ****         if (dmp_load_motion_driver_firmware()) {
 7156              		.loc 1 3443 9 view .LVU2164
 7157 0040 FFF7FEFF 		bl	consoleLog
 7158              	.LVL519:
3444:Src/mpu6050.c ****             consoleLog(" FAIL (DMP)\r\n");
 7159              		.loc 1 3444 9 view .LVU2165
3444:Src/mpu6050.c ****             consoleLog(" FAIL (DMP)\r\n");
 7160              		.loc 1 3444 13 is_stmt 0 view .LVU2166
 7161 0044 FFF7FEFF 		bl	dmp_load_motion_driver_firmware
 7162              	.LVL520:
3444:Src/mpu6050.c ****             consoleLog(" FAIL (DMP)\r\n");
 7163              		.loc 1 3444 12 view .LVU2167
 7164 0048 0546     		mov	r5, r0
 7165 004a 08B1     		cbz	r0, .L609
3445:Src/mpu6050.c ****             return -1;
 7166              		.loc 1 3445 13 is_stmt 1 view .LVU2168
 7167 004c 1248     		ldr	r0, .L611+16
 7168 004e E0E7     		b	.L610
 7169              	.L609:
3448:Src/mpu6050.c ****     dmp_register_tap_cb(mpu_tap_func);
 7170              		.loc 1 3448 5 view .LVU2169
 7171 0050 1248     		ldr	r0, .L611+20
 7172 0052 FFF7FEFF 		bl	inv_orientation_matrix_to_scalar
 7173              	.LVL521:
 7174 0056 FFF7FEFF 		bl	dmp_set_orientation
 7175              	.LVL522:
3449:Src/mpu6050.c ****     dmp_register_android_orient_cb(mpu_android_orient_func);
 7176              		.loc 1 3449 5 view .LVU2170
 7177 005a 1148     		ldr	r0, .L611+24
 7178 005c FFF7FEFF 		bl	dmp_register_tap_cb
 7179              	.LVL523:
3450:Src/mpu6050.c ****     /*
 7180              		.loc 1 3450 5 view .LVU2171
 7181 0060 1048     		ldr	r0, .L611+28
 7182 0062 FFF7FEFF 		bl	dmp_register_android_orient_cb
 7183              	.LVL524:
3464:Src/mpu6050.c ****                         DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_C
 7184              		.loc 1 3464 5 view .LVU2172
3464:Src/mpu6050.c ****                         DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_C
 7185              		.loc 1 3464 22 is_stmt 0 view .LVU2173
 7186 0066 F320     		movs	r0, #243
 7187 0068 2083     		strh	r0, [r4, #24]	@ movhi
3466:Src/mpu6050.c ****     dmp_set_fifo_rate(MPU_DEFAULT_HZ);
 7188              		.loc 1 3466 5 is_stmt 1 view .LVU2174
 7189 006a FFF7FEFF 		bl	dmp_enable_feature
 7190              	.LVL525:
ARM GAS  /tmp/cc39PcX6.s 			page 229


3467:Src/mpu6050.c ****     mpu_set_dmp_state(1);
 7191              		.loc 1 3467 5 view .LVU2175
 7192 006e 1420     		movs	r0, #20
 7193 0070 FFF7FEFF 		bl	dmp_set_fifo_rate
 7194              	.LVL526:
3468:Src/mpu6050.c ****     hal.dmp_on = 1;
 7195              		.loc 1 3468 5 view .LVU2176
 7196 0074 0120     		movs	r0, #1
 7197 0076 FFF7FEFF 		bl	mpu_set_dmp_state
 7198              	.LVL527:
3469:Src/mpu6050.c **** #endif
 7199              		.loc 1 3469 5 view .LVU2177
3469:Src/mpu6050.c **** #endif
 7200              		.loc 1 3469 16 is_stmt 0 view .LVU2178
 7201 007a 0123     		movs	r3, #1
3472:Src/mpu6050.c ****     return 0;
 7202              		.loc 1 3472 5 view .LVU2179
 7203 007c 0A48     		ldr	r0, .L611+32
3469:Src/mpu6050.c **** #endif
 7204              		.loc 1 3469 16 view .LVU2180
 7205 007e A370     		strb	r3, [r4, #2]
3472:Src/mpu6050.c ****     return 0;
 7206              		.loc 1 3472 5 is_stmt 1 view .LVU2181
 7207 0080 FFF7FEFF 		bl	consoleLog
 7208              	.LVL528:
3473:Src/mpu6050.c **** }
 7209              		.loc 1 3473 5 view .LVU2182
3473:Src/mpu6050.c **** }
 7210              		.loc 1 3473 12 is_stmt 0 view .LVU2183
 7211 0084 C9E7     		b	.L606
 7212              	.L612:
 7213 0086 00BF     		.align	2
 7214              	.L611:
 7215 0088 00000000 		.word	.LC19
 7216 008c 18000000 		.word	.LC20
 7217 0090 00000000 		.word	.LANCHOR2
 7218 0094 25000000 		.word	.LC21
 7219 0098 36000000 		.word	.LC22
 7220 009c 00000000 		.word	.LANCHOR3
 7221 00a0 00000000 		.word	mpu_tap_func
 7222 00a4 00000000 		.word	mpu_android_orient_func
 7223 00a8 44000000 		.word	.LC23
 7224              		.cfi_endproc
 7225              	.LFE113:
 7227              		.section	.text.mpu_read_gyro_raw,"ax",%progbits
 7228              		.align	1
 7229              		.global	mpu_read_gyro_raw
 7230              		.syntax unified
 7231              		.thumb
 7232              		.thumb_func
 7233              		.fpu softvfp
 7235              	mpu_read_gyro_raw:
 7236              	.LFB115:
3593:Src/mpu6050.c ****     uint8_t buffer[6];
 7237              		.loc 1 3593 1 is_stmt 1 view -0
 7238              		.cfi_startproc
 7239              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/cc39PcX6.s 			page 230


 7240              		@ frame_needed = 0, uses_anonymous_args = 0
3594:Src/mpu6050.c **** 
 7241              		.loc 1 3594 5 view .LVU2185
3597:Src/mpu6050.c **** 
 7242              		.loc 1 3597 5 view .LVU2186
3593:Src/mpu6050.c ****     uint8_t buffer[6];
 7243              		.loc 1 3593 1 is_stmt 0 view .LVU2187
 7244 0000 07B5     		push	{r0, r1, r2, lr}
 7245              	.LCFI107:
 7246              		.cfi_def_cfa_offset 16
 7247              		.cfi_offset 14, -4
3597:Src/mpu6050.c **** 
 7248              		.loc 1 3597 34 view .LVU2188
 7249 0002 0C4B     		ldr	r3, .L614
3597:Src/mpu6050.c **** 
 7250              		.loc 1 3597 5 view .LVU2189
 7251 0004 0622     		movs	r2, #6
 7252 0006 D3E90010 		ldrd	r1, r0, [r3]
 7253 000a 6B46     		mov	r3, sp
 7254 000c C97B     		ldrb	r1, [r1, #15]	@ zero_extendqisi2
 7255 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 7256 0010 FFF7FEFF 		bl	i2c_readBytes
 7257              	.LVL529:
3599:Src/mpu6050.c ****     mpu.gyro.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7258              		.loc 1 3599 5 is_stmt 1 view .LVU2190
3599:Src/mpu6050.c ****     mpu.gyro.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7259              		.loc 1 3599 16 is_stmt 0 view .LVU2191
 7260 0014 BDF80020 		ldrh	r2, [sp]
 7261 0018 074B     		ldr	r3, .L614+4
 7262 001a 52BA     		rev16	r2, r2
 7263 001c 1A80     		strh	r2, [r3]	@ movhi
3600:Src/mpu6050.c ****     mpu.gyro.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7264              		.loc 1 3600 5 is_stmt 1 view .LVU2192
3600:Src/mpu6050.c ****     mpu.gyro.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7265              		.loc 1 3600 16 is_stmt 0 view .LVU2193
 7266 001e BDF80220 		ldrh	r2, [sp, #2]
 7267 0022 52BA     		rev16	r2, r2
 7268 0024 5A80     		strh	r2, [r3, #2]	@ movhi
3601:Src/mpu6050.c **** 
 7269              		.loc 1 3601 5 is_stmt 1 view .LVU2194
3601:Src/mpu6050.c **** 
 7270              		.loc 1 3601 16 is_stmt 0 view .LVU2195
 7271 0026 BDF80420 		ldrh	r2, [sp, #4]
 7272 002a 52BA     		rev16	r2, r2
 7273 002c 9A80     		strh	r2, [r3, #4]	@ movhi
3610:Src/mpu6050.c **** 
 7274              		.loc 1 3610 1 view .LVU2196
 7275 002e 03B0     		add	sp, sp, #12
 7276              	.LCFI108:
 7277              		.cfi_def_cfa_offset 4
 7278              		@ sp needed
 7279 0030 5DF804FB 		ldr	pc, [sp], #4
 7280              	.L615:
 7281              		.align	2
 7282              	.L614:
 7283 0034 00000000 		.word	.LANCHOR0
 7284 0038 00000000 		.word	.LANCHOR4
ARM GAS  /tmp/cc39PcX6.s 			page 231


 7285              		.cfi_endproc
 7286              	.LFE115:
 7288              		.section	.text.mpu_read_accel_raw,"ax",%progbits
 7289              		.align	1
 7290              		.global	mpu_read_accel_raw
 7291              		.syntax unified
 7292              		.thumb
 7293              		.thumb_func
 7294              		.fpu softvfp
 7296              	mpu_read_accel_raw:
 7297              	.LFB116:
3614:Src/mpu6050.c ****     uint8_t buffer[6];
 7298              		.loc 1 3614 1 is_stmt 1 view -0
 7299              		.cfi_startproc
 7300              		@ args = 0, pretend = 0, frame = 8
 7301              		@ frame_needed = 0, uses_anonymous_args = 0
3615:Src/mpu6050.c **** 
 7302              		.loc 1 3615 5 view .LVU2198
3618:Src/mpu6050.c ****     
 7303              		.loc 1 3618 5 view .LVU2199
3614:Src/mpu6050.c ****     uint8_t buffer[6];
 7304              		.loc 1 3614 1 is_stmt 0 view .LVU2200
 7305 0000 07B5     		push	{r0, r1, r2, lr}
 7306              	.LCFI109:
 7307              		.cfi_def_cfa_offset 16
 7308              		.cfi_offset 14, -4
3618:Src/mpu6050.c ****     
 7309              		.loc 1 3618 34 view .LVU2201
 7310 0002 0C4B     		ldr	r3, .L617
3618:Src/mpu6050.c ****     
 7311              		.loc 1 3618 5 view .LVU2202
 7312 0004 0622     		movs	r2, #6
 7313 0006 D3E90010 		ldrd	r1, r0, [r3]
 7314 000a 6B46     		mov	r3, sp
 7315 000c 897B     		ldrb	r1, [r1, #14]	@ zero_extendqisi2
 7316 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 7317 0010 FFF7FEFF 		bl	i2c_readBytes
 7318              	.LVL530:
3620:Src/mpu6050.c ****     mpu.accel.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7319              		.loc 1 3620 5 is_stmt 1 view .LVU2203
3620:Src/mpu6050.c ****     mpu.accel.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7320              		.loc 1 3620 17 is_stmt 0 view .LVU2204
 7321 0014 BDF80020 		ldrh	r2, [sp]
 7322 0018 074B     		ldr	r3, .L617+4
 7323 001a 52BA     		rev16	r2, r2
 7324 001c DA80     		strh	r2, [r3, #6]	@ movhi
3621:Src/mpu6050.c ****     mpu.accel.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7325              		.loc 1 3621 5 is_stmt 1 view .LVU2205
3621:Src/mpu6050.c ****     mpu.accel.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7326              		.loc 1 3621 17 is_stmt 0 view .LVU2206
 7327 001e BDF80220 		ldrh	r2, [sp, #2]
 7328 0022 52BA     		rev16	r2, r2
 7329 0024 1A81     		strh	r2, [r3, #8]	@ movhi
3622:Src/mpu6050.c **** 
 7330              		.loc 1 3622 5 is_stmt 1 view .LVU2207
3622:Src/mpu6050.c **** 
 7331              		.loc 1 3622 17 is_stmt 0 view .LVU2208
ARM GAS  /tmp/cc39PcX6.s 			page 232


 7332 0026 BDF80420 		ldrh	r2, [sp, #4]
 7333 002a 52BA     		rev16	r2, r2
 7334 002c 5A81     		strh	r2, [r3, #10]	@ movhi
3632:Src/mpu6050.c **** 
 7335              		.loc 1 3632 1 view .LVU2209
 7336 002e 03B0     		add	sp, sp, #12
 7337              	.LCFI110:
 7338              		.cfi_def_cfa_offset 4
 7339              		@ sp needed
 7340 0030 5DF804FB 		ldr	pc, [sp], #4
 7341              	.L618:
 7342              		.align	2
 7343              	.L617:
 7344 0034 00000000 		.word	.LANCHOR0
 7345 0038 00000000 		.word	.LANCHOR4
 7346              		.cfi_endproc
 7347              	.LFE116:
 7349              		.global	__aeabi_f2d
 7350              		.global	__aeabi_d2f
 7351              		.global	__aeabi_dmul
 7352              		.global	__aeabi_d2iz
 7353              		.section	.text.mpu_calc_euler_angles,"ax",%progbits
 7354              		.align	1
 7355              		.global	mpu_calc_euler_angles
 7356              		.syntax unified
 7357              		.thumb
 7358              		.thumb_func
 7359              		.fpu softvfp
 7361              	mpu_calc_euler_angles:
 7362              	.LFB117:
3641:Src/mpu6050.c ****     
 7363              		.loc 1 3641 34 is_stmt 1 view -0
 7364              		.cfi_startproc
 7365              		@ args = 0, pretend = 0, frame = 16
 7366              		@ frame_needed = 0, uses_anonymous_args = 0
3643:Src/mpu6050.c ****     float yaw, pitch, roll;
 7367              		.loc 1 3643 5 view .LVU2211
3644:Src/mpu6050.c **** 
 7368              		.loc 1 3644 5 view .LVU2212
3647:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
 7369              		.loc 1 3647 5 view .LVU2213
3641:Src/mpu6050.c ****     
 7370              		.loc 1 3641 34 is_stmt 0 view .LVU2214
 7371 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7372              	.LCFI111:
 7373              		.cfi_def_cfa_offset 36
 7374              		.cfi_offset 4, -36
 7375              		.cfi_offset 5, -32
 7376              		.cfi_offset 6, -28
 7377              		.cfi_offset 7, -24
 7378              		.cfi_offset 8, -20
 7379              		.cfi_offset 9, -16
 7380              		.cfi_offset 10, -12
 7381              		.cfi_offset 11, -8
 7382              		.cfi_offset 14, -4
3647:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
 7383              		.loc 1 3647 24 view .LVU2215
ARM GAS  /tmp/cc39PcX6.s 			page 233


 7384 0004 6A4C     		ldr	r4, .L620+8
3641:Src/mpu6050.c ****     
 7385              		.loc 1 3641 34 view .LVU2216
 7386 0006 85B0     		sub	sp, sp, #20
 7387              	.LCFI112:
 7388              		.cfi_def_cfa_offset 56
3647:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
 7389              		.loc 1 3647 9 view .LVU2217
 7390 0008 E068     		ldr	r0, [r4, #12]
 7391 000a FFF7FEFF 		bl	__aeabi_i2f
 7392              	.LVL531:
3647:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
 7393              		.loc 1 3647 7 view .LVU2218
 7394 000e 4FF04251 		mov	r1, #813694976
 7395 0012 FFF7FEFF 		bl	__aeabi_fmul
 7396              	.LVL532:
 7397 0016 8246     		mov	r10, r0
 7398              	.LVL533:
3648:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
 7399              		.loc 1 3648 5 is_stmt 1 view .LVU2219
3648:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
 7400              		.loc 1 3648 9 is_stmt 0 view .LVU2220
 7401 0018 2069     		ldr	r0, [r4, #16]
 7402              	.LVL534:
3648:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
 7403              		.loc 1 3648 9 view .LVU2221
 7404 001a FFF7FEFF 		bl	__aeabi_i2f
 7405              	.LVL535:
3648:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
 7406              		.loc 1 3648 7 view .LVU2222
 7407 001e 4FF04251 		mov	r1, #813694976
 7408 0022 FFF7FEFF 		bl	__aeabi_fmul
 7409              	.LVL536:
 7410 0026 0546     		mov	r5, r0
 7411              	.LVL537:
3649:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7412              		.loc 1 3649 5 is_stmt 1 view .LVU2223
3649:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7413              		.loc 1 3649 9 is_stmt 0 view .LVU2224
 7414 0028 6069     		ldr	r0, [r4, #20]
 7415              	.LVL538:
3649:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7416              		.loc 1 3649 9 view .LVU2225
 7417 002a FFF7FEFF 		bl	__aeabi_i2f
 7418              	.LVL539:
3649:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7419              		.loc 1 3649 7 view .LVU2226
 7420 002e 4FF04251 		mov	r1, #813694976
 7421 0032 FFF7FEFF 		bl	__aeabi_fmul
 7422              	.LVL540:
 7423 0036 0646     		mov	r6, r0
 7424              	.LVL541:
3650:Src/mpu6050.c **** 
 7425              		.loc 1 3650 5 is_stmt 1 view .LVU2227
3650:Src/mpu6050.c **** 
 7426              		.loc 1 3650 9 is_stmt 0 view .LVU2228
 7427 0038 A069     		ldr	r0, [r4, #24]
ARM GAS  /tmp/cc39PcX6.s 			page 234


 7428              	.LVL542:
3650:Src/mpu6050.c **** 
 7429              		.loc 1 3650 9 view .LVU2229
 7430 003a FFF7FEFF 		bl	__aeabi_i2f
 7431              	.LVL543:
3650:Src/mpu6050.c **** 
 7432              		.loc 1 3650 7 view .LVU2230
 7433 003e 4FF04251 		mov	r1, #813694976
 7434 0042 FFF7FEFF 		bl	__aeabi_fmul
 7435              	.LVL544:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7436              		.loc 1 3653 50 view .LVU2231
 7437 0046 3146     		mov	r1, r6
3650:Src/mpu6050.c **** 
 7438              		.loc 1 3650 7 view .LVU2232
 7439 0048 0746     		mov	r7, r0
 7440              	.LVL545:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7441              		.loc 1 3653 5 is_stmt 1 view .LVU2233
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7442              		.loc 1 3653 50 is_stmt 0 view .LVU2234
 7443 004a 3046     		mov	r0, r6
 7444              	.LVL546:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7445              		.loc 1 3653 50 view .LVU2235
 7446 004c FFF7FEFF 		bl	__aeabi_fmul
 7447              	.LVL547:
 7448 0050 8346     		mov	fp, r0
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7449              		.loc 1 3653 44 view .LVU2236
 7450 0052 2946     		mov	r1, r5
 7451 0054 2846     		mov	r0, r5
 7452 0056 FFF7FEFF 		bl	__aeabi_fmul
 7453              	.LVL548:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7454              		.loc 1 3653 47 view .LVU2237
 7455 005a 5946     		mov	r1, fp
 7456 005c FFF7FEFF 		bl	__aeabi_fadd
 7457              	.LVL549:
 7458 0060 0146     		mov	r1, r0
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7459              		.loc 1 3653 41 view .LVU2238
 7460 0062 FFF7FEFF 		bl	__aeabi_fadd
 7461              	.LVL550:
 7462 0066 0146     		mov	r1, r0
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7463              		.loc 1 3653 38 view .LVU2239
 7464 0068 4FF07E50 		mov	r0, #1065353216
 7465 006c FFF7FEFF 		bl	__aeabi_fsub
 7466              	.LVL551:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7467              		.loc 1 3653 15 view .LVU2240
 7468 0070 FFF7FEFF 		bl	__aeabi_f2d
 7469              	.LVL552:
 7470 0074 8046     		mov	r8, r0
 7471 0076 8946     		mov	r9, r1
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
ARM GAS  /tmp/cc39PcX6.s 			page 235


 7472              		.loc 1 3653 25 view .LVU2241
 7473 0078 5046     		mov	r0, r10
 7474 007a 2946     		mov	r1, r5
 7475 007c FFF7FEFF 		bl	__aeabi_fmul
 7476              	.LVL553:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7477              		.loc 1 3653 31 view .LVU2242
 7478 0080 3946     		mov	r1, r7
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7479              		.loc 1 3653 25 view .LVU2243
 7480 0082 0090     		str	r0, [sp]
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7481              		.loc 1 3653 31 view .LVU2244
 7482 0084 3046     		mov	r0, r6
 7483 0086 FFF7FEFF 		bl	__aeabi_fmul
 7484              	.LVL554:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7485              		.loc 1 3653 28 view .LVU2245
 7486 008a 009B     		ldr	r3, [sp]
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7487              		.loc 1 3653 31 view .LVU2246
 7488 008c 0146     		mov	r1, r0
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7489              		.loc 1 3653 28 view .LVU2247
 7490 008e 1846     		mov	r0, r3
 7491 0090 FFF7FEFF 		bl	__aeabi_fadd
 7492              	.LVL555:
 7493 0094 0146     		mov	r1, r0
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7494              		.loc 1 3653 22 view .LVU2248
 7495 0096 FFF7FEFF 		bl	__aeabi_fadd
 7496              	.LVL556:
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7497              		.loc 1 3653 15 view .LVU2249
 7498 009a FFF7FEFF 		bl	__aeabi_f2d
 7499              	.LVL557:
 7500 009e 4246     		mov	r2, r8
 7501 00a0 4B46     		mov	r3, r9
 7502 00a2 FFF7FEFF 		bl	atan2
 7503              	.LVL558:
 7504 00a6 8046     		mov	r8, r0
 7505 00a8 8946     		mov	r9, r1
 7506              	.LVL559:
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7507              		.loc 1 3654 5 is_stmt 1 view .LVU2250
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7508              		.loc 1 3654 24 is_stmt 0 view .LVU2251
 7509 00aa 5046     		mov	r0, r10
 7510 00ac 3146     		mov	r1, r6
 7511 00ae FFF7FEFF 		bl	__aeabi_fmul
 7512              	.LVL560:
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7513              		.loc 1 3654 30 view .LVU2252
 7514 00b2 3946     		mov	r1, r7
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7515              		.loc 1 3654 24 view .LVU2253
 7516 00b4 0090     		str	r0, [sp]
ARM GAS  /tmp/cc39PcX6.s 			page 236


3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7517              		.loc 1 3654 30 view .LVU2254
 7518 00b6 2846     		mov	r0, r5
 7519 00b8 FFF7FEFF 		bl	__aeabi_fmul
 7520              	.LVL561:
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7521              		.loc 1 3654 27 view .LVU2255
 7522 00bc 009B     		ldr	r3, [sp]
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7523              		.loc 1 3654 30 view .LVU2256
 7524 00be 0146     		mov	r1, r0
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7525              		.loc 1 3654 27 view .LVU2257
 7526 00c0 1846     		mov	r0, r3
 7527 00c2 FFF7FEFF 		bl	__aeabi_fsub
 7528              	.LVL562:
 7529 00c6 0146     		mov	r1, r0
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7530              		.loc 1 3654 21 view .LVU2258
 7531 00c8 FFF7FEFF 		bl	__aeabi_fadd
 7532              	.LVL563:
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7533              		.loc 1 3654 15 view .LVU2259
 7534 00cc FFF7FEFF 		bl	__aeabi_f2d
 7535              	.LVL564:
 7536 00d0 FFF7FEFF 		bl	asin
 7537              	.LVL565:
 7538 00d4 CDE90001 		strd	r0, [sp]
 7539              	.LVL566:
3655:Src/mpu6050.c **** 
 7540              		.loc 1 3655 5 is_stmt 1 view .LVU2260
3655:Src/mpu6050.c **** 
 7541              		.loc 1 3655 50 is_stmt 0 view .LVU2261
 7542 00d8 3946     		mov	r1, r7
 7543 00da 3846     		mov	r0, r7
 7544              	.LVL567:
3655:Src/mpu6050.c **** 
 7545              		.loc 1 3655 50 view .LVU2262
 7546 00dc FFF7FEFF 		bl	__aeabi_fmul
 7547              	.LVL568:
3655:Src/mpu6050.c **** 
 7548              		.loc 1 3655 47 view .LVU2263
 7549 00e0 5946     		mov	r1, fp
 7550 00e2 FFF7FEFF 		bl	__aeabi_fadd
 7551              	.LVL569:
 7552 00e6 0146     		mov	r1, r0
3655:Src/mpu6050.c **** 
 7553              		.loc 1 3655 41 view .LVU2264
 7554 00e8 FFF7FEFF 		bl	__aeabi_fadd
 7555              	.LVL570:
 7556 00ec 0146     		mov	r1, r0
3655:Src/mpu6050.c **** 
 7557              		.loc 1 3655 38 view .LVU2265
 7558 00ee 4FF07E50 		mov	r0, #1065353216
 7559 00f2 FFF7FEFF 		bl	__aeabi_fsub
 7560              	.LVL571:
3655:Src/mpu6050.c **** 
ARM GAS  /tmp/cc39PcX6.s 			page 237


 7561              		.loc 1 3655 15 view .LVU2266
 7562 00f6 FFF7FEFF 		bl	__aeabi_f2d
 7563              	.LVL572:
 7564 00fa 0246     		mov	r2, r0
 7565 00fc 0B46     		mov	r3, r1
3655:Src/mpu6050.c **** 
 7566              		.loc 1 3655 25 view .LVU2267
 7567 00fe 5046     		mov	r0, r10
 7568 0100 3946     		mov	r1, r7
3655:Src/mpu6050.c **** 
 7569              		.loc 1 3655 15 view .LVU2268
 7570 0102 CDE90223 		strd	r2, [sp, #8]
3655:Src/mpu6050.c **** 
 7571              		.loc 1 3655 25 view .LVU2269
 7572 0106 FFF7FEFF 		bl	__aeabi_fmul
 7573              	.LVL573:
3655:Src/mpu6050.c **** 
 7574              		.loc 1 3655 31 view .LVU2270
 7575 010a 3146     		mov	r1, r6
3655:Src/mpu6050.c **** 
 7576              		.loc 1 3655 25 view .LVU2271
 7577 010c 0746     		mov	r7, r0
 7578              	.LVL574:
3655:Src/mpu6050.c **** 
 7579              		.loc 1 3655 31 view .LVU2272
 7580 010e 2846     		mov	r0, r5
 7581 0110 FFF7FEFF 		bl	__aeabi_fmul
 7582              	.LVL575:
 7583 0114 0146     		mov	r1, r0
3655:Src/mpu6050.c **** 
 7584              		.loc 1 3655 28 view .LVU2273
 7585 0116 3846     		mov	r0, r7
 7586 0118 FFF7FEFF 		bl	__aeabi_fadd
 7587              	.LVL576:
 7588 011c 0146     		mov	r1, r0
3655:Src/mpu6050.c **** 
 7589              		.loc 1 3655 22 view .LVU2274
 7590 011e FFF7FEFF 		bl	__aeabi_fadd
 7591              	.LVL577:
3655:Src/mpu6050.c **** 
 7592              		.loc 1 3655 15 view .LVU2275
 7593 0122 FFF7FEFF 		bl	__aeabi_f2d
 7594              	.LVL578:
 7595 0126 DDE90223 		ldrd	r2, [sp, #8]
 7596 012a FFF7FEFF 		bl	atan2
 7597              	.LVL579:
 7598 012e 0646     		mov	r6, r0
 7599              	.LVL580:
3655:Src/mpu6050.c **** 
 7600              		.loc 1 3655 15 view .LVU2276
 7601 0130 0F46     		mov	r7, r1
 7602              	.LVL581:
3658:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
 7603              		.loc 1 3658 5 is_stmt 1 view .LVU2277
3653:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7604              		.loc 1 3653 13 is_stmt 0 view .LVU2278
 7605 0132 4046     		mov	r0, r8
ARM GAS  /tmp/cc39PcX6.s 			page 238


 7606 0134 4946     		mov	r1, r9
 7607 0136 FFF7FEFF 		bl	__aeabi_d2f
 7608              	.LVL582:
3658:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
 7609              		.loc 1 3658 39 view .LVU2279
 7610 013a FFF7FEFF 		bl	__aeabi_f2d
 7611              	.LVL583:
 7612 013e 1AA3     		adr	r3, .L620
 7613 0140 D3E90023 		ldrd	r2, [r3]
 7614 0144 FFF7FEFF 		bl	__aeabi_dmul
 7615              	.LVL584:
3658:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
 7616              		.loc 1 3658 49 view .LVU2280
 7617 0148 0022     		movs	r2, #0
 7618 014a 1A4B     		ldr	r3, .L620+12
 7619 014c FFF7FEFF 		bl	__aeabi_dmul
 7620              	.LVL585:
3658:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
 7621              		.loc 1 3658 23 view .LVU2281
 7622 0150 FFF7FEFF 		bl	__aeabi_d2iz
 7623              	.LVL586:
 7624 0154 A083     		strh	r0, [r4, #28]	@ movhi
3659:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7625              		.loc 1 3659 5 is_stmt 1 view .LVU2282
3654:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7626              		.loc 1 3654 13 is_stmt 0 view .LVU2283
 7627 0156 DDE90001 		ldrd	r0, [sp]
 7628 015a FFF7FEFF 		bl	__aeabi_d2f
 7629              	.LVL587:
3659:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7630              		.loc 1 3659 39 view .LVU2284
 7631 015e FFF7FEFF 		bl	__aeabi_f2d
 7632              	.LVL588:
 7633 0162 11A3     		adr	r3, .L620
 7634 0164 D3E90023 		ldrd	r2, [r3]
 7635 0168 FFF7FEFF 		bl	__aeabi_dmul
 7636              	.LVL589:
3659:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7637              		.loc 1 3659 49 view .LVU2285
 7638 016c 0022     		movs	r2, #0
 7639 016e 114B     		ldr	r3, .L620+12
 7640 0170 FFF7FEFF 		bl	__aeabi_dmul
 7641              	.LVL590:
3659:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7642              		.loc 1 3659 23 view .LVU2286
 7643 0174 FFF7FEFF 		bl	__aeabi_d2iz
 7644              	.LVL591:
3655:Src/mpu6050.c **** 
 7645              		.loc 1 3655 13 view .LVU2287
 7646 0178 3946     		mov	r1, r7
3659:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7647              		.loc 1 3659 23 view .LVU2288
 7648 017a E083     		strh	r0, [r4, #30]	@ movhi
3660:Src/mpu6050.c ****     
 7649              		.loc 1 3660 5 is_stmt 1 view .LVU2289
3655:Src/mpu6050.c **** 
 7650              		.loc 1 3655 13 is_stmt 0 view .LVU2290
ARM GAS  /tmp/cc39PcX6.s 			page 239


 7651 017c 3046     		mov	r0, r6
 7652 017e FFF7FEFF 		bl	__aeabi_d2f
 7653              	.LVL592:
3660:Src/mpu6050.c ****     
 7654              		.loc 1 3660 39 view .LVU2291
 7655 0182 FFF7FEFF 		bl	__aeabi_f2d
 7656              	.LVL593:
 7657 0186 08A3     		adr	r3, .L620
 7658 0188 D3E90023 		ldrd	r2, [r3]
 7659 018c FFF7FEFF 		bl	__aeabi_dmul
 7660              	.LVL594:
3660:Src/mpu6050.c ****     
 7661              		.loc 1 3660 49 view .LVU2292
 7662 0190 0022     		movs	r2, #0
 7663 0192 084B     		ldr	r3, .L620+12
 7664 0194 FFF7FEFF 		bl	__aeabi_dmul
 7665              	.LVL595:
3660:Src/mpu6050.c ****     
 7666              		.loc 1 3660 23 view .LVU2293
 7667 0198 FFF7FEFF 		bl	__aeabi_d2iz
 7668              	.LVL596:
 7669 019c 2084     		strh	r0, [r4, #32]	@ movhi
3662:Src/mpu6050.c **** 
 7670              		.loc 1 3662 1 view .LVU2294
 7671 019e 05B0     		add	sp, sp, #20
 7672              	.LCFI113:
 7673              		.cfi_def_cfa_offset 36
 7674              	.LVL597:
3662:Src/mpu6050.c **** 
 7675              		.loc 1 3662 1 view .LVU2295
 7676              		@ sp needed
 7677 01a0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 7678              	.LVL598:
 7679              	.L621:
3662:Src/mpu6050.c **** 
 7680              		.loc 1 3662 1 view .LVU2296
 7681 01a4 AFF30080 		.align	3
 7682              	.L620:
 7683 01a8 F8C1631A 		.word	442745336
 7684 01ac DCA54C40 		.word	1078765020
 7685 01b0 00000000 		.word	.LANCHOR4
 7686 01b4 00005940 		.word	1079574528
 7687              		.cfi_endproc
 7688              	.LFE117:
 7690              		.section	.text.mpu_get_data,"ax",%progbits
 7691              		.align	1
 7692              		.global	mpu_get_data
 7693              		.syntax unified
 7694              		.thumb
 7695              		.thumb_func
 7696              		.fpu softvfp
 7698              	mpu_get_data:
 7699              	.LFB114:
3480:Src/mpu6050.c ****     
 7700              		.loc 1 3480 1 is_stmt 1 view -0
 7701              		.cfi_startproc
 7702              		@ args = 0, pretend = 0, frame = 32
ARM GAS  /tmp/cc39PcX6.s 			page 240


 7703              		@ frame_needed = 0, uses_anonymous_args = 0
3482:Src/mpu6050.c ****     unsigned long timestamp;
 7704              		.loc 1 3482 5 view .LVU2298
3483:Src/mpu6050.c ****     unsigned char new_data = 0, new_temp = 0;
 7705              		.loc 1 3483 5 view .LVU2299
3484:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7706              		.loc 1 3484 5 view .LVU2300
 7707              	.LVL599:
3485:Src/mpu6050.c **** 
 7708              		.loc 1 3485 5 view .LVU2301
3488:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7709              		.loc 1 3488 5 view .LVU2302
3480:Src/mpu6050.c ****     
 7710              		.loc 1 3480 1 is_stmt 0 view .LVU2303
 7711 0000 30B5     		push	{r4, r5, lr}
 7712              	.LCFI114:
 7713              		.cfi_def_cfa_offset 12
 7714              		.cfi_offset 4, -12
 7715              		.cfi_offset 5, -8
 7716              		.cfi_offset 14, -4
3488:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7717              		.loc 1 3488 33 view .LVU2304
 7718 0002 544B     		ldr	r3, .L669
3480:Src/mpu6050.c ****     
 7719              		.loc 1 3480 1 view .LVU2305
 7720 0004 8BB0     		sub	sp, sp, #44
 7721              	.LCFI115:
 7722              		.cfi_def_cfa_offset 56
3488:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7723              		.loc 1 3488 5 view .LVU2306
 7724 0006 D3E90013 		ldrd	r1, r3, [r3]
 7725 000a 0DF10902 		add	r2, sp, #9
 7726 000e C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 7727 0010 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 7728 0012 FFF7FEFF 		bl	i2c_readByte
 7729              	.LVL600:
3489:Src/mpu6050.c ****             hal.new_gyro = 1;
 7730              		.loc 1 3489 5 is_stmt 1 view .LVU2307
3489:Src/mpu6050.c ****             hal.new_gyro = 1;
 7731              		.loc 1 3489 8 is_stmt 0 view .LVU2308
 7732 0016 9DF80930 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 7733 001a 4F4C     		ldr	r4, .L669+4
3490:Src/mpu6050.c ****     }
 7734              		.loc 1 3490 13 is_stmt 1 view .LVU2309
3489:Src/mpu6050.c ****             hal.new_gyro = 1;
 7735              		.loc 1 3489 8 is_stmt 0 view .LVU2310
 7736 001c 13F0030F 		tst	r3, #3
3490:Src/mpu6050.c ****     }
 7737              		.loc 1 3490 26 view .LVU2311
 7738 0020 18BF     		it	ne
 7739 0022 0123     		movne	r3, #1
3493:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
 7740              		.loc 1 3493 5 view .LVU2312
 7741 0024 04A8     		add	r0, sp, #16
3490:Src/mpu6050.c ****     }
 7742              		.loc 1 3490 26 view .LVU2313
 7743 0026 18BF     		it	ne
ARM GAS  /tmp/cc39PcX6.s 			page 241


 7744 0028 2371     		strbne	r3, [r4, #4]
3493:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
 7745              		.loc 1 3493 5 is_stmt 1 view .LVU2314
 7746 002a FFF7FEFF 		bl	get_tick_count_ms
 7747              	.LVL601:
3497:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7748              		.loc 1 3497 5 view .LVU2315
3497:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7749              		.loc 1 3497 19 is_stmt 0 view .LVU2316
 7750 002e 049B     		ldr	r3, [sp, #16]
3497:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7751              		.loc 1 3497 8 view .LVU2317
 7752 0030 2269     		ldr	r2, [r4, #16]
 7753 0032 9A42     		cmp	r2, r3
3498:Src/mpu6050.c ****         new_temp = 1;
 7754              		.loc 1 3498 9 is_stmt 1 view .LVU2318
3498:Src/mpu6050.c ****         new_temp = 1;
 7755              		.loc 1 3498 38 is_stmt 0 view .LVU2319
 7756 0034 3CBF     		itt	cc
 7757 0036 03F5FA73 		addcc	r3, r3, #500
3498:Src/mpu6050.c ****         new_temp = 1;
 7758              		.loc 1 3498 26 view .LVU2320
 7759 003a 2361     		strcc	r3, [r4, #16]
3499:Src/mpu6050.c ****     }
 7760              		.loc 1 3499 9 is_stmt 1 view .LVU2321
 7761              	.LVL602:
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7762              		.loc 1 3503 12 is_stmt 0 view .LVU2322
 7763 003c 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
3499:Src/mpu6050.c ****     }
 7764              		.loc 1 3499 18 view .LVU2323
 7765 003e 34BF     		ite	cc
 7766 0040 0125     		movcc	r5, #1
3484:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7767              		.loc 1 3484 33 view .LVU2324
 7768 0042 0025     		movcs	r5, #0
 7769              	.LVL603:
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7770              		.loc 1 3503 5 is_stmt 1 view .LVU2325
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7771              		.loc 1 3503 8 is_stmt 0 view .LVU2326
 7772 0044 002B     		cmp	r3, #0
 7773 0046 49D0     		beq	.L625
3503:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7774              		.loc 1 3503 22 discriminator 1 view .LVU2327
 7775 0048 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 7776 004a 002B     		cmp	r3, #0
 7777 004c 46D0     		beq	.L625
 7778              	.LBB52:
3504:Src/mpu6050.c ****         static long quat[4], temperature;
 7779              		.loc 1 3504 9 is_stmt 1 view .LVU2328
3505:Src/mpu6050.c ****         unsigned char more;
 7780              		.loc 1 3505 9 view .LVU2329
3506:Src/mpu6050.c ****         /* This function gets new data from the FIFO when the DMP is in
 7781              		.loc 1 3506 9 view .LVU2330
3519:Src/mpu6050.c ****         if (!more)
 7782              		.loc 1 3519 9 view .LVU2331
ARM GAS  /tmp/cc39PcX6.s 			page 242


 7783 004e 0DF10B03 		add	r3, sp, #11
 7784 0052 0193     		str	r3, [sp, #4]
 7785 0054 05AB     		add	r3, sp, #20
 7786 0056 0093     		str	r3, [sp]
 7787 0058 404A     		ldr	r2, .L669+8
 7788 005a 03AB     		add	r3, sp, #12
 7789 005c 08A9     		add	r1, sp, #32
 7790 005e 06A8     		add	r0, sp, #24
 7791 0060 FFF7FEFF 		bl	dmp_read_fifo
 7792              	.LVL604:
3520:Src/mpu6050.c ****             hal.new_gyro = 0;
 7793              		.loc 1 3520 9 view .LVU2332
3520:Src/mpu6050.c ****             hal.new_gyro = 0;
 7794              		.loc 1 3520 12 is_stmt 0 view .LVU2333
 7795 0064 9DF80B30 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 7796 0068 03B9     		cbnz	r3, .L626
3521:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7797              		.loc 1 3521 13 is_stmt 1 view .LVU2334
3521:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7798              		.loc 1 3521 26 is_stmt 0 view .LVU2335
 7799 006a 2371     		strb	r3, [r4, #4]
 7800              	.L626:
3522:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7801              		.loc 1 3522 9 is_stmt 1 view .LVU2336
3522:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7802              		.loc 1 3522 12 is_stmt 0 view .LVU2337
 7803 006c BDF81430 		ldrh	r3, [sp, #20]
 7804 0070 03F07003 		and	r3, r3, #112
 7805 0074 A3B1     		cbz	r3, .L628
3523:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7806              		.loc 1 3523 13 is_stmt 1 view .LVU2338
3523:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7807              		.loc 1 3523 24 is_stmt 0 view .LVU2339
 7808 0076 3A4C     		ldr	r4, .L669+12
 7809 0078 BDF81830 		ldrh	r3, [sp, #24]
 7810 007c 2380     		strh	r3, [r4]	@ movhi
3524:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7811              		.loc 1 3524 13 is_stmt 1 view .LVU2340
3524:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7812              		.loc 1 3524 24 is_stmt 0 view .LVU2341
 7813 007e BDF81A30 		ldrh	r3, [sp, #26]
 7814 0082 6380     		strh	r3, [r4, #2]	@ movhi
3525:Src/mpu6050.c ****             new_data = 1;
 7815              		.loc 1 3525 13 is_stmt 1 view .LVU2342
3525:Src/mpu6050.c ****             new_data = 1;
 7816              		.loc 1 3525 24 is_stmt 0 view .LVU2343
 7817 0084 BDF81C30 		ldrh	r3, [sp, #28]
 7818 0088 A380     		strh	r3, [r4, #4]	@ movhi
3526:Src/mpu6050.c ****             if (new_temp) {
 7819              		.loc 1 3526 13 is_stmt 1 view .LVU2344
 7820              	.LVL605:
3527:Src/mpu6050.c ****                 new_temp = 0;
 7821              		.loc 1 3527 13 view .LVU2345
3527:Src/mpu6050.c ****                 new_temp = 0;
 7822              		.loc 1 3527 16 is_stmt 0 view .LVU2346
 7823 008a 4DB1     		cbz	r5, .L628
3528:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
ARM GAS  /tmp/cc39PcX6.s 			page 243


 7824              		.loc 1 3528 17 is_stmt 1 view .LVU2347
 7825              	.LVL606:
3529:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
 7826              		.loc 1 3529 17 view .LVU2348
 7827 008c 354D     		ldr	r5, .L669+16
 7828 008e 03A9     		add	r1, sp, #12
 7829 0090 2846     		mov	r0, r5
 7830 0092 FFF7FEFF 		bl	mpu_get_temperature
 7831              	.LVL607:
3530:Src/mpu6050.c ****             }
 7832              		.loc 1 3530 17 view .LVU2349
3530:Src/mpu6050.c ****             }
 7833              		.loc 1 3530 50 is_stmt 0 view .LVU2350
 7834 0096 6422     		movs	r2, #100
 7835 0098 2B68     		ldr	r3, [r5]
 7836 009a 5343     		muls	r3, r2, r3
3530:Src/mpu6050.c ****             }
 7837              		.loc 1 3530 56 view .LVU2351
 7838 009c 1B14     		asrs	r3, r3, #16
3530:Src/mpu6050.c ****             }
 7839              		.loc 1 3530 28 view .LVU2352
 7840 009e 6384     		strh	r3, [r4, #34]	@ movhi
 7841              	.LVL608:
 7842              	.L628:
3533:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7843              		.loc 1 3533 9 is_stmt 1 view .LVU2353
3533:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7844              		.loc 1 3533 21 is_stmt 0 view .LVU2354
 7845 00a0 BDF81420 		ldrh	r2, [sp, #20]
3533:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7846              		.loc 1 3533 12 view .LVU2355
 7847 00a4 1107     		lsls	r1, r2, #28
 7848 00a6 09D5     		bpl	.L630
3534:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7849              		.loc 1 3534 13 is_stmt 1 view .LVU2356
3534:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7850              		.loc 1 3534 25 is_stmt 0 view .LVU2357
 7851 00a8 2D4B     		ldr	r3, .L669+12
 7852 00aa BDF82010 		ldrh	r1, [sp, #32]
 7853 00ae D980     		strh	r1, [r3, #6]	@ movhi
3535:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7854              		.loc 1 3535 13 is_stmt 1 view .LVU2358
3535:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7855              		.loc 1 3535 25 is_stmt 0 view .LVU2359
 7856 00b0 BDF82210 		ldrh	r1, [sp, #34]
 7857 00b4 1981     		strh	r1, [r3, #8]	@ movhi
3536:Src/mpu6050.c ****             new_data = 1;
 7858              		.loc 1 3536 13 is_stmt 1 view .LVU2360
3536:Src/mpu6050.c ****             new_data = 1;
 7859              		.loc 1 3536 25 is_stmt 0 view .LVU2361
 7860 00b6 BDF82410 		ldrh	r1, [sp, #36]
 7861 00ba 5981     		strh	r1, [r3, #10]	@ movhi
3537:Src/mpu6050.c ****         }
 7862              		.loc 1 3537 13 is_stmt 1 view .LVU2362
 7863              	.LVL609:
 7864              	.L630:
3539:Src/mpu6050.c ****             mpu.quat.w = quat[0];
ARM GAS  /tmp/cc39PcX6.s 			page 244


 7865              		.loc 1 3539 9 view .LVU2363
3539:Src/mpu6050.c ****             mpu.quat.w = quat[0];
 7866              		.loc 1 3539 12 is_stmt 0 view .LVU2364
 7867 00bc D205     		lsls	r2, r2, #23
 7868 00be 0BD5     		bpl	.L622
3540:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7869              		.loc 1 3540 13 is_stmt 1 view .LVU2365
3540:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7870              		.loc 1 3540 30 is_stmt 0 view .LVU2366
 7871 00c0 264A     		ldr	r2, .L669+8
3540:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7872              		.loc 1 3540 24 view .LVU2367
 7873 00c2 274B     		ldr	r3, .L669+12
 7874 00c4 1168     		ldr	r1, [r2]
 7875 00c6 D960     		str	r1, [r3, #12]
3541:Src/mpu6050.c ****             mpu.quat.y = quat[2];
 7876              		.loc 1 3541 13 is_stmt 1 view .LVU2368
3541:Src/mpu6050.c ****             mpu.quat.y = quat[2];
 7877              		.loc 1 3541 24 is_stmt 0 view .LVU2369
 7878 00c8 5168     		ldr	r1, [r2, #4]
 7879 00ca 1961     		str	r1, [r3, #16]
3542:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7880              		.loc 1 3542 13 is_stmt 1 view .LVU2370
3542:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7881              		.loc 1 3542 24 is_stmt 0 view .LVU2371
 7882 00cc 9168     		ldr	r1, [r2, #8]
3543:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7883              		.loc 1 3543 24 view .LVU2372
 7884 00ce D268     		ldr	r2, [r2, #12]
3542:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7885              		.loc 1 3542 24 view .LVU2373
 7886 00d0 5961     		str	r1, [r3, #20]
3543:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7887              		.loc 1 3543 13 is_stmt 1 view .LVU2374
3543:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7888              		.loc 1 3543 24 is_stmt 0 view .LVU2375
 7889 00d2 9A61     		str	r2, [r3, #24]
3544:Src/mpu6050.c ****             new_data = 1;
 7890              		.loc 1 3544 13 is_stmt 1 view .LVU2376
 7891 00d4 FFF7FEFF 		bl	mpu_calc_euler_angles
 7892              	.LVL610:
3545:Src/mpu6050.c ****         }
 7893              		.loc 1 3545 13 view .LVU2377
 7894              	.L622:
3545:Src/mpu6050.c ****         }
 7895              		.loc 1 3545 13 is_stmt 0 view .LVU2378
 7896              	.LBE52:
3587:Src/mpu6050.c **** 
 7897              		.loc 1 3587 1 view .LVU2379
 7898 00d8 0BB0     		add	sp, sp, #44
 7899              	.LCFI116:
 7900              		.cfi_remember_state
 7901              		.cfi_def_cfa_offset 12
 7902              		@ sp needed
 7903 00da 30BD     		pop	{r4, r5, pc}
 7904              	.LVL611:
 7905              	.L625:
ARM GAS  /tmp/cc39PcX6.s 			page 245


 7906              	.LCFI117:
 7907              		.cfi_restore_state
3547:Src/mpu6050.c ****         short gyro[3], accel[3];
 7908              		.loc 1 3547 12 is_stmt 1 view .LVU2380
3547:Src/mpu6050.c ****         short gyro[3], accel[3];
 7909              		.loc 1 3547 19 is_stmt 0 view .LVU2381
 7910 00dc 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
3547:Src/mpu6050.c ****         short gyro[3], accel[3];
 7911              		.loc 1 3547 15 view .LVU2382
 7912 00de 002B     		cmp	r3, #0
 7913 00e0 FAD0     		beq	.L622
 7914              	.LBB53:
3548:Src/mpu6050.c ****         long temperature;
 7915              		.loc 1 3548 9 is_stmt 1 view .LVU2383
3549:Src/mpu6050.c ****         unsigned char sensors, more;
 7916              		.loc 1 3549 9 view .LVU2384
3550:Src/mpu6050.c ****         /* This function gets new data from the FIFO. The FIFO can contain
 7917              		.loc 1 3550 9 view .LVU2385
3560:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
 7918              		.loc 1 3560 9 view .LVU2386
3560:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
 7919              		.loc 1 3560 22 is_stmt 0 view .LVU2387
 7920 00e2 0023     		movs	r3, #0
 7921 00e4 2371     		strb	r3, [r4, #4]
3561:Src/mpu6050.c ****         if (more)
 7922              		.loc 1 3561 9 is_stmt 1 view .LVU2388
 7923 00e6 0DF10B03 		add	r3, sp, #11
 7924 00ea 0093     		str	r3, [sp]
 7925 00ec 03AA     		add	r2, sp, #12
 7926 00ee 0DF10A03 		add	r3, sp, #10
 7927 00f2 08A9     		add	r1, sp, #32
 7928 00f4 06A8     		add	r0, sp, #24
 7929 00f6 FFF7FEFF 		bl	mpu_read_fifo
 7930              	.LVL612:
3562:Src/mpu6050.c ****             hal.new_gyro = 1;
 7931              		.loc 1 3562 9 view .LVU2389
3562:Src/mpu6050.c ****             hal.new_gyro = 1;
 7932              		.loc 1 3562 12 is_stmt 0 view .LVU2390
 7933 00fa 9DF80B30 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 7934 00fe 0BB1     		cbz	r3, .L633
3563:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7935              		.loc 1 3563 13 is_stmt 1 view .LVU2391
3563:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7936              		.loc 1 3563 26 is_stmt 0 view .LVU2392
 7937 0100 0123     		movs	r3, #1
 7938 0102 2371     		strb	r3, [r4, #4]
 7939              	.L633:
3564:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7940              		.loc 1 3564 9 is_stmt 1 view .LVU2393
3564:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7941              		.loc 1 3564 12 is_stmt 0 view .LVU2394
 7942 0104 9DF80A30 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 7943 0108 13F0700F 		tst	r3, #112
 7944 010c 13D0     		beq	.L635
3565:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7945              		.loc 1 3565 13 is_stmt 1 view .LVU2395
3565:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
ARM GAS  /tmp/cc39PcX6.s 			page 246


 7946              		.loc 1 3565 24 is_stmt 0 view .LVU2396
 7947 010e 144C     		ldr	r4, .L669+12
 7948 0110 BDF81830 		ldrh	r3, [sp, #24]
 7949 0114 2380     		strh	r3, [r4]	@ movhi
3566:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7950              		.loc 1 3566 13 is_stmt 1 view .LVU2397
3566:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7951              		.loc 1 3566 24 is_stmt 0 view .LVU2398
 7952 0116 BDF81A30 		ldrh	r3, [sp, #26]
 7953 011a 6380     		strh	r3, [r4, #2]	@ movhi
3567:Src/mpu6050.c ****             new_data = 1;
 7954              		.loc 1 3567 13 is_stmt 1 view .LVU2399
3567:Src/mpu6050.c ****             new_data = 1;
 7955              		.loc 1 3567 24 is_stmt 0 view .LVU2400
 7956 011c BDF81C30 		ldrh	r3, [sp, #28]
 7957 0120 A380     		strh	r3, [r4, #4]	@ movhi
3568:Src/mpu6050.c ****             if (new_temp) {
 7958              		.loc 1 3568 13 is_stmt 1 view .LVU2401
 7959              	.LVL613:
3569:Src/mpu6050.c ****                 new_temp = 0;
 7960              		.loc 1 3569 13 view .LVU2402
3569:Src/mpu6050.c ****                 new_temp = 0;
 7961              		.loc 1 3569 16 is_stmt 0 view .LVU2403
 7962 0122 45B1     		cbz	r5, .L635
3570:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
 7963              		.loc 1 3570 17 is_stmt 1 view .LVU2404
 7964              	.LVL614:
3571:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
 7965              		.loc 1 3571 17 view .LVU2405
 7966 0124 03A9     		add	r1, sp, #12
 7967 0126 05A8     		add	r0, sp, #20
 7968 0128 FFF7FEFF 		bl	mpu_get_temperature
 7969              	.LVL615:
3572:Src/mpu6050.c ****             }
 7970              		.loc 1 3572 17 view .LVU2406
3572:Src/mpu6050.c ****             }
 7971              		.loc 1 3572 50 is_stmt 0 view .LVU2407
 7972 012c 6422     		movs	r2, #100
 7973 012e 059B     		ldr	r3, [sp, #20]
 7974 0130 5343     		muls	r3, r2, r3
3572:Src/mpu6050.c ****             }
 7975              		.loc 1 3572 56 view .LVU2408
 7976 0132 1B14     		asrs	r3, r3, #16
3572:Src/mpu6050.c ****             }
 7977              		.loc 1 3572 28 view .LVU2409
 7978 0134 6384     		strh	r3, [r4, #34]	@ movhi
 7979              	.LVL616:
 7980              	.L635:
3575:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7981              		.loc 1 3575 9 is_stmt 1 view .LVU2410
3575:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7982              		.loc 1 3575 12 is_stmt 0 view .LVU2411
 7983 0136 9DF80A30 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 7984 013a 1B07     		lsls	r3, r3, #28
 7985 013c CCD5     		bpl	.L622
3576:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7986              		.loc 1 3576 13 is_stmt 1 view .LVU2412
ARM GAS  /tmp/cc39PcX6.s 			page 247


3576:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7987              		.loc 1 3576 25 is_stmt 0 view .LVU2413
 7988 013e 084B     		ldr	r3, .L669+12
 7989 0140 BDF82020 		ldrh	r2, [sp, #32]
 7990 0144 DA80     		strh	r2, [r3, #6]	@ movhi
3577:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7991              		.loc 1 3577 13 is_stmt 1 view .LVU2414
3577:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7992              		.loc 1 3577 25 is_stmt 0 view .LVU2415
 7993 0146 BDF82220 		ldrh	r2, [sp, #34]
 7994 014a 1A81     		strh	r2, [r3, #8]	@ movhi
3578:Src/mpu6050.c ****             new_data = 1;
 7995              		.loc 1 3578 13 is_stmt 1 view .LVU2416
3578:Src/mpu6050.c ****             new_data = 1;
 7996              		.loc 1 3578 25 is_stmt 0 view .LVU2417
 7997 014c BDF82420 		ldrh	r2, [sp, #36]
 7998 0150 5A81     		strh	r2, [r3, #10]	@ movhi
3579:Src/mpu6050.c ****         }
 7999              		.loc 1 3579 13 is_stmt 1 view .LVU2418
 8000              	.LVL617:
3579:Src/mpu6050.c ****         }
 8001              		.loc 1 3579 13 is_stmt 0 view .LVU2419
 8002              	.LBE53:
3583:Src/mpu6050.c ****         // do something if needed
 8003              		.loc 1 3583 5 is_stmt 1 view .LVU2420
3585:Src/mpu6050.c ****         
 8004              		.loc 1 3585 5 view .LVU2421
3587:Src/mpu6050.c **** 
 8005              		.loc 1 3587 1 is_stmt 0 view .LVU2422
 8006 0152 C1E7     		b	.L622
 8007              	.L670:
 8008              		.align	2
 8009              	.L669:
 8010 0154 00000000 		.word	.LANCHOR0
 8011 0158 00000000 		.word	.LANCHOR2
 8012 015c 00000000 		.word	.LANCHOR5
 8013 0160 00000000 		.word	.LANCHOR4
 8014 0164 00000000 		.word	.LANCHOR6
 8015              		.cfi_endproc
 8016              	.LFE114:
 8018              		.section	.text.mpu_print_to_console,"ax",%progbits
 8019              		.align	1
 8020              		.global	mpu_print_to_console
 8021              		.syntax unified
 8022              		.thumb
 8023              		.thumb_func
 8024              		.fpu softvfp
 8026              	mpu_print_to_console:
 8027              	.LFB120:
3715:Src/mpu6050.c **** 
3716:Src/mpu6050.c **** 
3717:Src/mpu6050.c **** /* =========================== MPU Print data =========================== */
3718:Src/mpu6050.c **** 
3719:Src/mpu6050.c **** void mpu_print_to_console(void)
3720:Src/mpu6050.c **** {
 8028              		.loc 1 3720 1 is_stmt 1 view -0
 8029              		.cfi_startproc
ARM GAS  /tmp/cc39PcX6.s 			page 248


 8030              		@ args = 0, pretend = 0, frame = 0
 8031              		@ frame_needed = 0, uses_anonymous_args = 0
 8032              		@ link register save eliminated.
3721:Src/mpu6050.c **** #ifdef SERIAL_DEBUG
3722:Src/mpu6050.c ****     if (hal.report & PRINT_ACCEL) {
3723:Src/mpu6050.c ****         log_i( "accX:%d accY:%d accZ:%d\r\n", mpu.accel.x, mpu.accel.y, mpu.accel.z);
3724:Src/mpu6050.c ****     }
3725:Src/mpu6050.c ****     if (hal.report & PRINT_GYRO) {
3726:Src/mpu6050.c ****         log_i( "gyrX:%d gyrY:%d gyrZ:%d\r\n", mpu.gyro.x, mpu.gyro.y, mpu.gyro.z);
3727:Src/mpu6050.c ****     }
3728:Src/mpu6050.c ****     if (hal.report & PRINT_QUAT) {
3729:Src/mpu6050.c ****         log_i( "qW:%ld qX:%ld qY:%ld qZ:%ld\r\n", (long)mpu.quat.w, (long)mpu.quat.x, (long)mpu.qua
3730:Src/mpu6050.c ****     }
3731:Src/mpu6050.c ****     if (hal.report & PRINT_EULER) {
3732:Src/mpu6050.c ****         log_i( "Roll:%d Pitch:%d Yaw:%d\r\n", mpu.euler.roll, mpu.euler.pitch, mpu.euler.yaw);
3733:Src/mpu6050.c ****     }
3734:Src/mpu6050.c ****     if (hal.report & PRINT_TEMP) {
3735:Src/mpu6050.c ****         log_i( "Temp:%d\r\n", mpu.temp);
3736:Src/mpu6050.c ****     }
3737:Src/mpu6050.c ****     if (hal.report & PRINT_PEDO) {
3738:Src/mpu6050.c ****         unsigned long timestamp;
3739:Src/mpu6050.c ****         get_tick_count_ms(&timestamp);
3740:Src/mpu6050.c ****         if (timestamp > hal.next_pedo_ms) {
3741:Src/mpu6050.c ****             hal.next_pedo_ms = timestamp + PEDO_READ_MS;
3742:Src/mpu6050.c ****             unsigned long step_count, walk_time;
3743:Src/mpu6050.c ****             dmp_get_pedometer_step_count(&step_count);
3744:Src/mpu6050.c ****             dmp_get_pedometer_walk_time(&walk_time);
3745:Src/mpu6050.c ****             log_i( "Walked %ld steps in %ld sec\r\n", step_count, walk_time/1000);
3746:Src/mpu6050.c ****         }
3747:Src/mpu6050.c ****     }
3748:Src/mpu6050.c **** #endif
3749:Src/mpu6050.c **** }
 8033              		.loc 1 3749 1 view .LVU2424
 8034 0000 7047     		bx	lr
 8035              		.cfi_endproc
 8036              	.LFE120:
 8038              		.section	.text.mpu_handle_input,"ax",%progbits
 8039              		.align	1
 8040              		.global	mpu_handle_input
 8041              		.syntax unified
 8042              		.thumb
 8043              		.thumb_func
 8044              		.fpu softvfp
 8046              	mpu_handle_input:
 8047              	.LVL618:
 8048              	.LFB121:
3750:Src/mpu6050.c **** 
3751:Src/mpu6050.c **** #endif // MPU_SENSOR_ENABLE
3752:Src/mpu6050.c **** 
3753:Src/mpu6050.c **** 
3754:Src/mpu6050.c **** /* =========================== User Input Handling =========================== */
3755:Src/mpu6050.c **** 
3756:Src/mpu6050.c **** void mpu_handle_input(char c)
3757:Src/mpu6050.c **** {
 8049              		.loc 1 3757 1 view -0
 8050              		.cfi_startproc
 8051              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc39PcX6.s 			page 249


 8052              		@ frame_needed = 0, uses_anonymous_args = 0
 8053              		@ link register save eliminated.
3758:Src/mpu6050.c **** #ifdef SERIAL_DEBUG
3759:Src/mpu6050.c ****     switch (c) {
3760:Src/mpu6050.c ****         /* This command prints the Help text. */
3761:Src/mpu6050.c ****         case 'h':
3762:Src/mpu6050.c ****             consoleLog("=== HELP ===\r\n");
3763:Src/mpu6050.c ****             consoleLog("h: Print Help\r\n");
3764:Src/mpu6050.c ****             consoleLog("x: Print Serial AUX\r\n");
3765:Src/mpu6050.c ****             #ifdef MPU_SENSOR_ENABLE
3766:Src/mpu6050.c ****             consoleLog("8: Set Accelerometer on/off\r\n");
3767:Src/mpu6050.c ****             consoleLog("9: Set Gyroscope on/off\r\n");
3768:Src/mpu6050.c ****             consoleLog("r: Print Registers\r\n");
3769:Src/mpu6050.c ****             consoleLog("a: Print Accelerometer\r\n");
3770:Src/mpu6050.c ****             consoleLog("g: Print Gyroscope\r\n");
3771:Src/mpu6050.c ****             consoleLog("q: Print Quaternion\r\n");
3772:Src/mpu6050.c ****             consoleLog("e: Print Euler angles in deg*100\r\n");
3773:Src/mpu6050.c ****             consoleLog("t: Print Temperature in degC*100\r\n");
3774:Src/mpu6050.c ****             consoleLog("p: Print Pedometer\r\n");
3775:Src/mpu6050.c ****             consoleLog("0: Reset Pedometer\r\n");
3776:Src/mpu6050.c ****             consoleLog("1: Set DMP/MPU freq 10 Hz\r\n");
3777:Src/mpu6050.c ****             consoleLog("2: Set DMP/MPU freq 50 Hz\r\n");
3778:Src/mpu6050.c ****             consoleLog("3: Set DMP/MPU freq 100 Hz\r\n");
3779:Src/mpu6050.c ****             consoleLog(",: Set DMP interrupt to gesture\r\n");
3780:Src/mpu6050.c ****             consoleLog(".: Set DMP interrupt to continuous\r\n");
3781:Src/mpu6050.c ****             consoleLog("f: Set DMP on/off\r\n");
3782:Src/mpu6050.c ****             consoleLog("v: Set Quaternion on/off\r\n");
3783:Src/mpu6050.c ****             consoleLog("w: Test low-power accel mode\r\n");
3784:Src/mpu6050.c ****             consoleLog("s: Run self-test (device must be facing up or down)\r\n");
3785:Src/mpu6050.c ****             #endif // MPU_SENSOR_ENABLE
3786:Src/mpu6050.c ****             consoleLog("============\r\n");
3787:Src/mpu6050.c ****             break;
3788:Src/mpu6050.c **** 
3789:Src/mpu6050.c ****         /* These commands print individual sensor data. */
3790:Src/mpu6050.c ****         case 'x':
3791:Src/mpu6050.c ****             #ifdef SERIAL_AUX_RX
3792:Src/mpu6050.c ****             print_aux ^= PRINT_AUX;
3793:Src/mpu6050.c ****             #else
3794:Src/mpu6050.c ****             consoleLog("AUX serial NOT enabled\r\n");
3795:Src/mpu6050.c ****             #endif
3796:Src/mpu6050.c ****             break;
3797:Src/mpu6050.c **** 
3798:Src/mpu6050.c ****         #ifdef MPU_SENSOR_ENABLE
3799:Src/mpu6050.c ****         /* These commands turn off individual sensors. */
3800:Src/mpu6050.c ****         case '8':
3801:Src/mpu6050.c ****             hal.sensors ^= ACCEL_ON;
3802:Src/mpu6050.c ****             mpu_setup_gyro();
3803:Src/mpu6050.c ****             break;
3804:Src/mpu6050.c ****         case '9':
3805:Src/mpu6050.c ****             hal.sensors ^= GYRO_ON;
3806:Src/mpu6050.c ****             mpu_setup_gyro();
3807:Src/mpu6050.c ****             break;
3808:Src/mpu6050.c **** 
3809:Src/mpu6050.c ****         /* This command prints out the value of each gyro register for debugging.
3810:Src/mpu6050.c ****         * If logging is disabled, this function has no effect.
3811:Src/mpu6050.c ****         */
3812:Src/mpu6050.c ****         case 'r':
ARM GAS  /tmp/cc39PcX6.s 			page 250


3813:Src/mpu6050.c ****             mpu_reg_dump();
3814:Src/mpu6050.c ****             break;
3815:Src/mpu6050.c **** 
3816:Src/mpu6050.c ****         /* These commands print individual sensor data. */
3817:Src/mpu6050.c ****         case 'a':
3818:Src/mpu6050.c ****             hal.report ^= PRINT_ACCEL;
3819:Src/mpu6050.c ****             break;
3820:Src/mpu6050.c ****         case 'g':
3821:Src/mpu6050.c ****             hal.report ^= PRINT_GYRO;
3822:Src/mpu6050.c ****             break;
3823:Src/mpu6050.c ****         case 'q':
3824:Src/mpu6050.c ****             hal.report ^= PRINT_QUAT;
3825:Src/mpu6050.c ****             break;
3826:Src/mpu6050.c ****         case 'e':
3827:Src/mpu6050.c ****             hal.report ^= PRINT_EULER;
3828:Src/mpu6050.c ****             break;
3829:Src/mpu6050.c ****         case 't':
3830:Src/mpu6050.c ****             hal.report ^= PRINT_TEMP;
3831:Src/mpu6050.c ****             break;
3832:Src/mpu6050.c ****         case 'p':
3833:Src/mpu6050.c ****             /* Toggle pedometer display. */
3834:Src/mpu6050.c ****             hal.report ^= PRINT_PEDO;
3835:Src/mpu6050.c ****             break;
3836:Src/mpu6050.c ****         case '0':
3837:Src/mpu6050.c ****             /* Reset pedometer. */
3838:Src/mpu6050.c ****             dmp_set_pedometer_step_count(0);
3839:Src/mpu6050.c ****             dmp_set_pedometer_walk_time(0);
3840:Src/mpu6050.c ****             consoleLog("Pedometer reset OK\r\n");
3841:Src/mpu6050.c ****             break;
3842:Src/mpu6050.c **** 
3843:Src/mpu6050.c ****         /* Depending on your application, sensor data may be needed at a faster or
3844:Src/mpu6050.c ****         * slower rate. These commands can speed up or slow down the rate at which
3845:Src/mpu6050.c ****         * the sensor data is received.
3846:Src/mpu6050.c ****         */
3847:Src/mpu6050.c ****         case '1':
3848:Src/mpu6050.c ****             if (hal.dmp_on) {
3849:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(10))      {consoleLog("DMP 10 Hz\r\n");}
3850:Src/mpu6050.c ****             } else
3851:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(10))    {consoleLog("MPU 10 Hz\r\n");}
3852:Src/mpu6050.c ****             break;
3853:Src/mpu6050.c ****         case '2':
3854:Src/mpu6050.c ****             if (hal.dmp_on) {
3855:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(50))      {consoleLog("DMP 50 Hz\r\n");}
3856:Src/mpu6050.c ****             } else
3857:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(50))    {consoleLog("MPU 50 Hz\r\n");}
3858:Src/mpu6050.c ****             break;
3859:Src/mpu6050.c ****         case '3':
3860:Src/mpu6050.c ****             if (hal.dmp_on) {
3861:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(100))     {consoleLog("DMP 100 Hz\r\n");}
3862:Src/mpu6050.c ****             } else
3863:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(100))   {consoleLog("MPU 100 Hz\r\n");}
3864:Src/mpu6050.c ****             break;
3865:Src/mpu6050.c **** 
3866:Src/mpu6050.c ****             /* Set hardware to interrupt on gesture event only. This feature is
3867:Src/mpu6050.c ****             * useful for keeping the MCU asleep until the DMP detects as a tap or
3868:Src/mpu6050.c ****             * orientation event.
3869:Src/mpu6050.c ****             */
ARM GAS  /tmp/cc39PcX6.s 			page 251


3870:Src/mpu6050.c ****             case ',':
3871:Src/mpu6050.c ****             dmp_set_interrupt_mode(DMP_INT_GESTURE);
3872:Src/mpu6050.c ****             break;
3873:Src/mpu6050.c ****         case '.':
3874:Src/mpu6050.c ****             /* Set hardware to interrupt periodically. */
3875:Src/mpu6050.c ****             dmp_set_interrupt_mode(DMP_INT_CONTINUOUS);
3876:Src/mpu6050.c ****             break;
3877:Src/mpu6050.c **** 
3878:Src/mpu6050.c ****             /* Toggle DMP. */
3879:Src/mpu6050.c ****         case 'f':
3880:Src/mpu6050.c ****             if (hal.lp_accel_mode)  /* LP accel is not compatible with the DMP. */
3881:Src/mpu6050.c ****                 return;
3882:Src/mpu6050.c ****             if (hal.dmp_on) {
3883:Src/mpu6050.c ****                 unsigned short dmp_rate;
3884:Src/mpu6050.c ****                 unsigned char mask = 0;
3885:Src/mpu6050.c ****                 hal.dmp_on = 0;
3886:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
3887:Src/mpu6050.c ****                 /* Restore FIFO settings. */
3888:Src/mpu6050.c ****                 if (hal.sensors & ACCEL_ON)
3889:Src/mpu6050.c ****                     mask |= INV_XYZ_ACCEL;
3890:Src/mpu6050.c ****                 if (hal.sensors & GYRO_ON)
3891:Src/mpu6050.c ****                     mask |= INV_XYZ_GYRO;
3892:Src/mpu6050.c ****                 if (hal.sensors & COMPASS_ON)
3893:Src/mpu6050.c ****                     mask |= INV_XYZ_COMPASS;
3894:Src/mpu6050.c ****                 mpu_configure_fifo(mask);
3895:Src/mpu6050.c ****                 /* When the DMP is used, the hardware sampling rate is fixed at
3896:Src/mpu6050.c ****                 * 200Hz, and the DMP is configured to downsample the FIFO output
3897:Src/mpu6050.c ****                 * using the function dmp_set_fifo_rate. However, when the DMP is
3898:Src/mpu6050.c ****                 * turned off, the sampling rate remains at 200Hz. This could be
3899:Src/mpu6050.c ****                 * handled in mpu6050.c, but it would need to know that
3900:Src/mpu6050.c ****                 * mpu6050_dmp.c exists. To avoid this, we'll just
3901:Src/mpu6050.c ****                 * put the extra logic in the application layer.
3902:Src/mpu6050.c ****                 */
3903:Src/mpu6050.c ****                 dmp_get_fifo_rate(&dmp_rate);
3904:Src/mpu6050.c ****                 mpu_set_sample_rate(dmp_rate);
3905:Src/mpu6050.c ****                 consoleLog("DMP OFF\r\n");
3906:Src/mpu6050.c ****             } else {
3907:Src/mpu6050.c ****                 unsigned short sample_rate;
3908:Src/mpu6050.c ****                 hal.dmp_on = 1;
3909:Src/mpu6050.c ****                 /* Preserve current FIFO rate. */
3910:Src/mpu6050.c ****                 mpu_get_sample_rate(&sample_rate);
3911:Src/mpu6050.c ****                 dmp_set_fifo_rate(sample_rate);
3912:Src/mpu6050.c ****                 mpu_set_dmp_state(1);
3913:Src/mpu6050.c ****                 consoleLog("DMP ON\r\n");
3914:Src/mpu6050.c ****             }
3915:Src/mpu6050.c ****             break;
3916:Src/mpu6050.c **** 
3917:Src/mpu6050.c ****         case 'v':
3918:Src/mpu6050.c ****             /* Toggle LP quaternion.
3919:Src/mpu6050.c ****             * The DMP features can be enabled/disabled at runtime. Use this same
3920:Src/mpu6050.c ****             * approach for other features.
3921:Src/mpu6050.c ****             */
3922:Src/mpu6050.c ****             hal.dmp_features ^= DMP_FEATURE_6X_LP_QUAT;
3923:Src/mpu6050.c ****             dmp_enable_feature(hal.dmp_features);
3924:Src/mpu6050.c ****             if (!(hal.dmp_features & DMP_FEATURE_6X_LP_QUAT)) {
3925:Src/mpu6050.c ****                 consoleLog("Quat OFF\n");
3926:Src/mpu6050.c ****             } else
ARM GAS  /tmp/cc39PcX6.s 			page 252


3927:Src/mpu6050.c ****                 consoleLog("Quat ON\n");
3928:Src/mpu6050.c ****             break;
3929:Src/mpu6050.c **** 
3930:Src/mpu6050.c ****             /* Test out low-power accel mode. */
3931:Src/mpu6050.c ****         case 'w':
3932:Src/mpu6050.c ****             if (hal.dmp_on) {
3933:Src/mpu6050.c ****                 consoleLog("Low-power mode needs DMP to be off!\r\n");
3934:Src/mpu6050.c ****                 break;  /* LP accel is not compatible with the DMP. */
3935:Src/mpu6050.c ****             }
3936:Src/mpu6050.c ****             mpu_lp_accel_mode(20);
3937:Src/mpu6050.c ****             /* When LP accel mode is enabled, the driver automatically configures
3938:Src/mpu6050.c ****             * the hardware for latched interrupts. However, the MCU sometimes
3939:Src/mpu6050.c ****             * misses the rising/falling edge, and the hal.new_gyro flag is never
3940:Src/mpu6050.c ****             * set. To avoid getting locked in this state, we're overriding the
3941:Src/mpu6050.c ****             * driver's configuration and sticking to unlatched interrupt mode.
3942:Src/mpu6050.c ****             *
3943:Src/mpu6050.c ****             * TODO: The MCU supports level-triggered interrupts.
3944:Src/mpu6050.c ****             */
3945:Src/mpu6050.c ****             mpu_set_int_latched(0);
3946:Src/mpu6050.c ****             hal.sensors &= ~(GYRO_ON|COMPASS_ON);
3947:Src/mpu6050.c ****             hal.sensors |= ACCEL_ON;
3948:Src/mpu6050.c ****             hal.lp_accel_mode = 1;
3949:Src/mpu6050.c ****             break;
3950:Src/mpu6050.c **** 
3951:Src/mpu6050.c ****         /* The hardware self test is completely localized in the gyro driver.
3952:Src/mpu6050.c ****         * Logging is assumed to be enabled; otherwise, a couple LEDs could
3953:Src/mpu6050.c ****         * probably be used here to display the test results.
3954:Src/mpu6050.c ****         */
3955:Src/mpu6050.c ****         case 's':
3956:Src/mpu6050.c ****             mpu_start_self_test();
3957:Src/mpu6050.c ****             break;
3958:Src/mpu6050.c ****         #endif // MPU_SENSOR_ENABLE
3959:Src/mpu6050.c **** 
3960:Src/mpu6050.c ****         default:
3961:Src/mpu6050.c ****             break;
3962:Src/mpu6050.c ****     }
3963:Src/mpu6050.c **** #endif // SERIAL_DEBUG
3964:Src/mpu6050.c **** }
 8054              		.loc 1 3964 1 view .LVU2426
 8055 0000 7047     		bx	lr
 8056              		.cfi_endproc
 8057              	.LFE121:
 8059              		.global	test
 8060              		.global	hw
 8061              		.global	reg
 8062              		.global	mpu
 8063              		.section	.rodata
 8064              		.set	.LANCHOR1,. + 0
 8065              	.LC10:
 8066 0000 00000000 		.ascii	"\000\000\000\000\000\000"
 8066      0000
 8067              		.section	.bss.hal,"aw",%nobits
 8068              		.align	2
 8069              		.set	.LANCHOR2,. + 0
 8072              	hal:
 8073 0000 00000000 		.space	28
 8073      00000000 
ARM GAS  /tmp/cc39PcX6.s 			page 253


 8073      00000000 
 8073      00000000 
 8073      00000000 
 8074              		.section	.bss.mpu,"aw",%nobits
 8075              		.align	2
 8076              		.set	.LANCHOR4,. + 0
 8079              	mpu:
 8080 0000 00000000 		.space	36
 8080      00000000 
 8080      00000000 
 8080      00000000 
 8080      00000000 
 8081              		.section	.bss.quat.1,"aw",%nobits
 8082              		.align	2
 8083              		.set	.LANCHOR5,. + 0
 8086              	quat.1:
 8087 0000 00000000 		.space	16
 8087      00000000 
 8087      00000000 
 8087      00000000 
 8088              		.section	.bss.temperature.0,"aw",%nobits
 8089              		.align	2
 8090              		.set	.LANCHOR6,. + 0
 8093              	temperature.0:
 8094 0000 00000000 		.space	4
 8095              		.section	.data.MPU_ORIENTATION,"aw"
 8096              		.set	.LANCHOR3,. + 0
 8099              	MPU_ORIENTATION:
 8100 0000 01000000 		.ascii	"\001\000\000\000\001\000\000\000\001"
 8100      01000000 
 8100      01
 8101              		.section	.data.st,"aw"
 8102              		.align	2
 8103              		.set	.LANCHOR0,. + 0
 8106              	st:
 8107 0000 00000000 		.word	reg
 8108 0004 00000000 		.word	hw
 8109 0008 00000000 		.space	32
 8109      00000000 
 8109      00000000 
 8109      00000000 
 8109      00000000 
 8110 0028 00000000 		.word	test
 8111              		.section	.rodata.hw,"a"
 8112              		.align	1
 8115              	hw:
 8116 0000 68       		.byte	104
 8117 0001 00       		.space	1
 8118 0002 0004     		.short	1024
 8119 0004 76       		.byte	118
 8120 0005 00       		.space	1
 8121 0006 5401     		.short	340
 8122 0008 F7FD     		.short	-521
 8123 000a 0001     		.short	256
 8124              		.section	.rodata.reg,"a"
 8127              	reg:
 8128 0000 75       		.byte	117
ARM GAS  /tmp/cc39PcX6.s 			page 254


 8129 0001 19       		.byte	25
 8130 0002 1A       		.byte	26
 8131 0003 0C       		.byte	12
 8132 0004 6A       		.byte	106
 8133 0005 23       		.byte	35
 8134 0006 1B       		.byte	27
 8135 0007 1C       		.byte	28
 8136 0008 0000     		.space	2
 8137 000a 1F       		.byte	31
 8138 000b 20       		.byte	32
 8139 000c 72       		.byte	114
 8140 000d 74       		.byte	116
 8141 000e 43       		.byte	67
 8142 000f 3B       		.byte	59
 8143 0010 41       		.byte	65
 8144 0011 38       		.byte	56
 8145 0012 39       		.byte	57
 8146 0013 3A       		.byte	58
 8147 0014 00       		.space	1
 8148 0015 6B       		.byte	107
 8149 0016 6C       		.byte	108
 8150 0017 37       		.byte	55
 8151 0018 6F       		.byte	111
 8152 0019 06       		.byte	6
 8153 001a 24       		.byte	36
 8154 001b 6D       		.byte	109
 8155 001c 6E       		.byte	110
 8156 001d 70       		.byte	112
 8157              		.section	.rodata.test,"a"
 8158              		.align	2
 8161              	test:
 8162 0000 83000000 		.word	131
 8163 0004 00080000 		.word	2048
 8164 0008 00       		.byte	0
 8165 0009 01       		.byte	1
 8166 000a 00       		.byte	0
 8167 000b 18       		.byte	24
 8168 000c 3200     		.short	50
 8169 000e 05       		.byte	5
 8170 000f 00       		.space	1
 8171 0010 00002041 		.word	1092616192
 8172 0014 0000D242 		.word	1121058816
 8173 0018 295C0F3E 		.word	1041194025
 8174 001c 9A99993E 		.word	1050253722
 8175 0020 3333733F 		.word	1064514355
 8176 0024 295C0F3E 		.word	1041194025
 8177              		.text
 8178              	.Letext0:
 8179              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 8180              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 8181              		.file 4 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 8182              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 8183              		.file 6 "Inc/defines.h"
 8184              		.file 7 "Inc/util.h"
 8185              		.file 8 "/usr/include/newlib/math.h"
 8186              		.file 9 "Inc/mpu6050_dmp.h"
 8187              		.file 10 "Inc/systick.h"
ARM GAS  /tmp/cc39PcX6.s 			page 255


 8188              		.file 11 "/usr/include/newlib/string.h"
ARM GAS  /tmp/cc39PcX6.s 			page 256


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mpu6050.c
     /tmp/cc39PcX6.s:17     .text.get_st_biases:0000000000000000 $t
     /tmp/cc39PcX6.s:24     .text.get_st_biases:0000000000000000 get_st_biases
     /tmp/cc39PcX6.s:556    .text.get_st_biases:00000000000002e4 $d
     /tmp/cc39PcX6.s:563    .text.get_st_biases:00000000000002e8 $t
     /tmp/cc39PcX6.s:654    .text.mpu_tap_func:0000000000000000 $t
     /tmp/cc39PcX6.s:661    .text.mpu_tap_func:0000000000000000 mpu_tap_func
     /tmp/cc39PcX6.s:677    .text.mpu_tap_func:000000000000000a $d
     /tmp/cc39PcX6.s:683    .text.mpu_tap_func:0000000000000010 $t
     /tmp/cc39PcX6.s:717    .text.mpu_tap_func:000000000000002c $d
     /tmp/cc39PcX6.s:736    .text.mpu_android_orient_func:0000000000000000 $t
     /tmp/cc39PcX6.s:743    .text.mpu_android_orient_func:0000000000000000 mpu_android_orient_func
     /tmp/cc39PcX6.s:756    .text.mpu_android_orient_func:0000000000000008 $d
     /tmp/cc39PcX6.s:760    .text.mpu_android_orient_func:000000000000000c $t
     /tmp/cc39PcX6.s:796    .text.mpu_android_orient_func:0000000000000020 $d
     /tmp/cc39PcX6.s:804    .text.set_int_enable.isra.0:0000000000000000 $t
     /tmp/cc39PcX6.s:810    .text.set_int_enable.isra.0:0000000000000000 set_int_enable.isra.0
     /tmp/cc39PcX6.s:887    .text.set_int_enable.isra.0:0000000000000048 $d
     /tmp/cc39PcX6.s:892    .text.mpu_reg_dump:0000000000000000 $t
     /tmp/cc39PcX6.s:899    .text.mpu_reg_dump:0000000000000000 mpu_reg_dump
     /tmp/cc39PcX6.s:983    .text.mpu_reg_dump:0000000000000040 $d
     /tmp/cc39PcX6.s:988    .text.mpu_read_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:995    .text.mpu_read_reg:0000000000000000 mpu_read_reg
     /tmp/cc39PcX6.s:1053   .text.mpu_read_reg:0000000000000030 $d
     /tmp/cc39PcX6.s:1058   .text.mpu_get_gyro_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:1065   .text.mpu_get_gyro_reg:0000000000000000 mpu_get_gyro_reg
     /tmp/cc39PcX6.s:1156   .text.mpu_get_gyro_reg:0000000000000054 $d
     /tmp/cc39PcX6.s:1161   .text.mpu_get_accel_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:1168   .text.mpu_get_accel_reg:0000000000000000 mpu_get_accel_reg
     /tmp/cc39PcX6.s:1259   .text.mpu_get_accel_reg:0000000000000054 $d
     /tmp/cc39PcX6.s:1270   .text.mpu_get_temperature:0000000000000000 $t
     /tmp/cc39PcX6.s:1277   .text.mpu_get_temperature:0000000000000000 mpu_get_temperature
     /tmp/cc39PcX6.s:1396   .text.mpu_get_temperature:0000000000000078 $d
     /tmp/cc39PcX6.s:1402   .text.mpu_read_6500_accel_bias:0000000000000000 $t
     /tmp/cc39PcX6.s:1409   .text.mpu_read_6500_accel_bias:0000000000000000 mpu_read_6500_accel_bias
     /tmp/cc39PcX6.s:1504   .text.mpu_read_6500_accel_bias:0000000000000064 $d
     /tmp/cc39PcX6.s:1509   .text.mpu_read_6050_accel_bias:0000000000000000 $t
     /tmp/cc39PcX6.s:1516   .text.mpu_read_6050_accel_bias:0000000000000000 mpu_read_6050_accel_bias
     /tmp/cc39PcX6.s:1611   .text.mpu_read_6050_accel_bias:0000000000000064 $d
     /tmp/cc39PcX6.s:1616   .text.mpu_read_6500_gyro_bias:0000000000000000 $t
     /tmp/cc39PcX6.s:1623   .text.mpu_read_6500_gyro_bias:0000000000000000 mpu_read_6500_gyro_bias
     /tmp/cc39PcX6.s:1718   .text.mpu_read_6500_gyro_bias:0000000000000064 $d
     /tmp/cc39PcX6.s:1723   .text.mpu_set_gyro_bias_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:1730   .text.mpu_set_gyro_bias_reg:0000000000000000 mpu_set_gyro_bias_reg
     /tmp/cc39PcX6.s:1855   .text.mpu_set_gyro_bias_reg:0000000000000078 $d
     /tmp/cc39PcX6.s:1860   .text.mpu_set_accel_bias_6050_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:1867   .text.mpu_set_accel_bias_6050_reg:0000000000000000 mpu_set_accel_bias_6050_reg
     /tmp/cc39PcX6.s:2031   .text.mpu_set_accel_bias_6050_reg:00000000000000ac $d
     /tmp/cc39PcX6.s:2037   .text.mpu_set_accel_bias_6500_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:2044   .text.mpu_set_accel_bias_6500_reg:0000000000000000 mpu_set_accel_bias_6500_reg
     /tmp/cc39PcX6.s:2208   .text.mpu_set_accel_bias_6500_reg:00000000000000ac $d
     /tmp/cc39PcX6.s:2214   .text.mpu_reset_fifo:0000000000000000 $t
     /tmp/cc39PcX6.s:2221   .text.mpu_reset_fifo:0000000000000000 mpu_reset_fifo
     /tmp/cc39PcX6.s:2472   .text.mpu_reset_fifo:0000000000000164 $d
     /tmp/cc39PcX6.s:2478   .text.mpu_get_gyro_fsr:0000000000000000 $t
     /tmp/cc39PcX6.s:2485   .text.mpu_get_gyro_fsr:0000000000000000 mpu_get_gyro_fsr
ARM GAS  /tmp/cc39PcX6.s 			page 257


     /tmp/cc39PcX6.s:2502   .text.mpu_get_gyro_fsr:000000000000000c $d
     /tmp/cc39PcX6.s:2506   .text.mpu_get_gyro_fsr:0000000000000010 $t
     /tmp/cc39PcX6.s:2545   .text.mpu_get_gyro_fsr:0000000000000030 $d
     /tmp/cc39PcX6.s:2550   .text.mpu_set_gyro_fsr:0000000000000000 $t
     /tmp/cc39PcX6.s:2557   .text.mpu_set_gyro_fsr:0000000000000000 mpu_set_gyro_fsr
     /tmp/cc39PcX6.s:2665   .text.mpu_set_gyro_fsr:000000000000006c $d
     /tmp/cc39PcX6.s:2670   .text.mpu_get_accel_fsr:0000000000000000 $t
     /tmp/cc39PcX6.s:2677   .text.mpu_get_accel_fsr:0000000000000000 mpu_get_accel_fsr
     /tmp/cc39PcX6.s:2694   .text.mpu_get_accel_fsr:000000000000000c $d
     /tmp/cc39PcX6.s:2698   .text.mpu_get_accel_fsr:0000000000000010 $t
     /tmp/cc39PcX6.s:2747   .text.mpu_get_accel_fsr:0000000000000034 $d
     /tmp/cc39PcX6.s:2752   .text.mpu_set_accel_fsr:0000000000000000 $t
     /tmp/cc39PcX6.s:2759   .text.mpu_set_accel_fsr:0000000000000000 mpu_set_accel_fsr
     /tmp/cc39PcX6.s:2867   .text.mpu_set_accel_fsr:0000000000000064 $d
     /tmp/cc39PcX6.s:2872   .text.mpu_get_lpf:0000000000000000 $t
     /tmp/cc39PcX6.s:2879   .text.mpu_get_lpf:0000000000000000 mpu_get_lpf
     /tmp/cc39PcX6.s:2897   .text.mpu_get_lpf:000000000000000e $d
     /tmp/cc39PcX6.s:2903   .text.mpu_get_lpf:0000000000000014 $t
     /tmp/cc39PcX6.s:2952   .text.mpu_get_lpf:0000000000000034 $d
     /tmp/cc39PcX6.s:2957   .text.mpu_set_lpf:0000000000000000 $t
     /tmp/cc39PcX6.s:2964   .text.mpu_set_lpf:0000000000000000 mpu_set_lpf
     /tmp/cc39PcX6.s:3086   .text.mpu_set_lpf:0000000000000068 $d
     /tmp/cc39PcX6.s:3091   .text.mpu_get_sample_rate:0000000000000000 $t
     /tmp/cc39PcX6.s:3098   .text.mpu_get_sample_rate:0000000000000000 mpu_get_sample_rate
     /tmp/cc39PcX6.s:3132   .text.mpu_get_sample_rate:0000000000000018 $d
     /tmp/cc39PcX6.s:3137   .text.mpu_get_compass_sample_rate:0000000000000000 $t
     /tmp/cc39PcX6.s:3144   .text.mpu_get_compass_sample_rate:0000000000000000 mpu_get_compass_sample_rate
     /tmp/cc39PcX6.s:3166   .text.mpu_set_compass_sample_rate:0000000000000000 $t
     /tmp/cc39PcX6.s:3173   .text.mpu_set_compass_sample_rate:0000000000000000 mpu_set_compass_sample_rate
     /tmp/cc39PcX6.s:3191   .text.mpu_get_gyro_sens:0000000000000000 $t
     /tmp/cc39PcX6.s:3198   .text.mpu_get_gyro_sens:0000000000000000 mpu_get_gyro_sens
     /tmp/cc39PcX6.s:3215   .text.mpu_get_gyro_sens:000000000000000c $d
     /tmp/cc39PcX6.s:3219   .text.mpu_get_gyro_sens:0000000000000010 $t
     /tmp/cc39PcX6.s:3258   .text.mpu_get_gyro_sens:000000000000002c $d
     /tmp/cc39PcX6.s:3267   .text.mpu_get_accel_sens:0000000000000000 $t
     /tmp/cc39PcX6.s:3274   .text.mpu_get_accel_sens:0000000000000000 mpu_get_accel_sens
     /tmp/cc39PcX6.s:3291   .text.mpu_get_accel_sens:000000000000000c $d
     /tmp/cc39PcX6.s:3295   .text.mpu_get_accel_sens:0000000000000010 $t
     /tmp/cc39PcX6.s:3344   .text.mpu_get_accel_sens:000000000000003c $d
     /tmp/cc39PcX6.s:3349   .text.mpu_get_fifo_config:0000000000000000 $t
     /tmp/cc39PcX6.s:3356   .text.mpu_get_fifo_config:0000000000000000 mpu_get_fifo_config
     /tmp/cc39PcX6.s:3379   .text.mpu_get_fifo_config:000000000000000c $d
     /tmp/cc39PcX6.s:3384   .text.mpu_configure_fifo:0000000000000000 $t
     /tmp/cc39PcX6.s:3391   .text.mpu_configure_fifo:0000000000000000 mpu_configure_fifo
     /tmp/cc39PcX6.s:3486   .text.mpu_configure_fifo:0000000000000048 $d
     /tmp/cc39PcX6.s:3491   .text.mpu_get_power_state:0000000000000000 $t
     /tmp/cc39PcX6.s:3498   .text.mpu_get_power_state:0000000000000000 mpu_get_power_state
     /tmp/cc39PcX6.s:3524   .text.mpu_get_power_state:0000000000000010 $d
     /tmp/cc39PcX6.s:3529   .text.mpu_get_int_status:0000000000000000 $t
     /tmp/cc39PcX6.s:3536   .text.mpu_get_int_status:0000000000000000 mpu_get_int_status
     /tmp/cc39PcX6.s:3599   .text.mpu_get_int_status:0000000000000030 $d
     /tmp/cc39PcX6.s:3604   .text.mpu_read_fifo:0000000000000000 $t
     /tmp/cc39PcX6.s:3611   .text.mpu_read_fifo:0000000000000000 mpu_read_fifo
     /tmp/cc39PcX6.s:3966   .text.mpu_read_fifo:000000000000019c $d
     /tmp/cc39PcX6.s:3971   .text.mpu_read_fifo_stream:0000000000000000 $t
     /tmp/cc39PcX6.s:3978   .text.mpu_read_fifo_stream:0000000000000000 mpu_read_fifo_stream
     /tmp/cc39PcX6.s:4122   .text.mpu_read_fifo_stream:0000000000000094 $d
ARM GAS  /tmp/cc39PcX6.s 			page 258


     /tmp/cc39PcX6.s:4127   .text.mpu_set_bypass:0000000000000000 $t
     /tmp/cc39PcX6.s:4134   .text.mpu_set_bypass:0000000000000000 mpu_set_bypass
     /tmp/cc39PcX6.s:4317   .text.mpu_set_bypass:00000000000000e4 $d
     /tmp/cc39PcX6.s:4322   .text.mpu_set_int_level:0000000000000000 $t
     /tmp/cc39PcX6.s:4329   .text.mpu_set_int_level:0000000000000000 mpu_set_int_level
     /tmp/cc39PcX6.s:4350   .text.mpu_set_int_level:000000000000000c $d
     /tmp/cc39PcX6.s:4355   .text.mpu_set_int_latched:0000000000000000 $t
     /tmp/cc39PcX6.s:4362   .text.mpu_set_int_latched:0000000000000000 mpu_set_int_latched
     /tmp/cc39PcX6.s:4454   .text.mpu_set_int_latched:0000000000000060 $d
     /tmp/cc39PcX6.s:4459   .text.mpu_lp_accel_mode:0000000000000000 $t
     /tmp/cc39PcX6.s:4466   .text.mpu_lp_accel_mode:0000000000000000 mpu_lp_accel_mode
     /tmp/cc39PcX6.s:4647   .text.mpu_lp_accel_mode:00000000000000ac $d
     /tmp/cc39PcX6.s:4652   .text.mpu_set_sample_rate:0000000000000000 $t
     /tmp/cc39PcX6.s:4659   .text.mpu_set_sample_rate:0000000000000000 mpu_set_sample_rate
     /tmp/cc39PcX6.s:4779   .text.mpu_set_sample_rate:000000000000007c $d
     /tmp/cc39PcX6.s:4784   .text.mpu_set_sensors:0000000000000000 $t
     /tmp/cc39PcX6.s:4791   .text.mpu_set_sensors:0000000000000000 mpu_set_sensors
     /tmp/cc39PcX6.s:4959   .text.mpu_set_sensors:00000000000000bc $d
     /tmp/cc39PcX6.s:4964   .text.mpu_init:0000000000000000 $t
     /tmp/cc39PcX6.s:4971   .text.mpu_init:0000000000000000 mpu_init
     /tmp/cc39PcX6.s:5140   .text.mpu_init:00000000000000b0 $d
     /tmp/cc39PcX6.s:5145   .text.mpu_write_mem:0000000000000000 $t
     /tmp/cc39PcX6.s:5152   .text.mpu_write_mem:0000000000000000 mpu_write_mem
     /tmp/cc39PcX6.s:5252   .text.mpu_write_mem:000000000000005c $d
     /tmp/cc39PcX6.s:5257   .text.mpu_read_mem:0000000000000000 $t
     /tmp/cc39PcX6.s:5264   .text.mpu_read_mem:0000000000000000 mpu_read_mem
     /tmp/cc39PcX6.s:5364   .text.mpu_read_mem:000000000000005c $d
     /tmp/cc39PcX6.s:5369   .text.mpu_load_firmware:0000000000000000 $t
     /tmp/cc39PcX6.s:5376   .text.mpu_load_firmware:0000000000000000 mpu_load_firmware
     /tmp/cc39PcX6.s:5528   .text.mpu_load_firmware:000000000000009c $d
     /tmp/cc39PcX6.s:5533   .text.mpu_set_dmp_state:0000000000000000 $t
     /tmp/cc39PcX6.s:5540   .text.mpu_set_dmp_state:0000000000000000 mpu_set_dmp_state
     /tmp/cc39PcX6.s:5666   .text.mpu_set_dmp_state:0000000000000078 $d
     /tmp/cc39PcX6.s:5674   .text.mpu_run_self_test:0000000000000000 $t
     /tmp/cc39PcX6.s:5681   .text.mpu_run_self_test:0000000000000000 mpu_run_self_test
     /tmp/cc39PcX6.s:6385   .text.mpu_run_self_test:00000000000002ec $d
     /tmp/cc39PcX6.s:6401   .text.mpu_get_dmp_state:0000000000000000 $t
     /tmp/cc39PcX6.s:6408   .text.mpu_get_dmp_state:0000000000000000 mpu_get_dmp_state
     /tmp/cc39PcX6.s:6431   .text.mpu_get_dmp_state:000000000000000c $d
     /tmp/cc39PcX6.s:6436   .text.mpu_get_compass_reg:0000000000000000 $t
     /tmp/cc39PcX6.s:6443   .text.mpu_get_compass_reg:0000000000000000 mpu_get_compass_reg
     /tmp/cc39PcX6.s:6461   .text.mpu_get_compass_fsr:0000000000000000 $t
     /tmp/cc39PcX6.s:6468   .text.mpu_get_compass_fsr:0000000000000000 mpu_get_compass_fsr
     /tmp/cc39PcX6.s:6486   .text.mpu_lp_motion_interrupt:0000000000000000 $t
     /tmp/cc39PcX6.s:6493   .text.mpu_lp_motion_interrupt:0000000000000000 mpu_lp_motion_interrupt
     /tmp/cc39PcX6.s:6668   .text.mpu_lp_motion_interrupt:000000000000009c $d
     /tmp/cc39PcX6.s:6686   .text.mpu_start_self_test:0000000000000000 $t
     /tmp/cc39PcX6.s:6693   .text.mpu_start_self_test:0000000000000000 mpu_start_self_test
     /tmp/cc39PcX6.s:6773   .text.mpu_start_self_test:0000000000000038 $d
     /tmp/cc39PcX6.s:6790   .text.mpu_setup_gyro:0000000000000000 $t
     /tmp/cc39PcX6.s:6797   .text.mpu_setup_gyro:0000000000000000 mpu_setup_gyro
     /tmp/cc39PcX6.s:6895   .text.mpu_setup_gyro:0000000000000050 $d
     /tmp/cc39PcX6.s:6904   .text.inv_row_2_scale:0000000000000000 $t
     /tmp/cc39PcX6.s:6911   .text.inv_row_2_scale:0000000000000000 inv_row_2_scale
     /tmp/cc39PcX6.s:7012   .text.inv_orientation_matrix_to_scalar:0000000000000000 $t
     /tmp/cc39PcX6.s:7019   .text.inv_orientation_matrix_to_scalar:0000000000000000 inv_orientation_matrix_to_scalar
     /tmp/cc39PcX6.s:7080   .text.mpu_config:0000000000000000 $t
ARM GAS  /tmp/cc39PcX6.s 			page 259


     /tmp/cc39PcX6.s:7087   .text.mpu_config:0000000000000000 mpu_config
     /tmp/cc39PcX6.s:7215   .text.mpu_config:0000000000000088 $d
     /tmp/cc39PcX6.s:7228   .text.mpu_read_gyro_raw:0000000000000000 $t
     /tmp/cc39PcX6.s:7235   .text.mpu_read_gyro_raw:0000000000000000 mpu_read_gyro_raw
     /tmp/cc39PcX6.s:7283   .text.mpu_read_gyro_raw:0000000000000034 $d
     /tmp/cc39PcX6.s:7289   .text.mpu_read_accel_raw:0000000000000000 $t
     /tmp/cc39PcX6.s:7296   .text.mpu_read_accel_raw:0000000000000000 mpu_read_accel_raw
     /tmp/cc39PcX6.s:7344   .text.mpu_read_accel_raw:0000000000000034 $d
     /tmp/cc39PcX6.s:7354   .text.mpu_calc_euler_angles:0000000000000000 $t
     /tmp/cc39PcX6.s:7361   .text.mpu_calc_euler_angles:0000000000000000 mpu_calc_euler_angles
     /tmp/cc39PcX6.s:7683   .text.mpu_calc_euler_angles:00000000000001a8 $d
     /tmp/cc39PcX6.s:7691   .text.mpu_get_data:0000000000000000 $t
     /tmp/cc39PcX6.s:7698   .text.mpu_get_data:0000000000000000 mpu_get_data
     /tmp/cc39PcX6.s:8010   .text.mpu_get_data:0000000000000154 $d
     /tmp/cc39PcX6.s:8019   .text.mpu_print_to_console:0000000000000000 $t
     /tmp/cc39PcX6.s:8026   .text.mpu_print_to_console:0000000000000000 mpu_print_to_console
     /tmp/cc39PcX6.s:8039   .text.mpu_handle_input:0000000000000000 $t
     /tmp/cc39PcX6.s:8046   .text.mpu_handle_input:0000000000000000 mpu_handle_input
     /tmp/cc39PcX6.s:8161   .rodata.test:0000000000000000 test
     /tmp/cc39PcX6.s:8115   .rodata.hw:0000000000000000 hw
     /tmp/cc39PcX6.s:8127   .rodata.reg:0000000000000000 reg
     /tmp/cc39PcX6.s:8079   .bss.mpu:0000000000000000 mpu
     /tmp/cc39PcX6.s:8068   .bss.hal:0000000000000000 $d
     /tmp/cc39PcX6.s:8072   .bss.hal:0000000000000000 hal
     /tmp/cc39PcX6.s:8075   .bss.mpu:0000000000000000 $d
     /tmp/cc39PcX6.s:8082   .bss.quat.1:0000000000000000 $d
     /tmp/cc39PcX6.s:8086   .bss.quat.1:0000000000000000 quat.1
     /tmp/cc39PcX6.s:8089   .bss.temperature.0:0000000000000000 $d
     /tmp/cc39PcX6.s:8093   .bss.temperature.0:0000000000000000 temperature.0
     /tmp/cc39PcX6.s:8099   .data.MPU_ORIENTATION:0000000000000000 MPU_ORIENTATION
     /tmp/cc39PcX6.s:8102   .data.st:0000000000000000 $d
     /tmp/cc39PcX6.s:8106   .data.st:0000000000000000 st
     /tmp/cc39PcX6.s:8112   .rodata.hw:0000000000000000 $d
     /tmp/cc39PcX6.s:8136   .rodata.reg:0000000000000008 $d
     /tmp/cc39PcX6.s:8158   .rodata.test:0000000000000000 $d

UNDEFINED SYMBOLS
__aeabi_ldivmod
i2c_writeBytes
delay_1ms
i2c_readBytes
consoleLog
get_tick_count_ms
__aeabi_i2f
__aeabi_fsub
__aeabi_fdiv
__aeabi_fadd
__aeabi_fmul
__aeabi_f2iz
memcmp
__aeabi_fcmpeq
__aeabi_fcmpgt
__aeabi_fcmplt
dmp_load_motion_driver_firmware
dmp_set_orientation
dmp_register_tap_cb
dmp_register_android_orient_cb
ARM GAS  /tmp/cc39PcX6.s 			page 260


dmp_enable_feature
dmp_set_fifo_rate
__aeabi_f2d
__aeabi_d2f
__aeabi_dmul
__aeabi_d2iz
atan2
asin
i2c_readByte
dmp_read_fifo
