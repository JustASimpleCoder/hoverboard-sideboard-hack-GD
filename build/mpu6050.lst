ARM GAS  /tmp/ccNfEN49.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"mpu6050.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_ldivmod
  16              		.section	.text.get_st_biases,"ax",%progbits
  17              		.align	1
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	get_st_biases:
  25              	.LVL0:
  26              	.LFB99:
  27              		.file 1 "Src/mpu6050.c"
   1:Src/mpu6050.c **** /**
   2:Src/mpu6050.c ****   * This file was taken from InvenSense MotionApps v6.12 library and
   3:Src/mpu6050.c ****   * refactored for the hoverboard-sideboard-hack project.
   4:Src/mpu6050.c ****   *
   5:Src/mpu6050.c ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   6:Src/mpu6050.c ****   * Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
   7:Src/mpu6050.c ****   *
   8:Src/mpu6050.c ****   * This program is free software: you can redistribute it and/or modify
   9:Src/mpu6050.c ****   * it under the terms of the GNU General Public License as published by
  10:Src/mpu6050.c ****   * the Free Software Foundation, either version 3 of the License, or
  11:Src/mpu6050.c ****   * (at your option) any later version.
  12:Src/mpu6050.c ****   *
  13:Src/mpu6050.c ****   * This program is distributed in the hope that it will be useful,
  14:Src/mpu6050.c ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:Src/mpu6050.c ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:Src/mpu6050.c ****   * GNU General Public License for more details.
  17:Src/mpu6050.c ****   *
  18:Src/mpu6050.c ****   * You should have received a copy of the GNU General Public License
  19:Src/mpu6050.c ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  20:Src/mpu6050.c **** */
  21:Src/mpu6050.c **** 
  22:Src/mpu6050.c **** // Includes
  23:Src/mpu6050.c **** #include <stdio.h>
  24:Src/mpu6050.c **** #include <stdlib.h>
  25:Src/mpu6050.c **** #include <string.h>
  26:Src/mpu6050.c **** #include <math.h>
  27:Src/mpu6050.c **** #include "systick.h" 	
  28:Src/mpu6050.c **** #include "defines.h"
  29:Src/mpu6050.c **** #include "config.h"
  30:Src/mpu6050.c **** #include "util.h"
  31:Src/mpu6050.c **** #include "mpu6050.h"
ARM GAS  /tmp/ccNfEN49.s 			page 2


  32:Src/mpu6050.c **** #include "mpu6050_dmp.h"
  33:Src/mpu6050.c **** #include "madgwick_filter.h"
  34:Src/mpu6050.c **** 
  35:Src/mpu6050.c **** /* The following functions must be defined for this platform:
  36:Src/mpu6050.c ****  * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
  37:Src/mpu6050.c ****  *      unsigned char length, unsigned char const *data)
  38:Src/mpu6050.c ****  * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
  39:Src/mpu6050.c ****  *      unsigned char length, unsigned char *data)
  40:Src/mpu6050.c ****  * delay_ms(unsigned long num_ms)
  41:Src/mpu6050.c ****  * get_ms(unsigned long *count)
  42:Src/mpu6050.c ****  * labs(long x)
  43:Src/mpu6050.c ****  * fabsf(float x)
  44:Src/mpu6050.c ****  * min(int a, int b)
  45:Src/mpu6050.c ****  */
  46:Src/mpu6050.c **** 
  47:Src/mpu6050.c **** MPU_Data mpu;                                       // holds the MPU-6050 data
  48:Src/mpu6050.c **** Quaternion imu_quaternion;
  49:Src/mpu6050.c **** double last_quat_timestamp;
  50:Src/mpu6050.c **** 
  51:Src/mpu6050.c **** #ifdef SERIAL_AUX_RX
  52:Src/mpu6050.c **** uint8_t print_aux = 0;                              // print AUX serial data
  53:Src/mpu6050.c **** #endif
  54:Src/mpu6050.c **** 
  55:Src/mpu6050.c **** #ifdef  MPU_SENSOR_ENABLE
  56:Src/mpu6050.c **** 
  57:Src/mpu6050.c **** static signed char MPU_ORIENTATION[9] = {1, 0, 0,   // [-] MPU Sensor orientation matrix: set this 
  58:Src/mpu6050.c ****                                          0, 1, 0,
  59:Src/mpu6050.c ****                                          0, 0, 1};
  60:Src/mpu6050.c **** 
  61:Src/mpu6050.c **** 
  62:Src/mpu6050.c **** #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
  63:Src/mpu6050.c **** #error  Which gyro are you using? Define MPUxxxx in config.h
  64:Src/mpu6050.c **** #endif
  65:Src/mpu6050.c **** 
  66:Src/mpu6050.c **** 
  67:Src/mpu6050.c **** 
  68:Src/mpu6050.c **** /* Time for some messy macro work. =]
  69:Src/mpu6050.c ****  * #define MPU9150
  70:Src/mpu6050.c ****  * is equivalent to..
  71:Src/mpu6050.c ****  * #define MPU6050
  72:Src/mpu6050.c ****  * #define AK8975_SECONDARY
  73:Src/mpu6050.c ****  *
  74:Src/mpu6050.c ****  * #define MPU9250
  75:Src/mpu6050.c ****  * is equivalent to..
  76:Src/mpu6050.c ****  * #define MPU6500
  77:Src/mpu6050.c ****  * #define AK8963_SECONDARY
  78:Src/mpu6050.c ****  */
  79:Src/mpu6050.c **** #if defined MPU9150
  80:Src/mpu6050.c **** #ifndef MPU6050
  81:Src/mpu6050.c **** #define MPU6050
  82:Src/mpu6050.c **** #endif                          /* #ifndef MPU6050 */
  83:Src/mpu6050.c **** #if defined AK8963_SECONDARY
  84:Src/mpu6050.c **** #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
  85:Src/mpu6050.c **** #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
  86:Src/mpu6050.c **** #define AK8975_SECONDARY
  87:Src/mpu6050.c **** #endif                          /* #if defined AK8963_SECONDARY */
  88:Src/mpu6050.c **** #elif defined MPU9250           /* #if defined MPU9150 */
ARM GAS  /tmp/ccNfEN49.s 			page 3


  89:Src/mpu6050.c **** #ifndef MPU6500
  90:Src/mpu6050.c **** #define MPU6500
  91:Src/mpu6050.c **** #endif                          /* #ifndef MPU6500 */
  92:Src/mpu6050.c **** #if defined AK8975_SECONDARY
  93:Src/mpu6050.c **** #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
  94:Src/mpu6050.c **** #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
  95:Src/mpu6050.c **** #define AK8963_SECONDARY
  96:Src/mpu6050.c **** #endif                          /* #if defined AK8975_SECONDARY */
  97:Src/mpu6050.c **** #endif                          /* #if defined MPU9150 */
  98:Src/mpu6050.c **** 
  99:Src/mpu6050.c **** #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
 100:Src/mpu6050.c **** #define AK89xx_SECONDARY
 101:Src/mpu6050.c **** #else
 102:Src/mpu6050.c **** /* #warning "No compass = less profit for Invensense. Lame." */
 103:Src/mpu6050.c **** #endif
 104:Src/mpu6050.c **** 
 105:Src/mpu6050.c **** static int set_int_enable(unsigned char enable);
 106:Src/mpu6050.c **** 
 107:Src/mpu6050.c **** /* Hardware registers needed by driver. */
 108:Src/mpu6050.c **** struct gyro_reg_s {
 109:Src/mpu6050.c ****     unsigned char who_am_i;
 110:Src/mpu6050.c ****     unsigned char rate_div;
 111:Src/mpu6050.c ****     unsigned char lpf;
 112:Src/mpu6050.c ****     unsigned char prod_id;
 113:Src/mpu6050.c ****     unsigned char user_ctrl;
 114:Src/mpu6050.c ****     unsigned char fifo_en;
 115:Src/mpu6050.c ****     unsigned char gyro_cfg;
 116:Src/mpu6050.c ****     unsigned char accel_cfg;
 117:Src/mpu6050.c ****     unsigned char accel_cfg2;
 118:Src/mpu6050.c ****     unsigned char lp_accel_odr;
 119:Src/mpu6050.c ****     unsigned char motion_thr;
 120:Src/mpu6050.c ****     unsigned char motion_dur;
 121:Src/mpu6050.c ****     unsigned char fifo_count_h;
 122:Src/mpu6050.c ****     unsigned char fifo_r_w;
 123:Src/mpu6050.c ****     unsigned char raw_gyro;
 124:Src/mpu6050.c ****     unsigned char raw_accel;
 125:Src/mpu6050.c ****     unsigned char temp;
 126:Src/mpu6050.c ****     unsigned char int_enable;
 127:Src/mpu6050.c ****     unsigned char dmp_int_status;
 128:Src/mpu6050.c ****     unsigned char int_status;
 129:Src/mpu6050.c ****     unsigned char accel_intel;
 130:Src/mpu6050.c ****     unsigned char pwr_mgmt_1;
 131:Src/mpu6050.c ****     unsigned char pwr_mgmt_2;
 132:Src/mpu6050.c ****     unsigned char int_pin_cfg;
 133:Src/mpu6050.c ****     unsigned char mem_r_w;
 134:Src/mpu6050.c ****     unsigned char accel_offs;
 135:Src/mpu6050.c ****     unsigned char i2c_mst;
 136:Src/mpu6050.c ****     unsigned char bank_sel;
 137:Src/mpu6050.c ****     unsigned char mem_start_addr;
 138:Src/mpu6050.c ****     unsigned char prgm_start_h;
 139:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 140:Src/mpu6050.c ****     unsigned char s0_addr;
 141:Src/mpu6050.c ****     unsigned char s0_reg;
 142:Src/mpu6050.c ****     unsigned char s0_ctrl;
 143:Src/mpu6050.c ****     unsigned char s1_addr;
 144:Src/mpu6050.c ****     unsigned char s1_reg;
 145:Src/mpu6050.c ****     unsigned char s1_ctrl;
ARM GAS  /tmp/ccNfEN49.s 			page 4


 146:Src/mpu6050.c ****     unsigned char s4_ctrl;
 147:Src/mpu6050.c ****     unsigned char s0_do;
 148:Src/mpu6050.c ****     unsigned char s1_do;
 149:Src/mpu6050.c ****     unsigned char i2c_delay_ctrl;
 150:Src/mpu6050.c ****     unsigned char raw_compass;
 151:Src/mpu6050.c ****     /* The I2C_MST_VDDIO bit is in this register. */
 152:Src/mpu6050.c ****     unsigned char yg_offs_tc;
 153:Src/mpu6050.c **** #endif
 154:Src/mpu6050.c **** };
 155:Src/mpu6050.c **** 
 156:Src/mpu6050.c **** /* Information specific to a particular device. */
 157:Src/mpu6050.c **** struct hw_s {
 158:Src/mpu6050.c ****     unsigned char addr;
 159:Src/mpu6050.c ****     unsigned short max_fifo;
 160:Src/mpu6050.c ****     unsigned char num_reg;
 161:Src/mpu6050.c ****     unsigned short temp_sens;
 162:Src/mpu6050.c ****     short temp_offset;
 163:Src/mpu6050.c ****     unsigned short bank_size;
 164:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 165:Src/mpu6050.c ****     unsigned short compass_fsr;
 166:Src/mpu6050.c **** #endif
 167:Src/mpu6050.c **** };
 168:Src/mpu6050.c **** 
 169:Src/mpu6050.c **** /* When entering motion interrupt mode, the driver keeps track of the
 170:Src/mpu6050.c ****  * previous state so that it can be restored at a later time.
 171:Src/mpu6050.c ****  * TODO: This is tacky. Fix it.
 172:Src/mpu6050.c ****  */
 173:Src/mpu6050.c **** struct motion_int_cache_s {
 174:Src/mpu6050.c ****     unsigned short gyro_fsr;
 175:Src/mpu6050.c ****     unsigned char accel_fsr;
 176:Src/mpu6050.c ****     unsigned short lpf;
 177:Src/mpu6050.c ****     unsigned short sample_rate;
 178:Src/mpu6050.c ****     unsigned char sensors_on;
 179:Src/mpu6050.c ****     unsigned char fifo_sensors;
 180:Src/mpu6050.c ****     unsigned char dmp_on;
 181:Src/mpu6050.c **** };
 182:Src/mpu6050.c **** 
 183:Src/mpu6050.c **** /* Cached chip configuration data.
 184:Src/mpu6050.c ****  * TODO: A lot of these can be handled with a bitmask.
 185:Src/mpu6050.c ****  */
 186:Src/mpu6050.c **** struct chip_cfg_s {
 187:Src/mpu6050.c ****     /* Matches gyro_cfg >> 3 & 0x03 */
 188:Src/mpu6050.c ****     unsigned char gyro_fsr;
 189:Src/mpu6050.c ****     /* Matches accel_cfg >> 3 & 0x03 */
 190:Src/mpu6050.c ****     unsigned char accel_fsr;
 191:Src/mpu6050.c ****     /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
 192:Src/mpu6050.c ****     unsigned char sensors;
 193:Src/mpu6050.c ****     /* Matches config register. */
 194:Src/mpu6050.c ****     unsigned char lpf;
 195:Src/mpu6050.c ****     unsigned char clk_src;
 196:Src/mpu6050.c ****     /* Sample rate, NOT rate divider. */
 197:Src/mpu6050.c ****     unsigned short sample_rate;
 198:Src/mpu6050.c ****     /* Matches fifo_en register. */
 199:Src/mpu6050.c ****     unsigned char fifo_enable;
 200:Src/mpu6050.c ****     /* Matches int enable register. */
 201:Src/mpu6050.c ****     unsigned char int_enable;
 202:Src/mpu6050.c ****     /* 1 if devices on auxiliary I2C bus appear on the primary. */
ARM GAS  /tmp/ccNfEN49.s 			page 5


 203:Src/mpu6050.c ****     unsigned char bypass_mode;
 204:Src/mpu6050.c ****     /* 1 if half-sensitivity.
 205:Src/mpu6050.c ****      * NOTE: This doesn't belong here, but everything else in hw_s is const,
 206:Src/mpu6050.c ****      * and this allows us to save some precious RAM.
 207:Src/mpu6050.c ****      */
 208:Src/mpu6050.c ****     unsigned char accel_half;
 209:Src/mpu6050.c ****     /* 1 if device in low-power accel-only mode. */
 210:Src/mpu6050.c ****     unsigned char lp_accel_mode;
 211:Src/mpu6050.c ****     /* 1 if interrupts are only triggered on motion events. */
 212:Src/mpu6050.c ****     unsigned char int_motion_only;
 213:Src/mpu6050.c ****     struct motion_int_cache_s cache;
 214:Src/mpu6050.c ****     /* 1 for active low interrupts. */
 215:Src/mpu6050.c ****     unsigned char active_low_int;
 216:Src/mpu6050.c ****     /* 1 for latched interrupts. */
 217:Src/mpu6050.c ****     unsigned char latched_int;
 218:Src/mpu6050.c ****     /* 1 if DMP is enabled. */
 219:Src/mpu6050.c ****     unsigned char dmp_on;
 220:Src/mpu6050.c ****     /* Ensures that DMP will only be loaded once. */
 221:Src/mpu6050.c ****     unsigned char dmp_loaded;
 222:Src/mpu6050.c ****     /* Sampling rate used when DMP is enabled. */
 223:Src/mpu6050.c ****     unsigned short dmp_sample_rate;
 224:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 225:Src/mpu6050.c ****     /* Compass sample rate. */
 226:Src/mpu6050.c ****     unsigned short compass_sample_rate;
 227:Src/mpu6050.c ****     unsigned char compass_addr;
 228:Src/mpu6050.c ****     short mag_sens_adj[3];
 229:Src/mpu6050.c **** #endif
 230:Src/mpu6050.c **** };
 231:Src/mpu6050.c **** 
 232:Src/mpu6050.c **** /* Information for self-test. */
 233:Src/mpu6050.c **** struct test_s {
 234:Src/mpu6050.c ****     unsigned long gyro_sens;
 235:Src/mpu6050.c ****     unsigned long accel_sens;
 236:Src/mpu6050.c ****     unsigned char reg_rate_div;
 237:Src/mpu6050.c ****     unsigned char reg_lpf;
 238:Src/mpu6050.c ****     unsigned char reg_gyro_fsr;
 239:Src/mpu6050.c ****     unsigned char reg_accel_fsr;
 240:Src/mpu6050.c ****     unsigned short wait_ms;
 241:Src/mpu6050.c ****     unsigned char packet_thresh;
 242:Src/mpu6050.c ****     float min_dps;
 243:Src/mpu6050.c ****     float max_dps;
 244:Src/mpu6050.c ****     float max_gyro_var;
 245:Src/mpu6050.c ****     float min_g;
 246:Src/mpu6050.c ****     float max_g;
 247:Src/mpu6050.c ****     float max_accel_var;
 248:Src/mpu6050.c **** #ifdef MPU6500
 249:Src/mpu6050.c ****     float max_g_offset;
 250:Src/mpu6050.c ****     unsigned short sample_wait_ms;
 251:Src/mpu6050.c **** #endif
 252:Src/mpu6050.c **** };
 253:Src/mpu6050.c **** 
 254:Src/mpu6050.c **** /* Gyro driver state variables. */
 255:Src/mpu6050.c **** struct gyro_state_s {
 256:Src/mpu6050.c ****     const struct gyro_reg_s *reg;
 257:Src/mpu6050.c ****     const struct hw_s *hw;
 258:Src/mpu6050.c ****     struct chip_cfg_s chip_cfg;
 259:Src/mpu6050.c ****     const struct test_s *test;
ARM GAS  /tmp/ccNfEN49.s 			page 6


 260:Src/mpu6050.c **** };
 261:Src/mpu6050.c **** 
 262:Src/mpu6050.c **** /* Filter configurations. */
 263:Src/mpu6050.c **** enum lpf_e {
 264:Src/mpu6050.c ****     INV_FILTER_256HZ_NOLPF2 = 0,
 265:Src/mpu6050.c ****     INV_FILTER_188HZ,
 266:Src/mpu6050.c ****     INV_FILTER_98HZ,
 267:Src/mpu6050.c ****     INV_FILTER_42HZ,
 268:Src/mpu6050.c ****     INV_FILTER_20HZ,
 269:Src/mpu6050.c ****     INV_FILTER_10HZ,
 270:Src/mpu6050.c ****     INV_FILTER_5HZ,
 271:Src/mpu6050.c ****     INV_FILTER_2100HZ_NOLPF,
 272:Src/mpu6050.c ****     NUM_FILTER
 273:Src/mpu6050.c **** };
 274:Src/mpu6050.c **** 
 275:Src/mpu6050.c **** /* Full scale ranges. */
 276:Src/mpu6050.c **** enum gyro_fsr_e {
 277:Src/mpu6050.c ****     INV_FSR_250DPS = 0,
 278:Src/mpu6050.c ****     INV_FSR_500DPS,
 279:Src/mpu6050.c ****     INV_FSR_1000DPS,
 280:Src/mpu6050.c ****     INV_FSR_2000DPS,
 281:Src/mpu6050.c ****     NUM_GYRO_FSR
 282:Src/mpu6050.c **** };
 283:Src/mpu6050.c **** 
 284:Src/mpu6050.c **** /* Full scale ranges. */
 285:Src/mpu6050.c **** enum accel_fsr_e {
 286:Src/mpu6050.c ****     INV_FSR_2G = 0,
 287:Src/mpu6050.c ****     INV_FSR_4G,
 288:Src/mpu6050.c ****     INV_FSR_8G,
 289:Src/mpu6050.c ****     INV_FSR_16G,
 290:Src/mpu6050.c ****     NUM_ACCEL_FSR
 291:Src/mpu6050.c **** };
 292:Src/mpu6050.c **** 
 293:Src/mpu6050.c **** /* Clock sources. */
 294:Src/mpu6050.c **** enum clock_sel_e {
 295:Src/mpu6050.c ****     INV_CLK_INTERNAL = 0,
 296:Src/mpu6050.c ****     INV_CLK_PLL,
 297:Src/mpu6050.c ****     NUM_CLK
 298:Src/mpu6050.c **** };
 299:Src/mpu6050.c **** 
 300:Src/mpu6050.c **** /* Low-power accel wakeup rates. */
 301:Src/mpu6050.c **** enum lp_accel_rate_e {
 302:Src/mpu6050.c **** #if defined MPU6050
 303:Src/mpu6050.c ****     INV_LPA_1_25HZ,
 304:Src/mpu6050.c ****     INV_LPA_5HZ,
 305:Src/mpu6050.c ****     INV_LPA_20HZ,
 306:Src/mpu6050.c ****     INV_LPA_40HZ
 307:Src/mpu6050.c **** #elif defined MPU6500
 308:Src/mpu6050.c ****     INV_LPA_0_3125HZ,
 309:Src/mpu6050.c ****     INV_LPA_0_625HZ,
 310:Src/mpu6050.c ****     INV_LPA_1_25HZ,
 311:Src/mpu6050.c ****     INV_LPA_2_5HZ,
 312:Src/mpu6050.c ****     INV_LPA_5HZ,
 313:Src/mpu6050.c ****     INV_LPA_10HZ,
 314:Src/mpu6050.c ****     INV_LPA_20HZ,
 315:Src/mpu6050.c ****     INV_LPA_40HZ,
 316:Src/mpu6050.c ****     INV_LPA_80HZ,
ARM GAS  /tmp/ccNfEN49.s 			page 7


 317:Src/mpu6050.c ****     INV_LPA_160HZ,
 318:Src/mpu6050.c ****     INV_LPA_320HZ,
 319:Src/mpu6050.c ****     INV_LPA_640HZ
 320:Src/mpu6050.c **** #endif
 321:Src/mpu6050.c **** };
 322:Src/mpu6050.c **** 
 323:Src/mpu6050.c **** #define BIT_I2C_MST_VDDIO   (0x80)
 324:Src/mpu6050.c **** #define BIT_FIFO_EN         (0x40)
 325:Src/mpu6050.c **** #define BIT_DMP_EN          (0x80)
 326:Src/mpu6050.c **** #define BIT_FIFO_RST        (0x04)
 327:Src/mpu6050.c **** #define BIT_DMP_RST         (0x08)
 328:Src/mpu6050.c **** #define BIT_FIFO_OVERFLOW   (0x10)
 329:Src/mpu6050.c **** #define BIT_DATA_RDY_EN     (0x01)
 330:Src/mpu6050.c **** #define BIT_DMP_INT_EN      (0x02)
 331:Src/mpu6050.c **** #define BIT_MOT_INT_EN      (0x40)
 332:Src/mpu6050.c **** #define BITS_FSR            (0x18)
 333:Src/mpu6050.c **** #define BITS_LPF            (0x07)
 334:Src/mpu6050.c **** #define BITS_HPF            (0x07)
 335:Src/mpu6050.c **** #define BITS_CLK            (0x07)
 336:Src/mpu6050.c **** #define BIT_FIFO_SIZE_1024  (0x40)
 337:Src/mpu6050.c **** #define BIT_FIFO_SIZE_2048  (0x80)
 338:Src/mpu6050.c **** #define BIT_FIFO_SIZE_4096  (0xC0)
 339:Src/mpu6050.c **** #define BIT_RESET           (0x80)
 340:Src/mpu6050.c **** #define BIT_SLEEP           (0x40)
 341:Src/mpu6050.c **** #define BIT_S0_DELAY_EN     (0x01)
 342:Src/mpu6050.c **** #define BIT_S2_DELAY_EN     (0x04)
 343:Src/mpu6050.c **** #define BITS_SLAVE_LENGTH   (0x0F)
 344:Src/mpu6050.c **** #define BIT_SLAVE_BYTE_SW   (0x40)
 345:Src/mpu6050.c **** #define BIT_SLAVE_GROUP     (0x10)
 346:Src/mpu6050.c **** #define BIT_SLAVE_EN        (0x80)
 347:Src/mpu6050.c **** #define BIT_I2C_READ        (0x80)
 348:Src/mpu6050.c **** #define BITS_I2C_MASTER_DLY (0x1F)
 349:Src/mpu6050.c **** #define BIT_AUX_IF_EN       (0x20)
 350:Src/mpu6050.c **** #define BIT_ACTL            (0x80)
 351:Src/mpu6050.c **** #define BIT_LATCH_EN        (0x20)
 352:Src/mpu6050.c **** #define BIT_ANY_RD_CLR      (0x10)
 353:Src/mpu6050.c **** #define BIT_BYPASS_EN       (0x02)
 354:Src/mpu6050.c **** #define BITS_WOM_EN         (0xC0)
 355:Src/mpu6050.c **** #define BIT_LPA_CYCLE       (0x20)
 356:Src/mpu6050.c **** #define BIT_STBY_XA         (0x20)
 357:Src/mpu6050.c **** #define BIT_STBY_YA         (0x10)
 358:Src/mpu6050.c **** #define BIT_STBY_ZA         (0x08)
 359:Src/mpu6050.c **** #define BIT_STBY_XG         (0x04)
 360:Src/mpu6050.c **** #define BIT_STBY_YG         (0x02)
 361:Src/mpu6050.c **** #define BIT_STBY_ZG         (0x01)
 362:Src/mpu6050.c **** #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
 363:Src/mpu6050.c **** #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
 364:Src/mpu6050.c **** 
 365:Src/mpu6050.c **** #if defined AK8975_SECONDARY
 366:Src/mpu6050.c **** #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
 367:Src/mpu6050.c **** #define AK89xx_FSR                  (9830)
 368:Src/mpu6050.c **** #elif defined AK8963_SECONDARY
 369:Src/mpu6050.c **** #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
 370:Src/mpu6050.c **** #define AK89xx_FSR                  (4915)
 371:Src/mpu6050.c **** #endif
 372:Src/mpu6050.c **** 
 373:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
ARM GAS  /tmp/ccNfEN49.s 			page 8


 374:Src/mpu6050.c **** #define AKM_REG_WHOAMI      (0x00)
 375:Src/mpu6050.c **** 
 376:Src/mpu6050.c **** #define AKM_REG_ST1         (0x02)
 377:Src/mpu6050.c **** #define AKM_REG_HXL         (0x03)
 378:Src/mpu6050.c **** #define AKM_REG_ST2         (0x09)
 379:Src/mpu6050.c **** 
 380:Src/mpu6050.c **** #define AKM_REG_CNTL        (0x0A)
 381:Src/mpu6050.c **** #define AKM_REG_ASTC        (0x0C)
 382:Src/mpu6050.c **** #define AKM_REG_ASAX        (0x10)
 383:Src/mpu6050.c **** #define AKM_REG_ASAY        (0x11)
 384:Src/mpu6050.c **** #define AKM_REG_ASAZ        (0x12)
 385:Src/mpu6050.c **** 
 386:Src/mpu6050.c **** #define AKM_DATA_READY      (0x01)
 387:Src/mpu6050.c **** #define AKM_DATA_OVERRUN    (0x02)
 388:Src/mpu6050.c **** #define AKM_OVERFLOW        (0x80)
 389:Src/mpu6050.c **** #define AKM_DATA_ERROR      (0x40)
 390:Src/mpu6050.c **** 
 391:Src/mpu6050.c **** #define AKM_BIT_SELF_TEST   (0x40)
 392:Src/mpu6050.c **** 
 393:Src/mpu6050.c **** #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
 394:Src/mpu6050.c **** #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
 395:Src/mpu6050.c **** #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
 396:Src/mpu6050.c **** #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
 397:Src/mpu6050.c **** 
 398:Src/mpu6050.c **** #define AKM_WHOAMI      (0x48)
 399:Src/mpu6050.c **** #endif
 400:Src/mpu6050.c **** 
 401:Src/mpu6050.c **** #if defined MPU6050
 402:Src/mpu6050.c **** const struct gyro_reg_s reg = {
 403:Src/mpu6050.c ****     .who_am_i       = 0x75,
 404:Src/mpu6050.c ****     .rate_div       = 0x19,
 405:Src/mpu6050.c ****     .lpf            = 0x1A,
 406:Src/mpu6050.c ****     .prod_id        = 0x0C,
 407:Src/mpu6050.c ****     .user_ctrl      = 0x6A,
 408:Src/mpu6050.c ****     .fifo_en        = 0x23,
 409:Src/mpu6050.c ****     .gyro_cfg       = 0x1B,
 410:Src/mpu6050.c ****     .accel_cfg      = 0x1C,
 411:Src/mpu6050.c ****     .motion_thr     = 0x1F,
 412:Src/mpu6050.c ****     .motion_dur     = 0x20,
 413:Src/mpu6050.c ****     .fifo_count_h   = 0x72,
 414:Src/mpu6050.c ****     .fifo_r_w       = 0x74,
 415:Src/mpu6050.c ****     .raw_gyro       = 0x43,
 416:Src/mpu6050.c ****     .raw_accel      = 0x3B,
 417:Src/mpu6050.c ****     .temp           = 0x41,
 418:Src/mpu6050.c ****     .int_enable     = 0x38,
 419:Src/mpu6050.c ****     .dmp_int_status = 0x39,
 420:Src/mpu6050.c ****     .int_status     = 0x3A,
 421:Src/mpu6050.c ****     .pwr_mgmt_1     = 0x6B,
 422:Src/mpu6050.c ****     .pwr_mgmt_2     = 0x6C,
 423:Src/mpu6050.c ****     .int_pin_cfg    = 0x37,
 424:Src/mpu6050.c ****     .mem_r_w        = 0x6F,
 425:Src/mpu6050.c ****     .accel_offs     = 0x06,
 426:Src/mpu6050.c ****     .i2c_mst        = 0x24,
 427:Src/mpu6050.c ****     .bank_sel       = 0x6D,
 428:Src/mpu6050.c ****     .mem_start_addr = 0x6E,
 429:Src/mpu6050.c ****     .prgm_start_h   = 0x70
 430:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
ARM GAS  /tmp/ccNfEN49.s 			page 9


 431:Src/mpu6050.c ****     ,.raw_compass   = 0x49,
 432:Src/mpu6050.c ****     .yg_offs_tc     = 0x01,
 433:Src/mpu6050.c ****     .s0_addr        = 0x25,
 434:Src/mpu6050.c ****     .s0_reg         = 0x26,
 435:Src/mpu6050.c ****     .s0_ctrl        = 0x27,
 436:Src/mpu6050.c ****     .s1_addr        = 0x28,
 437:Src/mpu6050.c ****     .s1_reg         = 0x29,
 438:Src/mpu6050.c ****     .s1_ctrl        = 0x2A,
 439:Src/mpu6050.c ****     .s4_ctrl        = 0x34,
 440:Src/mpu6050.c ****     .s0_do          = 0x63,
 441:Src/mpu6050.c ****     .s1_do          = 0x64,
 442:Src/mpu6050.c ****     .i2c_delay_ctrl = 0x67
 443:Src/mpu6050.c **** #endif
 444:Src/mpu6050.c **** };
 445:Src/mpu6050.c **** const struct hw_s hw = {
 446:Src/mpu6050.c ****     .addr           = 0x68,
 447:Src/mpu6050.c ****     .max_fifo       = 1024,
 448:Src/mpu6050.c ****     .num_reg        = 118,
 449:Src/mpu6050.c ****     .temp_sens      = 340,
 450:Src/mpu6050.c ****     .temp_offset    = -521,
 451:Src/mpu6050.c ****     .bank_size      = 256
 452:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 453:Src/mpu6050.c ****     ,.compass_fsr    = AK89xx_FSR
 454:Src/mpu6050.c **** #endif
 455:Src/mpu6050.c **** };
 456:Src/mpu6050.c **** 
 457:Src/mpu6050.c **** const struct test_s test = {
 458:Src/mpu6050.c ****     .gyro_sens      = 32768/250,
 459:Src/mpu6050.c ****     .accel_sens     = 32768/16,
 460:Src/mpu6050.c ****     .reg_rate_div   = 0,    /* 1kHz. */
 461:Src/mpu6050.c ****     .reg_lpf        = 1,    /* 188Hz. */
 462:Src/mpu6050.c ****     .reg_gyro_fsr   = 0,    /* 250dps. */
 463:Src/mpu6050.c ****     .reg_accel_fsr  = 0x18, /* 16g. */
 464:Src/mpu6050.c ****     .wait_ms        = 50,
 465:Src/mpu6050.c ****     .packet_thresh  = 5,    /* 5% */
 466:Src/mpu6050.c ****     .min_dps        = 10.f,
 467:Src/mpu6050.c ****     .max_dps        = 105.f,
 468:Src/mpu6050.c ****     .max_gyro_var   = 0.14f,
 469:Src/mpu6050.c ****     .min_g          = 0.3f,
 470:Src/mpu6050.c ****     .max_g          = 0.95f,
 471:Src/mpu6050.c ****     .max_accel_var  = 0.14f
 472:Src/mpu6050.c **** };
 473:Src/mpu6050.c **** 
 474:Src/mpu6050.c **** static struct gyro_state_s st = {
 475:Src/mpu6050.c ****     .reg = &reg,
 476:Src/mpu6050.c ****     .hw = &hw,
 477:Src/mpu6050.c ****     .test = &test
 478:Src/mpu6050.c **** };
 479:Src/mpu6050.c **** #elif defined MPU6500
 480:Src/mpu6050.c **** const struct gyro_reg_s reg = {
 481:Src/mpu6050.c ****     .who_am_i       = 0x75,
 482:Src/mpu6050.c ****     .rate_div       = 0x19,
 483:Src/mpu6050.c ****     .lpf            = 0x1A,
 484:Src/mpu6050.c ****     .prod_id        = 0x0C,
 485:Src/mpu6050.c ****     .user_ctrl      = 0x6A,
 486:Src/mpu6050.c ****     .fifo_en        = 0x23,
 487:Src/mpu6050.c ****     .gyro_cfg       = 0x1B,
ARM GAS  /tmp/ccNfEN49.s 			page 10


 488:Src/mpu6050.c ****     .accel_cfg      = 0x1C,
 489:Src/mpu6050.c ****     .accel_cfg2     = 0x1D,
 490:Src/mpu6050.c ****     .lp_accel_odr   = 0x1E,
 491:Src/mpu6050.c ****     .motion_thr     = 0x1F,
 492:Src/mpu6050.c ****     .motion_dur     = 0x20,
 493:Src/mpu6050.c ****     .fifo_count_h   = 0x72,
 494:Src/mpu6050.c ****     .fifo_r_w       = 0x74,
 495:Src/mpu6050.c ****     .raw_gyro       = 0x43,
 496:Src/mpu6050.c ****     .raw_accel      = 0x3B,
 497:Src/mpu6050.c ****     .temp           = 0x41,
 498:Src/mpu6050.c ****     .int_enable     = 0x38,
 499:Src/mpu6050.c ****     .dmp_int_status = 0x39,
 500:Src/mpu6050.c ****     .int_status     = 0x3A,
 501:Src/mpu6050.c ****     .accel_intel    = 0x69,
 502:Src/mpu6050.c ****     .pwr_mgmt_1     = 0x6B,
 503:Src/mpu6050.c ****     .pwr_mgmt_2     = 0x6C,
 504:Src/mpu6050.c ****     .int_pin_cfg    = 0x37,
 505:Src/mpu6050.c ****     .mem_r_w        = 0x6F,
 506:Src/mpu6050.c ****     .accel_offs     = 0x77,
 507:Src/mpu6050.c ****     .i2c_mst        = 0x24,
 508:Src/mpu6050.c ****     .bank_sel       = 0x6D,
 509:Src/mpu6050.c ****     .mem_start_addr = 0x6E,
 510:Src/mpu6050.c ****     .prgm_start_h   = 0x70
 511:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 512:Src/mpu6050.c ****     ,.raw_compass   = 0x49,
 513:Src/mpu6050.c ****     .s0_addr        = 0x25,
 514:Src/mpu6050.c ****     .s0_reg         = 0x26,
 515:Src/mpu6050.c ****     .s0_ctrl        = 0x27,
 516:Src/mpu6050.c ****     .s1_addr        = 0x28,
 517:Src/mpu6050.c ****     .s1_reg         = 0x29,
 518:Src/mpu6050.c ****     .s1_ctrl        = 0x2A,
 519:Src/mpu6050.c ****     .s4_ctrl        = 0x34,
 520:Src/mpu6050.c ****     .s0_do          = 0x63,
 521:Src/mpu6050.c ****     .s1_do          = 0x64,
 522:Src/mpu6050.c ****     .i2c_delay_ctrl = 0x67
 523:Src/mpu6050.c **** #endif
 524:Src/mpu6050.c **** };
 525:Src/mpu6050.c **** const struct hw_s hw = {
 526:Src/mpu6050.c ****     .addr           = 0x68,
 527:Src/mpu6050.c ****     .max_fifo       = 1024,
 528:Src/mpu6050.c ****     .num_reg        = 128,
 529:Src/mpu6050.c ****     .temp_sens      = 321,
 530:Src/mpu6050.c ****     .temp_offset    = 0,
 531:Src/mpu6050.c ****     .bank_size      = 256
 532:Src/mpu6050.c **** #if defined AK89xx_SECONDARY
 533:Src/mpu6050.c ****     ,.compass_fsr    = AK89xx_FSR
 534:Src/mpu6050.c **** #endif
 535:Src/mpu6050.c **** };
 536:Src/mpu6050.c **** 
 537:Src/mpu6050.c **** const struct test_s test = {
 538:Src/mpu6050.c ****     .gyro_sens      = 32768/250,
 539:Src/mpu6050.c ****     .accel_sens     = 32768/2,  	    // FSR = +-2G = 16384 LSB/G
 540:Src/mpu6050.c ****     .reg_rate_div   = 0,    			// 1kHz.
 541:Src/mpu6050.c ****     .reg_lpf        = 2,    			// 92Hz low pass filter
 542:Src/mpu6050.c ****     .reg_gyro_fsr   = 0,    			// 250dps.
 543:Src/mpu6050.c ****     .reg_accel_fsr  = 0x0,  			// Accel FSR setting = 2g.
 544:Src/mpu6050.c ****     .wait_ms        = 200,   			// 200ms stabilization time
ARM GAS  /tmp/ccNfEN49.s 			page 11


 545:Src/mpu6050.c ****     .packet_thresh  = 200,    		    // 200 samples
 546:Src/mpu6050.c ****     .min_dps        = 20.f,  			// 20 dps for Gyro Criteria C
 547:Src/mpu6050.c ****     .max_dps        = 60.f, 			// Must exceed 60 dps threshold for Gyro Criteria B
 548:Src/mpu6050.c ****     .max_gyro_var   = .5f, 				// Must exceed +50% variation for Gyro Criteria A
 549:Src/mpu6050.c ****     .min_g          = .225f, 			// Accel must exceed Min 225 mg for Criteria B
 550:Src/mpu6050.c ****     .max_g          = .675f, 			// Accel cannot exceed Max 675 mg for Criteria B
 551:Src/mpu6050.c ****     .max_accel_var  = .5f,  			// Accel must be within 50% variation for Criteria A
 552:Src/mpu6050.c ****     .max_g_offset   = .5f,   			// 500 mg for Accel Criteria C
 553:Src/mpu6050.c ****     .sample_wait_ms = 10    			// 10ms sample time wait
 554:Src/mpu6050.c **** };
 555:Src/mpu6050.c **** 
 556:Src/mpu6050.c **** static struct gyro_state_s st = {
 557:Src/mpu6050.c ****     .reg = &reg,
 558:Src/mpu6050.c ****     .hw = &hw,
 559:Src/mpu6050.c ****     .test = &test
 560:Src/mpu6050.c **** };
 561:Src/mpu6050.c **** #endif
 562:Src/mpu6050.c **** 
 563:Src/mpu6050.c **** #define MAX_PACKET_LENGTH (12)
 564:Src/mpu6050.c **** #ifdef MPU6500
 565:Src/mpu6050.c **** #define HWST_MAX_PACKET_LENGTH (512)
 566:Src/mpu6050.c **** #endif
 567:Src/mpu6050.c **** 
 568:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 569:Src/mpu6050.c **** static int setup_compass(void);
 570:Src/mpu6050.c **** #define MAX_COMPASS_SAMPLE_RATE (100)
 571:Src/mpu6050.c **** #endif
 572:Src/mpu6050.c **** 
 573:Src/mpu6050.c **** /**
 574:Src/mpu6050.c ****  *  @brief      Enable/disable data ready interrupt.
 575:Src/mpu6050.c ****  *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready interrupt is used.
 576:Src/mpu6050.c ****  *  @param[in]  enable      1 to enable interrupt.
 577:Src/mpu6050.c ****  *  @return     0 if successful.
 578:Src/mpu6050.c ****  */
 579:Src/mpu6050.c **** static int set_int_enable(unsigned char enable)
 580:Src/mpu6050.c **** {
 581:Src/mpu6050.c ****     unsigned char tmp;
 582:Src/mpu6050.c **** 
 583:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
 584:Src/mpu6050.c ****         if (enable)
 585:Src/mpu6050.c ****             tmp = BIT_DMP_INT_EN;
 586:Src/mpu6050.c ****         else
 587:Src/mpu6050.c ****             tmp = 0x00;
 588:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 589:Src/mpu6050.c ****             return -1;
 590:Src/mpu6050.c ****         st.chip_cfg.int_enable = tmp;
 591:Src/mpu6050.c ****     } else {
 592:Src/mpu6050.c ****         if (!st.chip_cfg.sensors)
 593:Src/mpu6050.c ****             return -1;
 594:Src/mpu6050.c ****         if (enable && st.chip_cfg.int_enable)
 595:Src/mpu6050.c ****             return 0;
 596:Src/mpu6050.c ****         if (enable)
 597:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 598:Src/mpu6050.c ****         else
 599:Src/mpu6050.c ****             tmp = 0x00;
 600:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 601:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 12


 602:Src/mpu6050.c ****         st.chip_cfg.int_enable = tmp;
 603:Src/mpu6050.c ****     }
 604:Src/mpu6050.c ****     return 0;
 605:Src/mpu6050.c **** }
 606:Src/mpu6050.c **** 
 607:Src/mpu6050.c **** /**
 608:Src/mpu6050.c ****  *  @brief      Register dump for testing.
 609:Src/mpu6050.c ****  *  @return     0 if successful.
 610:Src/mpu6050.c ****  */
 611:Src/mpu6050.c **** int mpu_reg_dump(void)
 612:Src/mpu6050.c **** {
 613:Src/mpu6050.c ****     unsigned char ii;
 614:Src/mpu6050.c ****     unsigned char data;
 615:Src/mpu6050.c **** 
 616:Src/mpu6050.c ****     for (ii = 0; ii < st.hw->num_reg; ii++) {
 617:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 618:Src/mpu6050.c ****             continue;
 619:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, ii, 1, &data))
 620:Src/mpu6050.c ****             return -1;
 621:Src/mpu6050.c ****             #ifdef SERIAL_DEBUG
 622:Src/mpu6050.c ****                 log_i("%#5x: %#5x\r\n", ii, data);
 623:Src/mpu6050.c ****             #endif
 624:Src/mpu6050.c ****     }
 625:Src/mpu6050.c ****     return 0;
 626:Src/mpu6050.c **** }
 627:Src/mpu6050.c **** 
 628:Src/mpu6050.c **** /**
 629:Src/mpu6050.c ****  *  @brief      Read from a single register.
 630:Src/mpu6050.c ****  *  NOTE: The memory and FIFO read/write registers cannot be accessed.
 631:Src/mpu6050.c ****  *  @param[in]  reg     Register address.
 632:Src/mpu6050.c ****  *  @param[out] data    Register data.
 633:Src/mpu6050.c ****  *  @return     0 if successful.
 634:Src/mpu6050.c ****  */
 635:Src/mpu6050.c **** int mpu_read_reg(unsigned char reg, unsigned char *data)
 636:Src/mpu6050.c **** {
 637:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 638:Src/mpu6050.c ****         return -1;
 639:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 640:Src/mpu6050.c ****         return -1;
 641:Src/mpu6050.c ****     return i2c_read(st.hw->addr, reg, 1, data);
 642:Src/mpu6050.c **** }
 643:Src/mpu6050.c **** 
 644:Src/mpu6050.c **** /**
 645:Src/mpu6050.c ****  *  @brief      Initialize hardware.
 646:Src/mpu6050.c ****  *  Initial configuration:\n
 647:Src/mpu6050.c ****  *  Gyro FSR: +/- 2000DPS\n
 648:Src/mpu6050.c ****  *  Accel FSR +/- 2G\n
 649:Src/mpu6050.c ****  *  DLPF: 42Hz\n
 650:Src/mpu6050.c ****  *  FIFO rate: 50Hz\n
 651:Src/mpu6050.c ****  *  Clock source: Gyro PLL\n
 652:Src/mpu6050.c ****  *  FIFO: Disabled.\n
 653:Src/mpu6050.c ****  *  Data ready interrupt: Disabled, active low, unlatched.
 654:Src/mpu6050.c ****  *  @param[in]  int_param   Platform-specific parameters to interrupt API.
 655:Src/mpu6050.c ****  *  @return     0 if successful.
 656:Src/mpu6050.c ****  */
 657:Src/mpu6050.c **** int mpu_init(void)
 658:Src/mpu6050.c **** {
ARM GAS  /tmp/ccNfEN49.s 			page 13


 659:Src/mpu6050.c ****     unsigned char data[6];
 660:Src/mpu6050.c **** 
 661:Src/mpu6050.c ****     /* Reset device. */
 662:Src/mpu6050.c ****     data[0] = BIT_RESET;
 663:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 664:Src/mpu6050.c ****         return -1;
 665:Src/mpu6050.c ****     delay_ms(100);
 666:Src/mpu6050.c **** 
 667:Src/mpu6050.c ****     /* Wake up chip. */
 668:Src/mpu6050.c ****     data[0] = 0x00;
 669:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 670:Src/mpu6050.c ****         return -1;
 671:Src/mpu6050.c **** 
 672:Src/mpu6050.c ****    st.chip_cfg.accel_half = 0;
 673:Src/mpu6050.c **** 
 674:Src/mpu6050.c **** #ifdef MPU6500
 675:Src/mpu6050.c ****     /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
 676:Src/mpu6050.c ****      * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
 677:Src/mpu6050.c ****      */
 678:Src/mpu6050.c ****     data[0] = BIT_FIFO_SIZE_1024 | 0x8;
 679:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
 680:Src/mpu6050.c ****         return -1;
 681:Src/mpu6050.c **** #endif
 682:Src/mpu6050.c **** 
 683:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
 684:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 685:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 686:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 687:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 688:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 689:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 690:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 691:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 692:Src/mpu6050.c ****     st.chip_cfg.compass_sample_rate = 0xFFFF;
 693:Src/mpu6050.c **** #endif
 694:Src/mpu6050.c ****     /* mpu_set_sensors always preserves this setting. */
 695:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 696:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 697:Src/mpu6050.c ****     st.chip_cfg.active_low_int = 1;
 698:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 699:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 700:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 701:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 702:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 703:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 704:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = 0;
 705:Src/mpu6050.c **** 
 706:Src/mpu6050.c ****     if (mpu_set_gyro_fsr(MPU_GYRO_FSR))
 707:Src/mpu6050.c ****         return -1;
 708:Src/mpu6050.c ****     if (mpu_set_accel_fsr(MPU_ACCEL_FSR))
 709:Src/mpu6050.c ****         return -1;
 710:Src/mpu6050.c ****     if (mpu_set_lpf(42))
 711:Src/mpu6050.c ****         return -1;
 712:Src/mpu6050.c ****     if (mpu_set_sample_rate(50))
 713:Src/mpu6050.c ****         return -1;
 714:Src/mpu6050.c ****     if (mpu_configure_fifo(0))
 715:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 14


 716:Src/mpu6050.c **** 
 717:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 718:Src/mpu6050.c ****     setup_compass();
 719:Src/mpu6050.c ****     if (mpu_set_compass_sample_rate(10))
 720:Src/mpu6050.c ****         return -1;
 721:Src/mpu6050.c **** #else
 722:Src/mpu6050.c ****     /* Already disabled by setup_compass. */
 723:Src/mpu6050.c ****     if (mpu_set_bypass(0))
 724:Src/mpu6050.c ****         return -1;
 725:Src/mpu6050.c **** #endif
 726:Src/mpu6050.c **** 
 727:Src/mpu6050.c ****     mpu_set_sensors(0);
 728:Src/mpu6050.c ****     return 0;
 729:Src/mpu6050.c **** }
 730:Src/mpu6050.c **** 
 731:Src/mpu6050.c **** /**
 732:Src/mpu6050.c ****  *  @brief      Enter low-power accel-only mode.
 733:Src/mpu6050.c ****  *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
 734:Src/mpu6050.c ****  *  the accelerometer at one of the following frequencies:
 735:Src/mpu6050.c ****  *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
 736:Src/mpu6050.c ****  *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
 737:Src/mpu6050.c ****  *  \n If the requested rate is not one listed above, the device will be set to
 738:Src/mpu6050.c ****  *  the next highest rate. Requesting a rate above the maximum supported
 739:Src/mpu6050.c ****  *  frequency will result in an error.
 740:Src/mpu6050.c ****  *  \n To select a fractional wake-up frequency, round down the value passed to
 741:Src/mpu6050.c ****  *  @e rate.
 742:Src/mpu6050.c ****  *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
 743:Src/mpu6050.c ****  *                          accel mode.
 744:Src/mpu6050.c ****  *  @return     0 if successful.
 745:Src/mpu6050.c ****  */
 746:Src/mpu6050.c **** int mpu_lp_accel_mode(unsigned short rate)
 747:Src/mpu6050.c **** {
 748:Src/mpu6050.c ****     unsigned char tmp[2];
 749:Src/mpu6050.c **** 
 750:Src/mpu6050.c ****     if (rate > 40)
 751:Src/mpu6050.c ****         return -1;
 752:Src/mpu6050.c **** 
 753:Src/mpu6050.c ****     if (!rate) {
 754:Src/mpu6050.c ****         mpu_set_int_latched(0);
 755:Src/mpu6050.c ****         tmp[0] = 0;
 756:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 757:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 758:Src/mpu6050.c ****             return -1;
 759:Src/mpu6050.c ****         st.chip_cfg.lp_accel_mode = 0;
 760:Src/mpu6050.c ****         return 0;
 761:Src/mpu6050.c ****     }
 762:Src/mpu6050.c ****     /* For LP accel, we automatically configure the hardware to produce latched
 763:Src/mpu6050.c ****      * interrupts. In LP accel mode, the hardware cycles into sleep mode before
 764:Src/mpu6050.c ****      * it gets a chance to deassert the interrupt pin; therefore, we shift this
 765:Src/mpu6050.c ****      * responsibility over to the MCU.
 766:Src/mpu6050.c ****      *
 767:Src/mpu6050.c ****      * Any register read will clear the interrupt.
 768:Src/mpu6050.c ****      */
 769:Src/mpu6050.c ****     mpu_set_int_latched(1);
 770:Src/mpu6050.c **** #if defined MPU6050
 771:Src/mpu6050.c ****     tmp[0] = BIT_LPA_CYCLE;
 772:Src/mpu6050.c ****     if (rate == 1) {
ARM GAS  /tmp/ccNfEN49.s 			page 15


 773:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 774:Src/mpu6050.c ****         mpu_set_lpf(5);
 775:Src/mpu6050.c ****     } else if (rate <= 5) {
 776:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 777:Src/mpu6050.c ****         mpu_set_lpf(5);
 778:Src/mpu6050.c ****     } else if (rate <= 20) {
 779:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 780:Src/mpu6050.c ****         mpu_set_lpf(10);
 781:Src/mpu6050.c ****     } else {
 782:Src/mpu6050.c ****         tmp[1] = INV_LPA_40HZ;
 783:Src/mpu6050.c ****         mpu_set_lpf(20);
 784:Src/mpu6050.c ****     }
 785:Src/mpu6050.c ****     tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
 786:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 787:Src/mpu6050.c ****         return -1;
 788:Src/mpu6050.c **** #elif defined MPU6500
 789:Src/mpu6050.c ****     /* Set wake frequency. */
 790:Src/mpu6050.c ****     if (rate == 1)
 791:Src/mpu6050.c ****         tmp[0] = INV_LPA_1_25HZ;
 792:Src/mpu6050.c ****     else if (rate == 2)
 793:Src/mpu6050.c ****         tmp[0] = INV_LPA_2_5HZ;
 794:Src/mpu6050.c ****     else if (rate <= 5)
 795:Src/mpu6050.c ****         tmp[0] = INV_LPA_5HZ;
 796:Src/mpu6050.c ****     else if (rate <= 10)
 797:Src/mpu6050.c ****         tmp[0] = INV_LPA_10HZ;
 798:Src/mpu6050.c ****     else if (rate <= 20)
 799:Src/mpu6050.c ****         tmp[0] = INV_LPA_20HZ;
 800:Src/mpu6050.c ****     else if (rate <= 40)
 801:Src/mpu6050.c ****         tmp[0] = INV_LPA_40HZ;
 802:Src/mpu6050.c ****     else if (rate <= 80)
 803:Src/mpu6050.c ****         tmp[0] = INV_LPA_80HZ;
 804:Src/mpu6050.c ****     else if (rate <= 160)
 805:Src/mpu6050.c ****         tmp[0] = INV_LPA_160HZ;
 806:Src/mpu6050.c ****     else if (rate <= 320)
 807:Src/mpu6050.c ****         tmp[0] = INV_LPA_320HZ;
 808:Src/mpu6050.c ****     else
 809:Src/mpu6050.c ****         tmp[0] = INV_LPA_640HZ;
 810:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
 811:Src/mpu6050.c ****         return -1;
 812:Src/mpu6050.c ****     tmp[0] = BIT_LPA_CYCLE;
 813:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
 814:Src/mpu6050.c ****         return -1;
 815:Src/mpu6050.c **** #endif
 816:Src/mpu6050.c ****     st.chip_cfg.sensors = INV_XYZ_ACCEL;
 817:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 818:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 819:Src/mpu6050.c ****     mpu_configure_fifo(0);
 820:Src/mpu6050.c **** 
 821:Src/mpu6050.c ****     return 0;
 822:Src/mpu6050.c **** }
 823:Src/mpu6050.c **** 
 824:Src/mpu6050.c **** /**
 825:Src/mpu6050.c ****  *  @brief      Read raw gyro data directly from the registers.
 826:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
 827:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 828:Src/mpu6050.c ****  *  @return     0 if successful.
 829:Src/mpu6050.c ****  */
ARM GAS  /tmp/ccNfEN49.s 			page 16


 830:Src/mpu6050.c **** int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
 831:Src/mpu6050.c **** {
 832:Src/mpu6050.c ****     unsigned char tmp[6];
 833:Src/mpu6050.c **** 
 834:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
 835:Src/mpu6050.c ****         return -1;
 836:Src/mpu6050.c **** 
 837:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
 838:Src/mpu6050.c ****         return -1;
 839:Src/mpu6050.c ****     data[0] = (tmp[0] << 8) | tmp[1];
 840:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 841:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 842:Src/mpu6050.c ****     if (timestamp)
 843:Src/mpu6050.c ****         get_ms(timestamp);
 844:Src/mpu6050.c ****     return 0;
 845:Src/mpu6050.c **** }
 846:Src/mpu6050.c **** 
 847:Src/mpu6050.c **** /**
 848:Src/mpu6050.c ****  *  @brief      Read raw accel data directly from the registers.
 849:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
 850:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 851:Src/mpu6050.c ****  *  @return     0 if successful.
 852:Src/mpu6050.c ****  */
 853:Src/mpu6050.c **** int mpu_get_accel_reg(short *data, unsigned long *timestamp)
 854:Src/mpu6050.c **** {
 855:Src/mpu6050.c ****     unsigned char tmp[6];
 856:Src/mpu6050.c **** 
 857:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
 858:Src/mpu6050.c ****         return -1;
 859:Src/mpu6050.c **** 
 860:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
 861:Src/mpu6050.c ****         return -1;
 862:Src/mpu6050.c ****     data[0] = (tmp[0] << 8) | tmp[1];
 863:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 864:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 865:Src/mpu6050.c ****     if (timestamp)
 866:Src/mpu6050.c ****         get_ms(timestamp);
 867:Src/mpu6050.c ****     return 0;
 868:Src/mpu6050.c **** }
 869:Src/mpu6050.c **** 
 870:Src/mpu6050.c **** /**
 871:Src/mpu6050.c ****  *  @brief      Read temperature data directly from the registers.
 872:Src/mpu6050.c ****  *  @param[out] data        Data in q16 format.
 873:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
 874:Src/mpu6050.c ****  *  @return     0 if successful.
 875:Src/mpu6050.c ****  */
 876:Src/mpu6050.c **** int mpu_get_temperature(long *data, unsigned long *timestamp)
 877:Src/mpu6050.c **** {
 878:Src/mpu6050.c ****     unsigned char tmp[2];
 879:Src/mpu6050.c ****     short raw;
 880:Src/mpu6050.c **** 
 881:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
 882:Src/mpu6050.c ****         return -1;
 883:Src/mpu6050.c **** 
 884:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
 885:Src/mpu6050.c ****         return -1;
 886:Src/mpu6050.c ****     raw = (tmp[0] << 8) | tmp[1];
ARM GAS  /tmp/ccNfEN49.s 			page 17


 887:Src/mpu6050.c ****     if (timestamp)
 888:Src/mpu6050.c ****         get_ms(timestamp);
 889:Src/mpu6050.c **** 
 890:Src/mpu6050.c ****     data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
 891:Src/mpu6050.c ****     return 0;
 892:Src/mpu6050.c **** }
 893:Src/mpu6050.c **** 
 894:Src/mpu6050.c **** /**
 895:Src/mpu6050.c ****  *  @brief      Read biases to the accel bias 6500 registers.
 896:Src/mpu6050.c ****  *  This function reads from the MPU6500 accel offset cancellations registers.
 897:Src/mpu6050.c ****  *  The format are G in +-8G format. The register is initialized with OTP 
 898:Src/mpu6050.c ****  *  factory trim values.
 899:Src/mpu6050.c ****  *  @param[in]  accel_bias  returned structure with the accel bias
 900:Src/mpu6050.c ****  *  @return     0 if successful.
 901:Src/mpu6050.c ****  */
 902:Src/mpu6050.c **** int mpu_read_6500_accel_bias(long *accel_bias) {
 903:Src/mpu6050.c ****     unsigned char data[6];
 904:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
 905:Src/mpu6050.c ****         return -1;
 906:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
 907:Src/mpu6050.c ****         return -1;
 908:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7D, 2, &data[4]))
 909:Src/mpu6050.c ****         return -1;
 910:Src/mpu6050.c ****     accel_bias[0] = ((long)data[0]<<8) | data[1];
 911:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 912:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 913:Src/mpu6050.c ****     return 0;
 914:Src/mpu6050.c **** }
 915:Src/mpu6050.c **** 
 916:Src/mpu6050.c **** /**
 917:Src/mpu6050.c ****  *  @brief      Read biases to the accel bias 6050 registers.
 918:Src/mpu6050.c ****  *  This function reads from the MPU6050 accel offset cancellations registers.
 919:Src/mpu6050.c ****  *  The format are G in +-8G format. The register is initialized with OTP 
 920:Src/mpu6050.c ****  *  factory trim values.
 921:Src/mpu6050.c ****  *  @param[in]  accel_bias  returned structure with the accel bias
 922:Src/mpu6050.c ****  *  @return     0 if successful.
 923:Src/mpu6050.c ****  */
 924:Src/mpu6050.c **** int mpu_read_6050_accel_bias(long *accel_bias) {
 925:Src/mpu6050.c ****     unsigned char data[6];
 926:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
 927:Src/mpu6050.c ****         return -1;
 928:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
 929:Src/mpu6050.c ****         return -1;
 930:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0A, 2, &data[4]))
 931:Src/mpu6050.c ****         return -1;
 932:Src/mpu6050.c ****     accel_bias[0] = ((long)data[0]<<8) | data[1];
 933:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 934:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 935:Src/mpu6050.c ****     return 0;
 936:Src/mpu6050.c **** }
 937:Src/mpu6050.c **** 
 938:Src/mpu6050.c **** int mpu_read_6500_gyro_bias(long *gyro_bias) {
 939:Src/mpu6050.c ****     unsigned char data[6];
 940:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
 941:Src/mpu6050.c ****         return -1;
 942:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
 943:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 18


 944:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x17, 2, &data[4]))
 945:Src/mpu6050.c ****         return -1;
 946:Src/mpu6050.c ****     gyro_bias[0] = ((long)data[0]<<8) | data[1];
 947:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 948:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 949:Src/mpu6050.c ****     return 0;
 950:Src/mpu6050.c **** }
 951:Src/mpu6050.c **** 
 952:Src/mpu6050.c **** /**
 953:Src/mpu6050.c ****  *  @brief      Push biases to the gyro bias 6500/6050 registers.
 954:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
 955:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
 956:Src/mpu6050.c ****  *  in +-1000dps format.
 957:Src/mpu6050.c ****  *  @param[in]  gyro_bias  New biases.
 958:Src/mpu6050.c ****  *  @return     0 if successful.
 959:Src/mpu6050.c ****  */
 960:Src/mpu6050.c **** int mpu_set_gyro_bias_reg(long *gyro_bias)
 961:Src/mpu6050.c **** {
 962:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 963:Src/mpu6050.c ****     int i=0;
 964:Src/mpu6050.c ****     for(i=0;i<3;i++) {
 965:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 966:Src/mpu6050.c ****     }
 967:Src/mpu6050.c ****     data[0] = (gyro_bias[0] >> 8) & 0xff;
 968:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 969:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 970:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 971:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 972:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 973:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 974:Src/mpu6050.c ****         return -1;
 975:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
 976:Src/mpu6050.c ****         return -1;
 977:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x17, 2, &data[4]))
 978:Src/mpu6050.c ****         return -1;
 979:Src/mpu6050.c ****     return 0;
 980:Src/mpu6050.c **** }
 981:Src/mpu6050.c **** 
 982:Src/mpu6050.c **** /**
 983:Src/mpu6050.c ****  *  @brief      Push biases to the accel bias 6050 registers.
 984:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
 985:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
 986:Src/mpu6050.c ****  *  in +-16G format.
 987:Src/mpu6050.c ****  *  @param[in]  accel_bias  New biases.
 988:Src/mpu6050.c ****  *  @return     0 if successful.
 989:Src/mpu6050.c ****  */
 990:Src/mpu6050.c **** int mpu_set_accel_bias_6050_reg(const long *accel_bias) {
 991:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 992:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 993:Src/mpu6050.c **** 
 994:Src/mpu6050.c ****     if(mpu_read_6050_accel_bias(accel_reg_bias))
 995:Src/mpu6050.c ****         return -1;
 996:Src/mpu6050.c **** 
 997:Src/mpu6050.c ****     accel_reg_bias[0] -= (accel_bias[0] & ~1);
 998:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 999:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
1000:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 19


1001:Src/mpu6050.c ****     data[0] = (accel_reg_bias[0] >> 8) & 0xff;
1002:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
1003:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
1004:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
1005:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
1006:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
1007:Src/mpu6050.c **** 
1008:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x06, 2, &data[0]))
1009:Src/mpu6050.c ****         return -1;
1010:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x08, 2, &data[2]))
1011:Src/mpu6050.c ****         return -1;
1012:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x0A, 2, &data[4]))
1013:Src/mpu6050.c ****         return -1;
1014:Src/mpu6050.c **** 
1015:Src/mpu6050.c ****     return 0;
1016:Src/mpu6050.c **** }
1017:Src/mpu6050.c **** 
1018:Src/mpu6050.c **** 
1019:Src/mpu6050.c **** 
1020:Src/mpu6050.c **** /**
1021:Src/mpu6050.c ****  *  @brief      Push biases to the accel bias 6500 registers.
1022:Src/mpu6050.c ****  *  This function expects biases relative to the current sensor output, and
1023:Src/mpu6050.c ****  *  these biases will be added to the factory-supplied values. Bias inputs are LSB
1024:Src/mpu6050.c ****  *  in +-16G format.
1025:Src/mpu6050.c ****  *  @param[in]  accel_bias  New biases.
1026:Src/mpu6050.c ****  *  @return     0 if successful.
1027:Src/mpu6050.c ****  */
1028:Src/mpu6050.c **** int mpu_set_accel_bias_6500_reg(const long *accel_bias) {
1029:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
1030:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
1031:Src/mpu6050.c **** 
1032:Src/mpu6050.c ****     if(mpu_read_6500_accel_bias(accel_reg_bias))
1033:Src/mpu6050.c ****         return -1;
1034:Src/mpu6050.c **** 
1035:Src/mpu6050.c ****     // Preserve bit 0 of factory value (for temperature compensation)
1036:Src/mpu6050.c ****     accel_reg_bias[0] -= (accel_bias[0] & ~1);
1037:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
1038:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
1039:Src/mpu6050.c **** 
1040:Src/mpu6050.c ****     data[0] = (accel_reg_bias[0] >> 8) & 0xff;
1041:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
1042:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
1043:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
1044:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
1045:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
1046:Src/mpu6050.c **** 
1047:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x77, 2, &data[0]))
1048:Src/mpu6050.c ****         return -1;
1049:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x7A, 2, &data[2]))
1050:Src/mpu6050.c ****         return -1;
1051:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x7D, 2, &data[4]))
1052:Src/mpu6050.c ****         return -1;
1053:Src/mpu6050.c **** 
1054:Src/mpu6050.c ****     return 0;
1055:Src/mpu6050.c **** }
1056:Src/mpu6050.c **** 
1057:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 20


1058:Src/mpu6050.c **** /**
1059:Src/mpu6050.c ****  *  @brief  Reset FIFO read/write pointers.
1060:Src/mpu6050.c ****  *  @return 0 if successful.
1061:Src/mpu6050.c ****  */
1062:Src/mpu6050.c **** int mpu_reset_fifo(void)
1063:Src/mpu6050.c **** {
1064:Src/mpu6050.c ****     unsigned char data;
1065:Src/mpu6050.c **** 
1066:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1067:Src/mpu6050.c ****         return -1;
1068:Src/mpu6050.c **** 
1069:Src/mpu6050.c ****     data = 0;
1070:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1071:Src/mpu6050.c ****         return -1;
1072:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
1073:Src/mpu6050.c ****         return -1;
1074:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1075:Src/mpu6050.c ****         return -1;
1076:Src/mpu6050.c **** 
1077:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
1078:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
1079:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1080:Src/mpu6050.c ****             return -1;
1081:Src/mpu6050.c ****         delay_ms(50);
1082:Src/mpu6050.c ****         data = BIT_DMP_EN | BIT_FIFO_EN;
1083:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1084:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
1085:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1086:Src/mpu6050.c ****             return -1;
1087:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
1088:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
1089:Src/mpu6050.c ****         else
1090:Src/mpu6050.c ****             data = 0;
1091:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1092:Src/mpu6050.c ****             return -1;
1093:Src/mpu6050.c ****         data = 0;
1094:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
1095:Src/mpu6050.c ****             return -1;
1096:Src/mpu6050.c ****     } else {
1097:Src/mpu6050.c ****         data = BIT_FIFO_RST;
1098:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1099:Src/mpu6050.c ****             return -1;
1100:Src/mpu6050.c ****         if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
1101:Src/mpu6050.c ****             data = BIT_FIFO_EN;
1102:Src/mpu6050.c ****         else
1103:Src/mpu6050.c ****             data = BIT_FIFO_EN | BIT_AUX_IF_EN;
1104:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
1105:Src/mpu6050.c ****             return -1;
1106:Src/mpu6050.c ****         delay_ms(50);
1107:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
1108:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
1109:Src/mpu6050.c ****         else
1110:Src/mpu6050.c ****             data = 0;
1111:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
1112:Src/mpu6050.c ****             return -1;
1113:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
1114:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 21


1115:Src/mpu6050.c ****     }
1116:Src/mpu6050.c ****     return 0;
1117:Src/mpu6050.c **** }
1118:Src/mpu6050.c **** 
1119:Src/mpu6050.c **** /**
1120:Src/mpu6050.c ****  *  @brief      Get the gyro full-scale range.
1121:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
1122:Src/mpu6050.c ****  *  @return     0 if successful.
1123:Src/mpu6050.c ****  */
1124:Src/mpu6050.c **** int mpu_get_gyro_fsr(unsigned short *fsr)
1125:Src/mpu6050.c **** {
1126:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
1127:Src/mpu6050.c ****     case INV_FSR_250DPS:
1128:Src/mpu6050.c ****         fsr[0] = 250;
1129:Src/mpu6050.c ****         break;
1130:Src/mpu6050.c ****     case INV_FSR_500DPS:
1131:Src/mpu6050.c ****         fsr[0] = 500;
1132:Src/mpu6050.c ****         break;
1133:Src/mpu6050.c ****     case INV_FSR_1000DPS:
1134:Src/mpu6050.c ****         fsr[0] = 1000;
1135:Src/mpu6050.c ****         break;
1136:Src/mpu6050.c ****     case INV_FSR_2000DPS:
1137:Src/mpu6050.c ****         fsr[0] = 2000;
1138:Src/mpu6050.c ****         break;
1139:Src/mpu6050.c ****     default:
1140:Src/mpu6050.c ****         fsr[0] = 0;
1141:Src/mpu6050.c ****         break;
1142:Src/mpu6050.c ****     }
1143:Src/mpu6050.c ****     return 0;
1144:Src/mpu6050.c **** }
1145:Src/mpu6050.c **** 
1146:Src/mpu6050.c **** /**
1147:Src/mpu6050.c ****  *  @brief      Set the gyro full-scale range.
1148:Src/mpu6050.c ****  *  @param[in]  fsr Desired full-scale range.
1149:Src/mpu6050.c ****  *  @return     0 if successful.
1150:Src/mpu6050.c ****  */
1151:Src/mpu6050.c **** int mpu_set_gyro_fsr(unsigned short fsr)
1152:Src/mpu6050.c **** {
1153:Src/mpu6050.c ****     unsigned char data;
1154:Src/mpu6050.c **** 
1155:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1156:Src/mpu6050.c ****         return -1;
1157:Src/mpu6050.c **** 
1158:Src/mpu6050.c ****     switch (fsr) {
1159:Src/mpu6050.c ****     case 250:
1160:Src/mpu6050.c ****         data = INV_FSR_250DPS << 3;
1161:Src/mpu6050.c ****         break;
1162:Src/mpu6050.c ****     case 500:
1163:Src/mpu6050.c ****         data = INV_FSR_500DPS << 3;
1164:Src/mpu6050.c ****         break;
1165:Src/mpu6050.c ****     case 1000:
1166:Src/mpu6050.c ****         data = INV_FSR_1000DPS << 3;
1167:Src/mpu6050.c ****         break;
1168:Src/mpu6050.c ****     case 2000:
1169:Src/mpu6050.c ****         data = INV_FSR_2000DPS << 3;
1170:Src/mpu6050.c ****         break;
1171:Src/mpu6050.c ****     default:
ARM GAS  /tmp/ccNfEN49.s 			page 22


1172:Src/mpu6050.c ****         return -1;
1173:Src/mpu6050.c ****     }
1174:Src/mpu6050.c **** 
1175:Src/mpu6050.c ****     if (st.chip_cfg.gyro_fsr == (data >> 3))
1176:Src/mpu6050.c ****         return 0;
1177:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
1178:Src/mpu6050.c ****         return -1;
1179:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = data >> 3;
1180:Src/mpu6050.c ****     return 0;
1181:Src/mpu6050.c **** }
1182:Src/mpu6050.c **** 
1183:Src/mpu6050.c **** /**
1184:Src/mpu6050.c ****  *  @brief      Get the accel full-scale range.
1185:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
1186:Src/mpu6050.c ****  *  @return     0 if successful.
1187:Src/mpu6050.c ****  */
1188:Src/mpu6050.c **** int mpu_get_accel_fsr(unsigned char *fsr)
1189:Src/mpu6050.c **** {
1190:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
1191:Src/mpu6050.c ****     case INV_FSR_2G:
1192:Src/mpu6050.c ****         fsr[0] = 2;
1193:Src/mpu6050.c ****         break;
1194:Src/mpu6050.c ****     case INV_FSR_4G:
1195:Src/mpu6050.c ****         fsr[0] = 4;
1196:Src/mpu6050.c ****         break;
1197:Src/mpu6050.c ****     case INV_FSR_8G:
1198:Src/mpu6050.c ****         fsr[0] = 8;
1199:Src/mpu6050.c ****         break;
1200:Src/mpu6050.c ****     case INV_FSR_16G:
1201:Src/mpu6050.c ****         fsr[0] = 16;
1202:Src/mpu6050.c ****         break;
1203:Src/mpu6050.c ****     default:
1204:Src/mpu6050.c ****         return -1;
1205:Src/mpu6050.c ****     }
1206:Src/mpu6050.c ****     if (st.chip_cfg.accel_half)
1207:Src/mpu6050.c ****         fsr[0] <<= 1;
1208:Src/mpu6050.c ****     return 0;
1209:Src/mpu6050.c **** }
1210:Src/mpu6050.c **** 
1211:Src/mpu6050.c **** /**
1212:Src/mpu6050.c ****  *  @brief      Set the accel full-scale range.
1213:Src/mpu6050.c ****  *  @param[in]  fsr Desired full-scale range.
1214:Src/mpu6050.c ****  *  @return     0 if successful.
1215:Src/mpu6050.c ****  */
1216:Src/mpu6050.c **** int mpu_set_accel_fsr(unsigned char fsr)
1217:Src/mpu6050.c **** {
1218:Src/mpu6050.c ****     unsigned char data;
1219:Src/mpu6050.c **** 
1220:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1221:Src/mpu6050.c ****         return -1;
1222:Src/mpu6050.c **** 
1223:Src/mpu6050.c ****     switch (fsr) {
1224:Src/mpu6050.c ****     case 2:
1225:Src/mpu6050.c ****         data = INV_FSR_2G << 3;
1226:Src/mpu6050.c ****         break;
1227:Src/mpu6050.c ****     case 4:
1228:Src/mpu6050.c ****         data = INV_FSR_4G << 3;
ARM GAS  /tmp/ccNfEN49.s 			page 23


1229:Src/mpu6050.c ****         break;
1230:Src/mpu6050.c ****     case 8:
1231:Src/mpu6050.c ****         data = INV_FSR_8G << 3;
1232:Src/mpu6050.c ****         break;
1233:Src/mpu6050.c ****     case 16:
1234:Src/mpu6050.c ****         data = INV_FSR_16G << 3;
1235:Src/mpu6050.c ****         break;
1236:Src/mpu6050.c ****     default:
1237:Src/mpu6050.c ****         return -1;
1238:Src/mpu6050.c ****     }
1239:Src/mpu6050.c **** 
1240:Src/mpu6050.c ****     if (st.chip_cfg.accel_fsr == (data >> 3))
1241:Src/mpu6050.c ****         return 0;
1242:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
1243:Src/mpu6050.c ****         return -1;
1244:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = data >> 3;
1245:Src/mpu6050.c ****     return 0;
1246:Src/mpu6050.c **** }
1247:Src/mpu6050.c **** 
1248:Src/mpu6050.c **** /**
1249:Src/mpu6050.c ****  *  @brief      Get the current DLPF setting.
1250:Src/mpu6050.c ****  *  @param[out] lpf Current LPF setting.
1251:Src/mpu6050.c ****  *  0 if successful.
1252:Src/mpu6050.c ****  */
1253:Src/mpu6050.c **** int mpu_get_lpf(unsigned short *lpf)
1254:Src/mpu6050.c **** {
1255:Src/mpu6050.c ****     switch (st.chip_cfg.lpf) {
1256:Src/mpu6050.c ****     case INV_FILTER_188HZ:
1257:Src/mpu6050.c ****         lpf[0] = 188;
1258:Src/mpu6050.c ****         break;
1259:Src/mpu6050.c ****     case INV_FILTER_98HZ:
1260:Src/mpu6050.c ****         lpf[0] = 98;
1261:Src/mpu6050.c ****         break;
1262:Src/mpu6050.c ****     case INV_FILTER_42HZ:
1263:Src/mpu6050.c ****         lpf[0] = 42;
1264:Src/mpu6050.c ****         break;
1265:Src/mpu6050.c ****     case INV_FILTER_20HZ:
1266:Src/mpu6050.c ****         lpf[0] = 20;
1267:Src/mpu6050.c ****         break;
1268:Src/mpu6050.c ****     case INV_FILTER_10HZ:
1269:Src/mpu6050.c ****         lpf[0] = 10;
1270:Src/mpu6050.c ****         break;
1271:Src/mpu6050.c ****     case INV_FILTER_5HZ:
1272:Src/mpu6050.c ****         lpf[0] = 5;
1273:Src/mpu6050.c ****         break;
1274:Src/mpu6050.c ****     case INV_FILTER_256HZ_NOLPF2:
1275:Src/mpu6050.c ****     case INV_FILTER_2100HZ_NOLPF:
1276:Src/mpu6050.c ****     default:
1277:Src/mpu6050.c ****         lpf[0] = 0;
1278:Src/mpu6050.c ****         break;
1279:Src/mpu6050.c ****     }
1280:Src/mpu6050.c ****     return 0;
1281:Src/mpu6050.c **** }
1282:Src/mpu6050.c **** 
1283:Src/mpu6050.c **** /**
1284:Src/mpu6050.c ****  *  @brief      Set digital low pass filter.
1285:Src/mpu6050.c ****  *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
ARM GAS  /tmp/ccNfEN49.s 			page 24


1286:Src/mpu6050.c ****  *  @param[in]  lpf Desired LPF setting.
1287:Src/mpu6050.c ****  *  @return     0 if successful.
1288:Src/mpu6050.c ****  */
1289:Src/mpu6050.c **** int mpu_set_lpf(unsigned short lpf)
1290:Src/mpu6050.c **** {
1291:Src/mpu6050.c ****     unsigned char data;
1292:Src/mpu6050.c **** 
1293:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1294:Src/mpu6050.c ****         return -1;
1295:Src/mpu6050.c **** 
1296:Src/mpu6050.c ****     if (lpf >= 188)
1297:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
1298:Src/mpu6050.c ****     else if (lpf >= 98)
1299:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
1300:Src/mpu6050.c ****     else if (lpf >= 42)
1301:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
1302:Src/mpu6050.c ****     else if (lpf >= 20)
1303:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
1304:Src/mpu6050.c ****     else if (lpf >= 10)
1305:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
1306:Src/mpu6050.c ****     else
1307:Src/mpu6050.c ****         data = INV_FILTER_5HZ;
1308:Src/mpu6050.c **** 
1309:Src/mpu6050.c ****     if (st.chip_cfg.lpf == data)
1310:Src/mpu6050.c ****         return 0;
1311:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
1312:Src/mpu6050.c ****         return -1;
1313:Src/mpu6050.c ****     st.chip_cfg.lpf = data;
1314:Src/mpu6050.c ****     return 0;
1315:Src/mpu6050.c **** }
1316:Src/mpu6050.c **** 
1317:Src/mpu6050.c **** /**
1318:Src/mpu6050.c ****  *  @brief      Get sampling rate.
1319:Src/mpu6050.c ****  *  @param[out] rate    Current sampling rate (Hz).
1320:Src/mpu6050.c ****  *  @return     0 if successful.
1321:Src/mpu6050.c ****  */
1322:Src/mpu6050.c **** int mpu_get_sample_rate(unsigned short *rate)
1323:Src/mpu6050.c **** {
1324:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1325:Src/mpu6050.c ****         return -1;
1326:Src/mpu6050.c ****     else
1327:Src/mpu6050.c ****         rate[0] = st.chip_cfg.sample_rate;
1328:Src/mpu6050.c ****     return 0;
1329:Src/mpu6050.c **** }
1330:Src/mpu6050.c **** 
1331:Src/mpu6050.c **** /**
1332:Src/mpu6050.c ****  *  @brief      Set sampling rate.
1333:Src/mpu6050.c ****  *  Sampling rate must be between 4Hz and 1kHz.
1334:Src/mpu6050.c ****  *  @param[in]  rate    Desired sampling rate (Hz).
1335:Src/mpu6050.c ****  *  @return     0 if successful.
1336:Src/mpu6050.c ****  */
1337:Src/mpu6050.c **** int mpu_set_sample_rate(unsigned short rate)
1338:Src/mpu6050.c **** {
1339:Src/mpu6050.c ****     unsigned char data;
1340:Src/mpu6050.c **** 
1341:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors))
1342:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 25


1343:Src/mpu6050.c **** 
1344:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1345:Src/mpu6050.c ****         return -1;
1346:Src/mpu6050.c ****     else {
1347:Src/mpu6050.c ****         if (st.chip_cfg.lp_accel_mode) {
1348:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
1349:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
1350:Src/mpu6050.c ****                 mpu_lp_accel_mode(rate);
1351:Src/mpu6050.c ****                 return 0;
1352:Src/mpu6050.c ****             }
1353:Src/mpu6050.c ****             /* Requested rate exceeds the allowed frequencies in LP accel mode,
1354:Src/mpu6050.c ****              * switch back to full-power mode.
1355:Src/mpu6050.c ****              */
1356:Src/mpu6050.c ****             mpu_lp_accel_mode(0);
1357:Src/mpu6050.c ****         }
1358:Src/mpu6050.c ****         if (rate < 4)
1359:Src/mpu6050.c ****             rate = 4;
1360:Src/mpu6050.c ****         else if (rate > 1000)
1361:Src/mpu6050.c ****             rate = 1000;
1362:Src/mpu6050.c **** 
1363:Src/mpu6050.c ****         data = 1000 / rate - 1;
1364:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
1365:Src/mpu6050.c ****             return -1;
1366:Src/mpu6050.c **** 
1367:Src/mpu6050.c ****         st.chip_cfg.sample_rate = 1000 / (1 + data);
1368:Src/mpu6050.c **** 
1369:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1370:Src/mpu6050.c ****         mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
1371:Src/mpu6050.c **** #endif
1372:Src/mpu6050.c **** 
1373:Src/mpu6050.c ****         /* Automatically set LPF to 1/2 sampling rate. */
1374:Src/mpu6050.c ****         mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
1375:Src/mpu6050.c ****         return 0;
1376:Src/mpu6050.c ****     }
1377:Src/mpu6050.c **** }
1378:Src/mpu6050.c **** 
1379:Src/mpu6050.c **** /**
1380:Src/mpu6050.c ****  *  @brief      Get compass sampling rate.
1381:Src/mpu6050.c ****  *  @param[out] rate    Current compass sampling rate (Hz).
1382:Src/mpu6050.c ****  *  @return     0 if successful.
1383:Src/mpu6050.c ****  */
1384:Src/mpu6050.c **** int mpu_get_compass_sample_rate(unsigned short *rate)
1385:Src/mpu6050.c **** {
1386:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1387:Src/mpu6050.c ****     rate[0] = st.chip_cfg.compass_sample_rate;
1388:Src/mpu6050.c ****     return 0;
1389:Src/mpu6050.c **** #else
1390:Src/mpu6050.c ****     rate[0] = 0;
1391:Src/mpu6050.c ****     return -1;
1392:Src/mpu6050.c **** #endif
1393:Src/mpu6050.c **** }
1394:Src/mpu6050.c **** 
1395:Src/mpu6050.c **** /**
1396:Src/mpu6050.c ****  *  @brief      Set compass sampling rate.
1397:Src/mpu6050.c ****  *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
1398:Src/mpu6050.c ****  *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
1399:Src/mpu6050.c ****  *  sampling rate.
ARM GAS  /tmp/ccNfEN49.s 			page 26


1400:Src/mpu6050.c ****  *
1401:Src/mpu6050.c ****  *  \n WARNING: The new rate may be different than what was requested. Call
1402:Src/mpu6050.c ****  *  mpu_get_compass_sample_rate to check the actual setting.
1403:Src/mpu6050.c ****  *  @param[in]  rate    Desired compass sampling rate (Hz).
1404:Src/mpu6050.c ****  *  @return     0 if successful.
1405:Src/mpu6050.c ****  */
1406:Src/mpu6050.c **** int mpu_set_compass_sample_rate(unsigned short rate)
1407:Src/mpu6050.c **** {
1408:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1409:Src/mpu6050.c ****     unsigned char div;
1410:Src/mpu6050.c ****     if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
1411:Src/mpu6050.c ****         return -1;
1412:Src/mpu6050.c **** 
1413:Src/mpu6050.c ****     div = st.chip_cfg.sample_rate / rate - 1;
1414:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
1415:Src/mpu6050.c ****         return -1;
1416:Src/mpu6050.c ****     st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
1417:Src/mpu6050.c ****     return 0;
1418:Src/mpu6050.c **** #else
1419:Src/mpu6050.c ****     return -1;
1420:Src/mpu6050.c **** #endif
1421:Src/mpu6050.c **** }
1422:Src/mpu6050.c **** 
1423:Src/mpu6050.c **** /**
1424:Src/mpu6050.c ****  *  @brief      Get gyro sensitivity scale factor.
1425:Src/mpu6050.c ****  *  @param[out] sens    Conversion from hardware units to dps.
1426:Src/mpu6050.c ****  *  @return     0 if successful.
1427:Src/mpu6050.c ****  */
1428:Src/mpu6050.c **** int mpu_get_gyro_sens(float *sens)
1429:Src/mpu6050.c **** {
1430:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
1431:Src/mpu6050.c ****     case INV_FSR_250DPS:
1432:Src/mpu6050.c ****         sens[0] = 131.f;
1433:Src/mpu6050.c ****         break;
1434:Src/mpu6050.c ****     case INV_FSR_500DPS:
1435:Src/mpu6050.c ****         sens[0] = 65.5f;
1436:Src/mpu6050.c ****         break;
1437:Src/mpu6050.c ****     case INV_FSR_1000DPS:
1438:Src/mpu6050.c ****         sens[0] = 32.8f;
1439:Src/mpu6050.c ****         break;
1440:Src/mpu6050.c ****     case INV_FSR_2000DPS:
1441:Src/mpu6050.c ****         sens[0] = 16.4f;
1442:Src/mpu6050.c ****         break;
1443:Src/mpu6050.c ****     default:
1444:Src/mpu6050.c ****         return -1;
1445:Src/mpu6050.c ****     }
1446:Src/mpu6050.c ****     return 0;
1447:Src/mpu6050.c **** }
1448:Src/mpu6050.c **** 
1449:Src/mpu6050.c **** /**
1450:Src/mpu6050.c ****  *  @brief      Get accel sensitivity scale factor.
1451:Src/mpu6050.c ****  *  @param[out] sens    Conversion from hardware units to g's.
1452:Src/mpu6050.c ****  *  @return     0 if successful.
1453:Src/mpu6050.c ****  */
1454:Src/mpu6050.c **** int mpu_get_accel_sens(unsigned short *sens)
1455:Src/mpu6050.c **** {
1456:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
ARM GAS  /tmp/ccNfEN49.s 			page 27


1457:Src/mpu6050.c ****     case INV_FSR_2G:
1458:Src/mpu6050.c ****         sens[0] = 16384;
1459:Src/mpu6050.c ****         break;
1460:Src/mpu6050.c ****     case INV_FSR_4G:
1461:Src/mpu6050.c ****         sens[0] = 8192;
1462:Src/mpu6050.c ****         break;
1463:Src/mpu6050.c ****     case INV_FSR_8G:
1464:Src/mpu6050.c ****         sens[0] = 4096;
1465:Src/mpu6050.c ****         break;
1466:Src/mpu6050.c ****     case INV_FSR_16G:
1467:Src/mpu6050.c ****         sens[0] = 2048;
1468:Src/mpu6050.c ****         break;
1469:Src/mpu6050.c ****     default:
1470:Src/mpu6050.c ****         return -1;
1471:Src/mpu6050.c ****     }
1472:Src/mpu6050.c ****     if (st.chip_cfg.accel_half)
1473:Src/mpu6050.c ****         sens[0] >>= 1;
1474:Src/mpu6050.c ****     return 0;
1475:Src/mpu6050.c **** }
1476:Src/mpu6050.c **** 
1477:Src/mpu6050.c **** /**
1478:Src/mpu6050.c ****  *  @brief      Get current FIFO configuration.
1479:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1480:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1481:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1482:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1483:Src/mpu6050.c ****  *  @param[out] sensors Mask of sensors in FIFO.
1484:Src/mpu6050.c ****  *  @return     0 if successful.
1485:Src/mpu6050.c ****  */
1486:Src/mpu6050.c **** int mpu_get_fifo_config(unsigned char *sensors)
1487:Src/mpu6050.c **** {
1488:Src/mpu6050.c ****     sensors[0] = st.chip_cfg.fifo_enable;
1489:Src/mpu6050.c ****     return 0;
1490:Src/mpu6050.c **** }
1491:Src/mpu6050.c **** 
1492:Src/mpu6050.c **** /**
1493:Src/mpu6050.c ****  *  @brief      Select which sensors are pushed to FIFO.
1494:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1495:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1496:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1497:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1498:Src/mpu6050.c ****  *  @param[in]  sensors Mask of sensors to push to FIFO.
1499:Src/mpu6050.c ****  *  @return     0 if successful.
1500:Src/mpu6050.c ****  */
1501:Src/mpu6050.c **** int mpu_configure_fifo(unsigned char sensors)
1502:Src/mpu6050.c **** {
1503:Src/mpu6050.c ****     unsigned char prev;
1504:Src/mpu6050.c ****     int result = 0;
1505:Src/mpu6050.c **** 
1506:Src/mpu6050.c ****     /* Compass data isn't going into the FIFO. Stop trying. */
1507:Src/mpu6050.c ****     sensors &= ~INV_XYZ_COMPASS;
1508:Src/mpu6050.c **** 
1509:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1510:Src/mpu6050.c ****         return 0;
1511:Src/mpu6050.c ****     else {
1512:Src/mpu6050.c ****         if (!(st.chip_cfg.sensors))
1513:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 28


1514:Src/mpu6050.c ****         prev = st.chip_cfg.fifo_enable;
1515:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
1516:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
1517:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
1518:Src/mpu6050.c ****              * asleep.
1519:Src/mpu6050.c ****              */
1520:Src/mpu6050.c ****             result = -1;
1521:Src/mpu6050.c ****         else
1522:Src/mpu6050.c ****             result = 0;
1523:Src/mpu6050.c ****         if (sensors || st.chip_cfg.lp_accel_mode)
1524:Src/mpu6050.c ****             set_int_enable(1);
1525:Src/mpu6050.c ****         else
1526:Src/mpu6050.c ****             set_int_enable(0);
1527:Src/mpu6050.c ****         if (sensors) {
1528:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
1529:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
1530:Src/mpu6050.c ****                 return -1;
1531:Src/mpu6050.c ****             }
1532:Src/mpu6050.c ****         }
1533:Src/mpu6050.c ****     }
1534:Src/mpu6050.c **** 
1535:Src/mpu6050.c ****     return result;
1536:Src/mpu6050.c **** }
1537:Src/mpu6050.c **** 
1538:Src/mpu6050.c **** /**
1539:Src/mpu6050.c ****  *  @brief      Get current power state.
1540:Src/mpu6050.c ****  *  @param[in]  power_on    1 if turned on, 0 if suspended.
1541:Src/mpu6050.c ****  *  @return     0 if successful.
1542:Src/mpu6050.c ****  */
1543:Src/mpu6050.c **** int mpu_get_power_state(unsigned char *power_on)
1544:Src/mpu6050.c **** {
1545:Src/mpu6050.c ****     if (st.chip_cfg.sensors)
1546:Src/mpu6050.c ****         power_on[0] = 1;
1547:Src/mpu6050.c ****     else
1548:Src/mpu6050.c ****         power_on[0] = 0;
1549:Src/mpu6050.c ****     return 0;
1550:Src/mpu6050.c **** }
1551:Src/mpu6050.c **** 
1552:Src/mpu6050.c **** /**
1553:Src/mpu6050.c ****  *  @brief      Turn specific sensors on/off.
1554:Src/mpu6050.c ****  *  @e sensors can contain a combination of the following flags:
1555:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1556:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1557:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1558:Src/mpu6050.c ****  *  \n INV_XYZ_COMPASS
1559:Src/mpu6050.c ****  *  @param[in]  sensors    Mask of sensors to wake.
1560:Src/mpu6050.c ****  *  @return     0 if successful.
1561:Src/mpu6050.c ****  */
1562:Src/mpu6050.c **** int mpu_set_sensors(unsigned char sensors)
1563:Src/mpu6050.c **** {
1564:Src/mpu6050.c ****     unsigned char data;
1565:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1566:Src/mpu6050.c ****     unsigned char user_ctrl;
1567:Src/mpu6050.c **** #endif
1568:Src/mpu6050.c **** 
1569:Src/mpu6050.c ****     if (sensors & INV_XYZ_GYRO)
1570:Src/mpu6050.c ****         data = INV_CLK_PLL;
ARM GAS  /tmp/ccNfEN49.s 			page 29


1571:Src/mpu6050.c ****     else if (sensors)
1572:Src/mpu6050.c ****         data = 0;
1573:Src/mpu6050.c ****     else
1574:Src/mpu6050.c ****         data = BIT_SLEEP;
1575:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
1576:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
1577:Src/mpu6050.c ****         return -1;
1578:Src/mpu6050.c ****     }
1579:Src/mpu6050.c ****     st.chip_cfg.clk_src = data & ~BIT_SLEEP;
1580:Src/mpu6050.c **** 
1581:Src/mpu6050.c ****     data = 0;
1582:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
1583:Src/mpu6050.c ****         data |= BIT_STBY_XG;
1584:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
1585:Src/mpu6050.c ****         data |= BIT_STBY_YG;
1586:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
1587:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
1588:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
1589:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
1590:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
1591:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
1592:Src/mpu6050.c ****         return -1;
1593:Src/mpu6050.c ****     }
1594:Src/mpu6050.c **** 
1595:Src/mpu6050.c ****     if (sensors && (sensors != INV_XYZ_ACCEL))
1596:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
1597:Src/mpu6050.c ****         mpu_set_int_latched(0);
1598:Src/mpu6050.c **** 
1599:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1600:Src/mpu6050.c **** #ifdef AK89xx_BYPASS
1601:Src/mpu6050.c ****     if (sensors & INV_XYZ_COMPASS)
1602:Src/mpu6050.c ****         mpu_set_bypass(1);
1603:Src/mpu6050.c ****     else
1604:Src/mpu6050.c ****         mpu_set_bypass(0);
1605:Src/mpu6050.c **** #else
1606:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
1607:Src/mpu6050.c ****         return -1;
1608:Src/mpu6050.c ****     /* Handle AKM power management. */
1609:Src/mpu6050.c ****     if (sensors & INV_XYZ_COMPASS) {
1610:Src/mpu6050.c ****         data = AKM_SINGLE_MEASUREMENT;
1611:Src/mpu6050.c ****         user_ctrl |= BIT_AUX_IF_EN;
1612:Src/mpu6050.c ****     } else {
1613:Src/mpu6050.c ****         data = AKM_POWER_DOWN;
1614:Src/mpu6050.c ****         user_ctrl &= ~BIT_AUX_IF_EN;
1615:Src/mpu6050.c ****     }
1616:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1617:Src/mpu6050.c ****         user_ctrl |= BIT_DMP_EN;
1618:Src/mpu6050.c ****     else
1619:Src/mpu6050.c ****         user_ctrl &= ~BIT_DMP_EN;
1620:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
1621:Src/mpu6050.c ****         return -1;
1622:Src/mpu6050.c ****     /* Enable/disable I2C master mode. */
1623:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
1624:Src/mpu6050.c ****         return -1;
1625:Src/mpu6050.c **** #endif
1626:Src/mpu6050.c **** #endif
1627:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 30


1628:Src/mpu6050.c ****     st.chip_cfg.sensors = sensors;
1629:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
1630:Src/mpu6050.c ****     delay_ms(50);
1631:Src/mpu6050.c ****     return 0;
1632:Src/mpu6050.c **** }
1633:Src/mpu6050.c **** 
1634:Src/mpu6050.c **** /**
1635:Src/mpu6050.c ****  *  @brief      Read the MPU interrupt status registers.
1636:Src/mpu6050.c ****  *  @param[out] status  Mask of interrupt bits.
1637:Src/mpu6050.c ****  *  @return     0 if successful.
1638:Src/mpu6050.c ****  */
1639:Src/mpu6050.c **** int mpu_get_int_status(short *status)
1640:Src/mpu6050.c **** {
1641:Src/mpu6050.c ****     unsigned char tmp[2];
1642:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1643:Src/mpu6050.c ****         return -1;
1644:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
1645:Src/mpu6050.c ****         return -1;
1646:Src/mpu6050.c ****     status[0] = (tmp[0] << 8) | tmp[1];
1647:Src/mpu6050.c ****     return 0;
1648:Src/mpu6050.c **** }
1649:Src/mpu6050.c **** 
1650:Src/mpu6050.c **** /**
1651:Src/mpu6050.c ****  *  @brief      Get one packet from the FIFO.
1652:Src/mpu6050.c ****  *  If @e sensors does not contain a particular sensor, disregard the data
1653:Src/mpu6050.c ****  *  returned to that pointer.
1654:Src/mpu6050.c ****  *  \n @e sensors can contain a combination of the following flags:
1655:Src/mpu6050.c ****  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1656:Src/mpu6050.c ****  *  \n INV_XYZ_GYRO
1657:Src/mpu6050.c ****  *  \n INV_XYZ_ACCEL
1658:Src/mpu6050.c ****  *  \n If the FIFO has no new data, @e sensors will be zero.
1659:Src/mpu6050.c ****  *  \n If the FIFO is disabled, @e sensors will be zero and this function will
1660:Src/mpu6050.c ****  *  return a non-zero error code.
1661:Src/mpu6050.c ****  *  @param[out] gyro        Gyro data in hardware units.
1662:Src/mpu6050.c ****  *  @param[out] accel       Accel data in hardware units.
1663:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds.
1664:Src/mpu6050.c ****  *  @param[out] sensors     Mask of sensors read from FIFO.
1665:Src/mpu6050.c ****  *  @param[out] more        Number of remaining packets.
1666:Src/mpu6050.c ****  *  @return     0 if successful.
1667:Src/mpu6050.c ****  */
1668:Src/mpu6050.c **** int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
1669:Src/mpu6050.c ****         unsigned char *sensors, unsigned char *more)
1670:Src/mpu6050.c **** {
1671:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
1672:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
1673:Src/mpu6050.c ****     unsigned char packet_size = 0;
1674:Src/mpu6050.c ****     unsigned short fifo_count, index = 0;
1675:Src/mpu6050.c **** 
1676:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
1677:Src/mpu6050.c ****         return -1;
1678:Src/mpu6050.c **** 
1679:Src/mpu6050.c ****     sensors[0] = 0;
1680:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1681:Src/mpu6050.c ****         return -1;
1682:Src/mpu6050.c ****     if (!st.chip_cfg.fifo_enable)
1683:Src/mpu6050.c ****         return -1;
1684:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 31


1685:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_X_GYRO)
1686:Src/mpu6050.c ****         packet_size += 2;
1687:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
1688:Src/mpu6050.c ****         packet_size += 2;
1689:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
1690:Src/mpu6050.c ****         packet_size += 2;
1691:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
1692:Src/mpu6050.c ****         packet_size += 6;
1693:Src/mpu6050.c **** 
1694:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
1695:Src/mpu6050.c ****         return -1;
1696:Src/mpu6050.c ****     fifo_count = (data[0] << 8) | data[1];
1697:Src/mpu6050.c ****     if (fifo_count < packet_size)
1698:Src/mpu6050.c ****         return 0;
1699:Src/mpu6050.c ****         // #ifdef SERIAL_DEBUG
1700:Src/mpu6050.c ****         // log_i("FIFO count: %hd\r\n", fifo_count);
1701:Src/mpu6050.c ****         // #endif
1702:Src/mpu6050.c ****     if (fifo_count > (st.hw->max_fifo >> 1)) {
1703:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
1704:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
1705:Src/mpu6050.c ****             return -1;
1706:Src/mpu6050.c ****         if (data[0] & BIT_FIFO_OVERFLOW) {
1707:Src/mpu6050.c ****             mpu_reset_fifo();
1708:Src/mpu6050.c ****             return -2;
1709:Src/mpu6050.c ****         }
1710:Src/mpu6050.c ****     }
1711:Src/mpu6050.c ****     get_ms((unsigned long*)timestamp);
1712:Src/mpu6050.c **** 
1713:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
1714:Src/mpu6050.c ****         return -1;
1715:Src/mpu6050.c ****     more[0] = fifo_count / packet_size - 1;
1716:Src/mpu6050.c ****     sensors[0] = 0;
1717:Src/mpu6050.c **** 
1718:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
1719:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
1720:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
1721:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
1722:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
1723:Src/mpu6050.c ****         index += 6;
1724:Src/mpu6050.c ****     }
1725:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
1726:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
1727:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
1728:Src/mpu6050.c ****         index += 2;
1729:Src/mpu6050.c ****     }
1730:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
1731:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
1732:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
1733:Src/mpu6050.c ****         index += 2;
1734:Src/mpu6050.c ****     }
1735:Src/mpu6050.c ****     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
1736:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
1737:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
1738:Src/mpu6050.c ****         index += 2;
1739:Src/mpu6050.c ****     }
1740:Src/mpu6050.c **** 
1741:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 32


1742:Src/mpu6050.c **** }
1743:Src/mpu6050.c **** 
1744:Src/mpu6050.c **** /**
1745:Src/mpu6050.c ****  *  @brief      Get one unparsed packet from the FIFO.
1746:Src/mpu6050.c ****  *  This function should be used if the packet is to be parsed elsewhere.
1747:Src/mpu6050.c ****  *  @param[in]  length  Length of one FIFO packet.
1748:Src/mpu6050.c ****  *  @param[in]  data    FIFO packet.
1749:Src/mpu6050.c ****  *  @param[in]  more    Number of remaining packets.
1750:Src/mpu6050.c ****  */
1751:Src/mpu6050.c **** int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
1752:Src/mpu6050.c ****     unsigned char *more)
1753:Src/mpu6050.c **** {
1754:Src/mpu6050.c ****     unsigned char tmp[2];
1755:Src/mpu6050.c ****     unsigned short fifo_count;
1756:Src/mpu6050.c ****     if (!st.chip_cfg.dmp_on)
1757:Src/mpu6050.c ****         return -1;
1758:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
1759:Src/mpu6050.c ****         return -1;
1760:Src/mpu6050.c **** 
1761:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
1762:Src/mpu6050.c ****         return -1;
1763:Src/mpu6050.c ****     fifo_count = (tmp[0] << 8) | tmp[1];
1764:Src/mpu6050.c ****     if (fifo_count < length) {
1765:Src/mpu6050.c ****         more[0] = 0;
1766:Src/mpu6050.c ****         return -1;
1767:Src/mpu6050.c ****     }
1768:Src/mpu6050.c ****     if (fifo_count > (st.hw->max_fifo >> 1)) {
1769:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
1770:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
1771:Src/mpu6050.c ****             return -1;
1772:Src/mpu6050.c ****         if (tmp[0] & BIT_FIFO_OVERFLOW) {
1773:Src/mpu6050.c ****             mpu_reset_fifo();
1774:Src/mpu6050.c ****             return -2;
1775:Src/mpu6050.c ****         }
1776:Src/mpu6050.c ****     }
1777:Src/mpu6050.c **** 
1778:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
1779:Src/mpu6050.c ****         return -1;
1780:Src/mpu6050.c ****     more[0] = fifo_count / length - 1;
1781:Src/mpu6050.c ****     return 0;
1782:Src/mpu6050.c **** }
1783:Src/mpu6050.c **** 
1784:Src/mpu6050.c **** /**
1785:Src/mpu6050.c ****  *  @brief      Set device to bypass mode.
1786:Src/mpu6050.c ****  *  @param[in]  bypass_on   1 to enable bypass mode.
1787:Src/mpu6050.c ****  *  @return     0 if successful.
1788:Src/mpu6050.c ****  */
1789:Src/mpu6050.c **** int mpu_set_bypass(unsigned char bypass_on)
1790:Src/mpu6050.c **** {
1791:Src/mpu6050.c ****     unsigned char tmp;
1792:Src/mpu6050.c **** 
1793:Src/mpu6050.c ****     if (st.chip_cfg.bypass_mode == bypass_on)
1794:Src/mpu6050.c ****         return 0;
1795:Src/mpu6050.c **** 
1796:Src/mpu6050.c ****     if (bypass_on) {
1797:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1798:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 33


1799:Src/mpu6050.c ****         tmp &= ~BIT_AUX_IF_EN;
1800:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1801:Src/mpu6050.c ****             return -1;
1802:Src/mpu6050.c ****         delay_ms(3);
1803:Src/mpu6050.c ****         tmp = BIT_BYPASS_EN;
1804:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
1805:Src/mpu6050.c ****             tmp |= BIT_ACTL;
1806:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
1807:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1808:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1809:Src/mpu6050.c ****             return -1;
1810:Src/mpu6050.c ****     } else {
1811:Src/mpu6050.c ****         /* Enable I2C master mode if compass is being used. */
1812:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1813:Src/mpu6050.c ****             return -1;
1814:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
1815:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
1816:Src/mpu6050.c ****         else
1817:Src/mpu6050.c ****             tmp &= ~BIT_AUX_IF_EN;
1818:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
1819:Src/mpu6050.c ****             return -1;
1820:Src/mpu6050.c ****         delay_ms(3);
1821:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
1822:Src/mpu6050.c ****             tmp = BIT_ACTL;
1823:Src/mpu6050.c ****         else
1824:Src/mpu6050.c ****             tmp = 0;
1825:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
1826:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
1827:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1828:Src/mpu6050.c ****             return -1;
1829:Src/mpu6050.c ****     }
1830:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = bypass_on;
1831:Src/mpu6050.c ****     return 0;
1832:Src/mpu6050.c **** }
1833:Src/mpu6050.c **** 
1834:Src/mpu6050.c **** /**
1835:Src/mpu6050.c ****  *  @brief      Set interrupt level.
1836:Src/mpu6050.c ****  *  @param[in]  active_low  1 for active low, 0 for active high.
1837:Src/mpu6050.c ****  *  @return     0 if successful.
1838:Src/mpu6050.c ****  */
1839:Src/mpu6050.c **** int mpu_set_int_level(unsigned char active_low)
1840:Src/mpu6050.c **** {
1841:Src/mpu6050.c ****     st.chip_cfg.active_low_int = active_low;
1842:Src/mpu6050.c ****     return 0;
1843:Src/mpu6050.c **** }
1844:Src/mpu6050.c **** 
1845:Src/mpu6050.c **** /**
1846:Src/mpu6050.c ****  *  @brief      Enable latched interrupts.
1847:Src/mpu6050.c ****  *  Any MPU register will clear the interrupt.
1848:Src/mpu6050.c ****  *  @param[in]  enable  1 to enable, 0 to disable.
1849:Src/mpu6050.c ****  *  @return     0 if successful.
1850:Src/mpu6050.c ****  */
1851:Src/mpu6050.c **** int mpu_set_int_latched(unsigned char enable)
1852:Src/mpu6050.c **** {
1853:Src/mpu6050.c ****     unsigned char tmp;
1854:Src/mpu6050.c ****     if (st.chip_cfg.latched_int == enable)
1855:Src/mpu6050.c ****         return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 34


1856:Src/mpu6050.c **** 
1857:Src/mpu6050.c ****     if (enable)
1858:Src/mpu6050.c ****         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
1859:Src/mpu6050.c ****     else
1860:Src/mpu6050.c ****         tmp = 0;
1861:Src/mpu6050.c ****     if (st.chip_cfg.bypass_mode)
1862:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
1863:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
1864:Src/mpu6050.c ****         tmp |= BIT_ACTL;
1865:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
1866:Src/mpu6050.c ****         return -1;
1867:Src/mpu6050.c ****     st.chip_cfg.latched_int = enable;
1868:Src/mpu6050.c ****     return 0;
1869:Src/mpu6050.c **** }
1870:Src/mpu6050.c **** 
1871:Src/mpu6050.c **** #ifdef MPU6050
1872:Src/mpu6050.c **** static int get_accel_prod_shift(float *st_shift)
1873:Src/mpu6050.c **** {
1874:Src/mpu6050.c ****     unsigned char tmp[4], shift_code[3], ii;
1875:Src/mpu6050.c **** 
1876:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
1877:Src/mpu6050.c ****         return 0x07;
1878:Src/mpu6050.c **** 
1879:Src/mpu6050.c ****     shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
1880:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
1881:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
1882:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
1883:Src/mpu6050.c ****         if (!shift_code[ii]) {
1884:Src/mpu6050.c ****             st_shift[ii] = 0.f;
1885:Src/mpu6050.c ****             continue;
1886:Src/mpu6050.c ****         }
1887:Src/mpu6050.c ****         /* Equivalent to..
1888:Src/mpu6050.c ****          * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
1889:Src/mpu6050.c ****          */
1890:Src/mpu6050.c ****         st_shift[ii] = 0.34f;
1891:Src/mpu6050.c ****         while (--shift_code[ii])
1892:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
1893:Src/mpu6050.c ****     }
1894:Src/mpu6050.c ****     return 0;
1895:Src/mpu6050.c **** }
1896:Src/mpu6050.c **** 
1897:Src/mpu6050.c **** static int accel_self_test(long *bias_regular, long *bias_st)
1898:Src/mpu6050.c **** {
1899:Src/mpu6050.c ****     int jj, result = 0;
1900:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
1901:Src/mpu6050.c **** 
1902:Src/mpu6050.c ****     get_accel_prod_shift(st_shift);
1903:Src/mpu6050.c ****     for(jj = 0; jj < 3; jj++) {
1904:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
1905:Src/mpu6050.c ****         if (st_shift[jj]) {
1906:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
1907:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
1908:Src/mpu6050.c ****                 result |= 1 << jj;
1909:Src/mpu6050.c ****         } else if ((st_shift_cust < test.min_g) ||
1910:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
1911:Src/mpu6050.c ****             result |= 1 << jj;
1912:Src/mpu6050.c ****     }
ARM GAS  /tmp/ccNfEN49.s 			page 35


1913:Src/mpu6050.c **** 
1914:Src/mpu6050.c ****     return result;
1915:Src/mpu6050.c **** }
1916:Src/mpu6050.c **** 
1917:Src/mpu6050.c **** static int gyro_self_test(long *bias_regular, long *bias_st)
1918:Src/mpu6050.c **** {
1919:Src/mpu6050.c ****     int jj, result = 0;
1920:Src/mpu6050.c ****     unsigned char tmp[3];
1921:Src/mpu6050.c ****     float st_shift, st_shift_cust, st_shift_var;
1922:Src/mpu6050.c **** 
1923:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
1924:Src/mpu6050.c ****         return 0x07;
1925:Src/mpu6050.c **** 
1926:Src/mpu6050.c ****     tmp[0] &= 0x1F;
1927:Src/mpu6050.c ****     tmp[1] &= 0x1F;
1928:Src/mpu6050.c ****     tmp[2] &= 0x1F;
1929:Src/mpu6050.c **** 
1930:Src/mpu6050.c ****     for (jj = 0; jj < 3; jj++) {
1931:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
1932:Src/mpu6050.c ****         if (tmp[jj]) {
1933:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
1934:Src/mpu6050.c ****             while (--tmp[jj])
1935:Src/mpu6050.c ****                 st_shift *= 1.046f;
1936:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
1937:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
1938:Src/mpu6050.c ****                 result |= 1 << jj;
1939:Src/mpu6050.c ****         } else if ((st_shift_cust < test.min_dps) ||
1940:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
1941:Src/mpu6050.c ****             result |= 1 << jj;
1942:Src/mpu6050.c ****     }
1943:Src/mpu6050.c ****     return result;
1944:Src/mpu6050.c **** }
1945:Src/mpu6050.c **** 
1946:Src/mpu6050.c **** #endif 
1947:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
1948:Src/mpu6050.c **** static int compass_self_test(void)
1949:Src/mpu6050.c **** {
1950:Src/mpu6050.c ****     unsigned char tmp[6];
1951:Src/mpu6050.c ****     unsigned char tries = 10;
1952:Src/mpu6050.c ****     int result = 0x07;
1953:Src/mpu6050.c ****     short data;
1954:Src/mpu6050.c **** 
1955:Src/mpu6050.c ****     mpu_set_bypass(1);
1956:Src/mpu6050.c **** 
1957:Src/mpu6050.c ****     tmp[0] = AKM_POWER_DOWN;
1958:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
1959:Src/mpu6050.c ****         return 0x07;
1960:Src/mpu6050.c ****     tmp[0] = AKM_BIT_SELF_TEST;
1961:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
1962:Src/mpu6050.c ****         goto AKM_restore;
1963:Src/mpu6050.c ****     tmp[0] = AKM_MODE_SELF_TEST;
1964:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
1965:Src/mpu6050.c ****         goto AKM_restore;
1966:Src/mpu6050.c **** 
1967:Src/mpu6050.c ****     do {
1968:Src/mpu6050.c ****         delay_ms(10);
1969:Src/mpu6050.c ****         if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
ARM GAS  /tmp/ccNfEN49.s 			page 36


1970:Src/mpu6050.c ****             goto AKM_restore;
1971:Src/mpu6050.c ****         if (tmp[0] & AKM_DATA_READY)
1972:Src/mpu6050.c ****             break;
1973:Src/mpu6050.c ****     } while (tries--);
1974:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY))
1975:Src/mpu6050.c ****         goto AKM_restore;
1976:Src/mpu6050.c **** 
1977:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
1978:Src/mpu6050.c ****         goto AKM_restore;
1979:Src/mpu6050.c **** 
1980:Src/mpu6050.c ****     result = 0;
1981:Src/mpu6050.c **** #if defined MPU9150
1982:Src/mpu6050.c ****     data = (short)(tmp[1] << 8) | tmp[0];
1983:Src/mpu6050.c ****     if ((data > 100) || (data < -100))
1984:Src/mpu6050.c ****         result |= 0x01;
1985:Src/mpu6050.c ****     data = (short)(tmp[3] << 8) | tmp[2];
1986:Src/mpu6050.c ****     if ((data > 100) || (data < -100))
1987:Src/mpu6050.c ****         result |= 0x02;
1988:Src/mpu6050.c ****     data = (short)(tmp[5] << 8) | tmp[4];
1989:Src/mpu6050.c ****     if ((data > -300) || (data < -1000))
1990:Src/mpu6050.c ****         result |= 0x04;
1991:Src/mpu6050.c **** #elif defined MPU9250
1992:Src/mpu6050.c ****     data = (short)(tmp[1] << 8) | tmp[0];
1993:Src/mpu6050.c ****     if ((data > 200) || (data < -200))  
1994:Src/mpu6050.c ****         result |= 0x01;
1995:Src/mpu6050.c ****     data = (short)(tmp[3] << 8) | tmp[2];
1996:Src/mpu6050.c ****     if ((data > 200) || (data < -200))  
1997:Src/mpu6050.c ****         result |= 0x02;
1998:Src/mpu6050.c ****     data = (short)(tmp[5] << 8) | tmp[4];
1999:Src/mpu6050.c ****     if ((data > -800) || (data < -3200))  
2000:Src/mpu6050.c ****         result |= 0x04;
2001:Src/mpu6050.c **** #endif
2002:Src/mpu6050.c **** AKM_restore:
2003:Src/mpu6050.c ****     tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
2004:Src/mpu6050.c ****     i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
2005:Src/mpu6050.c ****     tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
2006:Src/mpu6050.c ****     i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
2007:Src/mpu6050.c ****     mpu_set_bypass(0);
2008:Src/mpu6050.c ****     return result;
2009:Src/mpu6050.c **** }
2010:Src/mpu6050.c **** #endif
2011:Src/mpu6050.c **** 
2012:Src/mpu6050.c **** static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
2013:Src/mpu6050.c **** {
  28              		.loc 1 2013 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 0, uses_anonymous_args = 0
2014:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  32              		.loc 1 2014 5 view .LVU1
2015:Src/mpu6050.c ****     unsigned char packet_count, ii;
  33              		.loc 1 2015 5 view .LVU2
2016:Src/mpu6050.c ****     unsigned short fifo_count;
  34              		.loc 1 2016 5 view .LVU3
2017:Src/mpu6050.c **** 
2018:Src/mpu6050.c ****     data[0] = 0x01;
  35              		.loc 1 2018 5 view .LVU4
ARM GAS  /tmp/ccNfEN49.s 			page 37


2013:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  36              		.loc 1 2013 1 is_stmt 0 view .LVU5
  37 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
  38              	.LCFI0:
  39              		.cfi_def_cfa_offset 28
  40              		.cfi_offset 4, -28
  41              		.cfi_offset 5, -24
  42              		.cfi_offset 6, -20
  43              		.cfi_offset 7, -16
  44              		.cfi_offset 8, -12
  45              		.cfi_offset 9, -8
  46              		.cfi_offset 14, -4
2019:Src/mpu6050.c ****     data[1] = 0;
  47              		.loc 1 2019 13 view .LVU6
  48 0004 0023     		movs	r3, #0
2018:Src/mpu6050.c ****     data[1] = 0;
  49              		.loc 1 2018 13 view .LVU7
  50 0006 0127     		movs	r7, #1
2013:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  51              		.loc 1 2013 1 view .LVU8
  52 0008 85B0     		sub	sp, sp, #20
  53              	.LCFI1:
  54              		.cfi_def_cfa_offset 48
2020:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
  55              		.loc 1 2020 34 view .LVU9
  56 000a B64C     		ldr	r4, .L22
2019:Src/mpu6050.c ****     data[1] = 0;
  57              		.loc 1 2019 13 view .LVU10
  58 000c 8DF80530 		strb	r3, [sp, #5]
2018:Src/mpu6050.c ****     data[1] = 0;
  59              		.loc 1 2018 13 view .LVU11
  60 0010 8DF80470 		strb	r7, [sp, #4]
2019:Src/mpu6050.c ****     data[1] = 0;
  61              		.loc 1 2019 5 is_stmt 1 view .LVU12
  62              		.loc 1 2020 5 view .LVU13
2013:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  63              		.loc 1 2013 1 is_stmt 0 view .LVU14
  64 0014 0646     		mov	r6, r0
  65 0016 0D46     		mov	r5, r1
  66              		.loc 1 2020 9 view .LVU15
  67 0018 D4E90010 		ldrd	r1, r0, [r4]
  68              	.LVL1:
2013:Src/mpu6050.c ****     unsigned char data[MAX_PACKET_LENGTH];
  69              		.loc 1 2013 1 view .LVU16
  70 001c 9046     		mov	r8, r2
  71              		.loc 1 2020 9 view .LVU17
  72 001e 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
  73 0020 0222     		movs	r2, #2
  74              	.LVL2:
  75              		.loc 1 2020 9 view .LVU18
  76 0022 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
  77 0024 01AB     		add	r3, sp, #4
  78 0026 FFF7FEFF 		bl	i2c_writeBytes
  79              	.LVL3:
  80              		.loc 1 2020 8 view .LVU19
  81 002a 8146     		mov	r9, r0
  82 002c 20B1     		cbz	r0, .L2
ARM GAS  /tmp/ccNfEN49.s 			page 38


  83              	.L4:
2021:Src/mpu6050.c ****         return -1;
  84              		.loc 1 2021 16 view .LVU20
  85 002e 4FF0FF30 		mov	r0, #-1
  86              	.L1:
2022:Src/mpu6050.c ****     delay_ms(200);
2023:Src/mpu6050.c ****     data[0] = 0;
2024:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
2025:Src/mpu6050.c ****         return -1;
2026:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2027:Src/mpu6050.c ****         return -1;
2028:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
2029:Src/mpu6050.c ****         return -1;
2030:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2031:Src/mpu6050.c ****         return -1;
2032:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2033:Src/mpu6050.c ****         return -1;
2034:Src/mpu6050.c ****     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
2035:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2036:Src/mpu6050.c ****         return -1;
2037:Src/mpu6050.c ****     delay_ms(15);
2038:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
2039:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
2040:Src/mpu6050.c ****         return -1;
2041:Src/mpu6050.c ****     data[0] = st.test->reg_rate_div;
2042:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
2043:Src/mpu6050.c ****         return -1;
2044:Src/mpu6050.c ****     if (hw_test)
2045:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
2046:Src/mpu6050.c ****     else
2047:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr;
2048:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
2049:Src/mpu6050.c ****         return -1;
2050:Src/mpu6050.c **** 
2051:Src/mpu6050.c ****     if (hw_test)
2052:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
2053:Src/mpu6050.c ****     else
2054:Src/mpu6050.c ****         data[0] = test.reg_accel_fsr;
2055:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
2056:Src/mpu6050.c ****         return -1;
2057:Src/mpu6050.c ****     if (hw_test)
2058:Src/mpu6050.c ****         delay_ms(200);
2059:Src/mpu6050.c **** 
2060:Src/mpu6050.c ****     /* Fill FIFO for test.wait_ms milliseconds. */
2061:Src/mpu6050.c ****     data[0] = BIT_FIFO_EN;
2062:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2063:Src/mpu6050.c ****         return -1;
2064:Src/mpu6050.c **** 
2065:Src/mpu6050.c ****     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2066:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2067:Src/mpu6050.c ****         return -1;
2068:Src/mpu6050.c ****     delay_ms(test.wait_ms);
2069:Src/mpu6050.c ****     data[0] = 0;
2070:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2071:Src/mpu6050.c ****         return -1;
2072:Src/mpu6050.c **** 
2073:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
ARM GAS  /tmp/ccNfEN49.s 			page 39


2074:Src/mpu6050.c ****         return -1;
2075:Src/mpu6050.c **** 
2076:Src/mpu6050.c ****     fifo_count = (data[0] << 8) | data[1];
2077:Src/mpu6050.c ****     packet_count = fifo_count / MAX_PACKET_LENGTH;
2078:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
2079:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
2080:Src/mpu6050.c **** 
2081:Src/mpu6050.c ****     for (ii = 0; ii < packet_count; ii++) {
2082:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
2083:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
2084:Src/mpu6050.c ****             return -1;
2085:Src/mpu6050.c ****         accel_cur[0] = ((short)data[0] << 8) | data[1];
2086:Src/mpu6050.c ****         accel_cur[1] = ((short)data[2] << 8) | data[3];
2087:Src/mpu6050.c ****         accel_cur[2] = ((short)data[4] << 8) | data[5];
2088:Src/mpu6050.c ****         accel[0] += (long)accel_cur[0];
2089:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
2090:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
2091:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
2092:Src/mpu6050.c ****         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
2093:Src/mpu6050.c ****         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
2094:Src/mpu6050.c ****         gyro[0] += (long)gyro_cur[0];
2095:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
2096:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
2097:Src/mpu6050.c ****     }
2098:Src/mpu6050.c **** #ifdef EMPL_NO_64BIT
2099:Src/mpu6050.c ****     gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
2100:Src/mpu6050.c ****     gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
2101:Src/mpu6050.c ****     gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
2102:Src/mpu6050.c ****     if (has_accel) {
2103:Src/mpu6050.c ****         accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
2104:Src/mpu6050.c ****             packet_count);
2105:Src/mpu6050.c ****         accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
2106:Src/mpu6050.c ****             packet_count);
2107:Src/mpu6050.c ****         accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
2108:Src/mpu6050.c ****             packet_count);
2109:Src/mpu6050.c ****         /* Don't remove gravity! */
2110:Src/mpu6050.c ****         accel[2] -= 65536L;
2111:Src/mpu6050.c ****     }
2112:Src/mpu6050.c **** #else
2113:Src/mpu6050.c ****     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
2114:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
2115:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
2116:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
2117:Src/mpu6050.c ****         packet_count);
2118:Src/mpu6050.c ****     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
2119:Src/mpu6050.c ****         packet_count);
2120:Src/mpu6050.c ****     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
2121:Src/mpu6050.c ****         packet_count);
2122:Src/mpu6050.c ****     /* Don't remove gravity! */
2123:Src/mpu6050.c ****     if (accel[2] > 0L)
2124:Src/mpu6050.c ****         accel[2] -= 65536L;
2125:Src/mpu6050.c ****     else
2126:Src/mpu6050.c ****         accel[2] += 65536L;
2127:Src/mpu6050.c **** #endif
2128:Src/mpu6050.c **** 
2129:Src/mpu6050.c ****     return 0;
2130:Src/mpu6050.c **** }
ARM GAS  /tmp/ccNfEN49.s 			page 40


  87              		.loc 1 2130 1 view .LVU21
  88 0032 05B0     		add	sp, sp, #20
  89              	.LCFI2:
  90              		.cfi_remember_state
  91              		.cfi_def_cfa_offset 28
  92              		@ sp needed
  93 0034 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
  94              	.LVL4:
  95              	.L2:
  96              	.LCFI3:
  97              		.cfi_restore_state
2022:Src/mpu6050.c ****     delay_ms(200);
  98              		.loc 1 2022 5 is_stmt 1 view .LVU22
  99 0038 C820     		movs	r0, #200
 100 003a FFF7FEFF 		bl	delay_1ms
 101              	.LVL5:
2023:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
 102              		.loc 1 2023 5 view .LVU23
2024:Src/mpu6050.c ****         return -1;
 103              		.loc 1 2024 9 is_stmt 0 view .LVU24
 104 003e D4E90010 		ldrd	r1, r0, [r4]
2023:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
 105              		.loc 1 2023 13 view .LVU25
 106 0042 8DF80490 		strb	r9, [sp, #4]
2024:Src/mpu6050.c ****         return -1;
 107              		.loc 1 2024 5 is_stmt 1 view .LVU26
2024:Src/mpu6050.c ****         return -1;
 108              		.loc 1 2024 9 is_stmt 0 view .LVU27
 109 0046 3A46     		mov	r2, r7
 110 0048 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 111 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 112 004c 01AB     		add	r3, sp, #4
 113 004e FFF7FEFF 		bl	i2c_writeBytes
 114              	.LVL6:
2024:Src/mpu6050.c ****         return -1;
 115              		.loc 1 2024 8 view .LVU28
 116 0052 0028     		cmp	r0, #0
 117 0054 EBD1     		bne	.L4
2026:Src/mpu6050.c ****         return -1;
 118              		.loc 1 2026 5 is_stmt 1 view .LVU29
2026:Src/mpu6050.c ****         return -1;
 119              		.loc 1 2026 9 is_stmt 0 view .LVU30
 120 0056 D4E90010 		ldrd	r1, r0, [r4]
 121 005a 3A46     		mov	r2, r7
 122 005c 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 123 005e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 124 0060 01AB     		add	r3, sp, #4
 125 0062 FFF7FEFF 		bl	i2c_writeBytes
 126              	.LVL7:
2026:Src/mpu6050.c ****         return -1;
 127              		.loc 1 2026 8 view .LVU31
 128 0066 0028     		cmp	r0, #0
 129 0068 E1D1     		bne	.L4
2028:Src/mpu6050.c ****         return -1;
 130              		.loc 1 2028 5 is_stmt 1 view .LVU32
2028:Src/mpu6050.c ****         return -1;
 131              		.loc 1 2028 9 is_stmt 0 view .LVU33
ARM GAS  /tmp/ccNfEN49.s 			page 41


 132 006a D4E90010 		ldrd	r1, r0, [r4]
 133 006e 3A46     		mov	r2, r7
 134 0070 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 135 0072 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 136 0074 01AB     		add	r3, sp, #4
 137 0076 FFF7FEFF 		bl	i2c_writeBytes
 138              	.LVL8:
2028:Src/mpu6050.c ****         return -1;
 139              		.loc 1 2028 8 view .LVU34
 140 007a 0028     		cmp	r0, #0
 141 007c D7D1     		bne	.L4
2030:Src/mpu6050.c ****         return -1;
 142              		.loc 1 2030 5 is_stmt 1 view .LVU35
2030:Src/mpu6050.c ****         return -1;
 143              		.loc 1 2030 9 is_stmt 0 view .LVU36
 144 007e D4E90010 		ldrd	r1, r0, [r4]
 145 0082 3A46     		mov	r2, r7
 146 0084 897E     		ldrb	r1, [r1, #26]	@ zero_extendqisi2
 147 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 148 0088 01AB     		add	r3, sp, #4
 149 008a FFF7FEFF 		bl	i2c_writeBytes
 150              	.LVL9:
2030:Src/mpu6050.c ****         return -1;
 151              		.loc 1 2030 8 view .LVU37
 152 008e 0028     		cmp	r0, #0
 153 0090 CDD1     		bne	.L4
2032:Src/mpu6050.c ****         return -1;
 154              		.loc 1 2032 5 is_stmt 1 view .LVU38
2032:Src/mpu6050.c ****         return -1;
 155              		.loc 1 2032 9 is_stmt 0 view .LVU39
 156 0092 D4E90010 		ldrd	r1, r0, [r4]
 157 0096 3A46     		mov	r2, r7
 158 0098 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 159 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 160 009c 01AB     		add	r3, sp, #4
 161 009e FFF7FEFF 		bl	i2c_writeBytes
 162              	.LVL10:
2032:Src/mpu6050.c ****         return -1;
 163              		.loc 1 2032 8 view .LVU40
 164 00a2 0028     		cmp	r0, #0
 165 00a4 C3D1     		bne	.L4
2034:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 166              		.loc 1 2034 5 is_stmt 1 view .LVU41
2035:Src/mpu6050.c ****         return -1;
 167              		.loc 1 2035 9 is_stmt 0 view .LVU42
 168 00a6 D4E90010 		ldrd	r1, r0, [r4]
2034:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 169              		.loc 1 2034 13 view .LVU43
 170 00aa 0C23     		movs	r3, #12
 171 00ac 8DF80430 		strb	r3, [sp, #4]
2035:Src/mpu6050.c ****         return -1;
 172              		.loc 1 2035 5 is_stmt 1 view .LVU44
2035:Src/mpu6050.c ****         return -1;
 173              		.loc 1 2035 9 is_stmt 0 view .LVU45
 174 00b0 3A46     		mov	r2, r7
 175 00b2 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 176 00b4 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
ARM GAS  /tmp/ccNfEN49.s 			page 42


 177 00b6 01AB     		add	r3, sp, #4
 178 00b8 FFF7FEFF 		bl	i2c_writeBytes
 179              	.LVL11:
2035:Src/mpu6050.c ****         return -1;
 180              		.loc 1 2035 8 view .LVU46
 181 00bc 0028     		cmp	r0, #0
 182 00be B6D1     		bne	.L4
2037:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
 183              		.loc 1 2037 5 is_stmt 1 view .LVU47
 184 00c0 0F20     		movs	r0, #15
 185 00c2 FFF7FEFF 		bl	delay_1ms
 186              	.LVL12:
2038:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 187              		.loc 1 2038 5 view .LVU48
2039:Src/mpu6050.c ****         return -1;
 188              		.loc 1 2039 9 is_stmt 0 view .LVU49
 189 00c6 D4E90010 		ldrd	r1, r0, [r4]
2038:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 190              		.loc 1 2038 22 view .LVU50
 191 00ca A36A     		ldr	r3, [r4, #40]
2039:Src/mpu6050.c ****         return -1;
 192              		.loc 1 2039 9 view .LVU51
 193 00cc 3A46     		mov	r2, r7
2038:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 194              		.loc 1 2038 13 view .LVU52
 195 00ce 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
2039:Src/mpu6050.c ****         return -1;
 196              		.loc 1 2039 9 view .LVU53
 197 00d0 8978     		ldrb	r1, [r1, #2]	@ zero_extendqisi2
2038:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
 198              		.loc 1 2038 13 view .LVU54
 199 00d2 8DF80430 		strb	r3, [sp, #4]
2039:Src/mpu6050.c ****         return -1;
 200              		.loc 1 2039 5 is_stmt 1 view .LVU55
2039:Src/mpu6050.c ****         return -1;
 201              		.loc 1 2039 9 is_stmt 0 view .LVU56
 202 00d6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 203 00d8 01AB     		add	r3, sp, #4
 204 00da FFF7FEFF 		bl	i2c_writeBytes
 205              	.LVL13:
2039:Src/mpu6050.c ****         return -1;
 206              		.loc 1 2039 8 view .LVU57
 207 00de 0028     		cmp	r0, #0
 208 00e0 A5D1     		bne	.L4
2041:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 209              		.loc 1 2041 5 is_stmt 1 view .LVU58
2042:Src/mpu6050.c ****         return -1;
 210              		.loc 1 2042 9 is_stmt 0 view .LVU59
 211 00e2 D4E90010 		ldrd	r1, r0, [r4]
2041:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 212              		.loc 1 2041 22 view .LVU60
 213 00e6 A36A     		ldr	r3, [r4, #40]
2042:Src/mpu6050.c ****         return -1;
 214              		.loc 1 2042 9 view .LVU61
 215 00e8 3A46     		mov	r2, r7
2041:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 216              		.loc 1 2041 13 view .LVU62
ARM GAS  /tmp/ccNfEN49.s 			page 43


 217 00ea 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
2042:Src/mpu6050.c ****         return -1;
 218              		.loc 1 2042 9 view .LVU63
 219 00ec 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
2041:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
 220              		.loc 1 2041 13 view .LVU64
 221 00ee 8DF80430 		strb	r3, [sp, #4]
2042:Src/mpu6050.c ****         return -1;
 222              		.loc 1 2042 5 is_stmt 1 view .LVU65
2042:Src/mpu6050.c ****         return -1;
 223              		.loc 1 2042 9 is_stmt 0 view .LVU66
 224 00f2 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 225 00f4 01AB     		add	r3, sp, #4
 226 00f6 FFF7FEFF 		bl	i2c_writeBytes
 227              	.LVL14:
2042:Src/mpu6050.c ****         return -1;
 228              		.loc 1 2042 8 view .LVU67
 229 00fa 0028     		cmp	r0, #0
 230 00fc 97D1     		bne	.L4
2044:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
 231              		.loc 1 2044 5 is_stmt 1 view .LVU68
2045:Src/mpu6050.c ****     else
 232              		.loc 1 2045 26 is_stmt 0 view .LVU69
 233 00fe A36A     		ldr	r3, [r4, #40]
 234 0100 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
2044:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
 235              		.loc 1 2044 8 view .LVU70
 236 0102 B8F1000F 		cmp	r8, #0
 237 0106 01D0     		beq	.L5
2045:Src/mpu6050.c ****     else
 238              		.loc 1 2045 9 is_stmt 1 view .LVU71
2045:Src/mpu6050.c ****     else
 239              		.loc 1 2045 17 is_stmt 0 view .LVU72
 240 0108 43F0E003 		orr	r3, r3, #224
 241              	.L5:
 242 010c 8DF80430 		strb	r3, [sp, #4]
2048:Src/mpu6050.c ****         return -1;
 243              		.loc 1 2048 5 is_stmt 1 view .LVU73
2048:Src/mpu6050.c ****         return -1;
 244              		.loc 1 2048 9 is_stmt 0 view .LVU74
 245 0110 D4E90010 		ldrd	r1, r0, [r4]
 246 0114 0122     		movs	r2, #1
 247 0116 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 248 0118 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 249 011a 01AB     		add	r3, sp, #4
 250 011c FFF7FEFF 		bl	i2c_writeBytes
 251              	.LVL15:
2048:Src/mpu6050.c ****         return -1;
 252              		.loc 1 2048 8 view .LVU75
 253 0120 0028     		cmp	r0, #0
 254 0122 84D1     		bne	.L4
2051:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
 255              		.loc 1 2051 5 is_stmt 1 view .LVU76
2051:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
 256              		.loc 1 2051 8 is_stmt 0 view .LVU77
 257 0124 B8F1000F 		cmp	r8, #0
 258 0128 00F0D980 		beq	.L14
ARM GAS  /tmp/ccNfEN49.s 			page 44


2052:Src/mpu6050.c ****     else
 259              		.loc 1 2052 9 is_stmt 1 view .LVU78
2052:Src/mpu6050.c ****     else
 260              		.loc 1 2052 26 is_stmt 0 view .LVU79
 261 012c A36A     		ldr	r3, [r4, #40]
2052:Src/mpu6050.c ****     else
 262              		.loc 1 2052 17 view .LVU80
 263 012e DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 264 0130 43F0E003 		orr	r3, r3, #224
 265              	.L6:
 266 0134 8DF80430 		strb	r3, [sp, #4]
2055:Src/mpu6050.c ****         return -1;
 267              		.loc 1 2055 5 is_stmt 1 view .LVU81
2055:Src/mpu6050.c ****         return -1;
 268              		.loc 1 2055 9 is_stmt 0 view .LVU82
 269 0138 D4E90010 		ldrd	r1, r0, [r4]
 270 013c 0122     		movs	r2, #1
 271 013e C979     		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 272 0140 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 273 0142 01AB     		add	r3, sp, #4
 274 0144 FFF7FEFF 		bl	i2c_writeBytes
 275              	.LVL16:
2055:Src/mpu6050.c ****         return -1;
 276              		.loc 1 2055 8 view .LVU83
 277 0148 0028     		cmp	r0, #0
 278 014a 7FF470AF 		bne	.L4
2057:Src/mpu6050.c ****         delay_ms(200);
 279              		.loc 1 2057 5 is_stmt 1 view .LVU84
2057:Src/mpu6050.c ****         delay_ms(200);
 280              		.loc 1 2057 8 is_stmt 0 view .LVU85
 281 014e B8F1000F 		cmp	r8, #0
 282 0152 02D0     		beq	.L7
2058:Src/mpu6050.c **** 
 283              		.loc 1 2058 9 is_stmt 1 view .LVU86
 284 0154 C820     		movs	r0, #200
 285 0156 FFF7FEFF 		bl	delay_1ms
 286              	.LVL17:
 287              	.L7:
2061:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 288              		.loc 1 2061 5 view .LVU87
2062:Src/mpu6050.c ****         return -1;
 289              		.loc 1 2062 9 is_stmt 0 view .LVU88
 290 015a D4E90010 		ldrd	r1, r0, [r4]
2061:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
 291              		.loc 1 2061 13 view .LVU89
 292 015e 4023     		movs	r3, #64
 293 0160 8DF80430 		strb	r3, [sp, #4]
2062:Src/mpu6050.c ****         return -1;
 294              		.loc 1 2062 5 is_stmt 1 view .LVU90
2062:Src/mpu6050.c ****         return -1;
 295              		.loc 1 2062 9 is_stmt 0 view .LVU91
 296 0164 0122     		movs	r2, #1
 297 0166 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 298 0168 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 299 016a 01AB     		add	r3, sp, #4
 300 016c FFF7FEFF 		bl	i2c_writeBytes
 301              	.LVL18:
ARM GAS  /tmp/ccNfEN49.s 			page 45


2062:Src/mpu6050.c ****         return -1;
 302              		.loc 1 2062 8 view .LVU92
 303 0170 0028     		cmp	r0, #0
 304 0172 7FF45CAF 		bne	.L4
2065:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 305              		.loc 1 2065 5 is_stmt 1 view .LVU93
2066:Src/mpu6050.c ****         return -1;
 306              		.loc 1 2066 9 is_stmt 0 view .LVU94
 307 0176 D4E90010 		ldrd	r1, r0, [r4]
2065:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 308              		.loc 1 2065 13 view .LVU95
 309 017a 7823     		movs	r3, #120
 310 017c 8DF80430 		strb	r3, [sp, #4]
2066:Src/mpu6050.c ****         return -1;
 311              		.loc 1 2066 5 is_stmt 1 view .LVU96
2066:Src/mpu6050.c ****         return -1;
 312              		.loc 1 2066 9 is_stmt 0 view .LVU97
 313 0180 0122     		movs	r2, #1
 314 0182 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 315 0184 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 316 0186 01AB     		add	r3, sp, #4
 317 0188 FFF7FEFF 		bl	i2c_writeBytes
 318              	.LVL19:
2066:Src/mpu6050.c ****         return -1;
 319              		.loc 1 2066 8 view .LVU98
 320 018c 0746     		mov	r7, r0
 321 018e 0028     		cmp	r0, #0
 322 0190 7FF44DAF 		bne	.L4
2068:Src/mpu6050.c ****     data[0] = 0;
 323              		.loc 1 2068 5 is_stmt 1 view .LVU99
 324 0194 3220     		movs	r0, #50
 325 0196 FFF7FEFF 		bl	delay_1ms
 326              	.LVL20:
2069:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 327              		.loc 1 2069 5 view .LVU100
2070:Src/mpu6050.c ****         return -1;
 328              		.loc 1 2070 9 is_stmt 0 view .LVU101
 329 019a D4E90010 		ldrd	r1, r0, [r4]
2069:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
 330              		.loc 1 2069 13 view .LVU102
 331 019e 8DF80470 		strb	r7, [sp, #4]
2070:Src/mpu6050.c ****         return -1;
 332              		.loc 1 2070 5 is_stmt 1 view .LVU103
2070:Src/mpu6050.c ****         return -1;
 333              		.loc 1 2070 9 is_stmt 0 view .LVU104
 334 01a2 0122     		movs	r2, #1
 335 01a4 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 336 01a6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 337 01a8 01AB     		add	r3, sp, #4
 338 01aa FFF7FEFF 		bl	i2c_writeBytes
 339              	.LVL21:
2070:Src/mpu6050.c ****         return -1;
 340              		.loc 1 2070 8 view .LVU105
 341 01ae 0028     		cmp	r0, #0
 342 01b0 7FF43DAF 		bne	.L4
2073:Src/mpu6050.c ****         return -1;
 343              		.loc 1 2073 5 is_stmt 1 view .LVU106
ARM GAS  /tmp/ccNfEN49.s 			page 46


2073:Src/mpu6050.c ****         return -1;
 344              		.loc 1 2073 9 is_stmt 0 view .LVU107
 345 01b4 D4E90010 		ldrd	r1, r0, [r4]
 346 01b8 0222     		movs	r2, #2
 347 01ba 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 348 01bc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 349 01be 01AB     		add	r3, sp, #4
 350 01c0 FFF7FEFF 		bl	i2c_readBytes
 351              	.LVL22:
2073:Src/mpu6050.c ****         return -1;
 352              		.loc 1 2073 8 view .LVU108
 353 01c4 0028     		cmp	r0, #0
 354 01c6 7FF432AF 		bne	.L4
2076:Src/mpu6050.c ****     packet_count = fifo_count / MAX_PACKET_LENGTH;
 355              		.loc 1 2076 5 is_stmt 1 view .LVU109
 356              	.LVL23:
2077:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 357              		.loc 1 2077 5 view .LVU110
2077:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 358              		.loc 1 2077 18 is_stmt 0 view .LVU111
 359 01ca 0C23     		movs	r3, #12
 360 01cc BDF80470 		ldrh	r7, [sp, #4]
2081:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 361              		.loc 1 2081 5 view .LVU112
 362 01d0 8046     		mov	r8, r0
2077:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 363              		.loc 1 2077 18 view .LVU113
 364 01d2 7FBA     		rev16	r7, r7
 365 01d4 BFB2     		uxth	r7, r7
 366 01d6 B7FBF3F7 		udiv	r7, r7, r3
2078:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 367              		.loc 1 2078 23 view .LVU114
 368 01da C6E90100 		strd	r0, r0, [r6, #4]
2078:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 369              		.loc 1 2078 13 view .LVU115
 370 01de 3060     		str	r0, [r6]
2079:Src/mpu6050.c **** 
 371              		.loc 1 2079 25 view .LVU116
 372 01e0 C5E90100 		strd	r0, r0, [r5, #4]
2077:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
 373              		.loc 1 2077 18 view .LVU117
 374 01e4 FFB2     		uxtb	r7, r7
 375              	.LVL24:
2078:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
 376              		.loc 1 2078 5 is_stmt 1 view .LVU118
2079:Src/mpu6050.c **** 
 377              		.loc 1 2079 5 view .LVU119
2079:Src/mpu6050.c **** 
 378              		.loc 1 2079 14 is_stmt 0 view .LVU120
 379 01e6 2860     		str	r0, [r5]
2081:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 380              		.loc 1 2081 5 is_stmt 1 view .LVU121
 381              	.LVL25:
 382              	.L8:
2081:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 383              		.loc 1 2081 18 discriminator 1 view .LVU122
2081:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
ARM GAS  /tmp/ccNfEN49.s 			page 47


 384              		.loc 1 2081 5 is_stmt 0 discriminator 1 view .LVU123
 385 01e8 5FFA88F3 		uxtb	r3, r8
 386 01ec BB42     		cmp	r3, r7
 387 01ee 7BD3     		bcc	.L9
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 388              		.loc 1 2113 5 is_stmt 1 view .LVU124
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 389              		.loc 1 2113 23 is_stmt 0 view .LVU125
 390 01f0 3468     		ldr	r4, [r6]
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 391              		.loc 1 2113 47 view .LVU126
 392 01f2 8322     		movs	r2, #131
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 393              		.loc 1 2113 23 view .LVU127
 394 01f4 E117     		asrs	r1, r4, #31
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 395              		.loc 1 2113 41 view .LVU128
 396 01f6 0904     		lsls	r1, r1, #16
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 397              		.loc 1 2113 47 view .LVU129
 398 01f8 0023     		movs	r3, #0
 399 01fa 2004     		lsls	r0, r4, #16
 400 01fc 41EA1441 		orr	r1, r1, r4, lsr #16
 401 0200 FFF7FEFF 		bl	__aeabi_ldivmod
 402              	.LVL26:
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 403              		.loc 1 2113 64 view .LVU130
 404 0204 3A46     		mov	r2, r7
 405 0206 0023     		movs	r3, #0
 406 0208 FFF7FEFF 		bl	__aeabi_ldivmod
 407              	.LVL27:
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 408              		.loc 1 2114 23 view .LVU131
 409 020c 7468     		ldr	r4, [r6, #4]
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 410              		.loc 1 2114 47 view .LVU132
 411 020e 8322     		movs	r2, #131
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 412              		.loc 1 2114 23 view .LVU133
 413 0210 E117     		asrs	r1, r4, #31
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 414              		.loc 1 2114 41 view .LVU134
 415 0212 0904     		lsls	r1, r1, #16
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 416              		.loc 1 2114 47 view .LVU135
 417 0214 0023     		movs	r3, #0
2113:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
 418              		.loc 1 2113 15 view .LVU136
 419 0216 3060     		str	r0, [r6]
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 420              		.loc 1 2114 5 is_stmt 1 view .LVU137
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 421              		.loc 1 2114 47 is_stmt 0 view .LVU138
 422 0218 41EA1441 		orr	r1, r1, r4, lsr #16
 423 021c 2004     		lsls	r0, r4, #16
 424 021e FFF7FEFF 		bl	__aeabi_ldivmod
 425              	.LVL28:
ARM GAS  /tmp/ccNfEN49.s 			page 48


2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 426              		.loc 1 2114 64 view .LVU139
 427 0222 3A46     		mov	r2, r7
 428 0224 0023     		movs	r3, #0
 429 0226 FFF7FEFF 		bl	__aeabi_ldivmod
 430              	.LVL29:
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 431              		.loc 1 2115 23 view .LVU140
 432 022a B468     		ldr	r4, [r6, #8]
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 433              		.loc 1 2115 47 view .LVU141
 434 022c 8322     		movs	r2, #131
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 435              		.loc 1 2115 23 view .LVU142
 436 022e E117     		asrs	r1, r4, #31
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 437              		.loc 1 2115 41 view .LVU143
 438 0230 0904     		lsls	r1, r1, #16
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 439              		.loc 1 2115 47 view .LVU144
 440 0232 0023     		movs	r3, #0
2114:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
 441              		.loc 1 2114 15 view .LVU145
 442 0234 7060     		str	r0, [r6, #4]
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 443              		.loc 1 2115 5 is_stmt 1 view .LVU146
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 444              		.loc 1 2115 47 is_stmt 0 view .LVU147
 445 0236 41EA1441 		orr	r1, r1, r4, lsr #16
 446 023a 2004     		lsls	r0, r4, #16
 447 023c FFF7FEFF 		bl	__aeabi_ldivmod
 448              	.LVL30:
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 449              		.loc 1 2115 64 view .LVU148
 450 0240 0023     		movs	r3, #0
 451 0242 3A46     		mov	r2, r7
 452 0244 FFF7FEFF 		bl	__aeabi_ldivmod
 453              	.LVL31:
2115:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
 454              		.loc 1 2115 15 view .LVU149
 455 0248 B060     		str	r0, [r6, #8]
2116:Src/mpu6050.c ****         packet_count);
 456              		.loc 1 2116 5 is_stmt 1 view .LVU150
2116:Src/mpu6050.c ****         packet_count);
 457              		.loc 1 2116 24 is_stmt 0 view .LVU151
 458 024a 2B68     		ldr	r3, [r5]
 459 024c D917     		asrs	r1, r3, #31
2116:Src/mpu6050.c ****         packet_count);
 460              		.loc 1 2116 43 view .LVU152
 461 024e 0904     		lsls	r1, r1, #16
2116:Src/mpu6050.c ****         packet_count);
 462              		.loc 1 2116 49 view .LVU153
 463 0250 51EA1341 		orrs	r1, r1, r3, lsr #16
2116:Src/mpu6050.c ****         packet_count);
 464              		.loc 1 2116 43 view .LVU154
 465 0254 4FEA0340 		lsl	r0, r3, #16
2116:Src/mpu6050.c ****         packet_count);
ARM GAS  /tmp/ccNfEN49.s 			page 49


 466              		.loc 1 2116 49 view .LVU155
 467 0258 04D5     		bpl	.L10
 468 025a 40F2FF73 		movw	r3, #2047
 469 025e C018     		adds	r0, r0, r3
 470 0260 41F10001 		adc	r1, r1, #0
 471              	.L10:
 472 0264 C00A     		lsrs	r0, r0, #11
2116:Src/mpu6050.c ****         packet_count);
 473              		.loc 1 2116 67 view .LVU156
 474 0266 0023     		movs	r3, #0
 475 0268 40EA4150 		orr	r0, r0, r1, lsl #21
 476 026c 3A46     		mov	r2, r7
 477 026e C912     		asrs	r1, r1, #11
 478 0270 FFF7FEFF 		bl	__aeabi_ldivmod
 479              	.LVL32:
2118:Src/mpu6050.c ****         packet_count);
 480              		.loc 1 2118 24 view .LVU157
 481 0274 6B68     		ldr	r3, [r5, #4]
2116:Src/mpu6050.c ****         packet_count);
 482              		.loc 1 2116 16 view .LVU158
 483 0276 2860     		str	r0, [r5]
2118:Src/mpu6050.c ****         packet_count);
 484              		.loc 1 2118 5 is_stmt 1 view .LVU159
2118:Src/mpu6050.c ****         packet_count);
 485              		.loc 1 2118 24 is_stmt 0 view .LVU160
 486 0278 D917     		asrs	r1, r3, #31
2118:Src/mpu6050.c ****         packet_count);
 487              		.loc 1 2118 43 view .LVU161
 488 027a 0904     		lsls	r1, r1, #16
2118:Src/mpu6050.c ****         packet_count);
 489              		.loc 1 2118 49 view .LVU162
 490 027c 51EA1341 		orrs	r1, r1, r3, lsr #16
2118:Src/mpu6050.c ****         packet_count);
 491              		.loc 1 2118 43 view .LVU163
 492 0280 4FEA0340 		lsl	r0, r3, #16
2118:Src/mpu6050.c ****         packet_count);
 493              		.loc 1 2118 49 view .LVU164
 494 0284 04D5     		bpl	.L11
 495 0286 40F2FF73 		movw	r3, #2047
 496 028a C018     		adds	r0, r0, r3
 497 028c 41F10001 		adc	r1, r1, #0
 498              	.L11:
 499 0290 C00A     		lsrs	r0, r0, #11
2118:Src/mpu6050.c ****         packet_count);
 500              		.loc 1 2118 67 view .LVU165
 501 0292 0023     		movs	r3, #0
 502 0294 40EA4150 		orr	r0, r0, r1, lsl #21
 503 0298 3A46     		mov	r2, r7
 504 029a C912     		asrs	r1, r1, #11
 505 029c FFF7FEFF 		bl	__aeabi_ldivmod
 506              	.LVL33:
2120:Src/mpu6050.c ****         packet_count);
 507              		.loc 1 2120 24 view .LVU166
 508 02a0 AB68     		ldr	r3, [r5, #8]
2118:Src/mpu6050.c ****         packet_count);
 509              		.loc 1 2118 16 view .LVU167
 510 02a2 6860     		str	r0, [r5, #4]
ARM GAS  /tmp/ccNfEN49.s 			page 50


2120:Src/mpu6050.c ****         packet_count);
 511              		.loc 1 2120 5 is_stmt 1 view .LVU168
2120:Src/mpu6050.c ****         packet_count);
 512              		.loc 1 2120 24 is_stmt 0 view .LVU169
 513 02a4 D917     		asrs	r1, r3, #31
2120:Src/mpu6050.c ****         packet_count);
 514              		.loc 1 2120 43 view .LVU170
 515 02a6 0904     		lsls	r1, r1, #16
2120:Src/mpu6050.c ****         packet_count);
 516              		.loc 1 2120 49 view .LVU171
 517 02a8 51EA1341 		orrs	r1, r1, r3, lsr #16
2120:Src/mpu6050.c ****         packet_count);
 518              		.loc 1 2120 43 view .LVU172
 519 02ac 4FEA0340 		lsl	r0, r3, #16
2120:Src/mpu6050.c ****         packet_count);
 520              		.loc 1 2120 49 view .LVU173
 521 02b0 04D5     		bpl	.L12
 522 02b2 40F2FF73 		movw	r3, #2047
 523 02b6 C018     		adds	r0, r0, r3
 524 02b8 41F10001 		adc	r1, r1, #0
 525              	.L12:
 526 02bc C00A     		lsrs	r0, r0, #11
2120:Src/mpu6050.c ****         packet_count);
 527              		.loc 1 2120 67 view .LVU174
 528 02be 40EA4150 		orr	r0, r0, r1, lsl #21
 529 02c2 3A46     		mov	r2, r7
 530 02c4 0023     		movs	r3, #0
 531 02c6 C912     		asrs	r1, r1, #11
 532 02c8 FFF7FEFF 		bl	__aeabi_ldivmod
 533              	.LVL34:
2123:Src/mpu6050.c ****         accel[2] -= 65536L;
 534              		.loc 1 2123 5 is_stmt 1 view .LVU175
2123:Src/mpu6050.c ****         accel[2] -= 65536L;
 535              		.loc 1 2123 8 is_stmt 0 view .LVU176
 536 02cc 0028     		cmp	r0, #0
2124:Src/mpu6050.c ****     else
 537              		.loc 1 2124 9 is_stmt 1 view .LVU177
2124:Src/mpu6050.c ****     else
 538              		.loc 1 2124 18 is_stmt 0 view .LVU178
 539 02ce CCBF     		ite	gt
 540 02d0 A0F58030 		subgt	r0, r0, #65536
2126:Src/mpu6050.c **** #endif
 541              		.loc 1 2126 9 is_stmt 1 view .LVU179
2126:Src/mpu6050.c **** #endif
 542              		.loc 1 2126 18 is_stmt 0 view .LVU180
 543 02d4 00F58030 		addle	r0, r0, #65536
 544 02d8 A860     		str	r0, [r5, #8]
2129:Src/mpu6050.c **** }
 545              		.loc 1 2129 12 view .LVU181
 546 02da 0020     		movs	r0, #0
 547 02dc A9E6     		b	.L1
 548              	.LVL35:
 549              	.L14:
2054:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
 550              		.loc 1 2054 17 view .LVU182
 551 02de 1823     		movs	r3, #24
 552 02e0 28E7     		b	.L6
ARM GAS  /tmp/ccNfEN49.s 			page 51


 553              	.L23:
 554 02e2 00BF     		.align	2
 555              	.L22:
 556 02e4 00000000 		.word	.LANCHOR0
 557              	.LVL36:
 558              	.L9:
 559              	.LBB7:
2082:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
 560              		.loc 1 2082 9 is_stmt 1 view .LVU183
2083:Src/mpu6050.c ****             return -1;
 561              		.loc 1 2083 9 view .LVU184
2083:Src/mpu6050.c ****             return -1;
 562              		.loc 1 2083 13 is_stmt 0 view .LVU185
 563 02e8 D4E90010 		ldrd	r1, r0, [r4]
 564 02ec 0C22     		movs	r2, #12
 565 02ee 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 566 02f0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 567 02f2 01AB     		add	r3, sp, #4
 568 02f4 FFF7FEFF 		bl	i2c_readBytes
 569              	.LVL37:
2083:Src/mpu6050.c ****             return -1;
 570              		.loc 1 2083 12 view .LVU186
 571 02f8 08F10108 		add	r8, r8, #1
 572              	.LVL38:
2083:Src/mpu6050.c ****             return -1;
 573              		.loc 1 2083 12 view .LVU187
 574 02fc 0028     		cmp	r0, #0
 575 02fe 7FF496AE 		bne	.L4
2085:Src/mpu6050.c ****         accel_cur[1] = ((short)data[2] << 8) | data[3];
 576              		.loc 1 2085 9 is_stmt 1 view .LVU188
 577              	.LVL39:
2086:Src/mpu6050.c ****         accel_cur[2] = ((short)data[4] << 8) | data[5];
 578              		.loc 1 2086 9 view .LVU189
 579 0302 BDF80630 		ldrh	r3, [sp, #6]
 580 0306 D9BA     		revsh	r1, r3
 581              	.LVL40:
2087:Src/mpu6050.c ****         accel[0] += (long)accel_cur[0];
 582              		.loc 1 2087 9 view .LVU190
 583 0308 BDF80830 		ldrh	r3, [sp, #8]
 584 030c DABA     		revsh	r2, r3
 585              	.LVL41:
2088:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 586              		.loc 1 2088 9 view .LVU191
2088:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 587              		.loc 1 2088 21 is_stmt 0 view .LVU192
 588 030e BDF80430 		ldrh	r3, [sp, #4]
 589 0312 D8BA     		revsh	r0, r3
2088:Src/mpu6050.c ****         accel[1] += (long)accel_cur[1];
 590              		.loc 1 2088 18 view .LVU193
 591 0314 2B68     		ldr	r3, [r5]
 592 0316 0344     		add	r3, r3, r0
 593 0318 2B60     		str	r3, [r5]
2089:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
 594              		.loc 1 2089 9 is_stmt 1 view .LVU194
2089:Src/mpu6050.c ****         accel[2] += (long)accel_cur[2];
 595              		.loc 1 2089 18 is_stmt 0 view .LVU195
 596 031a 6B68     		ldr	r3, [r5, #4]
ARM GAS  /tmp/ccNfEN49.s 			page 52


 597 031c 0B44     		add	r3, r3, r1
 598 031e 6B60     		str	r3, [r5, #4]
2090:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
 599              		.loc 1 2090 9 is_stmt 1 view .LVU196
2090:Src/mpu6050.c ****         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
 600              		.loc 1 2090 18 is_stmt 0 view .LVU197
 601 0320 AB68     		ldr	r3, [r5, #8]
 602 0322 1344     		add	r3, r3, r2
 603 0324 AB60     		str	r3, [r5, #8]
2091:Src/mpu6050.c ****         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
 604              		.loc 1 2091 9 is_stmt 1 view .LVU198
 605              	.LVL42:
2092:Src/mpu6050.c ****         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
 606              		.loc 1 2092 9 view .LVU199
 607 0326 BDF80C30 		ldrh	r3, [sp, #12]
 608 032a D9BA     		revsh	r1, r3
 609              	.LVL43:
2093:Src/mpu6050.c ****         gyro[0] += (long)gyro_cur[0];
 610              		.loc 1 2093 9 view .LVU200
 611 032c BDF80E30 		ldrh	r3, [sp, #14]
 612 0330 DABA     		revsh	r2, r3
 613              	.LVL44:
2094:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 614              		.loc 1 2094 9 view .LVU201
2094:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 615              		.loc 1 2094 20 is_stmt 0 view .LVU202
 616 0332 BDF80A30 		ldrh	r3, [sp, #10]
 617 0336 D8BA     		revsh	r0, r3
2094:Src/mpu6050.c ****         gyro[1] += (long)gyro_cur[1];
 618              		.loc 1 2094 17 view .LVU203
 619 0338 3368     		ldr	r3, [r6]
 620 033a 0344     		add	r3, r3, r0
 621 033c 3360     		str	r3, [r6]
2095:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
 622              		.loc 1 2095 9 is_stmt 1 view .LVU204
2095:Src/mpu6050.c ****         gyro[2] += (long)gyro_cur[2];
 623              		.loc 1 2095 17 is_stmt 0 view .LVU205
 624 033e 7368     		ldr	r3, [r6, #4]
 625 0340 0B44     		add	r3, r3, r1
 626 0342 7360     		str	r3, [r6, #4]
2096:Src/mpu6050.c ****     }
 627              		.loc 1 2096 9 is_stmt 1 view .LVU206
2096:Src/mpu6050.c ****     }
 628              		.loc 1 2096 17 is_stmt 0 view .LVU207
 629 0344 B368     		ldr	r3, [r6, #8]
 630 0346 1344     		add	r3, r3, r2
 631 0348 B360     		str	r3, [r6, #8]
 632              	.LBE7:
2081:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 633              		.loc 1 2081 37 is_stmt 1 view .LVU208
 634              	.LVL45:
2081:Src/mpu6050.c ****         short accel_cur[3], gyro_cur[3];
 635              		.loc 1 2081 37 is_stmt 0 view .LVU209
 636 034a 4DE7     		b	.L8
 637              		.cfi_endproc
 638              	.LFE99:
 640              		.section	.text.set_int_enable.isra.0,"ax",%progbits
ARM GAS  /tmp/ccNfEN49.s 			page 53


 641              		.align	1
 642              		.syntax unified
 643              		.thumb
 644              		.thumb_func
 645              		.fpu softvfp
 647              	set_int_enable.isra.0:
 648              	.LVL46:
 649              	.LFB124:
 579:Src/mpu6050.c **** {
 650              		.loc 1 579 12 is_stmt 1 view -0
 651              		.cfi_startproc
 652              		@ args = 0, pretend = 0, frame = 8
 653              		@ frame_needed = 0, uses_anonymous_args = 0
 581:Src/mpu6050.c **** 
 654              		.loc 1 581 5 view .LVU211
 583:Src/mpu6050.c ****         if (enable)
 655              		.loc 1 583 5 view .LVU212
 579:Src/mpu6050.c **** {
 656              		.loc 1 579 12 is_stmt 0 view .LVU213
 657 0000 13B5     		push	{r0, r1, r4, lr}
 658              	.LCFI4:
 659              		.cfi_def_cfa_offset 16
 660              		.cfi_offset 4, -8
 661              		.cfi_offset 14, -4
 583:Src/mpu6050.c ****         if (enable)
 662              		.loc 1 583 20 view .LVU214
 663 0002 114C     		ldr	r4, .L37
 583:Src/mpu6050.c ****         if (enable)
 664              		.loc 1 583 8 view .LVU215
 665 0004 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 666 0008 2BB1     		cbz	r3, .L25
 584:Src/mpu6050.c ****             tmp = BIT_DMP_INT_EN;
 667              		.loc 1 584 9 is_stmt 1 view .LVU216
 585:Src/mpu6050.c ****         else
 668              		.loc 1 585 17 is_stmt 0 view .LVU217
 669 000a 0028     		cmp	r0, #0
 670 000c 18BF     		it	ne
 671 000e 0220     		movne	r0, #2
 672              	.LVL47:
 673              	.L30:
 596:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 674              		.loc 1 596 9 is_stmt 1 view .LVU218
 599:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 675              		.loc 1 599 13 view .LVU219
 599:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
 676              		.loc 1 599 17 is_stmt 0 view .LVU220
 677 0010 8DF80700 		strb	r0, [sp, #7]
 678 0014 08E0     		b	.L31
 679              	.LVL48:
 680              	.L25:
 592:Src/mpu6050.c ****             return -1;
 681              		.loc 1 592 9 is_stmt 1 view .LVU221
 592:Src/mpu6050.c ****             return -1;
 682              		.loc 1 592 12 is_stmt 0 view .LVU222
 683 0016 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 684 0018 9BB1     		cbz	r3, .L24
 594:Src/mpu6050.c ****             return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 54


 685              		.loc 1 594 9 is_stmt 1 view .LVU223
 594:Src/mpu6050.c ****             return 0;
 686              		.loc 1 594 12 is_stmt 0 view .LVU224
 687 001a 0028     		cmp	r0, #0
 688 001c F8D0     		beq	.L30
 594:Src/mpu6050.c ****             return 0;
 689              		.loc 1 594 20 view .LVU225
 690 001e 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
 691 0020 7BB9     		cbnz	r3, .L24
 596:Src/mpu6050.c ****             tmp = BIT_DATA_RDY_EN;
 692              		.loc 1 596 9 is_stmt 1 view .LVU226
 597:Src/mpu6050.c ****         else
 693              		.loc 1 597 13 view .LVU227
 597:Src/mpu6050.c ****         else
 694              		.loc 1 597 17 is_stmt 0 view .LVU228
 695 0022 0123     		movs	r3, #1
 696 0024 8DF80730 		strb	r3, [sp, #7]
 697              	.LVL49:
 698              	.L31:
 600:Src/mpu6050.c ****             return -1;
 699              		.loc 1 600 9 is_stmt 1 view .LVU229
 600:Src/mpu6050.c ****             return -1;
 700              		.loc 1 600 13 is_stmt 0 view .LVU230
 701 0028 D4E90010 		ldrd	r1, r0, [r4]
 702 002c 0122     		movs	r2, #1
 703 002e 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 704 0030 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 705 0032 0DF10703 		add	r3, sp, #7
 706 0036 FFF7FEFF 		bl	i2c_writeBytes
 707              	.LVL50:
 600:Src/mpu6050.c ****             return -1;
 708              		.loc 1 600 12 view .LVU231
 709 003a 10B9     		cbnz	r0, .L24
 602:Src/mpu6050.c ****     }
 710              		.loc 1 602 9 is_stmt 1 view .LVU232
 602:Src/mpu6050.c ****     }
 711              		.loc 1 602 32 is_stmt 0 view .LVU233
 712 003c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 713 0040 6374     		strb	r3, [r4, #17]
 714              	.L24:
 605:Src/mpu6050.c **** 
 715              		.loc 1 605 1 view .LVU234
 716 0042 02B0     		add	sp, sp, #8
 717              	.LCFI5:
 718              		.cfi_def_cfa_offset 8
 719              		@ sp needed
 720 0044 10BD     		pop	{r4, pc}
 721              	.L38:
 722 0046 00BF     		.align	2
 723              	.L37:
 724 0048 00000000 		.word	.LANCHOR0
 725              		.cfi_endproc
 726              	.LFE124:
 728              		.section	.text.mpu_reg_dump,"ax",%progbits
 729              		.align	1
 730              		.global	mpu_reg_dump
 731              		.syntax unified
ARM GAS  /tmp/ccNfEN49.s 			page 55


 732              		.thumb
 733              		.thumb_func
 734              		.fpu softvfp
 736              	mpu_reg_dump:
 737              	.LFB60:
 612:Src/mpu6050.c ****     unsigned char ii;
 738              		.loc 1 612 1 is_stmt 1 view -0
 739              		.cfi_startproc
 740              		@ args = 0, pretend = 0, frame = 8
 741              		@ frame_needed = 0, uses_anonymous_args = 0
 613:Src/mpu6050.c ****     unsigned char data;
 742              		.loc 1 613 5 view .LVU236
 614:Src/mpu6050.c **** 
 743              		.loc 1 614 5 view .LVU237
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 744              		.loc 1 616 5 view .LVU238
 745              	.LVL51:
 612:Src/mpu6050.c ****     unsigned char ii;
 746              		.loc 1 612 1 is_stmt 0 view .LVU239
 747 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 748              	.LCFI6:
 749              		.cfi_def_cfa_offset 24
 750              		.cfi_offset 4, -12
 751              		.cfi_offset 5, -8
 752              		.cfi_offset 14, -4
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 753              		.loc 1 616 5 view .LVU240
 754 0002 0024     		movs	r4, #0
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 755              		.loc 1 616 25 view .LVU241
 756 0004 0E4D     		ldr	r5, .L46
 757              	.LVL52:
 758              	.L40:
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 759              		.loc 1 616 25 discriminator 1 view .LVU242
 760 0006 6868     		ldr	r0, [r5, #4]
 761 0008 E1B2     		uxtb	r1, r4
 762              	.LVL53:
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 763              		.loc 1 616 18 is_stmt 1 discriminator 1 view .LVU243
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 764              		.loc 1 616 5 is_stmt 0 discriminator 1 view .LVU244
 765 000a 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 766 000c 8B42     		cmp	r3, r1
 767 000e 02D8     		bhi	.L44
 625:Src/mpu6050.c **** }
 768              		.loc 1 625 12 view .LVU245
 769 0010 0020     		movs	r0, #0
 770              	.LVL54:
 771              	.L39:
 626:Src/mpu6050.c **** 
 772              		.loc 1 626 1 view .LVU246
 773 0012 03B0     		add	sp, sp, #12
 774              	.LCFI7:
 775              		.cfi_remember_state
 776              		.cfi_def_cfa_offset 12
 777              		@ sp needed
ARM GAS  /tmp/ccNfEN49.s 			page 56


 778 0014 30BD     		pop	{r4, r5, pc}
 779              	.LVL55:
 780              	.L44:
 781              	.LCFI8:
 782              		.cfi_restore_state
 617:Src/mpu6050.c ****             continue;
 783              		.loc 1 617 9 is_stmt 1 view .LVU247
 617:Src/mpu6050.c ****             continue;
 784              		.loc 1 617 21 is_stmt 0 view .LVU248
 785 0016 2B68     		ldr	r3, [r5]
 617:Src/mpu6050.c ****             continue;
 786              		.loc 1 617 12 view .LVU249
 787 0018 5A7B     		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 788 001a 8A42     		cmp	r2, r1
 789 001c 01D1     		bne	.L41
 790              	.LVL56:
 791              	.L42:
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 792              		.loc 1 616 39 is_stmt 1 view .LVU250
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 793              		.loc 1 616 39 is_stmt 0 view .LVU251
 794 001e 0134     		adds	r4, r4, #1
 795              	.LVL57:
 616:Src/mpu6050.c ****         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
 796              		.loc 1 616 39 view .LVU252
 797 0020 F1E7     		b	.L40
 798              	.LVL58:
 799              	.L41:
 617:Src/mpu6050.c ****             continue;
 800              		.loc 1 617 36 discriminator 1 view .LVU253
 801 0022 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 802 0024 8B42     		cmp	r3, r1
 803 0026 FAD0     		beq	.L42
 619:Src/mpu6050.c ****             return -1;
 804              		.loc 1 619 9 is_stmt 1 view .LVU254
 619:Src/mpu6050.c ****             return -1;
 805              		.loc 1 619 13 is_stmt 0 view .LVU255
 806 0028 0122     		movs	r2, #1
 807 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 808 002c 0DF10703 		add	r3, sp, #7
 809 0030 FFF7FEFF 		bl	i2c_readBytes
 810              	.LVL59:
 619:Src/mpu6050.c ****             return -1;
 811              		.loc 1 619 12 view .LVU256
 812 0034 0028     		cmp	r0, #0
 813 0036 F2D0     		beq	.L42
 620:Src/mpu6050.c ****             #ifdef SERIAL_DEBUG
 814              		.loc 1 620 20 view .LVU257
 815 0038 4FF0FF30 		mov	r0, #-1
 816 003c E9E7     		b	.L39
 817              	.L47:
 818 003e 00BF     		.align	2
 819              	.L46:
 820 0040 00000000 		.word	.LANCHOR0
 821              		.cfi_endproc
 822              	.LFE60:
 824              		.section	.text.mpu_read_reg,"ax",%progbits
ARM GAS  /tmp/ccNfEN49.s 			page 57


 825              		.align	1
 826              		.global	mpu_read_reg
 827              		.syntax unified
 828              		.thumb
 829              		.thumb_func
 830              		.fpu softvfp
 832              	mpu_read_reg:
 833              	.LVL60:
 834              	.LFB61:
 636:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 835              		.loc 1 636 1 is_stmt 1 view -0
 836              		.cfi_startproc
 837              		@ args = 0, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 637:Src/mpu6050.c ****         return -1;
 839              		.loc 1 637 5 view .LVU259
 636:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 840              		.loc 1 636 1 is_stmt 0 view .LVU260
 841 0000 10B5     		push	{r4, lr}
 842              	.LCFI9:
 843              		.cfi_def_cfa_offset 8
 844              		.cfi_offset 4, -8
 845              		.cfi_offset 14, -4
 637:Src/mpu6050.c ****         return -1;
 846              		.loc 1 637 18 view .LVU261
 847 0002 0B4A     		ldr	r2, .L53
 636:Src/mpu6050.c ****     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
 848              		.loc 1 636 1 view .LVU262
 849 0004 0B46     		mov	r3, r1
 637:Src/mpu6050.c ****         return -1;
 850              		.loc 1 637 18 view .LVU263
 851 0006 1168     		ldr	r1, [r2]
 852              	.LVL61:
 637:Src/mpu6050.c ****         return -1;
 853              		.loc 1 637 8 view .LVU264
 854 0008 4C7B     		ldrb	r4, [r1, #13]	@ zero_extendqisi2
 855 000a 8442     		cmp	r4, r0
 856 000c 0CD0     		beq	.L52
 637:Src/mpu6050.c ****         return -1;
 857              		.loc 1 637 33 discriminator 1 view .LVU265
 858 000e 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 859 0010 8142     		cmp	r1, r0
 860 0012 09D0     		beq	.L52
 639:Src/mpu6050.c ****         return -1;
 861              		.loc 1 639 5 is_stmt 1 view .LVU266
 639:Src/mpu6050.c ****         return -1;
 862              		.loc 1 639 18 is_stmt 0 view .LVU267
 863 0014 5468     		ldr	r4, [r2, #4]
 639:Src/mpu6050.c ****         return -1;
 864              		.loc 1 639 8 view .LVU268
 865 0016 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 866 0018 8242     		cmp	r2, r0
 867 001a 05D9     		bls	.L52
 641:Src/mpu6050.c **** }
 868              		.loc 1 641 5 is_stmt 1 view .LVU269
 641:Src/mpu6050.c **** }
 869              		.loc 1 641 12 is_stmt 0 view .LVU270
ARM GAS  /tmp/ccNfEN49.s 			page 58


 870 001c 0146     		mov	r1, r0
 871 001e 0122     		movs	r2, #1
 872 0020 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 873              	.LVL62:
 641:Src/mpu6050.c **** }
 874              		.loc 1 641 12 view .LVU271
 875 0022 FFF7FEFF 		bl	i2c_readBytes
 876              	.LVL63:
 877              	.L48:
 642:Src/mpu6050.c **** 
 878              		.loc 1 642 1 view .LVU272
 879 0026 10BD     		pop	{r4, pc}
 880              	.LVL64:
 881              	.L52:
 638:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 882              		.loc 1 638 16 view .LVU273
 883 0028 4FF0FF30 		mov	r0, #-1
 884              	.LVL65:
 638:Src/mpu6050.c ****     if (reg >= st.hw->num_reg)
 885              		.loc 1 638 16 view .LVU274
 886 002c FBE7     		b	.L48
 887              	.L54:
 888 002e 00BF     		.align	2
 889              	.L53:
 890 0030 00000000 		.word	.LANCHOR0
 891              		.cfi_endproc
 892              	.LFE61:
 894              		.section	.text.mpu_get_gyro_reg,"ax",%progbits
 895              		.align	1
 896              		.global	mpu_get_gyro_reg
 897              		.syntax unified
 898              		.thumb
 899              		.thumb_func
 900              		.fpu softvfp
 902              	mpu_get_gyro_reg:
 903              	.LVL66:
 904              	.LFB64:
 831:Src/mpu6050.c ****     unsigned char tmp[6];
 905              		.loc 1 831 1 is_stmt 1 view -0
 906              		.cfi_startproc
 907              		@ args = 0, pretend = 0, frame = 8
 908              		@ frame_needed = 0, uses_anonymous_args = 0
 832:Src/mpu6050.c **** 
 909              		.loc 1 832 5 view .LVU276
 834:Src/mpu6050.c ****         return -1;
 910              		.loc 1 834 5 view .LVU277
 831:Src/mpu6050.c ****     unsigned char tmp[6];
 911              		.loc 1 831 1 is_stmt 0 view .LVU278
 912 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 913              	.LCFI10:
 914              		.cfi_def_cfa_offset 24
 915              		.cfi_offset 4, -16
 916              		.cfi_offset 5, -12
 917              		.cfi_offset 6, -8
 918              		.cfi_offset 14, -4
 834:Src/mpu6050.c ****         return -1;
 919              		.loc 1 834 22 view .LVU279
ARM GAS  /tmp/ccNfEN49.s 			page 59


 920 0002 144B     		ldr	r3, .L60
 831:Src/mpu6050.c ****     unsigned char tmp[6];
 921              		.loc 1 831 1 view .LVU280
 922 0004 0546     		mov	r5, r0
 834:Src/mpu6050.c ****         return -1;
 923              		.loc 1 834 8 view .LVU281
 924 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 831:Src/mpu6050.c ****     unsigned char tmp[6];
 925              		.loc 1 831 1 view .LVU282
 926 0008 0C46     		mov	r4, r1
 834:Src/mpu6050.c ****         return -1;
 927              		.loc 1 834 8 view .LVU283
 928 000a 12F0700F 		tst	r2, #112
 929 000e 03D1     		bne	.L56
 930              	.LVL67:
 931              	.L58:
 835:Src/mpu6050.c **** 
 932              		.loc 1 835 16 view .LVU284
 933 0010 4FF0FF30 		mov	r0, #-1
 934              	.L55:
 845:Src/mpu6050.c **** 
 935              		.loc 1 845 1 view .LVU285
 936 0014 02B0     		add	sp, sp, #8
 937              	.LCFI11:
 938              		.cfi_remember_state
 939              		.cfi_def_cfa_offset 16
 940              		@ sp needed
 941 0016 70BD     		pop	{r4, r5, r6, pc}
 942              	.LVL68:
 943              	.L56:
 944              	.LCFI12:
 945              		.cfi_restore_state
 837:Src/mpu6050.c ****         return -1;
 946              		.loc 1 837 5 is_stmt 1 view .LVU286
 837:Src/mpu6050.c ****         return -1;
 947              		.loc 1 837 9 is_stmt 0 view .LVU287
 948 0018 D3E90010 		ldrd	r1, r0, [r3]
 949              	.LVL69:
 837:Src/mpu6050.c ****         return -1;
 950              		.loc 1 837 9 view .LVU288
 951 001c 0622     		movs	r2, #6
 952 001e 6B46     		mov	r3, sp
 953 0020 897B     		ldrb	r1, [r1, #14]	@ zero_extendqisi2
 954 0022 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 955 0024 FFF7FEFF 		bl	i2c_readBytes
 956              	.LVL70:
 837:Src/mpu6050.c ****         return -1;
 957              		.loc 1 837 8 view .LVU289
 958 0028 0646     		mov	r6, r0
 959 002a 0028     		cmp	r0, #0
 960 002c F0D1     		bne	.L58
 839:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 961              		.loc 1 839 5 is_stmt 1 view .LVU290
 839:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 962              		.loc 1 839 13 is_stmt 0 view .LVU291
 963 002e BDF80030 		ldrh	r3, [sp]
 843:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 60


 964              		.loc 1 843 9 view .LVU292
 965 0032 2046     		mov	r0, r4
 839:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 966              		.loc 1 839 13 view .LVU293
 967 0034 5BBA     		rev16	r3, r3
 968 0036 2B80     		strh	r3, [r5]	@ movhi
 840:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 969              		.loc 1 840 5 is_stmt 1 view .LVU294
 840:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 970              		.loc 1 840 13 is_stmt 0 view .LVU295
 971 0038 BDF80230 		ldrh	r3, [sp, #2]
 972 003c 5BBA     		rev16	r3, r3
 973 003e 6B80     		strh	r3, [r5, #2]	@ movhi
 841:Src/mpu6050.c ****     if (timestamp)
 974              		.loc 1 841 5 is_stmt 1 view .LVU296
 841:Src/mpu6050.c ****     if (timestamp)
 975              		.loc 1 841 13 is_stmt 0 view .LVU297
 976 0040 BDF80430 		ldrh	r3, [sp, #4]
 977 0044 5BBA     		rev16	r3, r3
 978 0046 AB80     		strh	r3, [r5, #4]	@ movhi
 842:Src/mpu6050.c ****         get_ms(timestamp);
 979              		.loc 1 842 5 is_stmt 1 view .LVU298
 842:Src/mpu6050.c ****         get_ms(timestamp);
 980              		.loc 1 842 8 is_stmt 0 view .LVU299
 981 0048 002C     		cmp	r4, #0
 982 004a E3D0     		beq	.L55
 983              	.LVL71:
 843:Src/mpu6050.c ****     return 0;
 984              		.loc 1 843 9 is_stmt 1 view .LVU300
 985 004c FFF7FEFF 		bl	get_tick_count_ms
 986              	.LVL72:
 844:Src/mpu6050.c **** }
 987              		.loc 1 844 12 is_stmt 0 view .LVU301
 988 0050 3046     		mov	r0, r6
 989 0052 DFE7     		b	.L55
 990              	.L61:
 991              		.align	2
 992              	.L60:
 993 0054 00000000 		.word	.LANCHOR0
 994              		.cfi_endproc
 995              	.LFE64:
 997              		.section	.text.mpu_get_accel_reg,"ax",%progbits
 998              		.align	1
 999              		.global	mpu_get_accel_reg
 1000              		.syntax unified
 1001              		.thumb
 1002              		.thumb_func
 1003              		.fpu softvfp
 1005              	mpu_get_accel_reg:
 1006              	.LVL73:
 1007              	.LFB65:
 854:Src/mpu6050.c ****     unsigned char tmp[6];
 1008              		.loc 1 854 1 is_stmt 1 view -0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 8
 1011              		@ frame_needed = 0, uses_anonymous_args = 0
 855:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 61


 1012              		.loc 1 855 5 view .LVU303
 857:Src/mpu6050.c ****         return -1;
 1013              		.loc 1 857 5 view .LVU304
 854:Src/mpu6050.c ****     unsigned char tmp[6];
 1014              		.loc 1 854 1 is_stmt 0 view .LVU305
 1015 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1016              	.LCFI13:
 1017              		.cfi_def_cfa_offset 24
 1018              		.cfi_offset 4, -16
 1019              		.cfi_offset 5, -12
 1020              		.cfi_offset 6, -8
 1021              		.cfi_offset 14, -4
 857:Src/mpu6050.c ****         return -1;
 1022              		.loc 1 857 22 view .LVU306
 1023 0002 144B     		ldr	r3, .L67
 854:Src/mpu6050.c ****     unsigned char tmp[6];
 1024              		.loc 1 854 1 view .LVU307
 1025 0004 0546     		mov	r5, r0
 857:Src/mpu6050.c ****         return -1;
 1026              		.loc 1 857 8 view .LVU308
 1027 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 854:Src/mpu6050.c ****     unsigned char tmp[6];
 1028              		.loc 1 854 1 view .LVU309
 1029 0008 0C46     		mov	r4, r1
 857:Src/mpu6050.c ****         return -1;
 1030              		.loc 1 857 8 view .LVU310
 1031 000a 1207     		lsls	r2, r2, #28
 1032 000c 03D4     		bmi	.L63
 1033              	.LVL74:
 1034              	.L65:
 858:Src/mpu6050.c **** 
 1035              		.loc 1 858 16 view .LVU311
 1036 000e 4FF0FF30 		mov	r0, #-1
 1037              	.L62:
 868:Src/mpu6050.c **** 
 1038              		.loc 1 868 1 view .LVU312
 1039 0012 02B0     		add	sp, sp, #8
 1040              	.LCFI14:
 1041              		.cfi_remember_state
 1042              		.cfi_def_cfa_offset 16
 1043              		@ sp needed
 1044 0014 70BD     		pop	{r4, r5, r6, pc}
 1045              	.LVL75:
 1046              	.L63:
 1047              	.LCFI15:
 1048              		.cfi_restore_state
 860:Src/mpu6050.c ****         return -1;
 1049              		.loc 1 860 5 is_stmt 1 view .LVU313
 860:Src/mpu6050.c ****         return -1;
 1050              		.loc 1 860 9 is_stmt 0 view .LVU314
 1051 0016 D3E90010 		ldrd	r1, r0, [r3]
 1052              	.LVL76:
 860:Src/mpu6050.c ****         return -1;
 1053              		.loc 1 860 9 view .LVU315
 1054 001a 0622     		movs	r2, #6
 1055 001c 6B46     		mov	r3, sp
 1056 001e C97B     		ldrb	r1, [r1, #15]	@ zero_extendqisi2
ARM GAS  /tmp/ccNfEN49.s 			page 62


 1057 0020 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1058 0022 FFF7FEFF 		bl	i2c_readBytes
 1059              	.LVL77:
 860:Src/mpu6050.c ****         return -1;
 1060              		.loc 1 860 8 view .LVU316
 1061 0026 0646     		mov	r6, r0
 1062 0028 0028     		cmp	r0, #0
 1063 002a F0D1     		bne	.L65
 862:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1064              		.loc 1 862 5 is_stmt 1 view .LVU317
 862:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1065              		.loc 1 862 13 is_stmt 0 view .LVU318
 1066 002c BDF80030 		ldrh	r3, [sp]
 866:Src/mpu6050.c ****     return 0;
 1067              		.loc 1 866 9 view .LVU319
 1068 0030 2046     		mov	r0, r4
 862:Src/mpu6050.c ****     data[1] = (tmp[2] << 8) | tmp[3];
 1069              		.loc 1 862 13 view .LVU320
 1070 0032 5BBA     		rev16	r3, r3
 1071 0034 2B80     		strh	r3, [r5]	@ movhi
 863:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1072              		.loc 1 863 5 is_stmt 1 view .LVU321
 863:Src/mpu6050.c ****     data[2] = (tmp[4] << 8) | tmp[5];
 1073              		.loc 1 863 13 is_stmt 0 view .LVU322
 1074 0036 BDF80230 		ldrh	r3, [sp, #2]
 1075 003a 5BBA     		rev16	r3, r3
 1076 003c 6B80     		strh	r3, [r5, #2]	@ movhi
 864:Src/mpu6050.c ****     if (timestamp)
 1077              		.loc 1 864 5 is_stmt 1 view .LVU323
 864:Src/mpu6050.c ****     if (timestamp)
 1078              		.loc 1 864 13 is_stmt 0 view .LVU324
 1079 003e BDF80430 		ldrh	r3, [sp, #4]
 1080 0042 5BBA     		rev16	r3, r3
 1081 0044 AB80     		strh	r3, [r5, #4]	@ movhi
 865:Src/mpu6050.c ****         get_ms(timestamp);
 1082              		.loc 1 865 5 is_stmt 1 view .LVU325
 865:Src/mpu6050.c ****         get_ms(timestamp);
 1083              		.loc 1 865 8 is_stmt 0 view .LVU326
 1084 0046 002C     		cmp	r4, #0
 1085 0048 E3D0     		beq	.L62
 1086              	.LVL78:
 866:Src/mpu6050.c ****     return 0;
 1087              		.loc 1 866 9 is_stmt 1 view .LVU327
 1088 004a FFF7FEFF 		bl	get_tick_count_ms
 1089              	.LVL79:
 867:Src/mpu6050.c **** }
 1090              		.loc 1 867 12 is_stmt 0 view .LVU328
 1091 004e 3046     		mov	r0, r6
 1092 0050 DFE7     		b	.L62
 1093              	.L68:
 1094 0052 00BF     		.align	2
 1095              	.L67:
 1096 0054 00000000 		.word	.LANCHOR0
 1097              		.cfi_endproc
 1098              	.LFE65:
 1100              		.global	__aeabi_i2f
 1101              		.global	__aeabi_fsub
ARM GAS  /tmp/ccNfEN49.s 			page 63


 1102              		.global	__aeabi_fdiv
 1103              		.global	__aeabi_fadd
 1104              		.global	__aeabi_fmul
 1105              		.global	__aeabi_f2iz
 1106              		.section	.text.mpu_get_temperature,"ax",%progbits
 1107              		.align	1
 1108              		.global	mpu_get_temperature
 1109              		.syntax unified
 1110              		.thumb
 1111              		.thumb_func
 1112              		.fpu softvfp
 1114              	mpu_get_temperature:
 1115              	.LVL80:
 1116              	.LFB66:
 877:Src/mpu6050.c ****     unsigned char tmp[2];
 1117              		.loc 1 877 1 is_stmt 1 view -0
 1118              		.cfi_startproc
 1119              		@ args = 0, pretend = 0, frame = 8
 1120              		@ frame_needed = 0, uses_anonymous_args = 0
 878:Src/mpu6050.c ****     short raw;
 1121              		.loc 1 878 5 view .LVU330
 879:Src/mpu6050.c **** 
 1122              		.loc 1 879 5 view .LVU331
 881:Src/mpu6050.c ****         return -1;
 1123              		.loc 1 881 5 view .LVU332
 877:Src/mpu6050.c ****     unsigned char tmp[2];
 1124              		.loc 1 877 1 is_stmt 0 view .LVU333
 1125 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1126              	.LCFI16:
 1127              		.cfi_def_cfa_offset 32
 1128              		.cfi_offset 4, -20
 1129              		.cfi_offset 5, -16
 1130              		.cfi_offset 6, -12
 1131              		.cfi_offset 7, -8
 1132              		.cfi_offset 14, -4
 881:Src/mpu6050.c ****         return -1;
 1133              		.loc 1 881 22 view .LVU334
 1134 0002 1D4C     		ldr	r4, .L77
 877:Src/mpu6050.c ****     unsigned char tmp[2];
 1135              		.loc 1 877 1 view .LVU335
 1136 0004 0646     		mov	r6, r0
 881:Src/mpu6050.c ****         return -1;
 1137              		.loc 1 881 8 view .LVU336
 1138 0006 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 877:Src/mpu6050.c ****     unsigned char tmp[2];
 1139              		.loc 1 877 1 view .LVU337
 1140 0008 0D46     		mov	r5, r1
 881:Src/mpu6050.c ****         return -1;
 1141              		.loc 1 881 8 view .LVU338
 1142 000a 1BB9     		cbnz	r3, .L70
 1143              	.LVL81:
 1144              	.L72:
 882:Src/mpu6050.c **** 
 1145              		.loc 1 882 16 view .LVU339
 1146 000c 4FF0FF30 		mov	r0, #-1
 1147              	.LVL82:
 1148              	.L69:
ARM GAS  /tmp/ccNfEN49.s 			page 64


 892:Src/mpu6050.c **** 
 1149              		.loc 1 892 1 view .LVU340
 1150 0010 03B0     		add	sp, sp, #12
 1151              	.LCFI17:
 1152              		.cfi_remember_state
 1153              		.cfi_def_cfa_offset 20
 1154              		@ sp needed
 1155 0012 F0BD     		pop	{r4, r5, r6, r7, pc}
 1156              	.LVL83:
 1157              	.L70:
 1158              	.LCFI18:
 1159              		.cfi_restore_state
 884:Src/mpu6050.c ****         return -1;
 1160              		.loc 1 884 5 is_stmt 1 view .LVU341
 884:Src/mpu6050.c ****         return -1;
 1161              		.loc 1 884 9 is_stmt 0 view .LVU342
 1162 0014 D4E90010 		ldrd	r1, r0, [r4]
 1163              	.LVL84:
 884:Src/mpu6050.c ****         return -1;
 1164              		.loc 1 884 9 view .LVU343
 1165 0018 0222     		movs	r2, #2
 1166 001a 097C     		ldrb	r1, [r1, #16]	@ zero_extendqisi2
 1167 001c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1168 001e 01AB     		add	r3, sp, #4
 1169 0020 FFF7FEFF 		bl	i2c_readBytes
 1170              	.LVL85:
 884:Src/mpu6050.c ****         return -1;
 1171              		.loc 1 884 8 view .LVU344
 1172 0024 0028     		cmp	r0, #0
 1173 0026 F1D1     		bne	.L72
 886:Src/mpu6050.c ****     if (timestamp)
 1174              		.loc 1 886 5 is_stmt 1 view .LVU345
 1175 0028 BDF80470 		ldrh	r7, [sp, #4]
 1176 002c FFBA     		revsh	r7, r7
 1177              	.LVL86:
 887:Src/mpu6050.c ****         get_ms(timestamp);
 1178              		.loc 1 887 5 view .LVU346
 887:Src/mpu6050.c ****         get_ms(timestamp);
 1179              		.loc 1 887 8 is_stmt 0 view .LVU347
 1180 002e 15B1     		cbz	r5, .L73
 888:Src/mpu6050.c **** 
 1181              		.loc 1 888 9 is_stmt 1 view .LVU348
 1182 0030 2846     		mov	r0, r5
 1183 0032 FFF7FEFF 		bl	get_tick_count_ms
 1184              	.LVL87:
 1185              	.L73:
 890:Src/mpu6050.c ****     return 0;
 1186              		.loc 1 890 5 view .LVU349
 890:Src/mpu6050.c ****     return 0;
 1187              		.loc 1 890 34 is_stmt 0 view .LVU350
 1188 0036 3846     		mov	r0, r7
 1189 0038 FFF7FEFF 		bl	__aeabi_i2f
 1190              	.LVL88:
 890:Src/mpu6050.c ****     return 0;
 1191              		.loc 1 890 45 view .LVU351
 1192 003c 6568     		ldr	r5, [r4, #4]
 1193              	.LVL89:
ARM GAS  /tmp/ccNfEN49.s 			page 65


 890:Src/mpu6050.c ****     return 0;
 1194              		.loc 1 890 34 view .LVU352
 1195 003e 0446     		mov	r4, r0
 890:Src/mpu6050.c ****     return 0;
 1196              		.loc 1 890 36 view .LVU353
 1197 0040 B5F90800 		ldrsh	r0, [r5, #8]
 1198 0044 FFF7FEFF 		bl	__aeabi_i2f
 1199              	.LVL90:
 1200 0048 0146     		mov	r1, r0
 890:Src/mpu6050.c ****     return 0;
 1201              		.loc 1 890 34 view .LVU354
 1202 004a 2046     		mov	r0, r4
 1203 004c FFF7FEFF 		bl	__aeabi_fsub
 1204              	.LVL91:
 1205 0050 0446     		mov	r4, r0
 890:Src/mpu6050.c ****     return 0;
 1206              		.loc 1 890 63 view .LVU355
 1207 0052 E888     		ldrh	r0, [r5, #6]
 1208 0054 FFF7FEFF 		bl	__aeabi_i2f
 1209              	.LVL92:
 1210 0058 0146     		mov	r1, r0
 1211 005a 2046     		mov	r0, r4
 1212 005c FFF7FEFF 		bl	__aeabi_fdiv
 1213              	.LVL93:
 890:Src/mpu6050.c ****     return 0;
 1214              		.loc 1 890 26 view .LVU356
 1215 0060 0649     		ldr	r1, .L77+4
 1216 0062 FFF7FEFF 		bl	__aeabi_fadd
 1217              	.LVL94:
 890:Src/mpu6050.c ****     return 0;
 1218              		.loc 1 890 84 view .LVU357
 1219 0066 4FF08F41 		mov	r1, #1199570944
 1220 006a FFF7FEFF 		bl	__aeabi_fmul
 1221              	.LVL95:
 890:Src/mpu6050.c ****     return 0;
 1222              		.loc 1 890 15 view .LVU358
 1223 006e FFF7FEFF 		bl	__aeabi_f2iz
 1224              	.LVL96:
 1225 0072 3060     		str	r0, [r6]
 891:Src/mpu6050.c **** }
 1226              		.loc 1 891 5 is_stmt 1 view .LVU359
 891:Src/mpu6050.c **** }
 1227              		.loc 1 891 12 is_stmt 0 view .LVU360
 1228 0074 0020     		movs	r0, #0
 1229 0076 CBE7     		b	.L69
 1230              	.L78:
 1231              		.align	2
 1232              	.L77:
 1233 0078 00000000 		.word	.LANCHOR0
 1234 007c 00000C42 		.word	1108082688
 1235              		.cfi_endproc
 1236              	.LFE66:
 1238              		.section	.text.mpu_read_6500_accel_bias,"ax",%progbits
 1239              		.align	1
 1240              		.global	mpu_read_6500_accel_bias
 1241              		.syntax unified
 1242              		.thumb
ARM GAS  /tmp/ccNfEN49.s 			page 66


 1243              		.thumb_func
 1244              		.fpu softvfp
 1246              	mpu_read_6500_accel_bias:
 1247              	.LVL97:
 1248              	.LFB67:
 902:Src/mpu6050.c ****     unsigned char data[6];
 1249              		.loc 1 902 48 is_stmt 1 view -0
 1250              		.cfi_startproc
 1251              		@ args = 0, pretend = 0, frame = 8
 1252              		@ frame_needed = 0, uses_anonymous_args = 0
 903:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
 1253              		.loc 1 903 5 view .LVU362
 904:Src/mpu6050.c ****         return -1;
 1254              		.loc 1 904 5 view .LVU363
 902:Src/mpu6050.c ****     unsigned char data[6];
 1255              		.loc 1 902 48 is_stmt 0 view .LVU364
 1256 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1257              	.LCFI19:
 1258              		.cfi_def_cfa_offset 24
 1259              		.cfi_offset 4, -12
 1260              		.cfi_offset 5, -8
 1261              		.cfi_offset 14, -4
 904:Src/mpu6050.c ****         return -1;
 1262              		.loc 1 904 20 view .LVU365
 1263 0002 184D     		ldr	r5, .L83
 902:Src/mpu6050.c ****     unsigned char data[6];
 1264              		.loc 1 902 48 view .LVU366
 1265 0004 0446     		mov	r4, r0
 904:Src/mpu6050.c ****         return -1;
 1266              		.loc 1 904 9 view .LVU367
 1267 0006 6868     		ldr	r0, [r5, #4]
 1268              	.LVL98:
 904:Src/mpu6050.c ****         return -1;
 1269              		.loc 1 904 9 view .LVU368
 1270 0008 6B46     		mov	r3, sp
 1271 000a 0222     		movs	r2, #2
 1272 000c 7721     		movs	r1, #119
 1273 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1274 0010 FFF7FEFF 		bl	i2c_readBytes
 1275              	.LVL99:
 904:Src/mpu6050.c ****         return -1;
 1276              		.loc 1 904 8 view .LVU369
 1277 0014 18B1     		cbz	r0, .L80
 1278              	.L82:
 905:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
 1279              		.loc 1 905 16 view .LVU370
 1280 0016 4FF0FF30 		mov	r0, #-1
 1281              	.L79:
 914:Src/mpu6050.c **** 
 1282              		.loc 1 914 1 view .LVU371
 1283 001a 03B0     		add	sp, sp, #12
 1284              	.LCFI20:
 1285              		.cfi_remember_state
 1286              		.cfi_def_cfa_offset 12
 1287              		@ sp needed
 1288 001c 30BD     		pop	{r4, r5, pc}
 1289              	.LVL100:
ARM GAS  /tmp/ccNfEN49.s 			page 67


 1290              	.L80:
 1291              	.LCFI21:
 1292              		.cfi_restore_state
 906:Src/mpu6050.c ****         return -1;
 1293              		.loc 1 906 5 is_stmt 1 view .LVU372
 906:Src/mpu6050.c ****         return -1;
 1294              		.loc 1 906 9 is_stmt 0 view .LVU373
 1295 001e 6868     		ldr	r0, [r5, #4]
 1296 0020 0222     		movs	r2, #2
 1297 0022 7A21     		movs	r1, #122
 1298 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1299 0026 0DF10203 		add	r3, sp, #2
 1300 002a FFF7FEFF 		bl	i2c_readBytes
 1301              	.LVL101:
 906:Src/mpu6050.c ****         return -1;
 1302              		.loc 1 906 8 view .LVU374
 1303 002e 0028     		cmp	r0, #0
 1304 0030 F1D1     		bne	.L82
 908:Src/mpu6050.c ****         return -1;
 1305              		.loc 1 908 5 is_stmt 1 view .LVU375
 908:Src/mpu6050.c ****         return -1;
 1306              		.loc 1 908 9 is_stmt 0 view .LVU376
 1307 0032 6868     		ldr	r0, [r5, #4]
 1308 0034 0222     		movs	r2, #2
 1309 0036 7D21     		movs	r1, #125
 1310 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1311 003a 01AB     		add	r3, sp, #4
 1312 003c FFF7FEFF 		bl	i2c_readBytes
 1313              	.LVL102:
 908:Src/mpu6050.c ****         return -1;
 1314              		.loc 1 908 8 view .LVU377
 1315 0040 0028     		cmp	r0, #0
 1316 0042 E8D1     		bne	.L82
 910:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1317              		.loc 1 910 5 is_stmt 1 view .LVU378
 910:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1318              		.loc 1 910 19 is_stmt 0 view .LVU379
 1319 0044 BDF80030 		ldrh	r3, [sp]
 1320 0048 5BBA     		rev16	r3, r3
 1321 004a 9BB2     		uxth	r3, r3
 1322 004c 2360     		str	r3, [r4]
 911:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1323              		.loc 1 911 5 is_stmt 1 view .LVU380
 911:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1324              		.loc 1 911 19 is_stmt 0 view .LVU381
 1325 004e BDF80230 		ldrh	r3, [sp, #2]
 1326 0052 5BBA     		rev16	r3, r3
 1327 0054 9BB2     		uxth	r3, r3
 1328 0056 6360     		str	r3, [r4, #4]
 912:Src/mpu6050.c ****     return 0;
 1329              		.loc 1 912 5 is_stmt 1 view .LVU382
 912:Src/mpu6050.c ****     return 0;
 1330              		.loc 1 912 19 is_stmt 0 view .LVU383
 1331 0058 BDF80430 		ldrh	r3, [sp, #4]
 1332 005c 5BBA     		rev16	r3, r3
 1333 005e 9BB2     		uxth	r3, r3
 1334 0060 A360     		str	r3, [r4, #8]
ARM GAS  /tmp/ccNfEN49.s 			page 68


 913:Src/mpu6050.c **** }
 1335              		.loc 1 913 5 is_stmt 1 view .LVU384
 913:Src/mpu6050.c **** }
 1336              		.loc 1 913 12 is_stmt 0 view .LVU385
 1337 0062 DAE7     		b	.L79
 1338              	.L84:
 1339              		.align	2
 1340              	.L83:
 1341 0064 00000000 		.word	.LANCHOR0
 1342              		.cfi_endproc
 1343              	.LFE67:
 1345              		.section	.text.mpu_read_6050_accel_bias,"ax",%progbits
 1346              		.align	1
 1347              		.global	mpu_read_6050_accel_bias
 1348              		.syntax unified
 1349              		.thumb
 1350              		.thumb_func
 1351              		.fpu softvfp
 1353              	mpu_read_6050_accel_bias:
 1354              	.LVL103:
 1355              	.LFB68:
 924:Src/mpu6050.c ****     unsigned char data[6];
 1356              		.loc 1 924 48 is_stmt 1 view -0
 1357              		.cfi_startproc
 1358              		@ args = 0, pretend = 0, frame = 8
 1359              		@ frame_needed = 0, uses_anonymous_args = 0
 925:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
 1360              		.loc 1 925 5 view .LVU387
 926:Src/mpu6050.c ****         return -1;
 1361              		.loc 1 926 5 view .LVU388
 924:Src/mpu6050.c ****     unsigned char data[6];
 1362              		.loc 1 924 48 is_stmt 0 view .LVU389
 1363 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1364              	.LCFI22:
 1365              		.cfi_def_cfa_offset 24
 1366              		.cfi_offset 4, -12
 1367              		.cfi_offset 5, -8
 1368              		.cfi_offset 14, -4
 926:Src/mpu6050.c ****         return -1;
 1369              		.loc 1 926 20 view .LVU390
 1370 0002 184D     		ldr	r5, .L89
 924:Src/mpu6050.c ****     unsigned char data[6];
 1371              		.loc 1 924 48 view .LVU391
 1372 0004 0446     		mov	r4, r0
 926:Src/mpu6050.c ****         return -1;
 1373              		.loc 1 926 9 view .LVU392
 1374 0006 6868     		ldr	r0, [r5, #4]
 1375              	.LVL104:
 926:Src/mpu6050.c ****         return -1;
 1376              		.loc 1 926 9 view .LVU393
 1377 0008 6B46     		mov	r3, sp
 1378 000a 0222     		movs	r2, #2
 1379 000c 0621     		movs	r1, #6
 1380 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1381 0010 FFF7FEFF 		bl	i2c_readBytes
 1382              	.LVL105:
 926:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 69


 1383              		.loc 1 926 8 view .LVU394
 1384 0014 18B1     		cbz	r0, .L86
 1385              	.L88:
 927:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
 1386              		.loc 1 927 16 view .LVU395
 1387 0016 4FF0FF30 		mov	r0, #-1
 1388              	.L85:
 936:Src/mpu6050.c **** 
 1389              		.loc 1 936 1 view .LVU396
 1390 001a 03B0     		add	sp, sp, #12
 1391              	.LCFI23:
 1392              		.cfi_remember_state
 1393              		.cfi_def_cfa_offset 12
 1394              		@ sp needed
 1395 001c 30BD     		pop	{r4, r5, pc}
 1396              	.LVL106:
 1397              	.L86:
 1398              	.LCFI24:
 1399              		.cfi_restore_state
 928:Src/mpu6050.c ****         return -1;
 1400              		.loc 1 928 5 is_stmt 1 view .LVU397
 928:Src/mpu6050.c ****         return -1;
 1401              		.loc 1 928 9 is_stmt 0 view .LVU398
 1402 001e 6868     		ldr	r0, [r5, #4]
 1403 0020 0222     		movs	r2, #2
 1404 0022 0821     		movs	r1, #8
 1405 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1406 0026 0DF10203 		add	r3, sp, #2
 1407 002a FFF7FEFF 		bl	i2c_readBytes
 1408              	.LVL107:
 928:Src/mpu6050.c ****         return -1;
 1409              		.loc 1 928 8 view .LVU399
 1410 002e 0028     		cmp	r0, #0
 1411 0030 F1D1     		bne	.L88
 930:Src/mpu6050.c ****         return -1;
 1412              		.loc 1 930 5 is_stmt 1 view .LVU400
 930:Src/mpu6050.c ****         return -1;
 1413              		.loc 1 930 9 is_stmt 0 view .LVU401
 1414 0032 6868     		ldr	r0, [r5, #4]
 1415 0034 0222     		movs	r2, #2
 1416 0036 0A21     		movs	r1, #10
 1417 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1418 003a 01AB     		add	r3, sp, #4
 1419 003c FFF7FEFF 		bl	i2c_readBytes
 1420              	.LVL108:
 930:Src/mpu6050.c ****         return -1;
 1421              		.loc 1 930 8 view .LVU402
 1422 0040 0028     		cmp	r0, #0
 1423 0042 E8D1     		bne	.L88
 932:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1424              		.loc 1 932 5 is_stmt 1 view .LVU403
 932:Src/mpu6050.c ****     accel_bias[1] = ((long)data[2]<<8) | data[3];
 1425              		.loc 1 932 19 is_stmt 0 view .LVU404
 1426 0044 BDF80030 		ldrh	r3, [sp]
 1427 0048 5BBA     		rev16	r3, r3
 1428 004a 9BB2     		uxth	r3, r3
 1429 004c 2360     		str	r3, [r4]
ARM GAS  /tmp/ccNfEN49.s 			page 70


 933:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1430              		.loc 1 933 5 is_stmt 1 view .LVU405
 933:Src/mpu6050.c ****     accel_bias[2] = ((long)data[4]<<8) | data[5];
 1431              		.loc 1 933 19 is_stmt 0 view .LVU406
 1432 004e BDF80230 		ldrh	r3, [sp, #2]
 1433 0052 5BBA     		rev16	r3, r3
 1434 0054 9BB2     		uxth	r3, r3
 1435 0056 6360     		str	r3, [r4, #4]
 934:Src/mpu6050.c ****     return 0;
 1436              		.loc 1 934 5 is_stmt 1 view .LVU407
 934:Src/mpu6050.c ****     return 0;
 1437              		.loc 1 934 19 is_stmt 0 view .LVU408
 1438 0058 BDF80430 		ldrh	r3, [sp, #4]
 1439 005c 5BBA     		rev16	r3, r3
 1440 005e 9BB2     		uxth	r3, r3
 1441 0060 A360     		str	r3, [r4, #8]
 935:Src/mpu6050.c **** }
 1442              		.loc 1 935 5 is_stmt 1 view .LVU409
 935:Src/mpu6050.c **** }
 1443              		.loc 1 935 12 is_stmt 0 view .LVU410
 1444 0062 DAE7     		b	.L85
 1445              	.L90:
 1446              		.align	2
 1447              	.L89:
 1448 0064 00000000 		.word	.LANCHOR0
 1449              		.cfi_endproc
 1450              	.LFE68:
 1452              		.section	.text.mpu_read_6500_gyro_bias,"ax",%progbits
 1453              		.align	1
 1454              		.global	mpu_read_6500_gyro_bias
 1455              		.syntax unified
 1456              		.thumb
 1457              		.thumb_func
 1458              		.fpu softvfp
 1460              	mpu_read_6500_gyro_bias:
 1461              	.LVL109:
 1462              	.LFB69:
 938:Src/mpu6050.c ****     unsigned char data[6];
 1463              		.loc 1 938 46 is_stmt 1 view -0
 1464              		.cfi_startproc
 1465              		@ args = 0, pretend = 0, frame = 8
 1466              		@ frame_needed = 0, uses_anonymous_args = 0
 939:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
 1467              		.loc 1 939 5 view .LVU412
 940:Src/mpu6050.c ****         return -1;
 1468              		.loc 1 940 5 view .LVU413
 938:Src/mpu6050.c ****     unsigned char data[6];
 1469              		.loc 1 938 46 is_stmt 0 view .LVU414
 1470 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1471              	.LCFI25:
 1472              		.cfi_def_cfa_offset 24
 1473              		.cfi_offset 4, -12
 1474              		.cfi_offset 5, -8
 1475              		.cfi_offset 14, -4
 940:Src/mpu6050.c ****         return -1;
 1476              		.loc 1 940 20 view .LVU415
 1477 0002 184D     		ldr	r5, .L95
ARM GAS  /tmp/ccNfEN49.s 			page 71


 938:Src/mpu6050.c ****     unsigned char data[6];
 1478              		.loc 1 938 46 view .LVU416
 1479 0004 0446     		mov	r4, r0
 940:Src/mpu6050.c ****         return -1;
 1480              		.loc 1 940 9 view .LVU417
 1481 0006 6868     		ldr	r0, [r5, #4]
 1482              	.LVL110:
 940:Src/mpu6050.c ****         return -1;
 1483              		.loc 1 940 9 view .LVU418
 1484 0008 6B46     		mov	r3, sp
 1485 000a 0222     		movs	r2, #2
 1486 000c 1321     		movs	r1, #19
 1487 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1488 0010 FFF7FEFF 		bl	i2c_readBytes
 1489              	.LVL111:
 940:Src/mpu6050.c ****         return -1;
 1490              		.loc 1 940 8 view .LVU419
 1491 0014 18B1     		cbz	r0, .L92
 1492              	.L94:
 941:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
 1493              		.loc 1 941 16 view .LVU420
 1494 0016 4FF0FF30 		mov	r0, #-1
 1495              	.L91:
 950:Src/mpu6050.c **** 
 1496              		.loc 1 950 1 view .LVU421
 1497 001a 03B0     		add	sp, sp, #12
 1498              	.LCFI26:
 1499              		.cfi_remember_state
 1500              		.cfi_def_cfa_offset 12
 1501              		@ sp needed
 1502 001c 30BD     		pop	{r4, r5, pc}
 1503              	.LVL112:
 1504              	.L92:
 1505              	.LCFI27:
 1506              		.cfi_restore_state
 942:Src/mpu6050.c ****         return -1;
 1507              		.loc 1 942 5 is_stmt 1 view .LVU422
 942:Src/mpu6050.c ****         return -1;
 1508              		.loc 1 942 9 is_stmt 0 view .LVU423
 1509 001e 6868     		ldr	r0, [r5, #4]
 1510 0020 0222     		movs	r2, #2
 1511 0022 1521     		movs	r1, #21
 1512 0024 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1513 0026 0DF10203 		add	r3, sp, #2
 1514 002a FFF7FEFF 		bl	i2c_readBytes
 1515              	.LVL113:
 942:Src/mpu6050.c ****         return -1;
 1516              		.loc 1 942 8 view .LVU424
 1517 002e 0028     		cmp	r0, #0
 1518 0030 F1D1     		bne	.L94
 944:Src/mpu6050.c ****         return -1;
 1519              		.loc 1 944 5 is_stmt 1 view .LVU425
 944:Src/mpu6050.c ****         return -1;
 1520              		.loc 1 944 9 is_stmt 0 view .LVU426
 1521 0032 6868     		ldr	r0, [r5, #4]
 1522 0034 0222     		movs	r2, #2
 1523 0036 1721     		movs	r1, #23
ARM GAS  /tmp/ccNfEN49.s 			page 72


 1524 0038 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1525 003a 01AB     		add	r3, sp, #4
 1526 003c FFF7FEFF 		bl	i2c_readBytes
 1527              	.LVL114:
 944:Src/mpu6050.c ****         return -1;
 1528              		.loc 1 944 8 view .LVU427
 1529 0040 0028     		cmp	r0, #0
 1530 0042 E8D1     		bne	.L94
 946:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 1531              		.loc 1 946 5 is_stmt 1 view .LVU428
 946:Src/mpu6050.c ****     gyro_bias[1] = ((long)data[2]<<8) | data[3];
 1532              		.loc 1 946 18 is_stmt 0 view .LVU429
 1533 0044 BDF80030 		ldrh	r3, [sp]
 1534 0048 5BBA     		rev16	r3, r3
 1535 004a 9BB2     		uxth	r3, r3
 1536 004c 2360     		str	r3, [r4]
 947:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 1537              		.loc 1 947 5 is_stmt 1 view .LVU430
 947:Src/mpu6050.c ****     gyro_bias[2] = ((long)data[4]<<8) | data[5];
 1538              		.loc 1 947 18 is_stmt 0 view .LVU431
 1539 004e BDF80230 		ldrh	r3, [sp, #2]
 1540 0052 5BBA     		rev16	r3, r3
 1541 0054 9BB2     		uxth	r3, r3
 1542 0056 6360     		str	r3, [r4, #4]
 948:Src/mpu6050.c ****     return 0;
 1543              		.loc 1 948 5 is_stmt 1 view .LVU432
 948:Src/mpu6050.c ****     return 0;
 1544              		.loc 1 948 18 is_stmt 0 view .LVU433
 1545 0058 BDF80430 		ldrh	r3, [sp, #4]
 1546 005c 5BBA     		rev16	r3, r3
 1547 005e 9BB2     		uxth	r3, r3
 1548 0060 A360     		str	r3, [r4, #8]
 949:Src/mpu6050.c **** }
 1549              		.loc 1 949 5 is_stmt 1 view .LVU434
 949:Src/mpu6050.c **** }
 1550              		.loc 1 949 12 is_stmt 0 view .LVU435
 1551 0062 DAE7     		b	.L91
 1552              	.L96:
 1553              		.align	2
 1554              	.L95:
 1555 0064 00000000 		.word	.LANCHOR0
 1556              		.cfi_endproc
 1557              	.LFE69:
 1559              		.section	.text.mpu_set_gyro_bias_reg,"ax",%progbits
 1560              		.align	1
 1561              		.global	mpu_set_gyro_bias_reg
 1562              		.syntax unified
 1563              		.thumb
 1564              		.thumb_func
 1565              		.fpu softvfp
 1567              	mpu_set_gyro_bias_reg:
 1568              	.LVL115:
 1569              	.LFB70:
 961:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1570              		.loc 1 961 1 is_stmt 1 view -0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccNfEN49.s 			page 73


 1573              		@ frame_needed = 0, uses_anonymous_args = 0
 962:Src/mpu6050.c ****     int i=0;
 1574              		.loc 1 962 5 view .LVU437
 963:Src/mpu6050.c ****     for(i=0;i<3;i++) {
 1575              		.loc 1 963 5 view .LVU438
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1576              		.loc 1 964 5 view .LVU439
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1577              		.loc 1 964 13 view .LVU440
 965:Src/mpu6050.c ****     }
 1578              		.loc 1 965 9 view .LVU441
 961:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1579              		.loc 1 961 1 is_stmt 0 view .LVU442
 1580 0000 13B5     		push	{r0, r1, r4, lr}
 1581              	.LCFI28:
 1582              		.cfi_def_cfa_offset 16
 1583              		.cfi_offset 4, -8
 1584              		.cfi_offset 14, -4
 965:Src/mpu6050.c ****     }
 1585              		.loc 1 965 24 view .LVU443
 1586 0002 4268     		ldr	r2, [r0, #4]
 1587 0004 0168     		ldr	r1, [r0]
 1588 0006 8368     		ldr	r3, [r0, #8]
 1589 0008 4942     		rsbs	r1, r1, #0
 1590 000a 5242     		rsbs	r2, r2, #0
 1591 000c 5B42     		rsbs	r3, r3, #0
 973:Src/mpu6050.c ****         return -1;
 1592              		.loc 1 973 21 view .LVU444
 1593 000e 1A4C     		ldr	r4, .L101
 965:Src/mpu6050.c ****     }
 1594              		.loc 1 965 21 view .LVU445
 1595 0010 0160     		str	r1, [r0]
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1596              		.loc 1 964 17 is_stmt 1 view .LVU446
 1597              	.LVL116:
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1598              		.loc 1 964 13 view .LVU447
 965:Src/mpu6050.c ****     }
 1599              		.loc 1 965 9 view .LVU448
 965:Src/mpu6050.c ****     }
 1600              		.loc 1 965 21 is_stmt 0 view .LVU449
 1601 0012 4260     		str	r2, [r0, #4]
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1602              		.loc 1 964 17 is_stmt 1 view .LVU450
 1603              	.LVL117:
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1604              		.loc 1 964 13 view .LVU451
 965:Src/mpu6050.c ****     }
 1605              		.loc 1 965 9 view .LVU452
 965:Src/mpu6050.c ****     }
 1606              		.loc 1 965 21 is_stmt 0 view .LVU453
 1607 0014 8360     		str	r3, [r0, #8]
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1608              		.loc 1 964 17 is_stmt 1 view .LVU454
 1609              	.LVL118:
 964:Src/mpu6050.c ****         gyro_bias[i]= (-gyro_bias[i]);
 1610              		.loc 1 964 13 view .LVU455
ARM GAS  /tmp/ccNfEN49.s 			page 74


 967:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1611              		.loc 1 967 5 view .LVU456
 967:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1612              		.loc 1 967 29 is_stmt 0 view .LVU457
 1613 0016 0812     		asrs	r0, r1, #8
 1614              	.LVL119:
 967:Src/mpu6050.c ****     data[1] = (gyro_bias[0]) & 0xff;
 1615              		.loc 1 967 13 view .LVU458
 1616 0018 8DF80000 		strb	r0, [sp]
 968:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 1617              		.loc 1 968 5 is_stmt 1 view .LVU459
 968:Src/mpu6050.c ****     data[2] = (gyro_bias[1] >> 8) & 0xff;
 1618              		.loc 1 968 13 is_stmt 0 view .LVU460
 1619 001c 8DF80110 		strb	r1, [sp, #1]
 969:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1620              		.loc 1 969 5 is_stmt 1 view .LVU461
 970:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 1621              		.loc 1 970 13 is_stmt 0 view .LVU462
 1622 0020 8DF80320 		strb	r2, [sp, #3]
 969:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1623              		.loc 1 969 29 view .LVU463
 1624 0024 1112     		asrs	r1, r2, #8
 973:Src/mpu6050.c ****         return -1;
 1625              		.loc 1 973 9 view .LVU464
 1626 0026 6068     		ldr	r0, [r4, #4]
 971:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1627              		.loc 1 971 29 view .LVU465
 1628 0028 1A12     		asrs	r2, r3, #8
 969:Src/mpu6050.c ****     data[3] = (gyro_bias[1]) & 0xff;
 1629              		.loc 1 969 13 view .LVU466
 1630 002a 8DF80210 		strb	r1, [sp, #2]
 970:Src/mpu6050.c ****     data[4] = (gyro_bias[2] >> 8) & 0xff;
 1631              		.loc 1 970 5 is_stmt 1 view .LVU467
 971:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1632              		.loc 1 971 5 view .LVU468
 971:Src/mpu6050.c ****     data[5] = (gyro_bias[2]) & 0xff;
 1633              		.loc 1 971 13 is_stmt 0 view .LVU469
 1634 002e 8DF80420 		strb	r2, [sp, #4]
 972:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 1635              		.loc 1 972 5 is_stmt 1 view .LVU470
 972:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
 1636              		.loc 1 972 13 is_stmt 0 view .LVU471
 1637 0032 8DF80530 		strb	r3, [sp, #5]
 973:Src/mpu6050.c ****         return -1;
 1638              		.loc 1 973 5 is_stmt 1 view .LVU472
 973:Src/mpu6050.c ****         return -1;
 1639              		.loc 1 973 9 is_stmt 0 view .LVU473
 1640 0036 0222     		movs	r2, #2
 1641 0038 6B46     		mov	r3, sp
 1642 003a 1321     		movs	r1, #19
 1643 003c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1644 003e FFF7FEFF 		bl	i2c_writeBytes
 1645              	.LVL120:
 973:Src/mpu6050.c ****         return -1;
 1646              		.loc 1 973 8 view .LVU474
 1647 0042 18B1     		cbz	r0, .L98
 1648              	.L100:
ARM GAS  /tmp/ccNfEN49.s 			page 75


 974:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
 1649              		.loc 1 974 16 view .LVU475
 1650 0044 4FF0FF30 		mov	r0, #-1
 1651              	.L97:
 980:Src/mpu6050.c **** 
 1652              		.loc 1 980 1 view .LVU476
 1653 0048 02B0     		add	sp, sp, #8
 1654              	.LCFI29:
 1655              		.cfi_remember_state
 1656              		.cfi_def_cfa_offset 8
 1657              		@ sp needed
 1658 004a 10BD     		pop	{r4, pc}
 1659              	.L98:
 1660              	.LCFI30:
 1661              		.cfi_restore_state
 975:Src/mpu6050.c ****         return -1;
 1662              		.loc 1 975 5 is_stmt 1 view .LVU477
 975:Src/mpu6050.c ****         return -1;
 1663              		.loc 1 975 9 is_stmt 0 view .LVU478
 1664 004c 6068     		ldr	r0, [r4, #4]
 1665 004e 0222     		movs	r2, #2
 1666 0050 1521     		movs	r1, #21
 1667 0052 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1668 0054 0DF10203 		add	r3, sp, #2
 1669 0058 FFF7FEFF 		bl	i2c_writeBytes
 1670              	.LVL121:
 975:Src/mpu6050.c ****         return -1;
 1671              		.loc 1 975 8 view .LVU479
 1672 005c 0028     		cmp	r0, #0
 1673 005e F1D1     		bne	.L100
 977:Src/mpu6050.c ****         return -1;
 1674              		.loc 1 977 5 is_stmt 1 view .LVU480
 977:Src/mpu6050.c ****         return -1;
 1675              		.loc 1 977 9 is_stmt 0 view .LVU481
 1676 0060 6068     		ldr	r0, [r4, #4]
 1677 0062 0222     		movs	r2, #2
 1678 0064 1721     		movs	r1, #23
 1679 0066 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1680 0068 01AB     		add	r3, sp, #4
 1681 006a FFF7FEFF 		bl	i2c_writeBytes
 1682              	.LVL122:
 977:Src/mpu6050.c ****         return -1;
 1683              		.loc 1 977 8 view .LVU482
 1684 006e 0038     		subs	r0, r0, #0
 1685 0070 18BF     		it	ne
 1686 0072 0120     		movne	r0, #1
 1687 0074 4042     		rsbs	r0, r0, #0
 1688 0076 E7E7     		b	.L97
 1689              	.L102:
 1690              		.align	2
 1691              	.L101:
 1692 0078 00000000 		.word	.LANCHOR0
 1693              		.cfi_endproc
 1694              	.LFE70:
 1696              		.section	.text.mpu_set_accel_bias_6050_reg,"ax",%progbits
 1697              		.align	1
 1698              		.global	mpu_set_accel_bias_6050_reg
ARM GAS  /tmp/ccNfEN49.s 			page 76


 1699              		.syntax unified
 1700              		.thumb
 1701              		.thumb_func
 1702              		.fpu softvfp
 1704              	mpu_set_accel_bias_6050_reg:
 1705              	.LVL123:
 1706              	.LFB71:
 990:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1707              		.loc 1 990 57 is_stmt 1 view -0
 1708              		.cfi_startproc
 1709              		@ args = 0, pretend = 0, frame = 24
 1710              		@ frame_needed = 0, uses_anonymous_args = 0
 991:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1711              		.loc 1 991 5 view .LVU484
 990:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1712              		.loc 1 990 57 is_stmt 0 view .LVU485
 1713 0000 10B5     		push	{r4, lr}
 1714              	.LCFI31:
 1715              		.cfi_def_cfa_offset 8
 1716              		.cfi_offset 4, -8
 1717              		.cfi_offset 14, -4
 991:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1718              		.loc 1 991 19 view .LVU486
 1719 0002 2A4B     		ldr	r3, .L107
 990:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1720              		.loc 1 990 57 view .LVU487
 1721 0004 0446     		mov	r4, r0
 991:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1722              		.loc 1 991 19 view .LVU488
 1723 0006 1868     		ldr	r0, [r3]	@ unaligned
 1724              	.LVL124:
 991:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1725              		.loc 1 991 19 view .LVU489
 1726 0008 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 990:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1727              		.loc 1 990 57 view .LVU490
 1728 000a 86B0     		sub	sp, sp, #24
 1729              	.LCFI32:
 1730              		.cfi_def_cfa_offset 32
 991:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1731              		.loc 1 991 19 view .LVU491
 1732 000c ADF80830 		strh	r3, [sp, #8]	@ unaligned
 992:Src/mpu6050.c **** 
 1733              		.loc 1 992 5 is_stmt 1 view .LVU492
 992:Src/mpu6050.c **** 
 1734              		.loc 1 992 10 is_stmt 0 view .LVU493
 1735 0010 0023     		movs	r3, #0
 991:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1736              		.loc 1 991 19 view .LVU494
 1737 0012 0190     		str	r0, [sp, #4]
 994:Src/mpu6050.c ****         return -1;
 1738              		.loc 1 994 8 view .LVU495
 1739 0014 03A8     		add	r0, sp, #12
 992:Src/mpu6050.c **** 
 1740              		.loc 1 992 10 view .LVU496
 1741 0016 CDE90333 		strd	r3, r3, [sp, #12]
 1742 001a 0593     		str	r3, [sp, #20]
ARM GAS  /tmp/ccNfEN49.s 			page 77


 994:Src/mpu6050.c ****         return -1;
 1743              		.loc 1 994 5 is_stmt 1 view .LVU497
 994:Src/mpu6050.c ****         return -1;
 1744              		.loc 1 994 8 is_stmt 0 view .LVU498
 1745 001c FFF7FEFF 		bl	mpu_read_6050_accel_bias
 1746              	.LVL125:
 994:Src/mpu6050.c ****         return -1;
 1747              		.loc 1 994 7 view .LVU499
 1748 0020 18B1     		cbz	r0, .L104
 1749              	.LVL126:
 1750              	.L106:
 995:Src/mpu6050.c **** 
 1751              		.loc 1 995 16 view .LVU500
 1752 0022 4FF0FF30 		mov	r0, #-1
 1753              	.L103:
1016:Src/mpu6050.c **** 
 1754              		.loc 1 1016 1 view .LVU501
 1755 0026 06B0     		add	sp, sp, #24
 1756              	.LCFI33:
 1757              		.cfi_remember_state
 1758              		.cfi_def_cfa_offset 8
 1759              		@ sp needed
 1760 0028 10BD     		pop	{r4, pc}
 1761              	.LVL127:
 1762              	.L104:
 1763              	.LCFI34:
 1764              		.cfi_restore_state
 997:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1765              		.loc 1 997 5 is_stmt 1 view .LVU502
 997:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1766              		.loc 1 997 41 is_stmt 0 view .LVU503
 1767 002a 2168     		ldr	r1, [r4]
 998:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1768              		.loc 1 998 41 view .LVU504
 1769 002c 6268     		ldr	r2, [r4, #4]
 997:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1770              		.loc 1 997 41 view .LVU505
 1771 002e 21F00103 		bic	r3, r1, #1
 997:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1772              		.loc 1 997 23 view .LVU506
 1773 0032 0399     		ldr	r1, [sp, #12]
 999:Src/mpu6050.c **** 
 1774              		.loc 1 999 41 view .LVU507
 1775 0034 A068     		ldr	r0, [r4, #8]
 997:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1776              		.loc 1 997 23 view .LVU508
 1777 0036 C91A     		subs	r1, r1, r3
 998:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1778              		.loc 1 998 41 view .LVU509
 1779 0038 22F00103 		bic	r3, r2, #1
 998:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1780              		.loc 1 998 23 view .LVU510
 1781 003c 049A     		ldr	r2, [sp, #16]
 999:Src/mpu6050.c **** 
 1782              		.loc 1 999 41 view .LVU511
 1783 003e 20F00100 		bic	r0, r0, #1
 998:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
ARM GAS  /tmp/ccNfEN49.s 			page 78


 1784              		.loc 1 998 23 view .LVU512
 1785 0042 D21A     		subs	r2, r2, r3
 999:Src/mpu6050.c **** 
 1786              		.loc 1 999 23 view .LVU513
 1787 0044 059B     		ldr	r3, [sp, #20]
1008:Src/mpu6050.c ****         return -1;
 1788              		.loc 1 1008 21 view .LVU514
 1789 0046 1A4C     		ldr	r4, .L107+4
 1790              	.LVL128:
 999:Src/mpu6050.c **** 
 1791              		.loc 1 999 23 view .LVU515
 1792 0048 1B1A     		subs	r3, r3, r0
1001:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1793              		.loc 1 1001 34 view .LVU516
 1794 004a 0812     		asrs	r0, r1, #8
 997:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1795              		.loc 1 997 23 view .LVU517
 1796 004c 0391     		str	r1, [sp, #12]
 998:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1797              		.loc 1 998 5 is_stmt 1 view .LVU518
 998:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1798              		.loc 1 998 23 is_stmt 0 view .LVU519
 1799 004e 0492     		str	r2, [sp, #16]
 999:Src/mpu6050.c **** 
 1800              		.loc 1 999 5 is_stmt 1 view .LVU520
1001:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1801              		.loc 1 1001 13 is_stmt 0 view .LVU521
 1802 0050 8DF80400 		strb	r0, [sp, #4]
1002:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1803              		.loc 1 1002 13 view .LVU522
 1804 0054 8DF80510 		strb	r1, [sp, #5]
1004:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1805              		.loc 1 1004 13 view .LVU523
 1806 0058 8DF80720 		strb	r2, [sp, #7]
1003:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1807              		.loc 1 1003 34 view .LVU524
 1808 005c 1112     		asrs	r1, r2, #8
1008:Src/mpu6050.c ****         return -1;
 1809              		.loc 1 1008 9 view .LVU525
 1810 005e 6068     		ldr	r0, [r4, #4]
1005:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1811              		.loc 1 1005 34 view .LVU526
 1812 0060 1A12     		asrs	r2, r3, #8
 999:Src/mpu6050.c **** 
 1813              		.loc 1 999 23 view .LVU527
 1814 0062 0593     		str	r3, [sp, #20]
1001:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1815              		.loc 1 1001 5 is_stmt 1 view .LVU528
1002:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1816              		.loc 1 1002 5 view .LVU529
1003:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1817              		.loc 1 1003 5 view .LVU530
1003:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1818              		.loc 1 1003 13 is_stmt 0 view .LVU531
 1819 0064 8DF80610 		strb	r1, [sp, #6]
1004:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1820              		.loc 1 1004 5 is_stmt 1 view .LVU532
ARM GAS  /tmp/ccNfEN49.s 			page 79


1005:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1821              		.loc 1 1005 5 view .LVU533
1005:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1822              		.loc 1 1005 13 is_stmt 0 view .LVU534
 1823 0068 8DF80820 		strb	r2, [sp, #8]
1006:Src/mpu6050.c **** 
 1824              		.loc 1 1006 5 is_stmt 1 view .LVU535
1006:Src/mpu6050.c **** 
 1825              		.loc 1 1006 13 is_stmt 0 view .LVU536
 1826 006c 8DF80930 		strb	r3, [sp, #9]
1008:Src/mpu6050.c ****         return -1;
 1827              		.loc 1 1008 5 is_stmt 1 view .LVU537
1008:Src/mpu6050.c ****         return -1;
 1828              		.loc 1 1008 9 is_stmt 0 view .LVU538
 1829 0070 0222     		movs	r2, #2
 1830 0072 0621     		movs	r1, #6
 1831 0074 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1832 0076 01AB     		add	r3, sp, #4
 1833 0078 FFF7FEFF 		bl	i2c_writeBytes
 1834              	.LVL129:
1008:Src/mpu6050.c ****         return -1;
 1835              		.loc 1 1008 8 view .LVU539
 1836 007c 0028     		cmp	r0, #0
 1837 007e D0D1     		bne	.L106
1010:Src/mpu6050.c ****         return -1;
 1838              		.loc 1 1010 5 is_stmt 1 view .LVU540
1010:Src/mpu6050.c ****         return -1;
 1839              		.loc 1 1010 9 is_stmt 0 view .LVU541
 1840 0080 6068     		ldr	r0, [r4, #4]
 1841 0082 0222     		movs	r2, #2
 1842 0084 0821     		movs	r1, #8
 1843 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1844 0088 0DF10603 		add	r3, sp, #6
 1845 008c FFF7FEFF 		bl	i2c_writeBytes
 1846              	.LVL130:
1010:Src/mpu6050.c ****         return -1;
 1847              		.loc 1 1010 8 view .LVU542
 1848 0090 0028     		cmp	r0, #0
 1849 0092 C6D1     		bne	.L106
1012:Src/mpu6050.c ****         return -1;
 1850              		.loc 1 1012 5 is_stmt 1 view .LVU543
1012:Src/mpu6050.c ****         return -1;
 1851              		.loc 1 1012 9 is_stmt 0 view .LVU544
 1852 0094 6068     		ldr	r0, [r4, #4]
 1853 0096 0222     		movs	r2, #2
 1854 0098 0A21     		movs	r1, #10
 1855 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 1856 009c 02AB     		add	r3, sp, #8
 1857 009e FFF7FEFF 		bl	i2c_writeBytes
 1858              	.LVL131:
1012:Src/mpu6050.c ****         return -1;
 1859              		.loc 1 1012 8 view .LVU545
 1860 00a2 0038     		subs	r0, r0, #0
 1861 00a4 18BF     		it	ne
 1862 00a6 0120     		movne	r0, #1
 1863 00a8 4042     		rsbs	r0, r0, #0
 1864 00aa BCE7     		b	.L103
ARM GAS  /tmp/ccNfEN49.s 			page 80


 1865              	.L108:
 1866              		.align	2
 1867              	.L107:
 1868 00ac 00000000 		.word	.LANCHOR1
 1869 00b0 00000000 		.word	.LANCHOR0
 1870              		.cfi_endproc
 1871              	.LFE71:
 1873              		.section	.text.mpu_set_accel_bias_6500_reg,"ax",%progbits
 1874              		.align	1
 1875              		.global	mpu_set_accel_bias_6500_reg
 1876              		.syntax unified
 1877              		.thumb
 1878              		.thumb_func
 1879              		.fpu softvfp
 1881              	mpu_set_accel_bias_6500_reg:
 1882              	.LVL132:
 1883              	.LFB72:
1028:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1884              		.loc 1 1028 57 is_stmt 1 view -0
 1885              		.cfi_startproc
 1886              		@ args = 0, pretend = 0, frame = 24
 1887              		@ frame_needed = 0, uses_anonymous_args = 0
1029:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1888              		.loc 1 1029 5 view .LVU547
1028:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1889              		.loc 1 1028 57 is_stmt 0 view .LVU548
 1890 0000 10B5     		push	{r4, lr}
 1891              	.LCFI35:
 1892              		.cfi_def_cfa_offset 8
 1893              		.cfi_offset 4, -8
 1894              		.cfi_offset 14, -4
1029:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1895              		.loc 1 1029 19 view .LVU549
 1896 0002 2A4B     		ldr	r3, .L113
1028:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1897              		.loc 1 1028 57 view .LVU550
 1898 0004 0446     		mov	r4, r0
1029:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1899              		.loc 1 1029 19 view .LVU551
 1900 0006 1868     		ldr	r0, [r3]	@ unaligned
 1901              	.LVL133:
1029:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1902              		.loc 1 1029 19 view .LVU552
 1903 0008 9B88     		ldrh	r3, [r3, #4]	@ unaligned
1028:Src/mpu6050.c ****     unsigned char data[6] = {0, 0, 0, 0, 0, 0};
 1904              		.loc 1 1028 57 view .LVU553
 1905 000a 86B0     		sub	sp, sp, #24
 1906              	.LCFI36:
 1907              		.cfi_def_cfa_offset 32
1029:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1908              		.loc 1 1029 19 view .LVU554
 1909 000c ADF80830 		strh	r3, [sp, #8]	@ unaligned
1030:Src/mpu6050.c **** 
 1910              		.loc 1 1030 5 is_stmt 1 view .LVU555
1030:Src/mpu6050.c **** 
 1911              		.loc 1 1030 10 is_stmt 0 view .LVU556
 1912 0010 0023     		movs	r3, #0
ARM GAS  /tmp/ccNfEN49.s 			page 81


1029:Src/mpu6050.c ****     long accel_reg_bias[3] = {0, 0, 0};
 1913              		.loc 1 1029 19 view .LVU557
 1914 0012 0190     		str	r0, [sp, #4]
1032:Src/mpu6050.c ****         return -1;
 1915              		.loc 1 1032 8 view .LVU558
 1916 0014 03A8     		add	r0, sp, #12
1030:Src/mpu6050.c **** 
 1917              		.loc 1 1030 10 view .LVU559
 1918 0016 CDE90333 		strd	r3, r3, [sp, #12]
 1919 001a 0593     		str	r3, [sp, #20]
1032:Src/mpu6050.c ****         return -1;
 1920              		.loc 1 1032 5 is_stmt 1 view .LVU560
1032:Src/mpu6050.c ****         return -1;
 1921              		.loc 1 1032 8 is_stmt 0 view .LVU561
 1922 001c FFF7FEFF 		bl	mpu_read_6500_accel_bias
 1923              	.LVL134:
1032:Src/mpu6050.c ****         return -1;
 1924              		.loc 1 1032 7 view .LVU562
 1925 0020 18B1     		cbz	r0, .L110
 1926              	.LVL135:
 1927              	.L112:
1033:Src/mpu6050.c **** 
 1928              		.loc 1 1033 16 view .LVU563
 1929 0022 4FF0FF30 		mov	r0, #-1
 1930              	.L109:
1055:Src/mpu6050.c **** 
 1931              		.loc 1 1055 1 view .LVU564
 1932 0026 06B0     		add	sp, sp, #24
 1933              	.LCFI37:
 1934              		.cfi_remember_state
 1935              		.cfi_def_cfa_offset 8
 1936              		@ sp needed
 1937 0028 10BD     		pop	{r4, pc}
 1938              	.LVL136:
 1939              	.L110:
 1940              	.LCFI38:
 1941              		.cfi_restore_state
1036:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1942              		.loc 1 1036 5 is_stmt 1 view .LVU565
1036:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1943              		.loc 1 1036 41 is_stmt 0 view .LVU566
 1944 002a 2168     		ldr	r1, [r4]
1037:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1945              		.loc 1 1037 41 view .LVU567
 1946 002c 6268     		ldr	r2, [r4, #4]
1036:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1947              		.loc 1 1036 41 view .LVU568
 1948 002e 21F00103 		bic	r3, r1, #1
1036:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1949              		.loc 1 1036 23 view .LVU569
 1950 0032 0399     		ldr	r1, [sp, #12]
1038:Src/mpu6050.c **** 
 1951              		.loc 1 1038 41 view .LVU570
 1952 0034 A068     		ldr	r0, [r4, #8]
1036:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1953              		.loc 1 1036 23 view .LVU571
 1954 0036 C91A     		subs	r1, r1, r3
ARM GAS  /tmp/ccNfEN49.s 			page 82


1037:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1955              		.loc 1 1037 41 view .LVU572
 1956 0038 22F00103 		bic	r3, r2, #1
1037:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1957              		.loc 1 1037 23 view .LVU573
 1958 003c 049A     		ldr	r2, [sp, #16]
1038:Src/mpu6050.c **** 
 1959              		.loc 1 1038 41 view .LVU574
 1960 003e 20F00100 		bic	r0, r0, #1
1037:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1961              		.loc 1 1037 23 view .LVU575
 1962 0042 D21A     		subs	r2, r2, r3
1038:Src/mpu6050.c **** 
 1963              		.loc 1 1038 23 view .LVU576
 1964 0044 059B     		ldr	r3, [sp, #20]
1047:Src/mpu6050.c ****         return -1;
 1965              		.loc 1 1047 21 view .LVU577
 1966 0046 1A4C     		ldr	r4, .L113+4
 1967              	.LVL137:
1038:Src/mpu6050.c **** 
 1968              		.loc 1 1038 23 view .LVU578
 1969 0048 1B1A     		subs	r3, r3, r0
1040:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1970              		.loc 1 1040 34 view .LVU579
 1971 004a 0812     		asrs	r0, r1, #8
1036:Src/mpu6050.c ****     accel_reg_bias[1] -= (accel_bias[1] & ~1);
 1972              		.loc 1 1036 23 view .LVU580
 1973 004c 0391     		str	r1, [sp, #12]
1037:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1974              		.loc 1 1037 5 is_stmt 1 view .LVU581
1037:Src/mpu6050.c ****     accel_reg_bias[2] -= (accel_bias[2] & ~1);
 1975              		.loc 1 1037 23 is_stmt 0 view .LVU582
 1976 004e 0492     		str	r2, [sp, #16]
1038:Src/mpu6050.c **** 
 1977              		.loc 1 1038 5 is_stmt 1 view .LVU583
1040:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
 1978              		.loc 1 1040 13 is_stmt 0 view .LVU584
 1979 0050 8DF80400 		strb	r0, [sp, #4]
1041:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1980              		.loc 1 1041 13 view .LVU585
 1981 0054 8DF80510 		strb	r1, [sp, #5]
1043:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1982              		.loc 1 1043 13 view .LVU586
 1983 0058 8DF80720 		strb	r2, [sp, #7]
1042:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1984              		.loc 1 1042 34 view .LVU587
 1985 005c 1112     		asrs	r1, r2, #8
1047:Src/mpu6050.c ****         return -1;
 1986              		.loc 1 1047 9 view .LVU588
 1987 005e 6068     		ldr	r0, [r4, #4]
1044:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1988              		.loc 1 1044 34 view .LVU589
 1989 0060 1A12     		asrs	r2, r3, #8
1038:Src/mpu6050.c **** 
 1990              		.loc 1 1038 23 view .LVU590
 1991 0062 0593     		str	r3, [sp, #20]
1040:Src/mpu6050.c ****     data[1] = (accel_reg_bias[0]) & 0xff;
ARM GAS  /tmp/ccNfEN49.s 			page 83


 1992              		.loc 1 1040 5 is_stmt 1 view .LVU591
1041:Src/mpu6050.c ****     data[2] = (accel_reg_bias[1] >> 8) & 0xff;
 1993              		.loc 1 1041 5 view .LVU592
1042:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1994              		.loc 1 1042 5 view .LVU593
1042:Src/mpu6050.c ****     data[3] = (accel_reg_bias[1]) & 0xff;
 1995              		.loc 1 1042 13 is_stmt 0 view .LVU594
 1996 0064 8DF80610 		strb	r1, [sp, #6]
1043:Src/mpu6050.c ****     data[4] = (accel_reg_bias[2] >> 8) & 0xff;
 1997              		.loc 1 1043 5 is_stmt 1 view .LVU595
1044:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1998              		.loc 1 1044 5 view .LVU596
1044:Src/mpu6050.c ****     data[5] = (accel_reg_bias[2]) & 0xff;
 1999              		.loc 1 1044 13 is_stmt 0 view .LVU597
 2000 0068 8DF80820 		strb	r2, [sp, #8]
1045:Src/mpu6050.c **** 
 2001              		.loc 1 1045 5 is_stmt 1 view .LVU598
1045:Src/mpu6050.c **** 
 2002              		.loc 1 1045 13 is_stmt 0 view .LVU599
 2003 006c 8DF80930 		strb	r3, [sp, #9]
1047:Src/mpu6050.c ****         return -1;
 2004              		.loc 1 1047 5 is_stmt 1 view .LVU600
1047:Src/mpu6050.c ****         return -1;
 2005              		.loc 1 1047 9 is_stmt 0 view .LVU601
 2006 0070 0222     		movs	r2, #2
 2007 0072 7721     		movs	r1, #119
 2008 0074 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2009 0076 01AB     		add	r3, sp, #4
 2010 0078 FFF7FEFF 		bl	i2c_writeBytes
 2011              	.LVL138:
1047:Src/mpu6050.c ****         return -1;
 2012              		.loc 1 1047 8 view .LVU602
 2013 007c 0028     		cmp	r0, #0
 2014 007e D0D1     		bne	.L112
1049:Src/mpu6050.c ****         return -1;
 2015              		.loc 1 1049 5 is_stmt 1 view .LVU603
1049:Src/mpu6050.c ****         return -1;
 2016              		.loc 1 1049 9 is_stmt 0 view .LVU604
 2017 0080 6068     		ldr	r0, [r4, #4]
 2018 0082 0222     		movs	r2, #2
 2019 0084 7A21     		movs	r1, #122
 2020 0086 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2021 0088 0DF10603 		add	r3, sp, #6
 2022 008c FFF7FEFF 		bl	i2c_writeBytes
 2023              	.LVL139:
1049:Src/mpu6050.c ****         return -1;
 2024              		.loc 1 1049 8 view .LVU605
 2025 0090 0028     		cmp	r0, #0
 2026 0092 C6D1     		bne	.L112
1051:Src/mpu6050.c ****         return -1;
 2027              		.loc 1 1051 5 is_stmt 1 view .LVU606
1051:Src/mpu6050.c ****         return -1;
 2028              		.loc 1 1051 9 is_stmt 0 view .LVU607
 2029 0094 6068     		ldr	r0, [r4, #4]
 2030 0096 0222     		movs	r2, #2
 2031 0098 7D21     		movs	r1, #125
 2032 009a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
ARM GAS  /tmp/ccNfEN49.s 			page 84


 2033 009c 02AB     		add	r3, sp, #8
 2034 009e FFF7FEFF 		bl	i2c_writeBytes
 2035              	.LVL140:
1051:Src/mpu6050.c ****         return -1;
 2036              		.loc 1 1051 8 view .LVU608
 2037 00a2 0038     		subs	r0, r0, #0
 2038 00a4 18BF     		it	ne
 2039 00a6 0120     		movne	r0, #1
 2040 00a8 4042     		rsbs	r0, r0, #0
 2041 00aa BCE7     		b	.L109
 2042              	.L114:
 2043              		.align	2
 2044              	.L113:
 2045 00ac 00000000 		.word	.LANCHOR1
 2046 00b0 00000000 		.word	.LANCHOR0
 2047              		.cfi_endproc
 2048              	.LFE72:
 2050              		.section	.text.mpu_reset_fifo,"ax",%progbits
 2051              		.align	1
 2052              		.global	mpu_reset_fifo
 2053              		.syntax unified
 2054              		.thumb
 2055              		.thumb_func
 2056              		.fpu softvfp
 2058              	mpu_reset_fifo:
 2059              	.LFB73:
1063:Src/mpu6050.c ****     unsigned char data;
 2060              		.loc 1 1063 1 is_stmt 1 view -0
 2061              		.cfi_startproc
 2062              		@ args = 0, pretend = 0, frame = 8
 2063              		@ frame_needed = 0, uses_anonymous_args = 0
1064:Src/mpu6050.c **** 
 2064              		.loc 1 1064 5 view .LVU610
1066:Src/mpu6050.c ****         return -1;
 2065              		.loc 1 1066 5 view .LVU611
1063:Src/mpu6050.c ****     unsigned char data;
 2066              		.loc 1 1063 1 is_stmt 0 view .LVU612
 2067 0000 13B5     		push	{r0, r1, r4, lr}
 2068              	.LCFI39:
 2069              		.cfi_def_cfa_offset 16
 2070              		.cfi_offset 4, -8
 2071              		.cfi_offset 14, -4
1066:Src/mpu6050.c ****         return -1;
 2072              		.loc 1 1066 22 view .LVU613
 2073 0002 584C     		ldr	r4, .L130
1066:Src/mpu6050.c ****         return -1;
 2074              		.loc 1 1066 8 view .LVU614
 2075 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2076 0006 1BB9     		cbnz	r3, .L116
 2077              	.L118:
1067:Src/mpu6050.c **** 
 2078              		.loc 1 1067 16 view .LVU615
 2079 0008 4FF0FF30 		mov	r0, #-1
 2080              	.L115:
1117:Src/mpu6050.c **** 
 2081              		.loc 1 1117 1 view .LVU616
 2082 000c 02B0     		add	sp, sp, #8
ARM GAS  /tmp/ccNfEN49.s 			page 85


 2083              	.LCFI40:
 2084              		.cfi_remember_state
 2085              		.cfi_def_cfa_offset 8
 2086              		@ sp needed
 2087 000e 10BD     		pop	{r4, pc}
 2088              	.L116:
 2089              	.LCFI41:
 2090              		.cfi_restore_state
1069:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2091              		.loc 1 1069 5 is_stmt 1 view .LVU617
1069:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2092              		.loc 1 1069 10 is_stmt 0 view .LVU618
 2093 0010 0023     		movs	r3, #0
1070:Src/mpu6050.c ****         return -1;
 2094              		.loc 1 1070 9 view .LVU619
 2095 0012 D4E90010 		ldrd	r1, r0, [r4]
1069:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
 2096              		.loc 1 1069 10 view .LVU620
 2097 0016 8DF80730 		strb	r3, [sp, #7]
1070:Src/mpu6050.c ****         return -1;
 2098              		.loc 1 1070 5 is_stmt 1 view .LVU621
1070:Src/mpu6050.c ****         return -1;
 2099              		.loc 1 1070 9 is_stmt 0 view .LVU622
 2100 001a 0122     		movs	r2, #1
 2101 001c 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2102 001e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2103 0020 0DF10703 		add	r3, sp, #7
 2104 0024 FFF7FEFF 		bl	i2c_writeBytes
 2105              	.LVL141:
1070:Src/mpu6050.c ****         return -1;
 2106              		.loc 1 1070 8 view .LVU623
 2107 0028 0028     		cmp	r0, #0
 2108 002a EDD1     		bne	.L118
1072:Src/mpu6050.c ****         return -1;
 2109              		.loc 1 1072 5 is_stmt 1 view .LVU624
1072:Src/mpu6050.c ****         return -1;
 2110              		.loc 1 1072 9 is_stmt 0 view .LVU625
 2111 002c D4E90010 		ldrd	r1, r0, [r4]
 2112 0030 0122     		movs	r2, #1
 2113 0032 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 2114 0034 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2115 0036 0DF10703 		add	r3, sp, #7
 2116 003a FFF7FEFF 		bl	i2c_writeBytes
 2117              	.LVL142:
1072:Src/mpu6050.c ****         return -1;
 2118              		.loc 1 1072 8 view .LVU626
 2119 003e 0028     		cmp	r0, #0
 2120 0040 E2D1     		bne	.L118
1074:Src/mpu6050.c ****         return -1;
 2121              		.loc 1 1074 5 is_stmt 1 view .LVU627
1074:Src/mpu6050.c ****         return -1;
 2122              		.loc 1 1074 9 is_stmt 0 view .LVU628
 2123 0042 D4E90010 		ldrd	r1, r0, [r4]
 2124 0046 0122     		movs	r2, #1
 2125 0048 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2126 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2127 004c 0DF10703 		add	r3, sp, #7
ARM GAS  /tmp/ccNfEN49.s 			page 86


 2128 0050 FFF7FEFF 		bl	i2c_writeBytes
 2129              	.LVL143:
1074:Src/mpu6050.c ****         return -1;
 2130              		.loc 1 1074 8 view .LVU629
 2131 0054 0028     		cmp	r0, #0
 2132 0056 D7D1     		bne	.L118
1077:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
 2133              		.loc 1 1077 5 is_stmt 1 view .LVU630
1079:Src/mpu6050.c ****             return -1;
 2134              		.loc 1 1079 13 is_stmt 0 view .LVU631
 2135 0058 D4E90030 		ldrd	r3, r0, [r4]
 2136 005c 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
1077:Src/mpu6050.c ****         data = BIT_FIFO_RST | BIT_DMP_RST;
 2137              		.loc 1 1077 8 view .LVU632
 2138 005e 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 2139 0062 002B     		cmp	r3, #0
 2140 0064 42D0     		beq	.L119
1078:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2141              		.loc 1 1078 9 is_stmt 1 view .LVU633
1078:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2142              		.loc 1 1078 14 is_stmt 0 view .LVU634
 2143 0066 0C23     		movs	r3, #12
 2144 0068 8DF80730 		strb	r3, [sp, #7]
1079:Src/mpu6050.c ****             return -1;
 2145              		.loc 1 1079 9 is_stmt 1 view .LVU635
1079:Src/mpu6050.c ****             return -1;
 2146              		.loc 1 1079 13 is_stmt 0 view .LVU636
 2147 006c 0122     		movs	r2, #1
 2148 006e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2149 0070 0DF10703 		add	r3, sp, #7
 2150 0074 FFF7FEFF 		bl	i2c_writeBytes
 2151              	.LVL144:
1079:Src/mpu6050.c ****             return -1;
 2152              		.loc 1 1079 12 view .LVU637
 2153 0078 0028     		cmp	r0, #0
 2154 007a C5D1     		bne	.L118
1081:Src/mpu6050.c ****         data = BIT_DMP_EN | BIT_FIFO_EN;
 2155              		.loc 1 1081 9 is_stmt 1 view .LVU638
 2156 007c 3220     		movs	r0, #50
 2157 007e FFF7FEFF 		bl	delay_1ms
 2158              	.LVL145:
1082:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
 2159              		.loc 1 1082 9 view .LVU639
1085:Src/mpu6050.c ****             return -1;
 2160              		.loc 1 1085 13 is_stmt 0 view .LVU640
 2161 0082 D4E90010 		ldrd	r1, r0, [r4]
1082:Src/mpu6050.c ****         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
 2162              		.loc 1 1082 14 view .LVU641
 2163 0086 C023     		movs	r3, #192
 2164 0088 8DF80730 		strb	r3, [sp, #7]
1083:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2165              		.loc 1 1083 9 is_stmt 1 view .LVU642
1083:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2166              		.loc 1 1083 12 is_stmt 0 view .LVU643
 2167 008c A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
1085:Src/mpu6050.c ****             return -1;
 2168              		.loc 1 1085 13 view .LVU644
ARM GAS  /tmp/ccNfEN49.s 			page 87


 2169 008e 0122     		movs	r2, #1
1083:Src/mpu6050.c ****             data |= BIT_AUX_IF_EN;
 2170              		.loc 1 1083 12 view .LVU645
 2171 0090 DB07     		lsls	r3, r3, #31
1084:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2172              		.loc 1 1084 13 is_stmt 1 view .LVU646
1084:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2173              		.loc 1 1084 18 is_stmt 0 view .LVU647
 2174 0092 44BF     		itt	mi
 2175 0094 E023     		movmi	r3, #224
 2176 0096 8DF80730 		strbmi	r3, [sp, #7]
1085:Src/mpu6050.c ****             return -1;
 2177              		.loc 1 1085 9 is_stmt 1 view .LVU648
1085:Src/mpu6050.c ****             return -1;
 2178              		.loc 1 1085 13 is_stmt 0 view .LVU649
 2179 009a 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2180 009c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2181 009e 0DF10703 		add	r3, sp, #7
 2182 00a2 FFF7FEFF 		bl	i2c_writeBytes
 2183              	.LVL146:
1085:Src/mpu6050.c ****             return -1;
 2184              		.loc 1 1085 12 view .LVU650
 2185 00a6 0028     		cmp	r0, #0
 2186 00a8 AED1     		bne	.L118
1087:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
 2187              		.loc 1 1087 9 is_stmt 1 view .LVU651
1091:Src/mpu6050.c ****             return -1;
 2188              		.loc 1 1091 13 is_stmt 0 view .LVU652
 2189 00aa D4E90010 		ldrd	r1, r0, [r4]
1087:Src/mpu6050.c ****             data = BIT_DMP_INT_EN;
 2190              		.loc 1 1087 24 view .LVU653
 2191 00ae 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
1091:Src/mpu6050.c ****             return -1;
 2192              		.loc 1 1091 13 view .LVU654
 2193 00b0 0122     		movs	r2, #1
1088:Src/mpu6050.c ****         else
 2194              		.loc 1 1088 18 view .LVU655
 2195 00b2 002B     		cmp	r3, #0
 2196 00b4 18BF     		it	ne
 2197 00b6 0223     		movne	r3, #2
 2198 00b8 8DF80730 		strb	r3, [sp, #7]
1091:Src/mpu6050.c ****             return -1;
 2199              		.loc 1 1091 9 is_stmt 1 view .LVU656
1091:Src/mpu6050.c ****             return -1;
 2200              		.loc 1 1091 13 is_stmt 0 view .LVU657
 2201 00bc 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2202 00be 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2203 00c0 0DF10703 		add	r3, sp, #7
 2204 00c4 FFF7FEFF 		bl	i2c_writeBytes
 2205              	.LVL147:
1091:Src/mpu6050.c ****             return -1;
 2206              		.loc 1 1091 12 view .LVU658
 2207 00c8 0028     		cmp	r0, #0
 2208 00ca 9DD1     		bne	.L118
1093:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
 2209              		.loc 1 1093 9 is_stmt 1 view .LVU659
1094:Src/mpu6050.c ****             return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 88


 2210              		.loc 1 1094 13 is_stmt 0 view .LVU660
 2211 00cc 0DF10703 		add	r3, sp, #7
1093:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
 2212              		.loc 1 1093 14 view .LVU661
 2213 00d0 8DF80700 		strb	r0, [sp, #7]
1094:Src/mpu6050.c ****             return -1;
 2214              		.loc 1 1094 9 is_stmt 1 view .LVU662
1094:Src/mpu6050.c ****             return -1;
 2215              		.loc 1 1094 13 is_stmt 0 view .LVU663
 2216 00d4 D4E90010 		ldrd	r1, r0, [r4]
 2217              	.L129:
1113:Src/mpu6050.c ****             return -1;
 2218              		.loc 1 1113 13 view .LVU664
 2219 00d8 0122     		movs	r2, #1
 2220 00da 4979     		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 2221 00dc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2222 00de FFF7FEFF 		bl	i2c_writeBytes
 2223              	.LVL148:
1113:Src/mpu6050.c ****             return -1;
 2224              		.loc 1 1113 12 view .LVU665
 2225 00e2 0038     		subs	r0, r0, #0
 2226 00e4 18BF     		it	ne
 2227 00e6 0120     		movne	r0, #1
 2228 00e8 4042     		rsbs	r0, r0, #0
 2229 00ea 8FE7     		b	.L115
 2230              	.L119:
1097:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2231              		.loc 1 1097 9 is_stmt 1 view .LVU666
1097:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2232              		.loc 1 1097 14 is_stmt 0 view .LVU667
 2233 00ec 0423     		movs	r3, #4
 2234 00ee 8DF80730 		strb	r3, [sp, #7]
1098:Src/mpu6050.c ****             return -1;
 2235              		.loc 1 1098 9 is_stmt 1 view .LVU668
1098:Src/mpu6050.c ****             return -1;
 2236              		.loc 1 1098 13 is_stmt 0 view .LVU669
 2237 00f2 0122     		movs	r2, #1
 2238 00f4 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2239 00f6 0DF10703 		add	r3, sp, #7
 2240 00fa FFF7FEFF 		bl	i2c_writeBytes
 2241              	.LVL149:
1098:Src/mpu6050.c ****             return -1;
 2242              		.loc 1 1098 12 view .LVU670
 2243 00fe 0028     		cmp	r0, #0
 2244 0100 82D1     		bne	.L118
1100:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2245              		.loc 1 1100 9 is_stmt 1 view .LVU671
1100:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2246              		.loc 1 1100 12 is_stmt 0 view .LVU672
 2247 0102 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 2248 0104 63BB     		cbnz	r3, .L124
1100:Src/mpu6050.c ****             data = BIT_FIFO_EN;
 2249              		.loc 1 1100 37 discriminator 1 view .LVU673
 2250 0106 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
1103:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
 2251              		.loc 1 1103 18 discriminator 1 view .LVU674
 2252 0108 13F0010F 		tst	r3, #1
ARM GAS  /tmp/ccNfEN49.s 			page 89


 2253 010c 0CBF     		ite	eq
 2254 010e 4023     		moveq	r3, #64
 2255 0110 6023     		movne	r3, #96
 2256              	.L122:
1104:Src/mpu6050.c ****             return -1;
 2257              		.loc 1 1104 13 view .LVU675
 2258 0112 D4E90010 		ldrd	r1, r0, [r4]
 2259 0116 8DF80730 		strb	r3, [sp, #7]
1104:Src/mpu6050.c ****             return -1;
 2260              		.loc 1 1104 9 is_stmt 1 view .LVU676
1104:Src/mpu6050.c ****             return -1;
 2261              		.loc 1 1104 13 is_stmt 0 view .LVU677
 2262 011a 0122     		movs	r2, #1
 2263 011c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 2264 011e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2265 0120 0DF10703 		add	r3, sp, #7
 2266 0124 FFF7FEFF 		bl	i2c_writeBytes
 2267              	.LVL150:
1104:Src/mpu6050.c ****             return -1;
 2268              		.loc 1 1104 12 view .LVU678
 2269 0128 0028     		cmp	r0, #0
 2270 012a 7FF46DAF 		bne	.L118
1106:Src/mpu6050.c ****         if (st.chip_cfg.int_enable)
 2271              		.loc 1 1106 9 is_stmt 1 view .LVU679
 2272 012e 3220     		movs	r0, #50
 2273 0130 FFF7FEFF 		bl	delay_1ms
 2274              	.LVL151:
1107:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2275              		.loc 1 1107 9 view .LVU680
1111:Src/mpu6050.c ****             return -1;
 2276              		.loc 1 1111 13 is_stmt 0 view .LVU681
 2277 0134 D4E90010 		ldrd	r1, r0, [r4]
1107:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2278              		.loc 1 1107 12 view .LVU682
 2279 0138 637C     		ldrb	r3, [r4, #17]	@ zero_extendqisi2
1111:Src/mpu6050.c ****             return -1;
 2280              		.loc 1 1111 13 view .LVU683
 2281 013a 0122     		movs	r2, #1
1107:Src/mpu6050.c ****             data = BIT_DATA_RDY_EN;
 2282              		.loc 1 1107 12 view .LVU684
 2283 013c 003B     		subs	r3, r3, #0
 2284 013e 18BF     		it	ne
 2285 0140 0123     		movne	r3, #1
 2286 0142 8DF80730 		strb	r3, [sp, #7]
1111:Src/mpu6050.c ****             return -1;
 2287              		.loc 1 1111 9 is_stmt 1 view .LVU685
1111:Src/mpu6050.c ****             return -1;
 2288              		.loc 1 1111 13 is_stmt 0 view .LVU686
 2289 0146 497C     		ldrb	r1, [r1, #17]	@ zero_extendqisi2
 2290 0148 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2291 014a 0DF10703 		add	r3, sp, #7
 2292 014e FFF7FEFF 		bl	i2c_writeBytes
 2293              	.LVL152:
1111:Src/mpu6050.c ****             return -1;
 2294              		.loc 1 1111 12 view .LVU687
 2295 0152 0028     		cmp	r0, #0
 2296 0154 7FF458AF 		bne	.L118
ARM GAS  /tmp/ccNfEN49.s 			page 90


1113:Src/mpu6050.c ****             return -1;
 2297              		.loc 1 1113 9 is_stmt 1 view .LVU688
1113:Src/mpu6050.c ****             return -1;
 2298              		.loc 1 1113 13 is_stmt 0 view .LVU689
 2299 0158 D4E90010 		ldrd	r1, r0, [r4]
 2300 015c 024B     		ldr	r3, .L130+4
 2301 015e BBE7     		b	.L129
 2302              	.L124:
1101:Src/mpu6050.c ****         else
 2303              		.loc 1 1101 18 view .LVU690
 2304 0160 4023     		movs	r3, #64
 2305 0162 D6E7     		b	.L122
 2306              	.L131:
 2307              		.align	2
 2308              	.L130:
 2309 0164 00000000 		.word	.LANCHOR0
 2310 0168 10000000 		.word	.LANCHOR0+16
 2311              		.cfi_endproc
 2312              	.LFE73:
 2314              		.section	.text.mpu_get_gyro_fsr,"ax",%progbits
 2315              		.align	1
 2316              		.global	mpu_get_gyro_fsr
 2317              		.syntax unified
 2318              		.thumb
 2319              		.thumb_func
 2320              		.fpu softvfp
 2322              	mpu_get_gyro_fsr:
 2323              	.LVL153:
 2324              	.LFB74:
1125:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
 2325              		.loc 1 1125 1 is_stmt 1 view -0
 2326              		.cfi_startproc
 2327              		@ args = 0, pretend = 0, frame = 0
 2328              		@ frame_needed = 0, uses_anonymous_args = 0
 2329              		@ link register save eliminated.
1126:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2330              		.loc 1 1126 5 view .LVU692
1126:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2331              		.loc 1 1126 24 is_stmt 0 view .LVU693
 2332 0000 0B4B     		ldr	r3, .L141
1126:Src/mpu6050.c ****     case INV_FSR_250DPS:
 2333              		.loc 1 1126 5 view .LVU694
 2334 0002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2335 0004 032B     		cmp	r3, #3
 2336 0006 10D8     		bhi	.L133
 2337 0008 DFE803F0 		tbb	[pc, r3]
 2338              	.L135:
 2339 000c 02       		.byte	(.L138-.L135)/2
 2340 000d 06       		.byte	(.L137-.L135)/2
 2341 000e 09       		.byte	(.L136-.L135)/2
 2342 000f 0C       		.byte	(.L134-.L135)/2
 2343              		.p2align 1
 2344              	.L138:
1128:Src/mpu6050.c ****         break;
 2345              		.loc 1 1128 9 is_stmt 1 view .LVU695
1128:Src/mpu6050.c ****         break;
 2346              		.loc 1 1128 16 is_stmt 0 view .LVU696
ARM GAS  /tmp/ccNfEN49.s 			page 91


 2347 0010 FA23     		movs	r3, #250
 2348              	.L140:
1140:Src/mpu6050.c ****         break;
 2349              		.loc 1 1140 16 view .LVU697
 2350 0012 0380     		strh	r3, [r0]	@ movhi
1141:Src/mpu6050.c ****     }
 2351              		.loc 1 1141 9 is_stmt 1 view .LVU698
1143:Src/mpu6050.c **** }
 2352              		.loc 1 1143 5 view .LVU699
1144:Src/mpu6050.c **** 
 2353              		.loc 1 1144 1 is_stmt 0 view .LVU700
 2354 0014 0020     		movs	r0, #0
 2355              	.LVL154:
1144:Src/mpu6050.c **** 
 2356              		.loc 1 1144 1 view .LVU701
 2357 0016 7047     		bx	lr
 2358              	.LVL155:
 2359              	.L137:
1131:Src/mpu6050.c ****         break;
 2360              		.loc 1 1131 9 is_stmt 1 view .LVU702
1131:Src/mpu6050.c ****         break;
 2361              		.loc 1 1131 16 is_stmt 0 view .LVU703
 2362 0018 4FF4FA73 		mov	r3, #500
 2363 001c F9E7     		b	.L140
 2364              	.L136:
1134:Src/mpu6050.c ****         break;
 2365              		.loc 1 1134 9 is_stmt 1 view .LVU704
1134:Src/mpu6050.c ****         break;
 2366              		.loc 1 1134 16 is_stmt 0 view .LVU705
 2367 001e 4FF47A73 		mov	r3, #1000
 2368 0022 F6E7     		b	.L140
 2369              	.L134:
1137:Src/mpu6050.c ****         break;
 2370              		.loc 1 1137 9 is_stmt 1 view .LVU706
1137:Src/mpu6050.c ****         break;
 2371              		.loc 1 1137 16 is_stmt 0 view .LVU707
 2372 0024 4FF4FA63 		mov	r3, #2000
 2373 0028 F3E7     		b	.L140
 2374              	.L133:
1140:Src/mpu6050.c ****         break;
 2375              		.loc 1 1140 9 is_stmt 1 view .LVU708
1140:Src/mpu6050.c ****         break;
 2376              		.loc 1 1140 16 is_stmt 0 view .LVU709
 2377 002a 0023     		movs	r3, #0
 2378 002c F1E7     		b	.L140
 2379              	.L142:
 2380 002e 00BF     		.align	2
 2381              	.L141:
 2382 0030 00000000 		.word	.LANCHOR0
 2383              		.cfi_endproc
 2384              	.LFE74:
 2386              		.section	.text.mpu_set_gyro_fsr,"ax",%progbits
 2387              		.align	1
 2388              		.global	mpu_set_gyro_fsr
 2389              		.syntax unified
 2390              		.thumb
 2391              		.thumb_func
ARM GAS  /tmp/ccNfEN49.s 			page 92


 2392              		.fpu softvfp
 2394              	mpu_set_gyro_fsr:
 2395              	.LVL156:
 2396              	.LFB75:
1152:Src/mpu6050.c ****     unsigned char data;
 2397              		.loc 1 1152 1 is_stmt 1 view -0
 2398              		.cfi_startproc
 2399              		@ args = 0, pretend = 0, frame = 8
 2400              		@ frame_needed = 0, uses_anonymous_args = 0
1153:Src/mpu6050.c **** 
 2401              		.loc 1 1153 5 view .LVU711
1155:Src/mpu6050.c ****         return -1;
 2402              		.loc 1 1155 5 view .LVU712
1152:Src/mpu6050.c ****     unsigned char data;
 2403              		.loc 1 1152 1 is_stmt 0 view .LVU713
 2404 0000 13B5     		push	{r0, r1, r4, lr}
 2405              	.LCFI42:
 2406              		.cfi_def_cfa_offset 16
 2407              		.cfi_offset 4, -8
 2408              		.cfi_offset 14, -4
1155:Src/mpu6050.c ****         return -1;
 2409              		.loc 1 1155 22 view .LVU714
 2410 0002 1A4C     		ldr	r4, .L156
1155:Src/mpu6050.c ****         return -1;
 2411              		.loc 1 1155 8 view .LVU715
 2412 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2413 0006 1BB9     		cbnz	r3, .L144
 2414              	.LVL157:
 2415              	.L155:
1158:Src/mpu6050.c ****     case 250:
 2416              		.loc 1 1158 5 view .LVU716
 2417 0008 4FF0FF30 		mov	r0, #-1
 2418              	.L143:
1181:Src/mpu6050.c **** 
 2419              		.loc 1 1181 1 view .LVU717
 2420 000c 02B0     		add	sp, sp, #8
 2421              	.LCFI43:
 2422              		.cfi_remember_state
 2423              		.cfi_def_cfa_offset 8
 2424              		@ sp needed
 2425 000e 10BD     		pop	{r4, pc}
 2426              	.LVL158:
 2427              	.L144:
 2428              	.LCFI44:
 2429              		.cfi_restore_state
1158:Src/mpu6050.c ****     case 250:
 2430              		.loc 1 1158 5 is_stmt 1 view .LVU718
 2431 0010 B0F57A7F 		cmp	r0, #1000
 2432 0014 25D0     		beq	.L146
 2433 0016 06D8     		bhi	.L147
 2434 0018 FA28     		cmp	r0, #250
 2435 001a 09D0     		beq	.L148
 2436 001c B0F5FA7F 		cmp	r0, #500
 2437 0020 F2D1     		bne	.L155
1163:Src/mpu6050.c ****         break;
 2438              		.loc 1 1163 9 view .LVU719
1163:Src/mpu6050.c ****         break;
ARM GAS  /tmp/ccNfEN49.s 			page 93


 2439              		.loc 1 1163 14 is_stmt 0 view .LVU720
 2440 0022 0823     		movs	r3, #8
 2441 0024 05E0     		b	.L154
 2442              	.L147:
1158:Src/mpu6050.c ****     case 250:
 2443              		.loc 1 1158 5 view .LVU721
 2444 0026 B0F5FA6F 		cmp	r0, #2000
 2445 002a EDD1     		bne	.L155
1169:Src/mpu6050.c ****         break;
 2446              		.loc 1 1169 9 is_stmt 1 view .LVU722
1169:Src/mpu6050.c ****         break;
 2447              		.loc 1 1169 14 is_stmt 0 view .LVU723
 2448 002c 1823     		movs	r3, #24
 2449 002e 00E0     		b	.L154
 2450              	.L148:
1160:Src/mpu6050.c ****         break;
 2451              		.loc 1 1160 9 is_stmt 1 view .LVU724
1160:Src/mpu6050.c ****         break;
 2452              		.loc 1 1160 14 is_stmt 0 view .LVU725
 2453 0030 0023     		movs	r3, #0
 2454              	.L154:
1169:Src/mpu6050.c ****         break;
 2455              		.loc 1 1169 14 view .LVU726
 2456 0032 8DF80730 		strb	r3, [sp, #7]
1170:Src/mpu6050.c ****     default:
 2457              		.loc 1 1170 9 is_stmt 1 view .LVU727
1175:Src/mpu6050.c ****         return 0;
 2458              		.loc 1 1175 5 view .LVU728
1175:Src/mpu6050.c ****         return 0;
 2459              		.loc 1 1175 30 is_stmt 0 view .LVU729
 2460 0036 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
1175:Src/mpu6050.c ****         return 0;
 2461              		.loc 1 1175 8 view .LVU730
 2462 003a 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 2463 003c B3EBD20F 		cmp	r3, r2, lsr #3
 2464 0040 11D0     		beq	.L153
1177:Src/mpu6050.c ****         return -1;
 2465              		.loc 1 1177 5 is_stmt 1 view .LVU731
1177:Src/mpu6050.c ****         return -1;
 2466              		.loc 1 1177 9 is_stmt 0 view .LVU732
 2467 0042 D4E90010 		ldrd	r1, r0, [r4]
 2468              	.LVL159:
1177:Src/mpu6050.c ****         return -1;
 2469              		.loc 1 1177 9 view .LVU733
 2470 0046 0122     		movs	r2, #1
 2471 0048 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 2472 004a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2473 004c 0DF10703 		add	r3, sp, #7
 2474 0050 FFF7FEFF 		bl	i2c_writeBytes
 2475              	.LVL160:
1177:Src/mpu6050.c ****         return -1;
 2476              		.loc 1 1177 8 view .LVU734
 2477 0054 0028     		cmp	r0, #0
 2478 0056 D7D1     		bne	.L155
1179:Src/mpu6050.c ****     return 0;
 2479              		.loc 1 1179 5 is_stmt 1 view .LVU735
1179:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 94


 2480              		.loc 1 1179 26 is_stmt 0 view .LVU736
 2481 0058 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2482 005c DB08     		lsrs	r3, r3, #3
 2483 005e 2372     		strb	r3, [r4, #8]
1180:Src/mpu6050.c **** }
 2484              		.loc 1 1180 5 is_stmt 1 view .LVU737
1180:Src/mpu6050.c **** }
 2485              		.loc 1 1180 12 is_stmt 0 view .LVU738
 2486 0060 D4E7     		b	.L143
 2487              	.LVL161:
 2488              	.L146:
1166:Src/mpu6050.c ****         break;
 2489              		.loc 1 1166 9 is_stmt 1 view .LVU739
1166:Src/mpu6050.c ****         break;
 2490              		.loc 1 1166 14 is_stmt 0 view .LVU740
 2491 0062 1023     		movs	r3, #16
 2492 0064 E5E7     		b	.L154
 2493              	.L153:
1176:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
 2494              		.loc 1 1176 16 view .LVU741
 2495 0066 0020     		movs	r0, #0
 2496              	.LVL162:
1176:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
 2497              		.loc 1 1176 16 view .LVU742
 2498 0068 D0E7     		b	.L143
 2499              	.L157:
 2500 006a 00BF     		.align	2
 2501              	.L156:
 2502 006c 00000000 		.word	.LANCHOR0
 2503              		.cfi_endproc
 2504              	.LFE75:
 2506              		.section	.text.mpu_get_accel_fsr,"ax",%progbits
 2507              		.align	1
 2508              		.global	mpu_get_accel_fsr
 2509              		.syntax unified
 2510              		.thumb
 2511              		.thumb_func
 2512              		.fpu softvfp
 2514              	mpu_get_accel_fsr:
 2515              	.LVL163:
 2516              	.LFB76:
1189:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
 2517              		.loc 1 1189 1 is_stmt 1 view -0
 2518              		.cfi_startproc
 2519              		@ args = 0, pretend = 0, frame = 0
 2520              		@ frame_needed = 0, uses_anonymous_args = 0
 2521              		@ link register save eliminated.
1190:Src/mpu6050.c ****     case INV_FSR_2G:
 2522              		.loc 1 1190 5 view .LVU744
1190:Src/mpu6050.c ****     case INV_FSR_2G:
 2523              		.loc 1 1190 24 is_stmt 0 view .LVU745
 2524 0000 0C4B     		ldr	r3, .L170
1190:Src/mpu6050.c ****     case INV_FSR_2G:
 2525              		.loc 1 1190 5 view .LVU746
 2526 0002 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 2527 0004 032A     		cmp	r2, #3
 2528 0006 12D8     		bhi	.L166
ARM GAS  /tmp/ccNfEN49.s 			page 95


 2529 0008 DFE802F0 		tbb	[pc, r2]
 2530              	.L161:
 2531 000c 02       		.byte	(.L164-.L161)/2
 2532 000d 0B       		.byte	(.L163-.L161)/2
 2533 000e 0D       		.byte	(.L162-.L161)/2
 2534 000f 0F       		.byte	(.L160-.L161)/2
 2535              		.p2align 1
 2536              	.L164:
1192:Src/mpu6050.c ****         break;
 2537              		.loc 1 1192 9 is_stmt 1 view .LVU747
1192:Src/mpu6050.c ****         break;
 2538              		.loc 1 1192 16 is_stmt 0 view .LVU748
 2539 0010 0222     		movs	r2, #2
 2540              	.L168:
1201:Src/mpu6050.c ****         break;
 2541              		.loc 1 1201 16 view .LVU749
 2542 0012 0270     		strb	r2, [r0]
1202:Src/mpu6050.c ****     default:
 2543              		.loc 1 1202 9 is_stmt 1 view .LVU750
1206:Src/mpu6050.c ****         fsr[0] <<= 1;
 2544              		.loc 1 1206 5 view .LVU751
1206:Src/mpu6050.c ****         fsr[0] <<= 1;
 2545              		.loc 1 1206 8 is_stmt 0 view .LVU752
 2546 0014 DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 2547 0016 13B1     		cbz	r3, .L169
1207:Src/mpu6050.c ****     return 0;
 2548              		.loc 1 1207 9 is_stmt 1 view .LVU753
1207:Src/mpu6050.c ****     return 0;
 2549              		.loc 1 1207 16 is_stmt 0 view .LVU754
 2550 0018 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 2551 001a 5B00     		lsls	r3, r3, #1
 2552 001c 0370     		strb	r3, [r0]
 2553              	.L169:
1208:Src/mpu6050.c **** }
 2554              		.loc 1 1208 12 view .LVU755
 2555 001e 0020     		movs	r0, #0
 2556              	.LVL164:
1208:Src/mpu6050.c **** }
 2557              		.loc 1 1208 12 view .LVU756
 2558 0020 7047     		bx	lr
 2559              	.LVL165:
 2560              	.L163:
1195:Src/mpu6050.c ****         break;
 2561              		.loc 1 1195 9 is_stmt 1 view .LVU757
1195:Src/mpu6050.c ****         break;
 2562              		.loc 1 1195 16 is_stmt 0 view .LVU758
 2563 0022 0422     		movs	r2, #4
 2564 0024 F5E7     		b	.L168
 2565              	.L162:
1198:Src/mpu6050.c ****         break;
 2566              		.loc 1 1198 9 is_stmt 1 view .LVU759
1198:Src/mpu6050.c ****         break;
 2567              		.loc 1 1198 16 is_stmt 0 view .LVU760
 2568 0026 0822     		movs	r2, #8
 2569 0028 F3E7     		b	.L168
 2570              	.L160:
1201:Src/mpu6050.c ****         break;
ARM GAS  /tmp/ccNfEN49.s 			page 96


 2571              		.loc 1 1201 9 is_stmt 1 view .LVU761
1201:Src/mpu6050.c ****         break;
 2572              		.loc 1 1201 16 is_stmt 0 view .LVU762
 2573 002a 1022     		movs	r2, #16
 2574 002c F1E7     		b	.L168
 2575              	.L166:
1190:Src/mpu6050.c ****     case INV_FSR_2G:
 2576              		.loc 1 1190 5 view .LVU763
 2577 002e 4FF0FF30 		mov	r0, #-1
 2578              	.LVL166:
1190:Src/mpu6050.c ****     case INV_FSR_2G:
 2579              		.loc 1 1190 5 view .LVU764
 2580 0032 7047     		bx	lr
 2581              	.L171:
 2582              		.align	2
 2583              	.L170:
 2584 0034 00000000 		.word	.LANCHOR0
 2585              		.cfi_endproc
 2586              	.LFE76:
 2588              		.section	.text.mpu_set_accel_fsr,"ax",%progbits
 2589              		.align	1
 2590              		.global	mpu_set_accel_fsr
 2591              		.syntax unified
 2592              		.thumb
 2593              		.thumb_func
 2594              		.fpu softvfp
 2596              	mpu_set_accel_fsr:
 2597              	.LVL167:
 2598              	.LFB77:
1217:Src/mpu6050.c ****     unsigned char data;
 2599              		.loc 1 1217 1 is_stmt 1 view -0
 2600              		.cfi_startproc
 2601              		@ args = 0, pretend = 0, frame = 8
 2602              		@ frame_needed = 0, uses_anonymous_args = 0
1218:Src/mpu6050.c **** 
 2603              		.loc 1 1218 5 view .LVU766
1220:Src/mpu6050.c ****         return -1;
 2604              		.loc 1 1220 5 view .LVU767
1217:Src/mpu6050.c ****     unsigned char data;
 2605              		.loc 1 1217 1 is_stmt 0 view .LVU768
 2606 0000 13B5     		push	{r0, r1, r4, lr}
 2607              	.LCFI45:
 2608              		.cfi_def_cfa_offset 16
 2609              		.cfi_offset 4, -8
 2610              		.cfi_offset 14, -4
1220:Src/mpu6050.c ****         return -1;
 2611              		.loc 1 1220 22 view .LVU769
 2612 0002 184C     		ldr	r4, .L185
1220:Src/mpu6050.c ****         return -1;
 2613              		.loc 1 1220 8 view .LVU770
 2614 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2615 0006 1BB9     		cbnz	r3, .L173
 2616              	.LVL168:
 2617              	.L184:
1223:Src/mpu6050.c ****     case 2:
 2618              		.loc 1 1223 5 view .LVU771
 2619 0008 4FF0FF30 		mov	r0, #-1
ARM GAS  /tmp/ccNfEN49.s 			page 97


 2620              	.L172:
1246:Src/mpu6050.c **** 
 2621              		.loc 1 1246 1 view .LVU772
 2622 000c 02B0     		add	sp, sp, #8
 2623              	.LCFI46:
 2624              		.cfi_remember_state
 2625              		.cfi_def_cfa_offset 8
 2626              		@ sp needed
 2627 000e 10BD     		pop	{r4, pc}
 2628              	.LVL169:
 2629              	.L173:
 2630              	.LCFI47:
 2631              		.cfi_restore_state
1223:Src/mpu6050.c ****     case 2:
 2632              		.loc 1 1223 5 is_stmt 1 view .LVU773
 2633 0010 0828     		cmp	r0, #8
 2634 0012 23D0     		beq	.L175
 2635 0014 05D8     		bhi	.L176
 2636 0016 0228     		cmp	r0, #2
 2637 0018 07D0     		beq	.L177
 2638 001a 0428     		cmp	r0, #4
 2639 001c F4D1     		bne	.L184
1228:Src/mpu6050.c ****         break;
 2640              		.loc 1 1228 9 view .LVU774
1228:Src/mpu6050.c ****         break;
 2641              		.loc 1 1228 14 is_stmt 0 view .LVU775
 2642 001e 0823     		movs	r3, #8
 2643 0020 04E0     		b	.L183
 2644              	.L176:
1223:Src/mpu6050.c ****     case 2:
 2645              		.loc 1 1223 5 view .LVU776
 2646 0022 1028     		cmp	r0, #16
 2647 0024 F0D1     		bne	.L184
1234:Src/mpu6050.c ****         break;
 2648              		.loc 1 1234 9 is_stmt 1 view .LVU777
1234:Src/mpu6050.c ****         break;
 2649              		.loc 1 1234 14 is_stmt 0 view .LVU778
 2650 0026 1823     		movs	r3, #24
 2651 0028 00E0     		b	.L183
 2652              	.L177:
1225:Src/mpu6050.c ****         break;
 2653              		.loc 1 1225 9 is_stmt 1 view .LVU779
1225:Src/mpu6050.c ****         break;
 2654              		.loc 1 1225 14 is_stmt 0 view .LVU780
 2655 002a 0023     		movs	r3, #0
 2656              	.L183:
1234:Src/mpu6050.c ****         break;
 2657              		.loc 1 1234 14 view .LVU781
 2658 002c 8DF80730 		strb	r3, [sp, #7]
1235:Src/mpu6050.c ****     default:
 2659              		.loc 1 1235 9 is_stmt 1 view .LVU782
1240:Src/mpu6050.c ****         return 0;
 2660              		.loc 1 1240 5 view .LVU783
1240:Src/mpu6050.c ****         return 0;
 2661              		.loc 1 1240 31 is_stmt 0 view .LVU784
 2662 0030 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
1240:Src/mpu6050.c ****         return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 98


 2663              		.loc 1 1240 8 view .LVU785
 2664 0034 637A     		ldrb	r3, [r4, #9]	@ zero_extendqisi2
 2665 0036 B3EBD20F 		cmp	r3, r2, lsr #3
 2666 003a 11D0     		beq	.L182
1242:Src/mpu6050.c ****         return -1;
 2667              		.loc 1 1242 5 is_stmt 1 view .LVU786
1242:Src/mpu6050.c ****         return -1;
 2668              		.loc 1 1242 9 is_stmt 0 view .LVU787
 2669 003c D4E90010 		ldrd	r1, r0, [r4]
 2670              	.LVL170:
1242:Src/mpu6050.c ****         return -1;
 2671              		.loc 1 1242 9 view .LVU788
 2672 0040 0122     		movs	r2, #1
 2673 0042 C979     		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 2674 0044 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2675 0046 0DF10703 		add	r3, sp, #7
 2676 004a FFF7FEFF 		bl	i2c_writeBytes
 2677              	.LVL171:
1242:Src/mpu6050.c ****         return -1;
 2678              		.loc 1 1242 8 view .LVU789
 2679 004e 0028     		cmp	r0, #0
 2680 0050 DAD1     		bne	.L184
1244:Src/mpu6050.c ****     return 0;
 2681              		.loc 1 1244 5 is_stmt 1 view .LVU790
1244:Src/mpu6050.c ****     return 0;
 2682              		.loc 1 1244 27 is_stmt 0 view .LVU791
 2683 0052 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2684 0056 DB08     		lsrs	r3, r3, #3
 2685 0058 6372     		strb	r3, [r4, #9]
1245:Src/mpu6050.c **** }
 2686              		.loc 1 1245 5 is_stmt 1 view .LVU792
1245:Src/mpu6050.c **** }
 2687              		.loc 1 1245 12 is_stmt 0 view .LVU793
 2688 005a D7E7     		b	.L172
 2689              	.LVL172:
 2690              	.L175:
1231:Src/mpu6050.c ****         break;
 2691              		.loc 1 1231 9 is_stmt 1 view .LVU794
1231:Src/mpu6050.c ****         break;
 2692              		.loc 1 1231 14 is_stmt 0 view .LVU795
 2693 005c 1023     		movs	r3, #16
 2694 005e E5E7     		b	.L183
 2695              	.L182:
1241:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
 2696              		.loc 1 1241 16 view .LVU796
 2697 0060 0020     		movs	r0, #0
 2698              	.LVL173:
1241:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
 2699              		.loc 1 1241 16 view .LVU797
 2700 0062 D3E7     		b	.L172
 2701              	.L186:
 2702              		.align	2
 2703              	.L185:
 2704 0064 00000000 		.word	.LANCHOR0
 2705              		.cfi_endproc
 2706              	.LFE77:
 2708              		.section	.text.mpu_get_lpf,"ax",%progbits
ARM GAS  /tmp/ccNfEN49.s 			page 99


 2709              		.align	1
 2710              		.global	mpu_get_lpf
 2711              		.syntax unified
 2712              		.thumb
 2713              		.thumb_func
 2714              		.fpu softvfp
 2716              	mpu_get_lpf:
 2717              	.LVL174:
 2718              	.LFB78:
1254:Src/mpu6050.c ****     switch (st.chip_cfg.lpf) {
 2719              		.loc 1 1254 1 is_stmt 1 view -0
 2720              		.cfi_startproc
 2721              		@ args = 0, pretend = 0, frame = 0
 2722              		@ frame_needed = 0, uses_anonymous_args = 0
 2723              		@ link register save eliminated.
1255:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2724              		.loc 1 1255 5 view .LVU799
1255:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2725              		.loc 1 1255 24 is_stmt 0 view .LVU800
 2726 0000 0C4B     		ldr	r3, .L198
1255:Src/mpu6050.c ****     case INV_FILTER_188HZ:
 2727              		.loc 1 1255 5 view .LVU801
 2728 0002 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 2729 0004 013B     		subs	r3, r3, #1
 2730 0006 052B     		cmp	r3, #5
 2731 0008 12D8     		bhi	.L188
 2732 000a DFE803F0 		tbb	[pc, r3]
 2733              	.L190:
 2734 000e 03       		.byte	(.L195-.L190)/2
 2735 000f 07       		.byte	(.L194-.L190)/2
 2736 0010 09       		.byte	(.L193-.L190)/2
 2737 0011 0B       		.byte	(.L192-.L190)/2
 2738 0012 0D       		.byte	(.L191-.L190)/2
 2739 0013 0F       		.byte	(.L189-.L190)/2
 2740              		.p2align 1
 2741              	.L195:
1257:Src/mpu6050.c ****         break;
 2742              		.loc 1 1257 9 is_stmt 1 view .LVU802
1257:Src/mpu6050.c ****         break;
 2743              		.loc 1 1257 16 is_stmt 0 view .LVU803
 2744 0014 BC23     		movs	r3, #188
 2745              	.L197:
1277:Src/mpu6050.c ****         break;
 2746              		.loc 1 1277 16 view .LVU804
 2747 0016 0380     		strh	r3, [r0]	@ movhi
1278:Src/mpu6050.c ****     }
 2748              		.loc 1 1278 9 is_stmt 1 view .LVU805
1280:Src/mpu6050.c **** }
 2749              		.loc 1 1280 5 view .LVU806
1281:Src/mpu6050.c **** 
 2750              		.loc 1 1281 1 is_stmt 0 view .LVU807
 2751 0018 0020     		movs	r0, #0
 2752              	.LVL175:
1281:Src/mpu6050.c **** 
 2753              		.loc 1 1281 1 view .LVU808
 2754 001a 7047     		bx	lr
 2755              	.LVL176:
ARM GAS  /tmp/ccNfEN49.s 			page 100


 2756              	.L194:
1260:Src/mpu6050.c ****         break;
 2757              		.loc 1 1260 9 is_stmt 1 view .LVU809
1260:Src/mpu6050.c ****         break;
 2758              		.loc 1 1260 16 is_stmt 0 view .LVU810
 2759 001c 6223     		movs	r3, #98
 2760 001e FAE7     		b	.L197
 2761              	.L193:
1263:Src/mpu6050.c ****         break;
 2762              		.loc 1 1263 9 is_stmt 1 view .LVU811
1263:Src/mpu6050.c ****         break;
 2763              		.loc 1 1263 16 is_stmt 0 view .LVU812
 2764 0020 2A23     		movs	r3, #42
 2765 0022 F8E7     		b	.L197
 2766              	.L192:
1266:Src/mpu6050.c ****         break;
 2767              		.loc 1 1266 9 is_stmt 1 view .LVU813
1266:Src/mpu6050.c ****         break;
 2768              		.loc 1 1266 16 is_stmt 0 view .LVU814
 2769 0024 1423     		movs	r3, #20
 2770 0026 F6E7     		b	.L197
 2771              	.L191:
1269:Src/mpu6050.c ****         break;
 2772              		.loc 1 1269 9 is_stmt 1 view .LVU815
1269:Src/mpu6050.c ****         break;
 2773              		.loc 1 1269 16 is_stmt 0 view .LVU816
 2774 0028 0A23     		movs	r3, #10
 2775 002a F4E7     		b	.L197
 2776              	.L189:
1272:Src/mpu6050.c ****         break;
 2777              		.loc 1 1272 9 is_stmt 1 view .LVU817
1272:Src/mpu6050.c ****         break;
 2778              		.loc 1 1272 16 is_stmt 0 view .LVU818
 2779 002c 0523     		movs	r3, #5
 2780 002e F2E7     		b	.L197
 2781              	.L188:
1277:Src/mpu6050.c ****         break;
 2782              		.loc 1 1277 9 is_stmt 1 view .LVU819
1277:Src/mpu6050.c ****         break;
 2783              		.loc 1 1277 16 is_stmt 0 view .LVU820
 2784 0030 0023     		movs	r3, #0
 2785 0032 F0E7     		b	.L197
 2786              	.L199:
 2787              		.align	2
 2788              	.L198:
 2789 0034 00000000 		.word	.LANCHOR0
 2790              		.cfi_endproc
 2791              	.LFE78:
 2793              		.section	.text.mpu_set_lpf,"ax",%progbits
 2794              		.align	1
 2795              		.global	mpu_set_lpf
 2796              		.syntax unified
 2797              		.thumb
 2798              		.thumb_func
 2799              		.fpu softvfp
 2801              	mpu_set_lpf:
 2802              	.LVL177:
ARM GAS  /tmp/ccNfEN49.s 			page 101


 2803              	.LFB79:
1290:Src/mpu6050.c ****     unsigned char data;
 2804              		.loc 1 1290 1 is_stmt 1 view -0
 2805              		.cfi_startproc
 2806              		@ args = 0, pretend = 0, frame = 8
 2807              		@ frame_needed = 0, uses_anonymous_args = 0
1291:Src/mpu6050.c **** 
 2808              		.loc 1 1291 5 view .LVU822
1293:Src/mpu6050.c ****         return -1;
 2809              		.loc 1 1293 5 view .LVU823
1290:Src/mpu6050.c ****     unsigned char data;
 2810              		.loc 1 1290 1 is_stmt 0 view .LVU824
 2811 0000 13B5     		push	{r0, r1, r4, lr}
 2812              	.LCFI48:
 2813              		.cfi_def_cfa_offset 16
 2814              		.cfi_offset 4, -8
 2815              		.cfi_offset 14, -4
1293:Src/mpu6050.c ****         return -1;
 2816              		.loc 1 1293 22 view .LVU825
 2817 0002 194C     		ldr	r4, .L212
1293:Src/mpu6050.c ****         return -1;
 2818              		.loc 1 1293 8 view .LVU826
 2819 0004 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2820 0006 1BB9     		cbnz	r3, .L201
 2821              	.LVL178:
 2822              	.L209:
1294:Src/mpu6050.c **** 
 2823              		.loc 1 1294 16 view .LVU827
 2824 0008 4FF0FF30 		mov	r0, #-1
 2825              	.L200:
1315:Src/mpu6050.c **** 
 2826              		.loc 1 1315 1 view .LVU828
 2827 000c 02B0     		add	sp, sp, #8
 2828              	.LCFI49:
 2829              		.cfi_remember_state
 2830              		.cfi_def_cfa_offset 8
 2831              		@ sp needed
 2832 000e 10BD     		pop	{r4, pc}
 2833              	.LVL179:
 2834              	.L201:
 2835              	.LCFI50:
 2836              		.cfi_restore_state
1296:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
 2837              		.loc 1 1296 5 is_stmt 1 view .LVU829
1296:Src/mpu6050.c ****         data = INV_FILTER_188HZ;
 2838              		.loc 1 1296 8 is_stmt 0 view .LVU830
 2839 0010 BB28     		cmp	r0, #187
 2840 0012 16D9     		bls	.L203
1297:Src/mpu6050.c ****     else if (lpf >= 98)
 2841              		.loc 1 1297 9 is_stmt 1 view .LVU831
1297:Src/mpu6050.c ****     else if (lpf >= 98)
 2842              		.loc 1 1297 14 is_stmt 0 view .LVU832
 2843 0014 0123     		movs	r3, #1
 2844              	.L211:
1307:Src/mpu6050.c **** 
 2845              		.loc 1 1307 14 view .LVU833
 2846 0016 8DF80730 		strb	r3, [sp, #7]
ARM GAS  /tmp/ccNfEN49.s 			page 102


1309:Src/mpu6050.c ****         return 0;
 2847              		.loc 1 1309 5 is_stmt 1 view .LVU834
1309:Src/mpu6050.c ****         return 0;
 2848              		.loc 1 1309 8 is_stmt 0 view .LVU835
 2849 001a E27A     		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 2850 001c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2851 0020 9A42     		cmp	r2, r3
 2852 0022 1FD0     		beq	.L210
1311:Src/mpu6050.c ****         return -1;
 2853              		.loc 1 1311 5 is_stmt 1 view .LVU836
1311:Src/mpu6050.c ****         return -1;
 2854              		.loc 1 1311 9 is_stmt 0 view .LVU837
 2855 0024 D4E90010 		ldrd	r1, r0, [r4]
 2856              	.LVL180:
1311:Src/mpu6050.c ****         return -1;
 2857              		.loc 1 1311 9 view .LVU838
 2858 0028 0122     		movs	r2, #1
 2859 002a 8978     		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 2860 002c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 2861 002e 0DF10703 		add	r3, sp, #7
 2862 0032 FFF7FEFF 		bl	i2c_writeBytes
 2863              	.LVL181:
1311:Src/mpu6050.c ****         return -1;
 2864              		.loc 1 1311 8 view .LVU839
 2865 0036 0028     		cmp	r0, #0
 2866 0038 E6D1     		bne	.L209
1313:Src/mpu6050.c ****     return 0;
 2867              		.loc 1 1313 5 is_stmt 1 view .LVU840
1313:Src/mpu6050.c ****     return 0;
 2868              		.loc 1 1313 21 is_stmt 0 view .LVU841
 2869 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2870 003e E372     		strb	r3, [r4, #11]
1314:Src/mpu6050.c **** }
 2871              		.loc 1 1314 5 is_stmt 1 view .LVU842
1314:Src/mpu6050.c **** }
 2872              		.loc 1 1314 12 is_stmt 0 view .LVU843
 2873 0040 E4E7     		b	.L200
 2874              	.LVL182:
 2875              	.L203:
1298:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
 2876              		.loc 1 1298 10 is_stmt 1 view .LVU844
1298:Src/mpu6050.c ****         data = INV_FILTER_98HZ;
 2877              		.loc 1 1298 13 is_stmt 0 view .LVU845
 2878 0042 6128     		cmp	r0, #97
 2879 0044 01D9     		bls	.L205
1299:Src/mpu6050.c ****     else if (lpf >= 42)
 2880              		.loc 1 1299 9 is_stmt 1 view .LVU846
1299:Src/mpu6050.c ****     else if (lpf >= 42)
 2881              		.loc 1 1299 14 is_stmt 0 view .LVU847
 2882 0046 0223     		movs	r3, #2
 2883 0048 E5E7     		b	.L211
 2884              	.L205:
1300:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
 2885              		.loc 1 1300 10 is_stmt 1 view .LVU848
1300:Src/mpu6050.c ****         data = INV_FILTER_42HZ;
 2886              		.loc 1 1300 13 is_stmt 0 view .LVU849
 2887 004a 2928     		cmp	r0, #41
ARM GAS  /tmp/ccNfEN49.s 			page 103


 2888 004c 01D9     		bls	.L206
1301:Src/mpu6050.c ****     else if (lpf >= 20)
 2889              		.loc 1 1301 9 is_stmt 1 view .LVU850
1301:Src/mpu6050.c ****     else if (lpf >= 20)
 2890              		.loc 1 1301 14 is_stmt 0 view .LVU851
 2891 004e 0323     		movs	r3, #3
 2892 0050 E1E7     		b	.L211
 2893              	.L206:
1302:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
 2894              		.loc 1 1302 10 is_stmt 1 view .LVU852
1302:Src/mpu6050.c ****         data = INV_FILTER_20HZ;
 2895              		.loc 1 1302 13 is_stmt 0 view .LVU853
 2896 0052 1328     		cmp	r0, #19
 2897 0054 01D9     		bls	.L207
1303:Src/mpu6050.c ****     else if (lpf >= 10)
 2898              		.loc 1 1303 9 is_stmt 1 view .LVU854
1303:Src/mpu6050.c ****     else if (lpf >= 10)
 2899              		.loc 1 1303 14 is_stmt 0 view .LVU855
 2900 0056 0423     		movs	r3, #4
 2901 0058 DDE7     		b	.L211
 2902              	.L207:
1304:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
 2903              		.loc 1 1304 10 is_stmt 1 view .LVU856
1304:Src/mpu6050.c ****         data = INV_FILTER_10HZ;
 2904              		.loc 1 1304 13 is_stmt 0 view .LVU857
 2905 005a 0928     		cmp	r0, #9
1305:Src/mpu6050.c ****     else
 2906              		.loc 1 1305 9 is_stmt 1 view .LVU858
1305:Src/mpu6050.c ****     else
 2907              		.loc 1 1305 14 is_stmt 0 view .LVU859
 2908 005c 8CBF     		ite	hi
 2909 005e 0523     		movhi	r3, #5
1307:Src/mpu6050.c **** 
 2910              		.loc 1 1307 9 is_stmt 1 view .LVU860
1307:Src/mpu6050.c **** 
 2911              		.loc 1 1307 14 is_stmt 0 view .LVU861
 2912 0060 0623     		movls	r3, #6
 2913 0062 D8E7     		b	.L211
 2914              	.L210:
1310:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
 2915              		.loc 1 1310 16 view .LVU862
 2916 0064 0020     		movs	r0, #0
 2917              	.LVL183:
1310:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
 2918              		.loc 1 1310 16 view .LVU863
 2919 0066 D1E7     		b	.L200
 2920              	.L213:
 2921              		.align	2
 2922              	.L212:
 2923 0068 00000000 		.word	.LANCHOR0
 2924              		.cfi_endproc
 2925              	.LFE79:
 2927              		.section	.text.mpu_get_sample_rate,"ax",%progbits
 2928              		.align	1
 2929              		.global	mpu_get_sample_rate
 2930              		.syntax unified
 2931              		.thumb
ARM GAS  /tmp/ccNfEN49.s 			page 104


 2932              		.thumb_func
 2933              		.fpu softvfp
 2935              	mpu_get_sample_rate:
 2936              	.LVL184:
 2937              	.LFB80:
1323:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
 2938              		.loc 1 1323 1 is_stmt 1 view -0
 2939              		.cfi_startproc
 2940              		@ args = 0, pretend = 0, frame = 0
 2941              		@ frame_needed = 0, uses_anonymous_args = 0
 2942              		@ link register save eliminated.
1324:Src/mpu6050.c ****         return -1;
 2943              		.loc 1 1324 5 view .LVU865
1324:Src/mpu6050.c ****         return -1;
 2944              		.loc 1 1324 20 is_stmt 0 view .LVU866
 2945 0000 054A     		ldr	r2, .L217
1323:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on)
 2946              		.loc 1 1323 1 view .LVU867
 2947 0002 0346     		mov	r3, r0
1324:Src/mpu6050.c ****         return -1;
 2948              		.loc 1 1324 8 view .LVU868
 2949 0004 92F82400 		ldrb	r0, [r2, #36]	@ zero_extendqisi2
 2950              	.LVL185:
1324:Src/mpu6050.c ****         return -1;
 2951              		.loc 1 1324 8 view .LVU869
 2952 0008 10B9     		cbnz	r0, .L216
1327:Src/mpu6050.c ****     return 0;
 2953              		.loc 1 1327 9 is_stmt 1 view .LVU870
1327:Src/mpu6050.c ****     return 0;
 2954              		.loc 1 1327 30 is_stmt 0 view .LVU871
 2955 000a D289     		ldrh	r2, [r2, #14]
1327:Src/mpu6050.c ****     return 0;
 2956              		.loc 1 1327 17 view .LVU872
 2957 000c 1A80     		strh	r2, [r3]	@ movhi
1328:Src/mpu6050.c **** }
 2958              		.loc 1 1328 5 is_stmt 1 view .LVU873
1328:Src/mpu6050.c **** }
 2959              		.loc 1 1328 12 is_stmt 0 view .LVU874
 2960 000e 7047     		bx	lr
 2961              	.L216:
1325:Src/mpu6050.c ****     else
 2962              		.loc 1 1325 16 view .LVU875
 2963 0010 4FF0FF30 		mov	r0, #-1
1329:Src/mpu6050.c **** 
 2964              		.loc 1 1329 1 view .LVU876
 2965 0014 7047     		bx	lr
 2966              	.L218:
 2967 0016 00BF     		.align	2
 2968              	.L217:
 2969 0018 00000000 		.word	.LANCHOR0
 2970              		.cfi_endproc
 2971              	.LFE80:
 2973              		.section	.text.mpu_get_compass_sample_rate,"ax",%progbits
 2974              		.align	1
 2975              		.global	mpu_get_compass_sample_rate
 2976              		.syntax unified
 2977              		.thumb
ARM GAS  /tmp/ccNfEN49.s 			page 105


 2978              		.thumb_func
 2979              		.fpu softvfp
 2981              	mpu_get_compass_sample_rate:
 2982              	.LVL186:
 2983              	.LFB82:
1385:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 2984              		.loc 1 1385 1 is_stmt 1 view -0
 2985              		.cfi_startproc
 2986              		@ args = 0, pretend = 0, frame = 0
 2987              		@ frame_needed = 0, uses_anonymous_args = 0
 2988              		@ link register save eliminated.
1390:Src/mpu6050.c ****     return -1;
 2989              		.loc 1 1390 5 view .LVU878
1390:Src/mpu6050.c ****     return -1;
 2990              		.loc 1 1390 13 is_stmt 0 view .LVU879
 2991 0000 0023     		movs	r3, #0
 2992 0002 0380     		strh	r3, [r0]	@ movhi
1391:Src/mpu6050.c **** #endif
 2993              		.loc 1 1391 5 is_stmt 1 view .LVU880
1393:Src/mpu6050.c **** 
 2994              		.loc 1 1393 1 is_stmt 0 view .LVU881
 2995 0004 4FF0FF30 		mov	r0, #-1
 2996              	.LVL187:
1393:Src/mpu6050.c **** 
 2997              		.loc 1 1393 1 view .LVU882
 2998 0008 7047     		bx	lr
 2999              		.cfi_endproc
 3000              	.LFE82:
 3002              		.section	.text.mpu_set_compass_sample_rate,"ax",%progbits
 3003              		.align	1
 3004              		.global	mpu_set_compass_sample_rate
 3005              		.syntax unified
 3006              		.thumb
 3007              		.thumb_func
 3008              		.fpu softvfp
 3010              	mpu_set_compass_sample_rate:
 3011              	.LVL188:
 3012              	.LFB83:
1407:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 3013              		.loc 1 1407 1 is_stmt 1 view -0
 3014              		.cfi_startproc
 3015              		@ args = 0, pretend = 0, frame = 0
 3016              		@ frame_needed = 0, uses_anonymous_args = 0
 3017              		@ link register save eliminated.
1419:Src/mpu6050.c **** #endif
 3018              		.loc 1 1419 5 view .LVU884
1421:Src/mpu6050.c **** 
 3019              		.loc 1 1421 1 is_stmt 0 view .LVU885
 3020 0000 4FF0FF30 		mov	r0, #-1
 3021              	.LVL189:
1421:Src/mpu6050.c **** 
 3022              		.loc 1 1421 1 view .LVU886
 3023 0004 7047     		bx	lr
 3024              		.cfi_endproc
 3025              	.LFE83:
 3027              		.section	.text.mpu_get_gyro_sens,"ax",%progbits
 3028              		.align	1
ARM GAS  /tmp/ccNfEN49.s 			page 106


 3029              		.global	mpu_get_gyro_sens
 3030              		.syntax unified
 3031              		.thumb
 3032              		.thumb_func
 3033              		.fpu softvfp
 3035              	mpu_get_gyro_sens:
 3036              	.LVL190:
 3037              	.LFB84:
1429:Src/mpu6050.c ****     switch (st.chip_cfg.gyro_fsr) {
 3038              		.loc 1 1429 1 is_stmt 1 view -0
 3039              		.cfi_startproc
 3040              		@ args = 0, pretend = 0, frame = 0
 3041              		@ frame_needed = 0, uses_anonymous_args = 0
 3042              		@ link register save eliminated.
1430:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3043              		.loc 1 1430 5 view .LVU888
1430:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3044              		.loc 1 1430 24 is_stmt 0 view .LVU889
 3045 0000 0A4B     		ldr	r3, .L230
1430:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3046              		.loc 1 1430 5 view .LVU890
 3047 0002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3048 0004 032B     		cmp	r3, #3
 3049 0006 0DD8     		bhi	.L228
 3050 0008 DFE803F0 		tbb	[pc, r3]
 3051              	.L224:
 3052 000c 02       		.byte	(.L227-.L224)/2
 3053 000d 06       		.byte	(.L226-.L224)/2
 3054 000e 08       		.byte	(.L225-.L224)/2
 3055 000f 0A       		.byte	(.L223-.L224)/2
 3056              		.p2align 1
 3057              	.L227:
1432:Src/mpu6050.c ****         break;
 3058              		.loc 1 1432 9 is_stmt 1 view .LVU891
1432:Src/mpu6050.c ****         break;
 3059              		.loc 1 1432 17 is_stmt 0 view .LVU892
 3060 0010 074B     		ldr	r3, .L230+4
 3061              	.L229:
1435:Src/mpu6050.c ****         break;
 3062              		.loc 1 1435 17 view .LVU893
 3063 0012 0360     		str	r3, [r0]	@ float
1436:Src/mpu6050.c ****     case INV_FSR_1000DPS:
 3064              		.loc 1 1436 9 is_stmt 1 view .LVU894
1446:Src/mpu6050.c **** }
 3065              		.loc 1 1446 12 is_stmt 0 view .LVU895
 3066 0014 0020     		movs	r0, #0
 3067              	.LVL191:
1436:Src/mpu6050.c ****     case INV_FSR_1000DPS:
 3068              		.loc 1 1436 9 view .LVU896
 3069 0016 7047     		bx	lr
 3070              	.LVL192:
 3071              	.L226:
1435:Src/mpu6050.c ****         break;
 3072              		.loc 1 1435 9 is_stmt 1 view .LVU897
1435:Src/mpu6050.c ****         break;
 3073              		.loc 1 1435 17 is_stmt 0 view .LVU898
 3074 0018 064B     		ldr	r3, .L230+8
ARM GAS  /tmp/ccNfEN49.s 			page 107


 3075 001a FAE7     		b	.L229
 3076              	.L225:
1438:Src/mpu6050.c ****         break;
 3077              		.loc 1 1438 9 is_stmt 1 view .LVU899
1438:Src/mpu6050.c ****         break;
 3078              		.loc 1 1438 17 is_stmt 0 view .LVU900
 3079 001c 064B     		ldr	r3, .L230+12
 3080 001e F8E7     		b	.L229
 3081              	.L223:
1441:Src/mpu6050.c ****         break;
 3082              		.loc 1 1441 9 is_stmt 1 view .LVU901
1441:Src/mpu6050.c ****         break;
 3083              		.loc 1 1441 17 is_stmt 0 view .LVU902
 3084 0020 064B     		ldr	r3, .L230+16
 3085 0022 F6E7     		b	.L229
 3086              	.L228:
1430:Src/mpu6050.c ****     case INV_FSR_250DPS:
 3087              		.loc 1 1430 5 view .LVU903
 3088 0024 4FF0FF30 		mov	r0, #-1
 3089              	.LVL193:
1447:Src/mpu6050.c **** 
 3090              		.loc 1 1447 1 view .LVU904
 3091 0028 7047     		bx	lr
 3092              	.L231:
 3093 002a 00BF     		.align	2
 3094              	.L230:
 3095 002c 00000000 		.word	.LANCHOR0
 3096 0030 00000343 		.word	1124270080
 3097 0034 00008342 		.word	1115881472
 3098 0038 33330342 		.word	1107505971
 3099 003c 33338341 		.word	1099117363
 3100              		.cfi_endproc
 3101              	.LFE84:
 3103              		.section	.text.mpu_get_accel_sens,"ax",%progbits
 3104              		.align	1
 3105              		.global	mpu_get_accel_sens
 3106              		.syntax unified
 3107              		.thumb
 3108              		.thumb_func
 3109              		.fpu softvfp
 3111              	mpu_get_accel_sens:
 3112              	.LVL194:
 3113              	.LFB85:
1455:Src/mpu6050.c ****     switch (st.chip_cfg.accel_fsr) {
 3114              		.loc 1 1455 1 is_stmt 1 view -0
 3115              		.cfi_startproc
 3116              		@ args = 0, pretend = 0, frame = 0
 3117              		@ frame_needed = 0, uses_anonymous_args = 0
 3118              		@ link register save eliminated.
1456:Src/mpu6050.c ****     case INV_FSR_2G:
 3119              		.loc 1 1456 5 view .LVU906
1456:Src/mpu6050.c ****     case INV_FSR_2G:
 3120              		.loc 1 1456 24 is_stmt 0 view .LVU907
 3121 0000 0E4B     		ldr	r3, .L244
1456:Src/mpu6050.c ****     case INV_FSR_2G:
 3122              		.loc 1 1456 5 view .LVU908
 3123 0002 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
ARM GAS  /tmp/ccNfEN49.s 			page 108


 3124 0004 032A     		cmp	r2, #3
 3125 0006 16D8     		bhi	.L240
 3126 0008 DFE802F0 		tbb	[pc, r2]
 3127              	.L235:
 3128 000c 02       		.byte	(.L238-.L235)/2
 3129 000d 0C       		.byte	(.L237-.L235)/2
 3130 000e 0F       		.byte	(.L236-.L235)/2
 3131 000f 12       		.byte	(.L234-.L235)/2
 3132              		.p2align 1
 3133              	.L238:
1458:Src/mpu6050.c ****         break;
 3134              		.loc 1 1458 9 is_stmt 1 view .LVU909
1458:Src/mpu6050.c ****         break;
 3135              		.loc 1 1458 17 is_stmt 0 view .LVU910
 3136 0010 4FF48042 		mov	r2, #16384
 3137              	.L242:
1467:Src/mpu6050.c ****         break;
 3138              		.loc 1 1467 17 view .LVU911
 3139 0014 0280     		strh	r2, [r0]	@ movhi
1468:Src/mpu6050.c ****     default:
 3140              		.loc 1 1468 9 is_stmt 1 view .LVU912
1472:Src/mpu6050.c ****         sens[0] >>= 1;
 3141              		.loc 1 1472 5 view .LVU913
1472:Src/mpu6050.c ****         sens[0] >>= 1;
 3142              		.loc 1 1472 8 is_stmt 0 view .LVU914
 3143 0016 DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 3144 0018 13B1     		cbz	r3, .L243
1473:Src/mpu6050.c ****     return 0;
 3145              		.loc 1 1473 9 is_stmt 1 view .LVU915
1473:Src/mpu6050.c ****     return 0;
 3146              		.loc 1 1473 17 is_stmt 0 view .LVU916
 3147 001a 0388     		ldrh	r3, [r0]
 3148 001c 5B08     		lsrs	r3, r3, #1
 3149 001e 0380     		strh	r3, [r0]	@ movhi
 3150              	.L243:
1474:Src/mpu6050.c **** }
 3151              		.loc 1 1474 12 view .LVU917
 3152 0020 0020     		movs	r0, #0
 3153              	.LVL195:
1474:Src/mpu6050.c **** }
 3154              		.loc 1 1474 12 view .LVU918
 3155 0022 7047     		bx	lr
 3156              	.LVL196:
 3157              	.L237:
1461:Src/mpu6050.c ****         break;
 3158              		.loc 1 1461 9 is_stmt 1 view .LVU919
1461:Src/mpu6050.c ****         break;
 3159              		.loc 1 1461 17 is_stmt 0 view .LVU920
 3160 0024 4FF40052 		mov	r2, #8192
 3161 0028 F4E7     		b	.L242
 3162              	.L236:
1464:Src/mpu6050.c ****         break;
 3163              		.loc 1 1464 9 is_stmt 1 view .LVU921
1464:Src/mpu6050.c ****         break;
 3164              		.loc 1 1464 17 is_stmt 0 view .LVU922
 3165 002a 4FF48052 		mov	r2, #4096
 3166 002e F1E7     		b	.L242
ARM GAS  /tmp/ccNfEN49.s 			page 109


 3167              	.L234:
1467:Src/mpu6050.c ****         break;
 3168              		.loc 1 1467 9 is_stmt 1 view .LVU923
1467:Src/mpu6050.c ****         break;
 3169              		.loc 1 1467 17 is_stmt 0 view .LVU924
 3170 0030 4FF40062 		mov	r2, #2048
 3171 0034 EEE7     		b	.L242
 3172              	.L240:
1456:Src/mpu6050.c ****     case INV_FSR_2G:
 3173              		.loc 1 1456 5 view .LVU925
 3174 0036 4FF0FF30 		mov	r0, #-1
 3175              	.LVL197:
1456:Src/mpu6050.c ****     case INV_FSR_2G:
 3176              		.loc 1 1456 5 view .LVU926
 3177 003a 7047     		bx	lr
 3178              	.L245:
 3179              		.align	2
 3180              	.L244:
 3181 003c 00000000 		.word	.LANCHOR0
 3182              		.cfi_endproc
 3183              	.LFE85:
 3185              		.section	.text.mpu_get_fifo_config,"ax",%progbits
 3186              		.align	1
 3187              		.global	mpu_get_fifo_config
 3188              		.syntax unified
 3189              		.thumb
 3190              		.thumb_func
 3191              		.fpu softvfp
 3193              	mpu_get_fifo_config:
 3194              	.LVL198:
 3195              	.LFB86:
1487:Src/mpu6050.c ****     sensors[0] = st.chip_cfg.fifo_enable;
 3196              		.loc 1 1487 1 is_stmt 1 view -0
 3197              		.cfi_startproc
 3198              		@ args = 0, pretend = 0, frame = 0
 3199              		@ frame_needed = 0, uses_anonymous_args = 0
 3200              		@ link register save eliminated.
1488:Src/mpu6050.c ****     return 0;
 3201              		.loc 1 1488 5 view .LVU928
1488:Src/mpu6050.c ****     return 0;
 3202              		.loc 1 1488 29 is_stmt 0 view .LVU929
 3203 0000 024B     		ldr	r3, .L247
 3204 0002 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
1488:Src/mpu6050.c ****     return 0;
 3205              		.loc 1 1488 16 view .LVU930
 3206 0004 0370     		strb	r3, [r0]
1489:Src/mpu6050.c **** }
 3207              		.loc 1 1489 5 is_stmt 1 view .LVU931
1490:Src/mpu6050.c **** 
 3208              		.loc 1 1490 1 is_stmt 0 view .LVU932
 3209 0006 0020     		movs	r0, #0
 3210              	.LVL199:
1490:Src/mpu6050.c **** 
 3211              		.loc 1 1490 1 view .LVU933
 3212 0008 7047     		bx	lr
 3213              	.L248:
 3214 000a 00BF     		.align	2
ARM GAS  /tmp/ccNfEN49.s 			page 110


 3215              	.L247:
 3216 000c 00000000 		.word	.LANCHOR0
 3217              		.cfi_endproc
 3218              	.LFE86:
 3220              		.section	.text.mpu_configure_fifo,"ax",%progbits
 3221              		.align	1
 3222              		.global	mpu_configure_fifo
 3223              		.syntax unified
 3224              		.thumb
 3225              		.thumb_func
 3226              		.fpu softvfp
 3228              	mpu_configure_fifo:
 3229              	.LVL200:
 3230              	.LFB87:
1502:Src/mpu6050.c ****     unsigned char prev;
 3231              		.loc 1 1502 1 is_stmt 1 view -0
 3232              		.cfi_startproc
 3233              		@ args = 0, pretend = 0, frame = 0
 3234              		@ frame_needed = 0, uses_anonymous_args = 0
1503:Src/mpu6050.c ****     int result = 0;
 3235              		.loc 1 1503 5 view .LVU935
1504:Src/mpu6050.c **** 
 3236              		.loc 1 1504 5 view .LVU936
1507:Src/mpu6050.c **** 
 3237              		.loc 1 1507 5 view .LVU937
1509:Src/mpu6050.c ****         return 0;
 3238              		.loc 1 1509 5 view .LVU938
1502:Src/mpu6050.c ****     unsigned char prev;
 3239              		.loc 1 1502 1 is_stmt 0 view .LVU939
 3240 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3241              	.LCFI51:
 3242              		.cfi_def_cfa_offset 24
 3243              		.cfi_offset 3, -24
 3244              		.cfi_offset 4, -20
 3245              		.cfi_offset 5, -16
 3246              		.cfi_offset 6, -12
 3247              		.cfi_offset 7, -8
 3248              		.cfi_offset 14, -4
1509:Src/mpu6050.c ****         return 0;
 3249              		.loc 1 1509 20 view .LVU940
 3250 0002 114E     		ldr	r6, .L258
1509:Src/mpu6050.c ****         return 0;
 3251              		.loc 1 1509 8 view .LVU941
 3252 0004 96F82430 		ldrb	r3, [r6, #36]	@ zero_extendqisi2
 3253 0008 E3B9     		cbnz	r3, .L253
1512:Src/mpu6050.c ****             return -1;
 3254              		.loc 1 1512 9 is_stmt 1 view .LVU942
1512:Src/mpu6050.c ****             return -1;
 3255              		.loc 1 1512 26 is_stmt 0 view .LVU943
 3256 000a B47A     		ldrb	r4, [r6, #10]	@ zero_extendqisi2
1512:Src/mpu6050.c ****             return -1;
 3257              		.loc 1 1512 12 view .LVU944
 3258 000c 9CB1     		cbz	r4, .L254
1507:Src/mpu6050.c **** 
 3259              		.loc 1 1507 13 view .LVU945
 3260 000e 00F0FE05 		and	r5, r0, #254
1514:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
ARM GAS  /tmp/ccNfEN49.s 			page 111


 3261              		.loc 1 1514 9 is_stmt 1 view .LVU946
1515:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3262              		.loc 1 1515 33 is_stmt 0 view .LVU947
 3263 0012 2C40     		ands	r4, r4, r5
1523:Src/mpu6050.c ****             set_int_enable(1);
 3264              		.loc 1 1523 21 view .LVU948
 3265 0014 307D     		ldrb	r0, [r6, #20]	@ zero_extendqisi2
 3266              	.LVL201:
1514:Src/mpu6050.c ****         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
 3267              		.loc 1 1514 14 view .LVU949
 3268 0016 377C     		ldrb	r7, [r6, #16]	@ zero_extendqisi2
 3269              	.LVL202:
1515:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3270              		.loc 1 1515 9 is_stmt 1 view .LVU950
1515:Src/mpu6050.c ****         if (st.chip_cfg.fifo_enable != sensors)
 3271              		.loc 1 1515 33 is_stmt 0 view .LVU951
 3272 0018 3474     		strb	r4, [r6, #16]
1516:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
 3273              		.loc 1 1516 9 is_stmt 1 view .LVU952
1516:Src/mpu6050.c ****             /* You're not getting what you asked for. Some sensors are
 3274              		.loc 1 1516 12 is_stmt 0 view .LVU953
 3275 001a 641B     		subs	r4, r4, r5
 3276 001c 18BF     		it	ne
 3277 001e 4FF0FF34 		movne	r4, #-1
 3278              	.LVL203:
1523:Src/mpu6050.c ****             set_int_enable(1);
 3279              		.loc 1 1523 9 is_stmt 1 view .LVU954
1523:Src/mpu6050.c ****             set_int_enable(1);
 3280              		.loc 1 1523 21 is_stmt 0 view .LVU955
 3281 0022 2843     		orrs	r0, r0, r5
 3282 0024 0AD0     		beq	.L251
1524:Src/mpu6050.c ****         else
 3283              		.loc 1 1524 13 is_stmt 1 view .LVU956
 3284 0026 0120     		movs	r0, #1
 3285 0028 FFF7FEFF 		bl	set_int_enable.isra.0
 3286              	.LVL204:
1527:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3287              		.loc 1 1527 9 view .LVU957
1527:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3288              		.loc 1 1527 12 is_stmt 0 view .LVU958
 3289 002c 45B1     		cbz	r5, .L249
1528:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3290              		.loc 1 1528 13 is_stmt 1 view .LVU959
1528:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3291              		.loc 1 1528 17 is_stmt 0 view .LVU960
 3292 002e FFF7FEFF 		bl	mpu_reset_fifo
 3293              	.LVL205:
1528:Src/mpu6050.c ****                 st.chip_cfg.fifo_enable = prev;
 3294              		.loc 1 1528 16 view .LVU961
 3295 0032 28B1     		cbz	r0, .L249
1529:Src/mpu6050.c ****                 return -1;
 3296              		.loc 1 1529 17 is_stmt 1 view .LVU962
1529:Src/mpu6050.c ****                 return -1;
 3297              		.loc 1 1529 41 is_stmt 0 view .LVU963
 3298 0034 3774     		strb	r7, [r6, #16]
1530:Src/mpu6050.c ****             }
 3299              		.loc 1 1530 17 is_stmt 1 view .LVU964
ARM GAS  /tmp/ccNfEN49.s 			page 112


 3300              	.LVL206:
 3301              	.L254:
1513:Src/mpu6050.c ****         prev = st.chip_cfg.fifo_enable;
 3302              		.loc 1 1513 20 is_stmt 0 view .LVU965
 3303 0036 4FF0FF34 		mov	r4, #-1
 3304 003a 01E0     		b	.L249
 3305              	.LVL207:
 3306              	.L251:
1526:Src/mpu6050.c ****         if (sensors) {
 3307              		.loc 1 1526 13 is_stmt 1 view .LVU966
 3308 003c FFF7FEFF 		bl	set_int_enable.isra.0
 3309              	.LVL208:
1527:Src/mpu6050.c ****             if (mpu_reset_fifo()) {
 3310              		.loc 1 1527 9 view .LVU967
 3311              	.L249:
1536:Src/mpu6050.c **** 
 3312              		.loc 1 1536 1 is_stmt 0 view .LVU968
 3313 0040 2046     		mov	r0, r4
 3314 0042 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3315              	.LVL209:
 3316              	.L253:
1510:Src/mpu6050.c ****     else {
 3317              		.loc 1 1510 16 view .LVU969
 3318 0044 0024     		movs	r4, #0
 3319 0046 FBE7     		b	.L249
 3320              	.L259:
 3321              		.align	2
 3322              	.L258:
 3323 0048 00000000 		.word	.LANCHOR0
 3324              		.cfi_endproc
 3325              	.LFE87:
 3327              		.section	.text.mpu_get_power_state,"ax",%progbits
 3328              		.align	1
 3329              		.global	mpu_get_power_state
 3330              		.syntax unified
 3331              		.thumb
 3332              		.thumb_func
 3333              		.fpu softvfp
 3335              	mpu_get_power_state:
 3336              	.LVL210:
 3337              	.LFB88:
1544:Src/mpu6050.c ****     if (st.chip_cfg.sensors)
 3338              		.loc 1 1544 1 is_stmt 1 view -0
 3339              		.cfi_startproc
 3340              		@ args = 0, pretend = 0, frame = 0
 3341              		@ frame_needed = 0, uses_anonymous_args = 0
 3342              		@ link register save eliminated.
1545:Src/mpu6050.c ****         power_on[0] = 1;
 3343              		.loc 1 1545 5 view .LVU971
1545:Src/mpu6050.c ****         power_on[0] = 1;
 3344              		.loc 1 1545 20 is_stmt 0 view .LVU972
 3345 0000 034B     		ldr	r3, .L261
1545:Src/mpu6050.c ****         power_on[0] = 1;
 3346              		.loc 1 1545 8 view .LVU973
 3347 0002 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 3348 0004 003B     		subs	r3, r3, #0
 3349 0006 18BF     		it	ne
ARM GAS  /tmp/ccNfEN49.s 			page 113


 3350 0008 0123     		movne	r3, #1
 3351 000a 0370     		strb	r3, [r0]
1549:Src/mpu6050.c **** }
 3352              		.loc 1 1549 5 is_stmt 1 view .LVU974
1550:Src/mpu6050.c **** 
 3353              		.loc 1 1550 1 is_stmt 0 view .LVU975
 3354 000c 0020     		movs	r0, #0
 3355              	.LVL211:
1550:Src/mpu6050.c **** 
 3356              		.loc 1 1550 1 view .LVU976
 3357 000e 7047     		bx	lr
 3358              	.L262:
 3359              		.align	2
 3360              	.L261:
 3361 0010 00000000 		.word	.LANCHOR0
 3362              		.cfi_endproc
 3363              	.LFE88:
 3365              		.section	.text.mpu_get_int_status,"ax",%progbits
 3366              		.align	1
 3367              		.global	mpu_get_int_status
 3368              		.syntax unified
 3369              		.thumb
 3370              		.thumb_func
 3371              		.fpu softvfp
 3373              	mpu_get_int_status:
 3374              	.LVL212:
 3375              	.LFB90:
1640:Src/mpu6050.c ****     unsigned char tmp[2];
 3376              		.loc 1 1640 1 is_stmt 1 view -0
 3377              		.cfi_startproc
 3378              		@ args = 0, pretend = 0, frame = 8
 3379              		@ frame_needed = 0, uses_anonymous_args = 0
1641:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3380              		.loc 1 1641 5 view .LVU978
1642:Src/mpu6050.c ****         return -1;
 3381              		.loc 1 1642 5 view .LVU979
1640:Src/mpu6050.c ****     unsigned char tmp[2];
 3382              		.loc 1 1640 1 is_stmt 0 view .LVU980
 3383 0000 13B5     		push	{r0, r1, r4, lr}
 3384              	.LCFI52:
 3385              		.cfi_def_cfa_offset 16
 3386              		.cfi_offset 4, -8
 3387              		.cfi_offset 14, -4
1642:Src/mpu6050.c ****         return -1;
 3388              		.loc 1 1642 21 view .LVU981
 3389 0002 0B4B     		ldr	r3, .L267
1640:Src/mpu6050.c ****     unsigned char tmp[2];
 3390              		.loc 1 1640 1 view .LVU982
 3391 0004 0446     		mov	r4, r0
1642:Src/mpu6050.c ****         return -1;
 3392              		.loc 1 1642 8 view .LVU983
 3393 0006 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 3394 0008 1AB9     		cbnz	r2, .L264
 3395              	.LVL213:
 3396              	.L266:
1643:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
 3397              		.loc 1 1643 16 view .LVU984
ARM GAS  /tmp/ccNfEN49.s 			page 114


 3398 000a 4FF0FF30 		mov	r0, #-1
 3399              	.L263:
1648:Src/mpu6050.c **** 
 3400              		.loc 1 1648 1 view .LVU985
 3401 000e 02B0     		add	sp, sp, #8
 3402              	.LCFI53:
 3403              		.cfi_remember_state
 3404              		.cfi_def_cfa_offset 8
 3405              		@ sp needed
 3406 0010 10BD     		pop	{r4, pc}
 3407              	.LVL214:
 3408              	.L264:
 3409              	.LCFI54:
 3410              		.cfi_restore_state
1644:Src/mpu6050.c ****         return -1;
 3411              		.loc 1 1644 5 is_stmt 1 view .LVU986
1644:Src/mpu6050.c ****         return -1;
 3412              		.loc 1 1644 9 is_stmt 0 view .LVU987
 3413 0012 D3E90010 		ldrd	r1, r0, [r3]
 3414              	.LVL215:
1644:Src/mpu6050.c ****         return -1;
 3415              		.loc 1 1644 9 view .LVU988
 3416 0016 0222     		movs	r2, #2
 3417 0018 897C     		ldrb	r1, [r1, #18]	@ zero_extendqisi2
 3418 001a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3419 001c 01AB     		add	r3, sp, #4
 3420 001e FFF7FEFF 		bl	i2c_readBytes
 3421              	.LVL216:
1644:Src/mpu6050.c ****         return -1;
 3422              		.loc 1 1644 8 view .LVU989
 3423 0022 0028     		cmp	r0, #0
 3424 0024 F1D1     		bne	.L266
1646:Src/mpu6050.c ****     return 0;
 3425              		.loc 1 1646 5 is_stmt 1 view .LVU990
1646:Src/mpu6050.c ****     return 0;
 3426              		.loc 1 1646 15 is_stmt 0 view .LVU991
 3427 0026 BDF80430 		ldrh	r3, [sp, #4]
 3428 002a 5BBA     		rev16	r3, r3
 3429 002c 2380     		strh	r3, [r4]	@ movhi
1647:Src/mpu6050.c **** }
 3430              		.loc 1 1647 5 is_stmt 1 view .LVU992
1647:Src/mpu6050.c **** }
 3431              		.loc 1 1647 12 is_stmt 0 view .LVU993
 3432 002e EEE7     		b	.L263
 3433              	.L268:
 3434              		.align	2
 3435              	.L267:
 3436 0030 00000000 		.word	.LANCHOR0
 3437              		.cfi_endproc
 3438              	.LFE90:
 3440              		.section	.text.mpu_read_fifo,"ax",%progbits
 3441              		.align	1
 3442              		.global	mpu_read_fifo
 3443              		.syntax unified
 3444              		.thumb
 3445              		.thumb_func
 3446              		.fpu softvfp
ARM GAS  /tmp/ccNfEN49.s 			page 115


 3448              	mpu_read_fifo:
 3449              	.LVL217:
 3450              	.LFB91:
1670:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3451              		.loc 1 1670 1 is_stmt 1 view -0
 3452              		.cfi_startproc
 3453              		@ args = 4, pretend = 0, frame = 16
 3454              		@ frame_needed = 0, uses_anonymous_args = 0
1672:Src/mpu6050.c ****     unsigned char packet_size = 0;
 3455              		.loc 1 1672 5 view .LVU995
1673:Src/mpu6050.c ****     unsigned short fifo_count, index = 0;
 3456              		.loc 1 1673 5 view .LVU996
1674:Src/mpu6050.c **** 
 3457              		.loc 1 1674 5 view .LVU997
1676:Src/mpu6050.c ****         return -1;
 3458              		.loc 1 1676 5 view .LVU998
1670:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3459              		.loc 1 1670 1 is_stmt 0 view .LVU999
 3460 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3461              	.LCFI55:
 3462              		.cfi_def_cfa_offset 36
 3463              		.cfi_offset 4, -36
 3464              		.cfi_offset 5, -32
 3465              		.cfi_offset 6, -28
 3466              		.cfi_offset 7, -24
 3467              		.cfi_offset 8, -20
 3468              		.cfi_offset 9, -16
 3469              		.cfi_offset 10, -12
 3470              		.cfi_offset 11, -8
 3471              		.cfi_offset 14, -4
1676:Src/mpu6050.c ****         return -1;
 3472              		.loc 1 1676 20 view .LVU1000
 3473 0004 654D     		ldr	r5, .L320
1670:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3474              		.loc 1 1670 1 view .LVU1001
 3475 0006 1E46     		mov	r6, r3
1676:Src/mpu6050.c ****         return -1;
 3476              		.loc 1 1676 8 view .LVU1002
 3477 0008 95F82430 		ldrb	r3, [r5, #36]	@ zero_extendqisi2
 3478              	.LVL218:
1670:Src/mpu6050.c ****     /* Assumes maximum packet size is gyro (6) + accel (6). */
 3479              		.loc 1 1670 1 view .LVU1003
 3480 000c 0746     		mov	r7, r0
 3481 000e 8946     		mov	r9, r1
 3482 0010 9246     		mov	r10, r2
 3483 0012 85B0     		sub	sp, sp, #20
 3484              	.LCFI56:
 3485              		.cfi_def_cfa_offset 56
1676:Src/mpu6050.c ****         return -1;
 3486              		.loc 1 1676 8 view .LVU1004
 3487 0014 23B1     		cbz	r3, .L270
 3488              	.LVL219:
 3489              	.L272:
1677:Src/mpu6050.c **** 
 3490              		.loc 1 1677 16 view .LVU1005
 3491 0016 4FF0FF30 		mov	r0, #-1
 3492              	.LVL220:
ARM GAS  /tmp/ccNfEN49.s 			page 116


 3493              	.L269:
1742:Src/mpu6050.c **** 
 3494              		.loc 1 1742 1 view .LVU1006
 3495 001a 05B0     		add	sp, sp, #20
 3496              	.LCFI57:
 3497              		.cfi_remember_state
 3498              		.cfi_def_cfa_offset 36
 3499              		@ sp needed
 3500 001c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3501              	.LVL221:
 3502              	.L270:
 3503              	.LCFI58:
 3504              		.cfi_restore_state
1679:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3505              		.loc 1 1679 5 is_stmt 1 view .LVU1007
1679:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 3506              		.loc 1 1679 16 is_stmt 0 view .LVU1008
 3507 0020 3370     		strb	r3, [r6]
1680:Src/mpu6050.c ****         return -1;
 3508              		.loc 1 1680 5 is_stmt 1 view .LVU1009
1680:Src/mpu6050.c ****         return -1;
 3509              		.loc 1 1680 8 is_stmt 0 view .LVU1010
 3510 0022 AB7A     		ldrb	r3, [r5, #10]	@ zero_extendqisi2
 3511 0024 002B     		cmp	r3, #0
 3512 0026 F6D0     		beq	.L272
1682:Src/mpu6050.c ****         return -1;
 3513              		.loc 1 1682 5 is_stmt 1 view .LVU1011
1682:Src/mpu6050.c ****         return -1;
 3514              		.loc 1 1682 21 is_stmt 0 view .LVU1012
 3515 0028 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
1682:Src/mpu6050.c ****         return -1;
 3516              		.loc 1 1682 8 view .LVU1013
 3517 002a 002B     		cmp	r3, #0
 3518 002c F3D0     		beq	.L272
1685:Src/mpu6050.c ****         packet_size += 2;
 3519              		.loc 1 1685 5 is_stmt 1 view .LVU1014
1686:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
 3520              		.loc 1 1686 21 is_stmt 0 view .LVU1015
 3521 002e 13F04004 		ands	r4, r3, #64
 3522 0032 18BF     		it	ne
 3523 0034 0224     		movne	r4, #2
 3524              	.LVL222:
1687:Src/mpu6050.c ****         packet_size += 2;
 3525              		.loc 1 1687 5 is_stmt 1 view .LVU1016
1687:Src/mpu6050.c ****         packet_size += 2;
 3526              		.loc 1 1687 8 is_stmt 0 view .LVU1017
 3527 0036 9806     		lsls	r0, r3, #26
 3528              	.LVL223:
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
 3529              		.loc 1 1688 9 is_stmt 1 view .LVU1018
1688:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
 3530              		.loc 1 1688 21 is_stmt 0 view .LVU1019
 3531 0038 48BF     		it	mi
 3532 003a 0234     		addmi	r4, r4, #2
 3533              	.LVL224:
1689:Src/mpu6050.c ****         packet_size += 2;
 3534              		.loc 1 1689 5 is_stmt 1 view .LVU1020
ARM GAS  /tmp/ccNfEN49.s 			page 117


1689:Src/mpu6050.c ****         packet_size += 2;
 3535              		.loc 1 1689 8 is_stmt 0 view .LVU1021
 3536 003c D906     		lsls	r1, r3, #27
 3537              	.LVL225:
1690:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3538              		.loc 1 1690 9 is_stmt 1 view .LVU1022
1690:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3539              		.loc 1 1690 21 is_stmt 0 view .LVU1023
 3540 003e 44BF     		itt	mi
 3541 0040 0234     		addmi	r4, r4, #2
 3542              	.LVL226:
1690:Src/mpu6050.c ****     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
 3543              		.loc 1 1690 21 view .LVU1024
 3544 0042 E4B2     		uxtbmi	r4, r4
 3545              	.LVL227:
1691:Src/mpu6050.c ****         packet_size += 6;
 3546              		.loc 1 1691 5 is_stmt 1 view .LVU1025
1691:Src/mpu6050.c ****         packet_size += 6;
 3547              		.loc 1 1691 8 is_stmt 0 view .LVU1026
 3548 0044 1A07     		lsls	r2, r3, #28
 3549              	.LVL228:
1692:Src/mpu6050.c **** 
 3550              		.loc 1 1692 9 is_stmt 1 view .LVU1027
1692:Src/mpu6050.c **** 
 3551              		.loc 1 1692 21 is_stmt 0 view .LVU1028
 3552 0046 48BF     		it	mi
 3553 0048 0634     		addmi	r4, r4, #6
 3554              	.LVL229:
1694:Src/mpu6050.c ****         return -1;
 3555              		.loc 1 1694 9 view .LVU1029
 3556 004a D5E90010 		ldrd	r1, r0, [r5]
 3557 004e 4FF00202 		mov	r2, #2
 3558 0052 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 3559 0054 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3560 0056 01AB     		add	r3, sp, #4
 3561              	.LVL230:
1692:Src/mpu6050.c **** 
 3562              		.loc 1 1692 21 view .LVU1030
 3563 0058 48BF     		it	mi
 3564 005a E4B2     		uxtbmi	r4, r4
 3565              	.LVL231:
1694:Src/mpu6050.c ****         return -1;
 3566              		.loc 1 1694 5 is_stmt 1 view .LVU1031
1694:Src/mpu6050.c ****         return -1;
 3567              		.loc 1 1694 9 is_stmt 0 view .LVU1032
 3568 005c FFF7FEFF 		bl	i2c_readBytes
 3569              	.LVL232:
1694:Src/mpu6050.c ****         return -1;
 3570              		.loc 1 1694 8 view .LVU1033
 3571 0060 0028     		cmp	r0, #0
 3572 0062 D8D1     		bne	.L272
1696:Src/mpu6050.c ****     if (fifo_count < packet_size)
 3573              		.loc 1 1696 5 is_stmt 1 view .LVU1034
 3574 0064 BDF80430 		ldrh	r3, [sp, #4]
1697:Src/mpu6050.c ****         return 0;
 3575              		.loc 1 1697 20 is_stmt 0 view .LVU1035
 3576 0068 1FFA84F8 		uxth	r8, r4
ARM GAS  /tmp/ccNfEN49.s 			page 118


 3577 006c 5BBA     		rev16	r3, r3
 3578 006e 1FFA83FB 		uxth	fp, r3
 3579              	.LVL233:
1697:Src/mpu6050.c ****         return 0;
 3580              		.loc 1 1697 5 is_stmt 1 view .LVU1036
1697:Src/mpu6050.c ****         return 0;
 3581              		.loc 1 1697 8 is_stmt 0 view .LVU1037
 3582 0072 D845     		cmp	r8, fp
 3583 0074 01D9     		bls	.L277
 3584              	.LVL234:
 3585              	.L319:
1738:Src/mpu6050.c ****     }
 3586              		.loc 1 1738 9 is_stmt 1 view .LVU1038
1741:Src/mpu6050.c **** }
 3587              		.loc 1 1741 12 is_stmt 0 view .LVU1039
 3588 0076 0020     		movs	r0, #0
1741:Src/mpu6050.c **** }
 3589              		.loc 1 1741 12 view .LVU1040
 3590 0078 CFE7     		b	.L269
 3591              	.LVL235:
 3592              	.L277:
1702:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3593              		.loc 1 1702 5 is_stmt 1 view .LVU1041
1702:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3594              		.loc 1 1702 25 is_stmt 0 view .LVU1042
 3595 007a 6868     		ldr	r0, [r5, #4]
1702:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3596              		.loc 1 1702 20 view .LVU1043
 3597 007c 4388     		ldrh	r3, [r0, #2]
 3598              	.LVL236:
1702:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3599              		.loc 1 1702 8 view .LVU1044
 3600 007e BBEB530F 		cmp	fp, r3, lsr #1
 3601 0082 11D9     		bls	.L278
1704:Src/mpu6050.c ****             return -1;
 3602              		.loc 1 1704 9 is_stmt 1 view .LVU1045
1704:Src/mpu6050.c ****             return -1;
 3603              		.loc 1 1704 13 is_stmt 0 view .LVU1046
 3604 0084 2968     		ldr	r1, [r5]
 3605 0086 0122     		movs	r2, #1
 3606 0088 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 3607 008a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3608 008c 01AB     		add	r3, sp, #4
 3609 008e FFF7FEFF 		bl	i2c_readBytes
 3610              	.LVL237:
1704:Src/mpu6050.c ****             return -1;
 3611              		.loc 1 1704 12 view .LVU1047
 3612 0092 0028     		cmp	r0, #0
 3613 0094 BFD1     		bne	.L272
1706:Src/mpu6050.c ****             mpu_reset_fifo();
 3614              		.loc 1 1706 9 is_stmt 1 view .LVU1048
1706:Src/mpu6050.c ****             mpu_reset_fifo();
 3615              		.loc 1 1706 12 is_stmt 0 view .LVU1049
 3616 0096 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3617 009a DB06     		lsls	r3, r3, #27
 3618 009c 04D5     		bpl	.L278
1707:Src/mpu6050.c ****             return -2;
ARM GAS  /tmp/ccNfEN49.s 			page 119


 3619              		.loc 1 1707 13 is_stmt 1 view .LVU1050
 3620 009e FFF7FEFF 		bl	mpu_reset_fifo
 3621              	.LVL238:
1708:Src/mpu6050.c ****         }
 3622              		.loc 1 1708 13 view .LVU1051
1708:Src/mpu6050.c ****         }
 3623              		.loc 1 1708 20 is_stmt 0 view .LVU1052
 3624 00a2 6FF00100 		mvn	r0, #1
 3625 00a6 B8E7     		b	.L269
 3626              	.L278:
1711:Src/mpu6050.c **** 
 3627              		.loc 1 1711 5 is_stmt 1 view .LVU1053
 3628 00a8 5046     		mov	r0, r10
 3629 00aa FFF7FEFF 		bl	get_tick_count_ms
 3630              	.LVL239:
1713:Src/mpu6050.c ****         return -1;
 3631              		.loc 1 1713 5 view .LVU1054
1713:Src/mpu6050.c ****         return -1;
 3632              		.loc 1 1713 9 is_stmt 0 view .LVU1055
 3633 00ae D5E90010 		ldrd	r1, r0, [r5]
 3634 00b2 2246     		mov	r2, r4
 3635 00b4 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 3636 00b6 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3637 00b8 01AB     		add	r3, sp, #4
 3638 00ba FFF7FEFF 		bl	i2c_readBytes
 3639              	.LVL240:
1713:Src/mpu6050.c ****         return -1;
 3640              		.loc 1 1713 8 view .LVU1056
 3641 00be 0028     		cmp	r0, #0
 3642 00c0 A9D1     		bne	.L272
1715:Src/mpu6050.c ****     sensors[0] = 0;
 3643              		.loc 1 1715 5 is_stmt 1 view .LVU1057
1715:Src/mpu6050.c ****     sensors[0] = 0;
 3644              		.loc 1 1715 26 is_stmt 0 view .LVU1058
 3645 00c2 BBFBF4F3 		udiv	r3, fp, r4
1715:Src/mpu6050.c ****     sensors[0] = 0;
 3646              		.loc 1 1715 13 view .LVU1059
 3647 00c6 0E9A     		ldr	r2, [sp, #56]
1715:Src/mpu6050.c ****     sensors[0] = 0;
 3648              		.loc 1 1715 40 view .LVU1060
 3649 00c8 013B     		subs	r3, r3, #1
1715:Src/mpu6050.c ****     sensors[0] = 0;
 3650              		.loc 1 1715 13 view .LVU1061
 3651 00ca 1370     		strb	r3, [r2]
1716:Src/mpu6050.c **** 
 3652              		.loc 1 1716 5 is_stmt 1 view .LVU1062
1716:Src/mpu6050.c **** 
 3653              		.loc 1 1716 16 is_stmt 0 view .LVU1063
 3654 00cc 3070     		strb	r0, [r6]
1718:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3655              		.loc 1 1718 5 is_stmt 1 view .LVU1064
1718:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3656              		.loc 1 1718 8 is_stmt 0 view .LVU1065
 3657 00ce 002C     		cmp	r4, #0
 3658 00d0 D1D0     		beq	.L319
1718:Src/mpu6050.c ****         accel[0] = (data[index+0] << 8) | data[index+1];
 3659              		.loc 1 1718 32 discriminator 1 view .LVU1066
ARM GAS  /tmp/ccNfEN49.s 			page 120


 3660 00d2 2A7C     		ldrb	r2, [r5, #16]	@ zero_extendqisi2
 3661 00d4 12F00802 		ands	r2, r2, #8
 3662 00d8 16D0     		beq	.L280
1719:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3663              		.loc 1 1719 9 is_stmt 1 view .LVU1067
1719:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3664              		.loc 1 1719 18 is_stmt 0 view .LVU1068
 3665 00da BDF80430 		ldrh	r3, [sp, #4]
1725:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3666              		.loc 1 1725 8 view .LVU1069
 3667 00de B8F1060F 		cmp	r8, #6
1719:Src/mpu6050.c ****         accel[1] = (data[index+2] << 8) | data[index+3];
 3668              		.loc 1 1719 18 view .LVU1070
 3669 00e2 5BBA     		rev16	r3, r3
 3670 00e4 A9F80030 		strh	r3, [r9]	@ movhi
1720:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
 3671              		.loc 1 1720 9 is_stmt 1 view .LVU1071
1720:Src/mpu6050.c ****         accel[2] = (data[index+4] << 8) | data[index+5];
 3672              		.loc 1 1720 18 is_stmt 0 view .LVU1072
 3673 00e8 BDF80630 		ldrh	r3, [sp, #6]
 3674 00ec 5BBA     		rev16	r3, r3
 3675 00ee A9F80230 		strh	r3, [r9, #2]	@ movhi
1721:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
 3676              		.loc 1 1721 9 is_stmt 1 view .LVU1073
1721:Src/mpu6050.c ****         sensors[0] |= INV_XYZ_ACCEL;
 3677              		.loc 1 1721 18 is_stmt 0 view .LVU1074
 3678 00f2 BDF80830 		ldrh	r3, [sp, #8]
 3679 00f6 5BBA     		rev16	r3, r3
 3680 00f8 A9F80430 		strh	r3, [r9, #4]	@ movhi
1722:Src/mpu6050.c ****         index += 6;
 3681              		.loc 1 1722 9 is_stmt 1 view .LVU1075
1722:Src/mpu6050.c ****         index += 6;
 3682              		.loc 1 1722 20 is_stmt 0 view .LVU1076
 3683 00fc 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3684 00fe 43F00803 		orr	r3, r3, #8
 3685 0102 3370     		strb	r3, [r6]
1723:Src/mpu6050.c ****     }
 3686              		.loc 1 1723 9 is_stmt 1 view .LVU1077
 3687              	.LVL241:
1725:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3688              		.loc 1 1725 5 view .LVU1078
1725:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3689              		.loc 1 1725 8 is_stmt 0 view .LVU1079
 3690 0104 B7D0     		beq	.L319
1723:Src/mpu6050.c ****     }
 3691              		.loc 1 1723 15 view .LVU1080
 3692 0106 0622     		movs	r2, #6
 3693              	.LVL242:
 3694              	.L280:
1725:Src/mpu6050.c ****         gyro[0] = (data[index+0] << 8) | data[index+1];
 3695              		.loc 1 1725 32 discriminator 1 view .LVU1081
 3696 0108 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3697 010a 5806     		lsls	r0, r3, #25
 3698 010c 15D5     		bpl	.L281
1726:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3699              		.loc 1 1726 9 is_stmt 1 view .LVU1082
1726:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
ARM GAS  /tmp/ccNfEN49.s 			page 121


 3700              		.loc 1 1726 24 is_stmt 0 view .LVU1083
 3701 010e 02F11003 		add	r3, r2, #16
 3702 0112 6B44     		add	r3, sp, r3
 3703 0114 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1726:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3704              		.loc 1 1726 52 view .LVU1084
 3705 0118 531C     		adds	r3, r2, #1
 3706 011a 9BB2     		uxth	r3, r3
1726:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3707              		.loc 1 1726 46 view .LVU1085
 3708 011c 1033     		adds	r3, r3, #16
 3709 011e 6B44     		add	r3, sp, r3
 3710 0120 13F80C3C 		ldrb	r3, [r3, #-12]	@ zero_extendqisi2
1728:Src/mpu6050.c ****     }
 3711              		.loc 1 1728 15 view .LVU1086
 3712 0124 0232     		adds	r2, r2, #2
1726:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3713              		.loc 1 1726 40 view .LVU1087
 3714 0126 43EA0123 		orr	r3, r3, r1, lsl #8
1726:Src/mpu6050.c ****         sensors[0] |= INV_X_GYRO;
 3715              		.loc 1 1726 17 view .LVU1088
 3716 012a 3B80     		strh	r3, [r7]	@ movhi
1727:Src/mpu6050.c ****         index += 2;
 3717              		.loc 1 1727 9 is_stmt 1 view .LVU1089
1727:Src/mpu6050.c ****         index += 2;
 3718              		.loc 1 1727 20 is_stmt 0 view .LVU1090
 3719 012c 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
1728:Src/mpu6050.c ****     }
 3720              		.loc 1 1728 15 view .LVU1091
 3721 012e 92B2     		uxth	r2, r2
1727:Src/mpu6050.c ****         index += 2;
 3722              		.loc 1 1727 20 view .LVU1092
 3723 0130 43F04003 		orr	r3, r3, #64
1730:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3724              		.loc 1 1730 8 view .LVU1093
 3725 0134 9045     		cmp	r8, r2
1727:Src/mpu6050.c ****         index += 2;
 3726              		.loc 1 1727 20 view .LVU1094
 3727 0136 3370     		strb	r3, [r6]
1728:Src/mpu6050.c ****     }
 3728              		.loc 1 1728 9 is_stmt 1 view .LVU1095
1730:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3729              		.loc 1 1730 5 view .LVU1096
1730:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3730              		.loc 1 1730 8 is_stmt 0 view .LVU1097
 3731 0138 9DD0     		beq	.L319
 3732              	.L281:
1730:Src/mpu6050.c ****         gyro[1] = (data[index+0] << 8) | data[index+1];
 3733              		.loc 1 1730 32 discriminator 1 view .LVU1098
 3734 013a 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3735 013c 9906     		lsls	r1, r3, #26
 3736 013e 15D5     		bpl	.L282
1731:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3737              		.loc 1 1731 9 is_stmt 1 view .LVU1099
1731:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3738              		.loc 1 1731 24 is_stmt 0 view .LVU1100
 3739 0140 02F11003 		add	r3, r2, #16
ARM GAS  /tmp/ccNfEN49.s 			page 122


 3740 0144 6B44     		add	r3, sp, r3
 3741 0146 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1731:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3742              		.loc 1 1731 52 view .LVU1101
 3743 014a 531C     		adds	r3, r2, #1
 3744 014c 9BB2     		uxth	r3, r3
1731:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3745              		.loc 1 1731 46 view .LVU1102
 3746 014e 1033     		adds	r3, r3, #16
 3747 0150 6B44     		add	r3, sp, r3
 3748 0152 13F80C3C 		ldrb	r3, [r3, #-12]	@ zero_extendqisi2
1733:Src/mpu6050.c ****     }
 3749              		.loc 1 1733 15 view .LVU1103
 3750 0156 0232     		adds	r2, r2, #2
1731:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3751              		.loc 1 1731 40 view .LVU1104
 3752 0158 43EA0123 		orr	r3, r3, r1, lsl #8
1731:Src/mpu6050.c ****         sensors[0] |= INV_Y_GYRO;
 3753              		.loc 1 1731 17 view .LVU1105
 3754 015c 7B80     		strh	r3, [r7, #2]	@ movhi
1732:Src/mpu6050.c ****         index += 2;
 3755              		.loc 1 1732 9 is_stmt 1 view .LVU1106
1732:Src/mpu6050.c ****         index += 2;
 3756              		.loc 1 1732 20 is_stmt 0 view .LVU1107
 3757 015e 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
1733:Src/mpu6050.c ****     }
 3758              		.loc 1 1733 15 view .LVU1108
 3759 0160 92B2     		uxth	r2, r2
1732:Src/mpu6050.c ****         index += 2;
 3760              		.loc 1 1732 20 view .LVU1109
 3761 0162 43F02003 		orr	r3, r3, #32
1735:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3762              		.loc 1 1735 8 view .LVU1110
 3763 0166 9045     		cmp	r8, r2
1732:Src/mpu6050.c ****         index += 2;
 3764              		.loc 1 1732 20 view .LVU1111
 3765 0168 3370     		strb	r3, [r6]
1733:Src/mpu6050.c ****     }
 3766              		.loc 1 1733 9 is_stmt 1 view .LVU1112
1735:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3767              		.loc 1 1735 5 view .LVU1113
1735:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3768              		.loc 1 1735 8 is_stmt 0 view .LVU1114
 3769 016a 84D0     		beq	.L319
 3770              	.L282:
1735:Src/mpu6050.c ****         gyro[2] = (data[index+0] << 8) | data[index+1];
 3771              		.loc 1 1735 32 discriminator 1 view .LVU1115
 3772 016c 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
 3773 016e DB06     		lsls	r3, r3, #27
 3774 0170 81D5     		bpl	.L319
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3775              		.loc 1 1736 9 is_stmt 1 view .LVU1116
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3776              		.loc 1 1736 24 is_stmt 0 view .LVU1117
 3777 0172 02F11003 		add	r3, r2, #16
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3778              		.loc 1 1736 52 view .LVU1118
ARM GAS  /tmp/ccNfEN49.s 			page 123


 3779 0176 0132     		adds	r2, r2, #1
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3780              		.loc 1 1736 24 view .LVU1119
 3781 0178 6B44     		add	r3, sp, r3
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3782              		.loc 1 1736 52 view .LVU1120
 3783 017a 92B2     		uxth	r2, r2
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3784              		.loc 1 1736 24 view .LVU1121
 3785 017c 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3786              		.loc 1 1736 46 view .LVU1122
 3787 0180 02F11003 		add	r3, r2, #16
 3788 0184 0DEB0302 		add	r2, sp, r3
 3789 0188 12F80C3C 		ldrb	r3, [r2, #-12]	@ zero_extendqisi2
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3790              		.loc 1 1736 40 view .LVU1123
 3791 018c 43EA0123 		orr	r3, r3, r1, lsl #8
1736:Src/mpu6050.c ****         sensors[0] |= INV_Z_GYRO;
 3792              		.loc 1 1736 17 view .LVU1124
 3793 0190 BB80     		strh	r3, [r7, #4]	@ movhi
1737:Src/mpu6050.c ****         index += 2;
 3794              		.loc 1 1737 9 is_stmt 1 view .LVU1125
1737:Src/mpu6050.c ****         index += 2;
 3795              		.loc 1 1737 20 is_stmt 0 view .LVU1126
 3796 0192 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3797 0194 43F01003 		orr	r3, r3, #16
 3798 0198 3370     		strb	r3, [r6]
 3799 019a 6CE7     		b	.L319
 3800              	.L321:
 3801              		.align	2
 3802              	.L320:
 3803 019c 00000000 		.word	.LANCHOR0
 3804              		.cfi_endproc
 3805              	.LFE91:
 3807              		.section	.text.mpu_read_fifo_stream,"ax",%progbits
 3808              		.align	1
 3809              		.global	mpu_read_fifo_stream
 3810              		.syntax unified
 3811              		.thumb
 3812              		.thumb_func
 3813              		.fpu softvfp
 3815              	mpu_read_fifo_stream:
 3816              	.LVL243:
 3817              	.LFB92:
1753:Src/mpu6050.c ****     unsigned char tmp[2];
 3818              		.loc 1 1753 1 is_stmt 1 view -0
 3819              		.cfi_startproc
 3820              		@ args = 0, pretend = 0, frame = 8
 3821              		@ frame_needed = 0, uses_anonymous_args = 0
1754:Src/mpu6050.c ****     unsigned short fifo_count;
 3822              		.loc 1 1754 5 view .LVU1128
1755:Src/mpu6050.c ****     if (!st.chip_cfg.dmp_on)
 3823              		.loc 1 1755 5 view .LVU1129
1756:Src/mpu6050.c ****         return -1;
 3824              		.loc 1 1756 5 view .LVU1130
1753:Src/mpu6050.c ****     unsigned char tmp[2];
ARM GAS  /tmp/ccNfEN49.s 			page 124


 3825              		.loc 1 1753 1 is_stmt 0 view .LVU1131
 3826 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 3827              	.LCFI59:
 3828              		.cfi_def_cfa_offset 32
 3829              		.cfi_offset 4, -24
 3830              		.cfi_offset 5, -20
 3831              		.cfi_offset 6, -16
 3832              		.cfi_offset 7, -12
 3833              		.cfi_offset 8, -8
 3834              		.cfi_offset 14, -4
1756:Src/mpu6050.c ****         return -1;
 3835              		.loc 1 1756 21 view .LVU1132
 3836 0004 234F     		ldr	r7, .L335
1753:Src/mpu6050.c ****     unsigned char tmp[2];
 3837              		.loc 1 1753 1 view .LVU1133
 3838 0006 0646     		mov	r6, r0
1756:Src/mpu6050.c ****         return -1;
 3839              		.loc 1 1756 8 view .LVU1134
 3840 0008 97F82430 		ldrb	r3, [r7, #36]	@ zero_extendqisi2
1753:Src/mpu6050.c ****     unsigned char tmp[2];
 3841              		.loc 1 1753 1 view .LVU1135
 3842 000c 8846     		mov	r8, r1
 3843 000e 1546     		mov	r5, r2
1756:Src/mpu6050.c ****         return -1;
 3844              		.loc 1 1756 8 view .LVU1136
 3845 0010 23B9     		cbnz	r3, .L323
 3846              	.LVL244:
 3847              	.L334:
1766:Src/mpu6050.c ****     }
 3848              		.loc 1 1766 9 is_stmt 1 view .LVU1137
1766:Src/mpu6050.c ****     }
 3849              		.loc 1 1766 16 is_stmt 0 view .LVU1138
 3850 0012 4FF0FF30 		mov	r0, #-1
 3851              	.L322:
1782:Src/mpu6050.c **** 
 3852              		.loc 1 1782 1 view .LVU1139
 3853 0016 02B0     		add	sp, sp, #8
 3854              	.LCFI60:
 3855              		.cfi_remember_state
 3856              		.cfi_def_cfa_offset 24
 3857              		@ sp needed
 3858 0018 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3859              	.LVL245:
 3860              	.L323:
 3861              	.LCFI61:
 3862              		.cfi_restore_state
1758:Src/mpu6050.c ****         return -1;
 3863              		.loc 1 1758 5 is_stmt 1 view .LVU1140
1758:Src/mpu6050.c ****         return -1;
 3864              		.loc 1 1758 8 is_stmt 0 view .LVU1141
 3865 001c BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 3866 001e 002B     		cmp	r3, #0
 3867 0020 F7D0     		beq	.L334
1761:Src/mpu6050.c ****         return -1;
 3868              		.loc 1 1761 5 is_stmt 1 view .LVU1142
1761:Src/mpu6050.c ****         return -1;
 3869              		.loc 1 1761 9 is_stmt 0 view .LVU1143
ARM GAS  /tmp/ccNfEN49.s 			page 125


 3870 0022 D7E90010 		ldrd	r1, r0, [r7]
 3871              	.LVL246:
1761:Src/mpu6050.c ****         return -1;
 3872              		.loc 1 1761 9 view .LVU1144
 3873 0026 0222     		movs	r2, #2
 3874              	.LVL247:
1761:Src/mpu6050.c ****         return -1;
 3875              		.loc 1 1761 9 view .LVU1145
 3876 0028 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
 3877 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3878 002c 01AB     		add	r3, sp, #4
 3879 002e FFF7FEFF 		bl	i2c_readBytes
 3880              	.LVL248:
1761:Src/mpu6050.c ****         return -1;
 3881              		.loc 1 1761 8 view .LVU1146
 3882 0032 0028     		cmp	r0, #0
 3883 0034 EDD1     		bne	.L334
1763:Src/mpu6050.c ****     if (fifo_count < length) {
 3884              		.loc 1 1763 5 is_stmt 1 view .LVU1147
 3885 0036 BDF80440 		ldrh	r4, [sp, #4]
 3886 003a 62BA     		rev16	r2, r4
 3887 003c 94B2     		uxth	r4, r2
 3888              	.LVL249:
1764:Src/mpu6050.c ****         more[0] = 0;
 3889              		.loc 1 1764 5 view .LVU1148
1764:Src/mpu6050.c ****         more[0] = 0;
 3890              		.loc 1 1764 8 is_stmt 0 view .LVU1149
 3891 003e A642     		cmp	r6, r4
 3892 0040 01D9     		bls	.L326
1765:Src/mpu6050.c ****         return -1;
 3893              		.loc 1 1765 9 is_stmt 1 view .LVU1150
1765:Src/mpu6050.c ****         return -1;
 3894              		.loc 1 1765 17 is_stmt 0 view .LVU1151
 3895 0042 2870     		strb	r0, [r5]
 3896 0044 E5E7     		b	.L334
 3897              	.L326:
1768:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3898              		.loc 1 1768 5 is_stmt 1 view .LVU1152
1768:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3899              		.loc 1 1768 25 is_stmt 0 view .LVU1153
 3900 0046 7868     		ldr	r0, [r7, #4]
1768:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3901              		.loc 1 1768 20 view .LVU1154
 3902 0048 4388     		ldrh	r3, [r0, #2]
1768:Src/mpu6050.c ****         /* FIFO is 50% full, better check overflow bit. */
 3903              		.loc 1 1768 8 view .LVU1155
 3904 004a B4EB530F 		cmp	r4, r3, lsr #1
 3905 004e 11D9     		bls	.L327
1770:Src/mpu6050.c ****             return -1;
 3906              		.loc 1 1770 9 is_stmt 1 view .LVU1156
1770:Src/mpu6050.c ****             return -1;
 3907              		.loc 1 1770 13 is_stmt 0 view .LVU1157
 3908 0050 3968     		ldr	r1, [r7]
 3909 0052 0122     		movs	r2, #1
 3910              	.LVL250:
1770:Src/mpu6050.c ****             return -1;
 3911              		.loc 1 1770 13 view .LVU1158
ARM GAS  /tmp/ccNfEN49.s 			page 126


 3912 0054 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 3913 0056 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3914 0058 01AB     		add	r3, sp, #4
 3915 005a FFF7FEFF 		bl	i2c_readBytes
 3916              	.LVL251:
1770:Src/mpu6050.c ****             return -1;
 3917              		.loc 1 1770 12 view .LVU1159
 3918 005e 0028     		cmp	r0, #0
 3919 0060 D7D1     		bne	.L334
1772:Src/mpu6050.c ****             mpu_reset_fifo();
 3920              		.loc 1 1772 9 is_stmt 1 view .LVU1160
1772:Src/mpu6050.c ****             mpu_reset_fifo();
 3921              		.loc 1 1772 12 is_stmt 0 view .LVU1161
 3922 0062 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 3923 0066 DB06     		lsls	r3, r3, #27
 3924 0068 04D5     		bpl	.L327
1773:Src/mpu6050.c ****             return -2;
 3925              		.loc 1 1773 13 is_stmt 1 view .LVU1162
 3926 006a FFF7FEFF 		bl	mpu_reset_fifo
 3927              	.LVL252:
1774:Src/mpu6050.c ****         }
 3928              		.loc 1 1774 13 view .LVU1163
1774:Src/mpu6050.c ****         }
 3929              		.loc 1 1774 20 is_stmt 0 view .LVU1164
 3930 006e 6FF00100 		mvn	r0, #1
 3931 0072 D0E7     		b	.L322
 3932              	.L327:
1778:Src/mpu6050.c ****         return -1;
 3933              		.loc 1 1778 5 is_stmt 1 view .LVU1165
1778:Src/mpu6050.c ****         return -1;
 3934              		.loc 1 1778 9 is_stmt 0 view .LVU1166
 3935 0074 D7E90010 		ldrd	r1, r0, [r7]
 3936 0078 4346     		mov	r3, r8
 3937 007a 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 3938 007c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 3939 007e F2B2     		uxtb	r2, r6
 3940 0080 FFF7FEFF 		bl	i2c_readBytes
 3941              	.LVL253:
1778:Src/mpu6050.c ****         return -1;
 3942              		.loc 1 1778 8 view .LVU1167
 3943 0084 0028     		cmp	r0, #0
 3944 0086 C4D1     		bne	.L334
1780:Src/mpu6050.c ****     return 0;
 3945              		.loc 1 1780 5 is_stmt 1 view .LVU1168
1780:Src/mpu6050.c ****     return 0;
 3946              		.loc 1 1780 35 is_stmt 0 view .LVU1169
 3947 0088 B4FBF6F4 		udiv	r4, r4, r6
 3948              	.LVL254:
1780:Src/mpu6050.c ****     return 0;
 3949              		.loc 1 1780 35 view .LVU1170
 3950 008c 013C     		subs	r4, r4, #1
1780:Src/mpu6050.c ****     return 0;
 3951              		.loc 1 1780 13 view .LVU1171
 3952 008e 2C70     		strb	r4, [r5]
1781:Src/mpu6050.c **** }
 3953              		.loc 1 1781 5 is_stmt 1 view .LVU1172
1781:Src/mpu6050.c **** }
ARM GAS  /tmp/ccNfEN49.s 			page 127


 3954              		.loc 1 1781 12 is_stmt 0 view .LVU1173
 3955 0090 C1E7     		b	.L322
 3956              	.L336:
 3957 0092 00BF     		.align	2
 3958              	.L335:
 3959 0094 00000000 		.word	.LANCHOR0
 3960              		.cfi_endproc
 3961              	.LFE92:
 3963              		.section	.text.mpu_set_bypass,"ax",%progbits
 3964              		.align	1
 3965              		.global	mpu_set_bypass
 3966              		.syntax unified
 3967              		.thumb
 3968              		.thumb_func
 3969              		.fpu softvfp
 3971              	mpu_set_bypass:
 3972              	.LVL255:
 3973              	.LFB93:
1790:Src/mpu6050.c ****     unsigned char tmp;
 3974              		.loc 1 1790 1 is_stmt 1 view -0
 3975              		.cfi_startproc
 3976              		@ args = 0, pretend = 0, frame = 8
 3977              		@ frame_needed = 0, uses_anonymous_args = 0
1791:Src/mpu6050.c **** 
 3978              		.loc 1 1791 5 view .LVU1175
1793:Src/mpu6050.c ****         return 0;
 3979              		.loc 1 1793 5 view .LVU1176
1790:Src/mpu6050.c ****     unsigned char tmp;
 3980              		.loc 1 1790 1 is_stmt 0 view .LVU1177
 3981 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 3982              	.LCFI62:
 3983              		.cfi_def_cfa_offset 24
 3984              		.cfi_offset 4, -12
 3985              		.cfi_offset 5, -8
 3986              		.cfi_offset 14, -4
1793:Src/mpu6050.c ****         return 0;
 3987              		.loc 1 1793 20 view .LVU1178
 3988 0002 384C     		ldr	r4, .L361
1790:Src/mpu6050.c ****     unsigned char tmp;
 3989              		.loc 1 1790 1 view .LVU1179
 3990 0004 0546     		mov	r5, r0
1793:Src/mpu6050.c ****         return 0;
 3991              		.loc 1 1793 8 view .LVU1180
 3992 0006 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 3993 0008 8342     		cmp	r3, r0
 3994 000a 69D0     		beq	.L349
1796:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 3995              		.loc 1 1796 5 is_stmt 1 view .LVU1181
1797:Src/mpu6050.c ****             return -1;
 3996              		.loc 1 1797 13 is_stmt 0 view .LVU1182
 3997 000c 6368     		ldr	r3, [r4, #4]
 3998 000e 0122     		movs	r2, #1
 3999 0010 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 4000              	.LVL256:
1797:Src/mpu6050.c ****             return -1;
 4001              		.loc 1 1797 13 view .LVU1183
 4002 0012 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccNfEN49.s 			page 128


 4003 0014 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 4004 0016 0DF10703 		add	r3, sp, #7
1796:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4005              		.loc 1 1796 8 view .LVU1184
 4006 001a 6DB3     		cbz	r5, .L339
1797:Src/mpu6050.c ****             return -1;
 4007              		.loc 1 1797 9 is_stmt 1 view .LVU1185
1797:Src/mpu6050.c ****             return -1;
 4008              		.loc 1 1797 13 is_stmt 0 view .LVU1186
 4009 001c FFF7FEFF 		bl	i2c_readBytes
 4010              	.LVL257:
1797:Src/mpu6050.c ****             return -1;
 4011              		.loc 1 1797 12 view .LVU1187
 4012 0020 18B1     		cbz	r0, .L340
 4013              	.L341:
1798:Src/mpu6050.c ****         tmp &= ~BIT_AUX_IF_EN;
 4014              		.loc 1 1798 20 view .LVU1188
 4015 0022 4FF0FF30 		mov	r0, #-1
 4016              	.L337:
1832:Src/mpu6050.c **** 
 4017              		.loc 1 1832 1 view .LVU1189
 4018 0026 03B0     		add	sp, sp, #12
 4019              	.LCFI63:
 4020              		.cfi_remember_state
 4021              		.cfi_def_cfa_offset 12
 4022              		@ sp needed
 4023 0028 30BD     		pop	{r4, r5, pc}
 4024              	.L340:
 4025              	.LCFI64:
 4026              		.cfi_restore_state
1799:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4027              		.loc 1 1799 9 is_stmt 1 view .LVU1190
1799:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4028              		.loc 1 1799 13 is_stmt 0 view .LVU1191
 4029 002a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1800:Src/mpu6050.c ****             return -1;
 4030              		.loc 1 1800 13 view .LVU1192
 4031 002e D4E90010 		ldrd	r1, r0, [r4]
1799:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4032              		.loc 1 1799 13 view .LVU1193
 4033 0032 23F02003 		bic	r3, r3, #32
 4034 0036 8DF80730 		strb	r3, [sp, #7]
1800:Src/mpu6050.c ****             return -1;
 4035              		.loc 1 1800 9 is_stmt 1 view .LVU1194
1800:Src/mpu6050.c ****             return -1;
 4036              		.loc 1 1800 13 is_stmt 0 view .LVU1195
 4037 003a 0122     		movs	r2, #1
 4038 003c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 4039 003e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4040 0040 0DF10703 		add	r3, sp, #7
 4041 0044 FFF7FEFF 		bl	i2c_writeBytes
 4042              	.LVL258:
1800:Src/mpu6050.c ****             return -1;
 4043              		.loc 1 1800 12 view .LVU1196
 4044 0048 0028     		cmp	r0, #0
 4045 004a EAD1     		bne	.L341
1802:Src/mpu6050.c ****         tmp = BIT_BYPASS_EN;
ARM GAS  /tmp/ccNfEN49.s 			page 129


 4046              		.loc 1 1802 9 is_stmt 1 view .LVU1197
 4047 004c 0320     		movs	r0, #3
 4048 004e FFF7FEFF 		bl	delay_1ms
 4049              	.LVL259:
1803:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4050              		.loc 1 1803 9 view .LVU1198
1803:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4051              		.loc 1 1803 13 is_stmt 0 view .LVU1199
 4052 0052 0223     		movs	r3, #2
 4053 0054 8DF80730 		strb	r3, [sp, #7]
1804:Src/mpu6050.c ****             tmp |= BIT_ACTL;
 4054              		.loc 1 1804 9 is_stmt 1 view .LVU1200
1804:Src/mpu6050.c ****             tmp |= BIT_ACTL;
 4055              		.loc 1 1804 12 is_stmt 0 view .LVU1201
 4056 0058 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 4057 005c 13B1     		cbz	r3, .L342
1805:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
 4058              		.loc 1 1805 13 is_stmt 1 view .LVU1202
1805:Src/mpu6050.c ****         if (st.chip_cfg.latched_int)
 4059              		.loc 1 1805 17 is_stmt 0 view .LVU1203
 4060 005e 8223     		movs	r3, #130
 4061 0060 8DF80730 		strb	r3, [sp, #7]
 4062              	.L342:
1806:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4063              		.loc 1 1806 9 is_stmt 1 view .LVU1204
1806:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4064              		.loc 1 1806 12 is_stmt 0 view .LVU1205
 4065 0064 94F82330 		ldrb	r3, [r4, #35]	@ zero_extendqisi2
 4066 0068 73B3     		cbz	r3, .L347
1807:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4067              		.loc 1 1807 13 is_stmt 1 view .LVU1206
1807:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4068              		.loc 1 1807 17 is_stmt 0 view .LVU1207
 4069 006a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4070              	.L360:
1826:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4071              		.loc 1 1826 13 is_stmt 1 view .LVU1208
1826:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4072              		.loc 1 1826 17 is_stmt 0 view .LVU1209
 4073 006e 43F03003 		orr	r3, r3, #48
 4074 0072 8DF80730 		strb	r3, [sp, #7]
 4075 0076 27E0     		b	.L347
 4076              	.L339:
1812:Src/mpu6050.c ****             return -1;
 4077              		.loc 1 1812 9 is_stmt 1 view .LVU1210
1812:Src/mpu6050.c ****             return -1;
 4078              		.loc 1 1812 13 is_stmt 0 view .LVU1211
 4079 0078 FFF7FEFF 		bl	i2c_readBytes
 4080              	.LVL260:
1812:Src/mpu6050.c ****             return -1;
 4081              		.loc 1 1812 12 view .LVU1212
 4082 007c 0028     		cmp	r0, #0
 4083 007e D0D1     		bne	.L341
1814:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4084              		.loc 1 1814 9 is_stmt 1 view .LVU1213
1818:Src/mpu6050.c ****             return -1;
 4085              		.loc 1 1818 13 is_stmt 0 view .LVU1214
ARM GAS  /tmp/ccNfEN49.s 			page 130


 4086 0080 D4E90010 		ldrd	r1, r0, [r4]
1814:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4087              		.loc 1 1814 12 view .LVU1215
 4088 0084 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
1799:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4089              		.loc 1 1799 13 view .LVU1216
 4090 0086 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1814:Src/mpu6050.c ****             tmp |= BIT_AUX_IF_EN;
 4091              		.loc 1 1814 12 view .LVU1217
 4092 008a D207     		lsls	r2, r2, #31
1815:Src/mpu6050.c ****         else
 4093              		.loc 1 1815 13 is_stmt 1 view .LVU1218
1815:Src/mpu6050.c ****         else
 4094              		.loc 1 1815 17 is_stmt 0 view .LVU1219
 4095 008c 4CBF     		ite	mi
 4096 008e 43F02003 		orrmi	r3, r3, #32
1817:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4097              		.loc 1 1817 13 is_stmt 1 view .LVU1220
1817:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
 4098              		.loc 1 1817 17 is_stmt 0 view .LVU1221
 4099 0092 03F0DF03 		andpl	r3, r3, #223
 4100 0096 8DF80730 		strb	r3, [sp, #7]
1818:Src/mpu6050.c ****             return -1;
 4101              		.loc 1 1818 9 is_stmt 1 view .LVU1222
1818:Src/mpu6050.c ****             return -1;
 4102              		.loc 1 1818 13 is_stmt 0 view .LVU1223
 4103 009a 0122     		movs	r2, #1
 4104 009c 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 4105 009e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4106 00a0 0DF10703 		add	r3, sp, #7
 4107 00a4 FFF7FEFF 		bl	i2c_writeBytes
 4108              	.LVL261:
1818:Src/mpu6050.c ****             return -1;
 4109              		.loc 1 1818 12 view .LVU1224
 4110 00a8 0028     		cmp	r0, #0
 4111 00aa BAD1     		bne	.L341
1820:Src/mpu6050.c ****         if (st.chip_cfg.active_low_int)
 4112              		.loc 1 1820 9 is_stmt 1 view .LVU1225
 4113 00ac 0320     		movs	r0, #3
 4114 00ae FFF7FEFF 		bl	delay_1ms
 4115              	.LVL262:
1821:Src/mpu6050.c ****             tmp = BIT_ACTL;
 4116              		.loc 1 1821 9 view .LVU1226
1821:Src/mpu6050.c ****             tmp = BIT_ACTL;
 4117              		.loc 1 1821 24 is_stmt 0 view .LVU1227
 4118 00b2 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
1825:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4119              		.loc 1 1825 12 view .LVU1228
 4120 00b6 94F82320 		ldrb	r2, [r4, #35]	@ zero_extendqisi2
1822:Src/mpu6050.c ****         else
 4121              		.loc 1 1822 17 view .LVU1229
 4122 00ba 002B     		cmp	r3, #0
 4123 00bc 18BF     		it	ne
 4124 00be 8023     		movne	r3, #128
 4125 00c0 8DF80730 		strb	r3, [sp, #7]
1825:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4126              		.loc 1 1825 9 is_stmt 1 view .LVU1230
ARM GAS  /tmp/ccNfEN49.s 			page 131


1825:Src/mpu6050.c ****             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
 4127              		.loc 1 1825 12 is_stmt 0 view .LVU1231
 4128 00c4 002A     		cmp	r2, #0
 4129 00c6 D2D1     		bne	.L360
 4130              	.L347:
1827:Src/mpu6050.c ****             return -1;
 4131              		.loc 1 1827 9 is_stmt 1 view .LVU1232
1827:Src/mpu6050.c ****             return -1;
 4132              		.loc 1 1827 13 is_stmt 0 view .LVU1233
 4133 00c8 D4E90010 		ldrd	r1, r0, [r4]
 4134 00cc 0122     		movs	r2, #1
 4135 00ce C97D     		ldrb	r1, [r1, #23]	@ zero_extendqisi2
 4136 00d0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4137 00d2 0DF10703 		add	r3, sp, #7
 4138 00d6 FFF7FEFF 		bl	i2c_writeBytes
 4139              	.LVL263:
1827:Src/mpu6050.c ****             return -1;
 4140              		.loc 1 1827 12 view .LVU1234
 4141 00da 0028     		cmp	r0, #0
 4142 00dc A1D1     		bne	.L341
1830:Src/mpu6050.c ****     return 0;
 4143              		.loc 1 1830 5 is_stmt 1 view .LVU1235
1830:Src/mpu6050.c ****     return 0;
 4144              		.loc 1 1830 29 is_stmt 0 view .LVU1236
 4145 00de A574     		strb	r5, [r4, #18]
1831:Src/mpu6050.c **** }
 4146              		.loc 1 1831 5 is_stmt 1 view .LVU1237
 4147              	.L349:
1794:Src/mpu6050.c **** 
 4148              		.loc 1 1794 16 is_stmt 0 view .LVU1238
 4149 00e0 0020     		movs	r0, #0
 4150 00e2 A0E7     		b	.L337
 4151              	.L362:
 4152              		.align	2
 4153              	.L361:
 4154 00e4 00000000 		.word	.LANCHOR0
 4155              		.cfi_endproc
 4156              	.LFE93:
 4158              		.section	.text.mpu_set_int_level,"ax",%progbits
 4159              		.align	1
 4160              		.global	mpu_set_int_level
 4161              		.syntax unified
 4162              		.thumb
 4163              		.thumb_func
 4164              		.fpu softvfp
 4166              	mpu_set_int_level:
 4167              	.LVL264:
 4168              	.LFB94:
1840:Src/mpu6050.c ****     st.chip_cfg.active_low_int = active_low;
 4169              		.loc 1 1840 1 is_stmt 1 view -0
 4170              		.cfi_startproc
 4171              		@ args = 0, pretend = 0, frame = 0
 4172              		@ frame_needed = 0, uses_anonymous_args = 0
 4173              		@ link register save eliminated.
1841:Src/mpu6050.c ****     return 0;
 4174              		.loc 1 1841 5 view .LVU1240
1841:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 132


 4175              		.loc 1 1841 32 is_stmt 0 view .LVU1241
 4176 0000 024B     		ldr	r3, .L364
 4177 0002 83F82200 		strb	r0, [r3, #34]
1842:Src/mpu6050.c **** }
 4178              		.loc 1 1842 5 is_stmt 1 view .LVU1242
1843:Src/mpu6050.c **** 
 4179              		.loc 1 1843 1 is_stmt 0 view .LVU1243
 4180 0006 0020     		movs	r0, #0
 4181              	.LVL265:
1843:Src/mpu6050.c **** 
 4182              		.loc 1 1843 1 view .LVU1244
 4183 0008 7047     		bx	lr
 4184              	.L365:
 4185 000a 00BF     		.align	2
 4186              	.L364:
 4187 000c 00000000 		.word	.LANCHOR0
 4188              		.cfi_endproc
 4189              	.LFE94:
 4191              		.section	.text.mpu_set_int_latched,"ax",%progbits
 4192              		.align	1
 4193              		.global	mpu_set_int_latched
 4194              		.syntax unified
 4195              		.thumb
 4196              		.thumb_func
 4197              		.fpu softvfp
 4199              	mpu_set_int_latched:
 4200              	.LVL266:
 4201              	.LFB95:
1852:Src/mpu6050.c ****     unsigned char tmp;
 4202              		.loc 1 1852 1 is_stmt 1 view -0
 4203              		.cfi_startproc
 4204              		@ args = 0, pretend = 0, frame = 8
 4205              		@ frame_needed = 0, uses_anonymous_args = 0
1853:Src/mpu6050.c ****     if (st.chip_cfg.latched_int == enable)
 4206              		.loc 1 1853 5 view .LVU1246
1854:Src/mpu6050.c ****         return 0;
 4207              		.loc 1 1854 5 view .LVU1247
1852:Src/mpu6050.c ****     unsigned char tmp;
 4208              		.loc 1 1852 1 is_stmt 0 view .LVU1248
 4209 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4210              	.LCFI65:
 4211              		.cfi_def_cfa_offset 24
 4212              		.cfi_offset 4, -12
 4213              		.cfi_offset 5, -8
 4214              		.cfi_offset 14, -4
1854:Src/mpu6050.c ****         return 0;
 4215              		.loc 1 1854 20 view .LVU1249
 4216 0002 174C     		ldr	r4, .L380
1852:Src/mpu6050.c ****     unsigned char tmp;
 4217              		.loc 1 1852 1 view .LVU1250
 4218 0004 0546     		mov	r5, r0
1854:Src/mpu6050.c ****         return 0;
 4219              		.loc 1 1854 8 view .LVU1251
 4220 0006 94F82330 		ldrb	r3, [r4, #35]	@ zero_extendqisi2
 4221 000a 8342     		cmp	r3, r0
 4222 000c 22D0     		beq	.L371
1857:Src/mpu6050.c ****         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
ARM GAS  /tmp/ccNfEN49.s 			page 133


 4223              		.loc 1 1857 5 is_stmt 1 view .LVU1252
1858:Src/mpu6050.c ****     else
 4224              		.loc 1 1858 13 is_stmt 0 view .LVU1253
 4225 000e 0028     		cmp	r0, #0
 4226 0010 0CBF     		ite	eq
 4227 0012 0023     		moveq	r3, #0
 4228 0014 3023     		movne	r3, #48
1861:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4229              		.loc 1 1861 8 view .LVU1254
 4230 0016 A27C     		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 4231 0018 8DF80730 		strb	r3, [sp, #7]
1861:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4232              		.loc 1 1861 5 is_stmt 1 view .LVU1255
1861:Src/mpu6050.c ****         tmp |= BIT_BYPASS_EN;
 4233              		.loc 1 1861 8 is_stmt 0 view .LVU1256
 4234 001c 1AB1     		cbz	r2, .L369
1862:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
 4235              		.loc 1 1862 9 is_stmt 1 view .LVU1257
1862:Src/mpu6050.c ****     if (st.chip_cfg.active_low_int)
 4236              		.loc 1 1862 13 is_stmt 0 view .LVU1258
 4237 001e 43F00203 		orr	r3, r3, #2
 4238 0022 8DF80730 		strb	r3, [sp, #7]
 4239              	.L369:
1863:Src/mpu6050.c ****         tmp |= BIT_ACTL;
 4240              		.loc 1 1863 5 is_stmt 1 view .LVU1259
1863:Src/mpu6050.c ****         tmp |= BIT_ACTL;
 4241              		.loc 1 1863 8 is_stmt 0 view .LVU1260
 4242 0026 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 4243 002a 2BB1     		cbz	r3, .L370
1864:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4244              		.loc 1 1864 9 is_stmt 1 view .LVU1261
1864:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
 4245              		.loc 1 1864 13 is_stmt 0 view .LVU1262
 4246 002c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4247 0030 63F07F03 		orn	r3, r3, #127
 4248 0034 8DF80730 		strb	r3, [sp, #7]
 4249              	.L370:
1865:Src/mpu6050.c ****         return -1;
 4250              		.loc 1 1865 5 is_stmt 1 view .LVU1263
1865:Src/mpu6050.c ****         return -1;
 4251              		.loc 1 1865 9 is_stmt 0 view .LVU1264
 4252 0038 D4E90010 		ldrd	r1, r0, [r4]
 4253              	.LVL267:
1865:Src/mpu6050.c ****         return -1;
 4254              		.loc 1 1865 9 view .LVU1265
 4255 003c 0122     		movs	r2, #1
 4256 003e C97D     		ldrb	r1, [r1, #23]	@ zero_extendqisi2
 4257 0040 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4258 0042 0DF10703 		add	r3, sp, #7
 4259 0046 FFF7FEFF 		bl	i2c_writeBytes
 4260              	.LVL268:
1865:Src/mpu6050.c ****         return -1;
 4261              		.loc 1 1865 8 view .LVU1266
 4262 004a 28B9     		cbnz	r0, .L373
1867:Src/mpu6050.c ****     return 0;
 4263              		.loc 1 1867 5 is_stmt 1 view .LVU1267
1867:Src/mpu6050.c ****     return 0;
ARM GAS  /tmp/ccNfEN49.s 			page 134


 4264              		.loc 1 1867 29 is_stmt 0 view .LVU1268
 4265 004c 84F82350 		strb	r5, [r4, #35]
1868:Src/mpu6050.c **** }
 4266              		.loc 1 1868 5 is_stmt 1 view .LVU1269
 4267              	.L366:
1869:Src/mpu6050.c **** 
 4268              		.loc 1 1869 1 is_stmt 0 view .LVU1270
 4269 0050 03B0     		add	sp, sp, #12
 4270              	.LCFI66:
 4271              		.cfi_remember_state
 4272              		.cfi_def_cfa_offset 12
 4273              		@ sp needed
 4274 0052 30BD     		pop	{r4, r5, pc}
 4275              	.LVL269:
 4276              	.L371:
 4277              	.LCFI67:
 4278              		.cfi_restore_state
1855:Src/mpu6050.c **** 
 4279              		.loc 1 1855 16 view .LVU1271
 4280 0054 0020     		movs	r0, #0
 4281              	.LVL270:
1855:Src/mpu6050.c **** 
 4282              		.loc 1 1855 16 view .LVU1272
 4283 0056 FBE7     		b	.L366
 4284              	.L373:
1866:Src/mpu6050.c ****     st.chip_cfg.latched_int = enable;
 4285              		.loc 1 1866 16 view .LVU1273
 4286 0058 4FF0FF30 		mov	r0, #-1
 4287 005c F8E7     		b	.L366
 4288              	.L381:
 4289 005e 00BF     		.align	2
 4290              	.L380:
 4291 0060 00000000 		.word	.LANCHOR0
 4292              		.cfi_endproc
 4293              	.LFE95:
 4295              		.section	.text.mpu_lp_accel_mode,"ax",%progbits
 4296              		.align	1
 4297              		.global	mpu_lp_accel_mode
 4298              		.syntax unified
 4299              		.thumb
 4300              		.thumb_func
 4301              		.fpu softvfp
 4303              	mpu_lp_accel_mode:
 4304              	.LVL271:
 4305              	.LFB63:
 747:Src/mpu6050.c ****     unsigned char tmp[2];
 4306              		.loc 1 747 1 is_stmt 1 view -0
 4307              		.cfi_startproc
 4308              		@ args = 0, pretend = 0, frame = 8
 4309              		@ frame_needed = 0, uses_anonymous_args = 0
 748:Src/mpu6050.c **** 
 4310              		.loc 1 748 5 view .LVU1275
 750:Src/mpu6050.c ****         return -1;
 4311              		.loc 1 750 5 view .LVU1276
 750:Src/mpu6050.c ****         return -1;
 4312              		.loc 1 750 8 is_stmt 0 view .LVU1277
 4313 0000 2828     		cmp	r0, #40
ARM GAS  /tmp/ccNfEN49.s 			page 135


 747:Src/mpu6050.c ****     unsigned char tmp[2];
 4314              		.loc 1 747 1 view .LVU1278
 4315 0002 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4316              	.LCFI68:
 4317              		.cfi_def_cfa_offset 24
 4318              		.cfi_offset 4, -12
 4319              		.cfi_offset 5, -8
 4320              		.cfi_offset 14, -4
 747:Src/mpu6050.c ****     unsigned char tmp[2];
 4321              		.loc 1 747 1 view .LVU1279
 4322 0004 0446     		mov	r4, r0
 750:Src/mpu6050.c ****         return -1;
 4323              		.loc 1 750 8 view .LVU1280
 4324 0006 03D9     		bls	.L383
 4325              	.LVL272:
 4326              	.L386:
 751:Src/mpu6050.c **** 
 4327              		.loc 1 751 16 view .LVU1281
 4328 0008 4FF0FF30 		mov	r0, #-1
 4329              	.L382:
 822:Src/mpu6050.c **** 
 4330              		.loc 1 822 1 view .LVU1282
 4331 000c 03B0     		add	sp, sp, #12
 4332              	.LCFI69:
 4333              		.cfi_remember_state
 4334              		.cfi_def_cfa_offset 12
 4335              		@ sp needed
 4336 000e 30BD     		pop	{r4, r5, pc}
 4337              	.LVL273:
 4338              	.L383:
 4339              	.LCFI70:
 4340              		.cfi_restore_state
 753:Src/mpu6050.c ****         mpu_set_int_latched(0);
 4341              		.loc 1 753 5 is_stmt 1 view .LVU1283
 4342 0010 264D     		ldr	r5, .L393
 753:Src/mpu6050.c ****         mpu_set_int_latched(0);
 4343              		.loc 1 753 8 is_stmt 0 view .LVU1284
 4344 0012 90B9     		cbnz	r0, .L385
 754:Src/mpu6050.c ****         tmp[0] = 0;
 4345              		.loc 1 754 9 is_stmt 1 view .LVU1285
 4346 0014 FFF7FEFF 		bl	mpu_set_int_latched
 4347              	.LVL274:
 755:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 4348              		.loc 1 755 9 view .LVU1286
 757:Src/mpu6050.c ****             return -1;
 4349              		.loc 1 757 13 is_stmt 0 view .LVU1287
 4350 0018 D5E90010 		ldrd	r1, r0, [r5]
 756:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4351              		.loc 1 756 16 view .LVU1288
 4352 001c 0723     		movs	r3, #7
 755:Src/mpu6050.c ****         tmp[1] = BIT_STBY_XYZG;
 4353              		.loc 1 755 16 view .LVU1289
 4354 001e 8DF80440 		strb	r4, [sp, #4]
 756:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4355              		.loc 1 756 9 is_stmt 1 view .LVU1290
 756:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4356              		.loc 1 756 16 is_stmt 0 view .LVU1291
ARM GAS  /tmp/ccNfEN49.s 			page 136


 4357 0022 8DF80530 		strb	r3, [sp, #5]
 757:Src/mpu6050.c ****             return -1;
 4358              		.loc 1 757 9 is_stmt 1 view .LVU1292
 757:Src/mpu6050.c ****             return -1;
 4359              		.loc 1 757 13 is_stmt 0 view .LVU1293
 4360 0026 0222     		movs	r2, #2
 4361 0028 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4362 002a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4363 002c 01AB     		add	r3, sp, #4
 4364 002e FFF7FEFF 		bl	i2c_writeBytes
 4365              	.LVL275:
 757:Src/mpu6050.c ****             return -1;
 4366              		.loc 1 757 12 view .LVU1294
 4367 0032 0028     		cmp	r0, #0
 4368 0034 E8D1     		bne	.L386
 759:Src/mpu6050.c ****         return 0;
 4369              		.loc 1 759 9 is_stmt 1 view .LVU1295
 759:Src/mpu6050.c ****         return 0;
 4370              		.loc 1 759 35 is_stmt 0 view .LVU1296
 4371 0036 2875     		strb	r0, [r5, #20]
 760:Src/mpu6050.c ****     }
 4372              		.loc 1 760 9 is_stmt 1 view .LVU1297
 760:Src/mpu6050.c ****     }
 4373              		.loc 1 760 16 is_stmt 0 view .LVU1298
 4374 0038 E8E7     		b	.L382
 4375              	.LVL276:
 4376              	.L385:
 769:Src/mpu6050.c **** #if defined MPU6050
 4377              		.loc 1 769 5 is_stmt 1 view .LVU1299
 4378 003a 0120     		movs	r0, #1
 4379              	.LVL277:
 769:Src/mpu6050.c **** #if defined MPU6050
 4380              		.loc 1 769 5 is_stmt 0 view .LVU1300
 4381 003c FFF7FEFF 		bl	mpu_set_int_latched
 4382              	.LVL278:
 771:Src/mpu6050.c ****     if (rate == 1) {
 4383              		.loc 1 771 5 is_stmt 1 view .LVU1301
 771:Src/mpu6050.c ****     if (rate == 1) {
 4384              		.loc 1 771 12 is_stmt 0 view .LVU1302
 4385 0040 2023     		movs	r3, #32
 772:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4386              		.loc 1 772 8 view .LVU1303
 4387 0042 012C     		cmp	r4, #1
 771:Src/mpu6050.c ****     if (rate == 1) {
 4388              		.loc 1 771 12 view .LVU1304
 4389 0044 8DF80430 		strb	r3, [sp, #4]
 772:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4390              		.loc 1 772 5 is_stmt 1 view .LVU1305
 772:Src/mpu6050.c ****         tmp[1] = INV_LPA_1_25HZ;
 4391              		.loc 1 772 8 is_stmt 0 view .LVU1306
 4392 0048 20D1     		bne	.L387
 773:Src/mpu6050.c ****         mpu_set_lpf(5);
 4393              		.loc 1 773 9 is_stmt 1 view .LVU1307
 773:Src/mpu6050.c ****         mpu_set_lpf(5);
 4394              		.loc 1 773 16 is_stmt 0 view .LVU1308
 4395 004a 0023     		movs	r3, #0
 4396              	.L392:
ARM GAS  /tmp/ccNfEN49.s 			page 137


 777:Src/mpu6050.c ****     } else if (rate <= 20) {
 4397              		.loc 1 777 9 view .LVU1309
 4398 004c 0520     		movs	r0, #5
 776:Src/mpu6050.c ****         mpu_set_lpf(5);
 4399              		.loc 1 776 16 view .LVU1310
 4400 004e 8DF80530 		strb	r3, [sp, #5]
 777:Src/mpu6050.c ****     } else if (rate <= 20) {
 4401              		.loc 1 777 9 is_stmt 1 view .LVU1311
 4402              	.L391:
 783:Src/mpu6050.c ****     }
 4403              		.loc 1 783 9 is_stmt 0 view .LVU1312
 4404 0052 FFF7FEFF 		bl	mpu_set_lpf
 4405              	.LVL279:
 785:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4406              		.loc 1 785 5 is_stmt 1 view .LVU1313
 786:Src/mpu6050.c ****         return -1;
 4407              		.loc 1 786 9 is_stmt 0 view .LVU1314
 4408 0056 D5E90010 		ldrd	r1, r0, [r5]
 785:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4409              		.loc 1 785 18 view .LVU1315
 4410 005a 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 786:Src/mpu6050.c ****         return -1;
 4411              		.loc 1 786 9 view .LVU1316
 4412 005e 0222     		movs	r2, #2
 785:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4413              		.loc 1 785 22 view .LVU1317
 4414 0060 9B01     		lsls	r3, r3, #6
 785:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4415              		.loc 1 785 28 view .LVU1318
 4416 0062 43F00703 		orr	r3, r3, #7
 785:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
 4417              		.loc 1 785 12 view .LVU1319
 4418 0066 8DF80530 		strb	r3, [sp, #5]
 786:Src/mpu6050.c ****         return -1;
 4419              		.loc 1 786 5 is_stmt 1 view .LVU1320
 786:Src/mpu6050.c ****         return -1;
 4420              		.loc 1 786 9 is_stmt 0 view .LVU1321
 4421 006a 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4422 006c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4423 006e 01AB     		add	r3, sp, #4
 4424 0070 FFF7FEFF 		bl	i2c_writeBytes
 4425              	.LVL280:
 786:Src/mpu6050.c ****         return -1;
 4426              		.loc 1 786 8 view .LVU1322
 4427 0074 0446     		mov	r4, r0
 4428 0076 0028     		cmp	r0, #0
 4429 0078 C6D1     		bne	.L386
 816:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 4430              		.loc 1 816 5 is_stmt 1 view .LVU1323
 816:Src/mpu6050.c ****     st.chip_cfg.clk_src = 0;
 4431              		.loc 1 816 25 is_stmt 0 view .LVU1324
 4432 007a 0823     		movs	r3, #8
 4433 007c AB72     		strb	r3, [r5, #10]
 817:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 4434              		.loc 1 817 5 is_stmt 1 view .LVU1325
 818:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4435              		.loc 1 818 31 is_stmt 0 view .LVU1326
ARM GAS  /tmp/ccNfEN49.s 			page 138


 4436 007e 0123     		movs	r3, #1
 817:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 1;
 4437              		.loc 1 817 25 view .LVU1327
 4438 0080 2873     		strb	r0, [r5, #12]
 818:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4439              		.loc 1 818 5 is_stmt 1 view .LVU1328
 818:Src/mpu6050.c ****     mpu_configure_fifo(0);
 4440              		.loc 1 818 31 is_stmt 0 view .LVU1329
 4441 0082 2B75     		strb	r3, [r5, #20]
 819:Src/mpu6050.c **** 
 4442              		.loc 1 819 5 is_stmt 1 view .LVU1330
 4443 0084 FFF7FEFF 		bl	mpu_configure_fifo
 4444              	.LVL281:
 821:Src/mpu6050.c **** }
 4445              		.loc 1 821 5 view .LVU1331
 821:Src/mpu6050.c **** }
 4446              		.loc 1 821 12 is_stmt 0 view .LVU1332
 4447 0088 2046     		mov	r0, r4
 4448 008a BFE7     		b	.L382
 4449              	.L387:
 775:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 4450              		.loc 1 775 12 is_stmt 1 view .LVU1333
 775:Src/mpu6050.c ****         tmp[1] = INV_LPA_5HZ;
 4451              		.loc 1 775 15 is_stmt 0 view .LVU1334
 4452 008c 052C     		cmp	r4, #5
 4453 008e 01D8     		bhi	.L389
 776:Src/mpu6050.c ****         mpu_set_lpf(5);
 4454              		.loc 1 776 9 is_stmt 1 view .LVU1335
 776:Src/mpu6050.c ****         mpu_set_lpf(5);
 4455              		.loc 1 776 16 is_stmt 0 view .LVU1336
 4456 0090 0123     		movs	r3, #1
 4457 0092 DBE7     		b	.L392
 4458              	.L389:
 778:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 4459              		.loc 1 778 12 is_stmt 1 view .LVU1337
 778:Src/mpu6050.c ****         tmp[1] = INV_LPA_20HZ;
 4460              		.loc 1 778 15 is_stmt 0 view .LVU1338
 4461 0094 142C     		cmp	r4, #20
 779:Src/mpu6050.c ****         mpu_set_lpf(10);
 4462              		.loc 1 779 9 is_stmt 1 view .LVU1339
 779:Src/mpu6050.c ****         mpu_set_lpf(10);
 4463              		.loc 1 779 16 is_stmt 0 view .LVU1340
 4464 0096 95BF     		itete	ls
 4465 0098 0223     		movls	r3, #2
 782:Src/mpu6050.c ****         mpu_set_lpf(20);
 4466              		.loc 1 782 16 view .LVU1341
 4467 009a 0323     		movhi	r3, #3
 780:Src/mpu6050.c ****     } else {
 4468              		.loc 1 780 9 view .LVU1342
 4469 009c 0A20     		movls	r0, #10
 783:Src/mpu6050.c ****     }
 4470              		.loc 1 783 9 view .LVU1343
 4471 009e 1420     		movhi	r0, #20
 779:Src/mpu6050.c ****         mpu_set_lpf(10);
 4472              		.loc 1 779 16 view .LVU1344
 4473 00a0 94BF     		ite	ls
 4474 00a2 8DF80530 		strbls	r3, [sp, #5]
ARM GAS  /tmp/ccNfEN49.s 			page 139


 780:Src/mpu6050.c ****     } else {
 4475              		.loc 1 780 9 is_stmt 1 view .LVU1345
 782:Src/mpu6050.c ****         mpu_set_lpf(20);
 4476              		.loc 1 782 9 view .LVU1346
 782:Src/mpu6050.c ****         mpu_set_lpf(20);
 4477              		.loc 1 782 16 is_stmt 0 view .LVU1347
 4478 00a6 8DF80530 		strbhi	r3, [sp, #5]
 783:Src/mpu6050.c ****     }
 4479              		.loc 1 783 9 is_stmt 1 view .LVU1348
 4480 00aa D2E7     		b	.L391
 4481              	.L394:
 4482              		.align	2
 4483              	.L393:
 4484 00ac 00000000 		.word	.LANCHOR0
 4485              		.cfi_endproc
 4486              	.LFE63:
 4488              		.section	.text.mpu_set_sample_rate,"ax",%progbits
 4489              		.align	1
 4490              		.global	mpu_set_sample_rate
 4491              		.syntax unified
 4492              		.thumb
 4493              		.thumb_func
 4494              		.fpu softvfp
 4496              	mpu_set_sample_rate:
 4497              	.LVL282:
 4498              	.LFB81:
1338:Src/mpu6050.c ****     unsigned char data;
 4499              		.loc 1 1338 1 view -0
 4500              		.cfi_startproc
 4501              		@ args = 0, pretend = 0, frame = 8
 4502              		@ frame_needed = 0, uses_anonymous_args = 0
1339:Src/mpu6050.c **** 
 4503              		.loc 1 1339 5 view .LVU1350
1341:Src/mpu6050.c ****         return -1;
 4504              		.loc 1 1341 5 view .LVU1351
1338:Src/mpu6050.c ****     unsigned char data;
 4505              		.loc 1 1338 1 is_stmt 0 view .LVU1352
 4506 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 4507              	.LCFI71:
 4508              		.cfi_def_cfa_offset 32
 4509              		.cfi_offset 4, -20
 4510              		.cfi_offset 5, -16
 4511              		.cfi_offset 6, -12
 4512              		.cfi_offset 7, -8
 4513              		.cfi_offset 14, -4
1341:Src/mpu6050.c ****         return -1;
 4514              		.loc 1 1341 22 view .LVU1353
 4515 0002 1E4E     		ldr	r6, .L405
1338:Src/mpu6050.c ****     unsigned char data;
 4516              		.loc 1 1338 1 view .LVU1354
 4517 0004 0546     		mov	r5, r0
1341:Src/mpu6050.c ****         return -1;
 4518              		.loc 1 1341 8 view .LVU1355
 4519 0006 B37A     		ldrb	r3, [r6, #10]	@ zero_extendqisi2
 4520 0008 1BB9     		cbnz	r3, .L396
 4521              	.LVL283:
 4522              	.L398:
ARM GAS  /tmp/ccNfEN49.s 			page 140


1342:Src/mpu6050.c **** 
 4523              		.loc 1 1342 16 view .LVU1356
 4524 000a 4FF0FF30 		mov	r0, #-1
 4525              	.L395:
1377:Src/mpu6050.c **** 
 4526              		.loc 1 1377 1 view .LVU1357
 4527 000e 03B0     		add	sp, sp, #12
 4528              	.LCFI72:
 4529              		.cfi_remember_state
 4530              		.cfi_def_cfa_offset 20
 4531              		@ sp needed
 4532 0010 F0BD     		pop	{r4, r5, r6, r7, pc}
 4533              	.LVL284:
 4534              	.L396:
 4535              	.LCFI73:
 4536              		.cfi_restore_state
1344:Src/mpu6050.c ****         return -1;
 4537              		.loc 1 1344 5 is_stmt 1 view .LVU1358
1344:Src/mpu6050.c ****         return -1;
 4538              		.loc 1 1344 8 is_stmt 0 view .LVU1359
 4539 0012 96F82440 		ldrb	r4, [r6, #36]	@ zero_extendqisi2
 4540 0016 002C     		cmp	r4, #0
 4541 0018 F7D1     		bne	.L398
1347:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
 4542              		.loc 1 1347 9 is_stmt 1 view .LVU1360
1347:Src/mpu6050.c ****             if (rate && (rate <= 40)) {
 4543              		.loc 1 1347 12 is_stmt 0 view .LVU1361
 4544 001a 337D     		ldrb	r3, [r6, #20]	@ zero_extendqisi2
 4545 001c 4BB1     		cbz	r3, .L399
1348:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
 4546              		.loc 1 1348 13 is_stmt 1 view .LVU1362
1348:Src/mpu6050.c ****                 /* Just stay in low-power accel mode. */
 4547              		.loc 1 1348 16 is_stmt 0 view .LVU1363
 4548 001e 431E     		subs	r3, r0, #1
 4549 0020 272B     		cmp	r3, #39
 4550 0022 03D8     		bhi	.L400
1350:Src/mpu6050.c ****                 return 0;
 4551              		.loc 1 1350 17 is_stmt 1 view .LVU1364
 4552 0024 FFF7FEFF 		bl	mpu_lp_accel_mode
 4553              	.LVL285:
1351:Src/mpu6050.c ****             }
 4554              		.loc 1 1351 17 view .LVU1365
 4555              	.L404:
1375:Src/mpu6050.c ****     }
 4556              		.loc 1 1375 9 view .LVU1366
1375:Src/mpu6050.c ****     }
 4557              		.loc 1 1375 16 is_stmt 0 view .LVU1367
 4558 0028 2046     		mov	r0, r4
 4559 002a F0E7     		b	.L395
 4560              	.LVL286:
 4561              	.L400:
1356:Src/mpu6050.c ****         }
 4562              		.loc 1 1356 13 is_stmt 1 view .LVU1368
 4563 002c 2046     		mov	r0, r4
 4564              	.LVL287:
1356:Src/mpu6050.c ****         }
 4565              		.loc 1 1356 13 is_stmt 0 view .LVU1369
ARM GAS  /tmp/ccNfEN49.s 			page 141


 4566 002e FFF7FEFF 		bl	mpu_lp_accel_mode
 4567              	.LVL288:
 4568              	.L399:
1358:Src/mpu6050.c ****             rate = 4;
 4569              		.loc 1 1358 9 is_stmt 1 view .LVU1370
1364:Src/mpu6050.c ****             return -1;
 4570              		.loc 1 1364 13 is_stmt 0 view .LVU1371
 4571 0032 D6E90010 		ldrd	r1, r0, [r6]
 4572 0036 B5F57A7F 		cmp	r5, #1000
 4573 003a 28BF     		it	cs
 4574 003c 4FF47A75 		movcs	r5, #1000
 4575              	.LVL289:
1363:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4576              		.loc 1 1363 9 is_stmt 1 view .LVU1372
1363:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4577              		.loc 1 1363 21 is_stmt 0 view .LVU1373
 4578 0040 042D     		cmp	r5, #4
 4579 0042 38BF     		it	cc
 4580 0044 0425     		movcc	r5, #4
 4581              	.LVL290:
1363:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4582              		.loc 1 1363 21 view .LVU1374
 4583 0046 4FF47A77 		mov	r7, #1000
 4584 004a B7FBF5F5 		udiv	r5, r7, r5
1363:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4585              		.loc 1 1363 28 view .LVU1375
 4586 004e 013D     		subs	r5, r5, #1
1363:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
 4587              		.loc 1 1363 14 view .LVU1376
 4588 0050 8DF80750 		strb	r5, [sp, #7]
1364:Src/mpu6050.c ****             return -1;
 4589              		.loc 1 1364 9 is_stmt 1 view .LVU1377
1364:Src/mpu6050.c ****             return -1;
 4590              		.loc 1 1364 13 is_stmt 0 view .LVU1378
 4591 0054 0122     		movs	r2, #1
 4592 0056 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4593 0058 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4594 005a 0DF10703 		add	r3, sp, #7
 4595 005e FFF7FEFF 		bl	i2c_writeBytes
 4596              	.LVL291:
1364:Src/mpu6050.c ****             return -1;
 4597              		.loc 1 1364 12 view .LVU1379
 4598 0062 0446     		mov	r4, r0
 4599 0064 0028     		cmp	r0, #0
 4600 0066 D0D1     		bne	.L398
1367:Src/mpu6050.c **** 
 4601              		.loc 1 1367 9 is_stmt 1 view .LVU1380
1367:Src/mpu6050.c **** 
 4602              		.loc 1 1367 45 is_stmt 0 view .LVU1381
 4603 0068 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 4604 006c 0130     		adds	r0, r0, #1
1367:Src/mpu6050.c **** 
 4605              		.loc 1 1367 33 view .LVU1382
 4606 006e B7FBF0F0 		udiv	r0, r7, r0
 4607 0072 F081     		strh	r0, [r6, #14]	@ movhi
1374:Src/mpu6050.c ****         return 0;
 4608              		.loc 1 1374 9 is_stmt 1 view .LVU1383
ARM GAS  /tmp/ccNfEN49.s 			page 142


 4609 0074 4008     		lsrs	r0, r0, #1
 4610 0076 FFF7FEFF 		bl	mpu_set_lpf
 4611              	.LVL292:
 4612 007a D5E7     		b	.L404
 4613              	.L406:
 4614              		.align	2
 4615              	.L405:
 4616 007c 00000000 		.word	.LANCHOR0
 4617              		.cfi_endproc
 4618              	.LFE81:
 4620              		.section	.text.mpu_set_sensors,"ax",%progbits
 4621              		.align	1
 4622              		.global	mpu_set_sensors
 4623              		.syntax unified
 4624              		.thumb
 4625              		.thumb_func
 4626              		.fpu softvfp
 4628              	mpu_set_sensors:
 4629              	.LVL293:
 4630              	.LFB89:
1563:Src/mpu6050.c ****     unsigned char data;
 4631              		.loc 1 1563 1 view -0
 4632              		.cfi_startproc
 4633              		@ args = 0, pretend = 0, frame = 8
 4634              		@ frame_needed = 0, uses_anonymous_args = 0
1564:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4635              		.loc 1 1564 5 view .LVU1385
1569:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4636              		.loc 1 1569 5 view .LVU1386
1569:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4637              		.loc 1 1569 8 is_stmt 0 view .LVU1387
 4638 0000 10F07003 		ands	r3, r0, #112
1563:Src/mpu6050.c ****     unsigned char data;
 4639              		.loc 1 1563 1 view .LVU1388
 4640 0004 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4641              	.LCFI74:
 4642              		.cfi_def_cfa_offset 24
 4643              		.cfi_offset 4, -12
 4644              		.cfi_offset 5, -8
 4645              		.cfi_offset 14, -4
1563:Src/mpu6050.c ****     unsigned char data;
 4646              		.loc 1 1563 1 view .LVU1389
 4647 0006 0446     		mov	r4, r0
1569:Src/mpu6050.c ****         data = INV_CLK_PLL;
 4648              		.loc 1 1569 8 view .LVU1390
 4649 0008 13D0     		beq	.L408
1570:Src/mpu6050.c ****     else if (sensors)
 4650              		.loc 1 1570 9 is_stmt 1 view .LVU1391
1570:Src/mpu6050.c ****     else if (sensors)
 4651              		.loc 1 1570 14 is_stmt 0 view .LVU1392
 4652 000a 0123     		movs	r3, #1
 4653              	.L423:
1575:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4654              		.loc 1 1575 34 view .LVU1393
 4655 000c 2B4D     		ldr	r5, .L424
1574:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4656              		.loc 1 1574 14 view .LVU1394
ARM GAS  /tmp/ccNfEN49.s 			page 143


 4657 000e 8DF80730 		strb	r3, [sp, #7]
1575:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4658              		.loc 1 1575 5 is_stmt 1 view .LVU1395
1575:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4659              		.loc 1 1575 9 is_stmt 0 view .LVU1396
 4660 0012 D5E90010 		ldrd	r1, r0, [r5]
 4661              	.LVL294:
1575:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4662              		.loc 1 1575 9 view .LVU1397
 4663 0016 0122     		movs	r2, #1
 4664 0018 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4665 001a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4666 001c 0DF10703 		add	r3, sp, #7
 4667 0020 FFF7FEFF 		bl	i2c_writeBytes
 4668              	.LVL295:
1575:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4669              		.loc 1 1575 8 view .LVU1398
 4670 0024 48B1     		cbz	r0, .L411
 4671              	.L418:
1576:Src/mpu6050.c ****         return -1;
 4672              		.loc 1 1576 9 is_stmt 1 view .LVU1399
1576:Src/mpu6050.c ****         return -1;
 4673              		.loc 1 1576 29 is_stmt 0 view .LVU1400
 4674 0026 0023     		movs	r3, #0
1577:Src/mpu6050.c ****     }
 4675              		.loc 1 1577 16 view .LVU1401
 4676 0028 4FF0FF30 		mov	r0, #-1
1576:Src/mpu6050.c ****         return -1;
 4677              		.loc 1 1576 29 view .LVU1402
 4678 002c AB72     		strb	r3, [r5, #10]
1577:Src/mpu6050.c ****     }
 4679              		.loc 1 1577 9 is_stmt 1 view .LVU1403
 4680              	.L407:
1632:Src/mpu6050.c **** 
 4681              		.loc 1 1632 1 is_stmt 0 view .LVU1404
 4682 002e 03B0     		add	sp, sp, #12
 4683              	.LCFI75:
 4684              		.cfi_remember_state
 4685              		.cfi_def_cfa_offset 12
 4686              		@ sp needed
 4687 0030 30BD     		pop	{r4, r5, pc}
 4688              	.LVL296:
 4689              	.L408:
 4690              	.LCFI76:
 4691              		.cfi_restore_state
1571:Src/mpu6050.c ****         data = 0;
 4692              		.loc 1 1571 10 is_stmt 1 view .LVU1405
1571:Src/mpu6050.c ****         data = 0;
 4693              		.loc 1 1571 13 is_stmt 0 view .LVU1406
 4694 0032 0028     		cmp	r0, #0
 4695 0034 EAD1     		bne	.L423
1574:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4696              		.loc 1 1574 9 is_stmt 1 view .LVU1407
1574:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
 4697              		.loc 1 1574 14 is_stmt 0 view .LVU1408
 4698 0036 4023     		movs	r3, #64
 4699 0038 E8E7     		b	.L423
ARM GAS  /tmp/ccNfEN49.s 			page 144


 4700              	.LVL297:
 4701              	.L411:
1579:Src/mpu6050.c **** 
 4702              		.loc 1 1579 5 is_stmt 1 view .LVU1409
1579:Src/mpu6050.c **** 
 4703              		.loc 1 1579 32 is_stmt 0 view .LVU1410
 4704 003a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4705 003e 23F04003 		bic	r3, r3, #64
1579:Src/mpu6050.c **** 
 4706              		.loc 1 1579 25 view .LVU1411
 4707 0042 2B73     		strb	r3, [r5, #12]
1581:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
 4708              		.loc 1 1581 5 is_stmt 1 view .LVU1412
1582:Src/mpu6050.c ****         data |= BIT_STBY_XG;
 4709              		.loc 1 1582 5 view .LVU1413
1582:Src/mpu6050.c ****         data |= BIT_STBY_XG;
 4710              		.loc 1 1582 8 is_stmt 0 view .LVU1414
 4711 0044 6306     		lsls	r3, r4, #25
1583:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4712              		.loc 1 1583 14 view .LVU1415
 4713 0046 56BF     		itet	pl
 4714 0048 0423     		movpl	r3, #4
1581:Src/mpu6050.c ****     if (!(sensors & INV_X_GYRO))
 4715              		.loc 1 1581 10 view .LVU1416
 4716 004a 8DF80700 		strbmi	r0, [sp, #7]
1583:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4717              		.loc 1 1583 9 is_stmt 1 view .LVU1417
1583:Src/mpu6050.c ****     if (!(sensors & INV_Y_GYRO))
 4718              		.loc 1 1583 14 is_stmt 0 view .LVU1418
 4719 004e 8DF80730 		strbpl	r3, [sp, #7]
1584:Src/mpu6050.c ****         data |= BIT_STBY_YG;
 4720              		.loc 1 1584 5 is_stmt 1 view .LVU1419
1584:Src/mpu6050.c ****         data |= BIT_STBY_YG;
 4721              		.loc 1 1584 8 is_stmt 0 view .LVU1420
 4722 0052 A106     		lsls	r1, r4, #26
1585:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4723              		.loc 1 1585 9 is_stmt 1 view .LVU1421
1585:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4724              		.loc 1 1585 14 is_stmt 0 view .LVU1422
 4725 0054 58BF     		it	pl
 4726 0056 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1590:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4727              		.loc 1 1590 9 view .LVU1423
 4728 005a D5E90010 		ldrd	r1, r0, [r5]
1585:Src/mpu6050.c ****     if (!(sensors & INV_Z_GYRO))
 4729              		.loc 1 1585 14 view .LVU1424
 4730 005e 5CBF     		itt	pl
 4731 0060 43F00203 		orrpl	r3, r3, #2
 4732 0064 8DF80730 		strbpl	r3, [sp, #7]
1586:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
 4733              		.loc 1 1586 5 is_stmt 1 view .LVU1425
1586:Src/mpu6050.c ****         data |= BIT_STBY_ZG;
 4734              		.loc 1 1586 8 is_stmt 0 view .LVU1426
 4735 0068 E206     		lsls	r2, r4, #27
1587:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4736              		.loc 1 1587 9 is_stmt 1 view .LVU1427
1587:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
ARM GAS  /tmp/ccNfEN49.s 			page 145


 4737              		.loc 1 1587 14 is_stmt 0 view .LVU1428
 4738 006a 58BF     		it	pl
 4739 006c 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1590:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4740              		.loc 1 1590 9 view .LVU1429
 4741 0070 4FF00102 		mov	r2, #1
1587:Src/mpu6050.c ****     if (!(sensors & INV_XYZ_ACCEL))
 4742              		.loc 1 1587 14 view .LVU1430
 4743 0074 5CBF     		itt	pl
 4744 0076 43F00103 		orrpl	r3, r3, #1
 4745 007a 8DF80730 		strbpl	r3, [sp, #7]
1588:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
 4746              		.loc 1 1588 5 is_stmt 1 view .LVU1431
1588:Src/mpu6050.c ****         data |= BIT_STBY_XYZA;
 4747              		.loc 1 1588 8 is_stmt 0 view .LVU1432
 4748 007e 2307     		lsls	r3, r4, #28
1589:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4749              		.loc 1 1589 9 is_stmt 1 view .LVU1433
1589:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4750              		.loc 1 1589 14 is_stmt 0 view .LVU1434
 4751 0080 58BF     		it	pl
 4752 0082 9DF80730 		ldrbpl	r3, [sp, #7]	@ zero_extendqisi2
1590:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4753              		.loc 1 1590 9 view .LVU1435
 4754 0086 897D     		ldrb	r1, [r1, #22]	@ zero_extendqisi2
1589:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
 4755              		.loc 1 1589 14 view .LVU1436
 4756 0088 5CBF     		itt	pl
 4757 008a 43F03803 		orrpl	r3, r3, #56
 4758 008e 8DF80730 		strbpl	r3, [sp, #7]
1590:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4759              		.loc 1 1590 5 is_stmt 1 view .LVU1437
1590:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4760              		.loc 1 1590 9 is_stmt 0 view .LVU1438
 4761 0092 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4762 0094 0DF10703 		add	r3, sp, #7
 4763 0098 FFF7FEFF 		bl	i2c_writeBytes
 4764              	.LVL298:
1590:Src/mpu6050.c ****         st.chip_cfg.sensors = 0;
 4765              		.loc 1 1590 8 view .LVU1439
 4766 009c 0028     		cmp	r0, #0
 4767 009e C2D1     		bne	.L418
1595:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
 4768              		.loc 1 1595 5 is_stmt 1 view .LVU1440
1595:Src/mpu6050.c ****         /* Latched interrupts only used in LP accel mode. */
 4769              		.loc 1 1595 8 is_stmt 0 view .LVU1441
 4770 00a0 14F0F70F 		tst	r4, #247
 4771 00a4 01D0     		beq	.L419
1597:Src/mpu6050.c **** 
 4772              		.loc 1 1597 9 is_stmt 1 view .LVU1442
 4773 00a6 FFF7FEFF 		bl	mpu_set_int_latched
 4774              	.LVL299:
 4775              	.L419:
1628:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4776              		.loc 1 1628 5 view .LVU1443
1628:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4777              		.loc 1 1628 25 is_stmt 0 view .LVU1444
ARM GAS  /tmp/ccNfEN49.s 			page 146


 4778 00aa AC72     		strb	r4, [r5, #10]
1629:Src/mpu6050.c ****     delay_ms(50);
 4779              		.loc 1 1629 5 is_stmt 1 view .LVU1445
1629:Src/mpu6050.c ****     delay_ms(50);
 4780              		.loc 1 1629 31 is_stmt 0 view .LVU1446
 4781 00ac 0024     		movs	r4, #0
1630:Src/mpu6050.c ****     return 0;
 4782              		.loc 1 1630 5 view .LVU1447
 4783 00ae 3220     		movs	r0, #50
1629:Src/mpu6050.c ****     delay_ms(50);
 4784              		.loc 1 1629 31 view .LVU1448
 4785 00b0 2C75     		strb	r4, [r5, #20]
1630:Src/mpu6050.c ****     return 0;
 4786              		.loc 1 1630 5 is_stmt 1 view .LVU1449
 4787 00b2 FFF7FEFF 		bl	delay_1ms
 4788              	.LVL300:
1631:Src/mpu6050.c **** }
 4789              		.loc 1 1631 5 view .LVU1450
1631:Src/mpu6050.c **** }
 4790              		.loc 1 1631 12 is_stmt 0 view .LVU1451
 4791 00b6 2046     		mov	r0, r4
 4792 00b8 B9E7     		b	.L407
 4793              	.L425:
 4794 00ba 00BF     		.align	2
 4795              	.L424:
 4796 00bc 00000000 		.word	.LANCHOR0
 4797              		.cfi_endproc
 4798              	.LFE89:
 4800              		.section	.text.mpu_init,"ax",%progbits
 4801              		.align	1
 4802              		.global	mpu_init
 4803              		.syntax unified
 4804              		.thumb
 4805              		.thumb_func
 4806              		.fpu softvfp
 4808              	mpu_init:
 4809              	.LFB62:
 658:Src/mpu6050.c ****     unsigned char data[6];
 4810              		.loc 1 658 1 is_stmt 1 view -0
 4811              		.cfi_startproc
 4812              		@ args = 0, pretend = 0, frame = 8
 4813              		@ frame_needed = 0, uses_anonymous_args = 0
 659:Src/mpu6050.c **** 
 4814              		.loc 1 659 5 view .LVU1453
 662:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4815              		.loc 1 662 5 view .LVU1454
 662:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4816              		.loc 1 662 13 is_stmt 0 view .LVU1455
 4817 0000 8023     		movs	r3, #128
 658:Src/mpu6050.c ****     unsigned char data[6];
 4818              		.loc 1 658 1 view .LVU1456
 4819 0002 37B5     		push	{r0, r1, r2, r4, r5, lr}
 4820              	.LCFI77:
 4821              		.cfi_def_cfa_offset 24
 4822              		.cfi_offset 4, -12
 4823              		.cfi_offset 5, -8
 4824              		.cfi_offset 14, -4
ARM GAS  /tmp/ccNfEN49.s 			page 147


 663:Src/mpu6050.c ****         return -1;
 4825              		.loc 1 663 34 view .LVU1457
 4826 0004 2A4C     		ldr	r4, .L430
 662:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4827              		.loc 1 662 13 view .LVU1458
 4828 0006 8DF80030 		strb	r3, [sp]
 663:Src/mpu6050.c ****         return -1;
 4829              		.loc 1 663 5 is_stmt 1 view .LVU1459
 663:Src/mpu6050.c ****         return -1;
 4830              		.loc 1 663 9 is_stmt 0 view .LVU1460
 4831 000a D4E90010 		ldrd	r1, r0, [r4]
 4832 000e 6B46     		mov	r3, sp
 4833 0010 0122     		movs	r2, #1
 4834 0012 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4835 0014 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4836 0016 FFF7FEFF 		bl	i2c_writeBytes
 4837              	.LVL301:
 663:Src/mpu6050.c ****         return -1;
 4838              		.loc 1 663 8 view .LVU1461
 4839 001a 0546     		mov	r5, r0
 4840 001c 20B1     		cbz	r0, .L427
 4841              	.L429:
 664:Src/mpu6050.c ****     delay_ms(100);
 4842              		.loc 1 664 16 view .LVU1462
 4843 001e 4FF0FF34 		mov	r4, #-1
 4844              	.L426:
 729:Src/mpu6050.c **** 
 4845              		.loc 1 729 1 view .LVU1463
 4846 0022 2046     		mov	r0, r4
 4847 0024 03B0     		add	sp, sp, #12
 4848              	.LCFI78:
 4849              		.cfi_remember_state
 4850              		.cfi_def_cfa_offset 12
 4851              		@ sp needed
 4852 0026 30BD     		pop	{r4, r5, pc}
 4853              	.L427:
 4854              	.LCFI79:
 4855              		.cfi_restore_state
 665:Src/mpu6050.c **** 
 4856              		.loc 1 665 5 is_stmt 1 view .LVU1464
 4857 0028 6420     		movs	r0, #100
 4858 002a FFF7FEFF 		bl	delay_1ms
 4859              	.LVL302:
 668:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4860              		.loc 1 668 5 view .LVU1465
 669:Src/mpu6050.c ****         return -1;
 4861              		.loc 1 669 9 is_stmt 0 view .LVU1466
 4862 002e D4E90010 		ldrd	r1, r0, [r4]
 668:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
 4863              		.loc 1 668 13 view .LVU1467
 4864 0032 8DF80050 		strb	r5, [sp]
 669:Src/mpu6050.c ****         return -1;
 4865              		.loc 1 669 5 is_stmt 1 view .LVU1468
 669:Src/mpu6050.c ****         return -1;
 4866              		.loc 1 669 9 is_stmt 0 view .LVU1469
 4867 0036 6B46     		mov	r3, sp
 4868 0038 0122     		movs	r2, #1
ARM GAS  /tmp/ccNfEN49.s 			page 148


 4869 003a 497D     		ldrb	r1, [r1, #21]	@ zero_extendqisi2
 4870 003c 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 4871 003e FFF7FEFF 		bl	i2c_writeBytes
 4872              	.LVL303:
 669:Src/mpu6050.c ****         return -1;
 4873              		.loc 1 669 8 view .LVU1470
 4874 0042 0028     		cmp	r0, #0
 4875 0044 EBD1     		bne	.L429
 672:Src/mpu6050.c **** 
 4876              		.loc 1 672 4 is_stmt 1 view .LVU1471
 684:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 4877              		.loc 1 684 5 view .LVU1472
 685:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 4878              		.loc 1 685 5 view .LVU1473
 686:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 4879              		.loc 1 686 5 view .LVU1474
 687:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 4880              		.loc 1 687 5 view .LVU1475
 688:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 4881              		.loc 1 688 5 view .LVU1476
 688:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 4882              		.loc 1 688 29 is_stmt 0 view .LVU1477
 4883 0046 4FF6FF73 		movw	r3, #65535
 4884 004a E381     		strh	r3, [r4, #14]	@ movhi
 689:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 4885              		.loc 1 689 5 is_stmt 1 view .LVU1478
 689:Src/mpu6050.c ****     st.chip_cfg.bypass_mode = 0xFF;
 4886              		.loc 1 689 29 is_stmt 0 view .LVU1479
 4887 004c 2374     		strb	r3, [r4, #16]
 690:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4888              		.loc 1 690 5 is_stmt 1 view .LVU1480
 695:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 4889              		.loc 1 695 5 view .LVU1481
 685:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 4890              		.loc 1 685 26 is_stmt 0 view .LVU1482
 4891 004e 4FF0FF33 		mov	r3, #-1
 690:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 4892              		.loc 1 690 29 view .LVU1483
 4893 0052 FF22     		movs	r2, #255
 685:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 4894              		.loc 1 685 26 view .LVU1484
 4895 0054 A360     		str	r3, [r4, #8]
 695:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 4896              		.loc 1 695 25 view .LVU1485
 4897 0056 0123     		movs	r3, #1
 700:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 4898              		.loc 1 700 31 view .LVU1486
 4899 0058 A082     		strh	r0, [r4, #20]	@ movhi
 701:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 4900              		.loc 1 701 5 view .LVU1487
 4901 005a C4F81600 		str	r0, [r4, #22]	@ unaligned
 4902 005e C4F81A00 		str	r0, [r4, #26]	@ unaligned
 4903 0062 C4F81E00 		str	r0, [r4, #30]	@ unaligned
 702:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 4904              		.loc 1 702 24 view .LVU1488
 4905 0066 6062     		str	r0, [r4, #36]
 690:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
ARM GAS  /tmp/ccNfEN49.s 			page 149


 4906              		.loc 1 690 29 view .LVU1489
 4907 0068 6282     		strh	r2, [r4, #18]	@ movhi
 706:Src/mpu6050.c ****         return -1;
 4908              		.loc 1 706 9 view .LVU1490
 4909 006a 4FF4FA60 		mov	r0, #2000
 697:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 4910              		.loc 1 697 32 view .LVU1491
 4911 006e 6384     		strh	r3, [r4, #34]	@ movhi
 695:Src/mpu6050.c ****     /* Handled in next call to mpu_set_bypass. */
 4912              		.loc 1 695 25 view .LVU1492
 4913 0070 2373     		strb	r3, [r4, #12]
 697:Src/mpu6050.c ****     st.chip_cfg.latched_int = 0;
 4914              		.loc 1 697 5 is_stmt 1 view .LVU1493
 698:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 4915              		.loc 1 698 5 view .LVU1494
 699:Src/mpu6050.c ****     st.chip_cfg.lp_accel_mode = 0;
 4916              		.loc 1 699 5 view .LVU1495
 700:Src/mpu6050.c ****     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
 4917              		.loc 1 700 5 view .LVU1496
 701:Src/mpu6050.c ****     st.chip_cfg.dmp_on = 0;
 4918              		.loc 1 701 5 view .LVU1497
 702:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 0;
 4919              		.loc 1 702 5 view .LVU1498
 703:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = 0;
 4920              		.loc 1 703 5 view .LVU1499
 704:Src/mpu6050.c **** 
 4921              		.loc 1 704 5 view .LVU1500
 706:Src/mpu6050.c ****         return -1;
 4922              		.loc 1 706 5 view .LVU1501
 706:Src/mpu6050.c ****         return -1;
 4923              		.loc 1 706 9 is_stmt 0 view .LVU1502
 4924 0072 FFF7FEFF 		bl	mpu_set_gyro_fsr
 4925              	.LVL304:
 706:Src/mpu6050.c ****         return -1;
 4926              		.loc 1 706 8 view .LVU1503
 4927 0076 0028     		cmp	r0, #0
 4928 0078 D1D1     		bne	.L429
 708:Src/mpu6050.c ****         return -1;
 4929              		.loc 1 708 5 is_stmt 1 view .LVU1504
 708:Src/mpu6050.c ****         return -1;
 4930              		.loc 1 708 9 is_stmt 0 view .LVU1505
 4931 007a 0220     		movs	r0, #2
 4932 007c FFF7FEFF 		bl	mpu_set_accel_fsr
 4933              	.LVL305:
 708:Src/mpu6050.c ****         return -1;
 4934              		.loc 1 708 8 view .LVU1506
 4935 0080 0028     		cmp	r0, #0
 4936 0082 CCD1     		bne	.L429
 710:Src/mpu6050.c ****         return -1;
 4937              		.loc 1 710 5 is_stmt 1 view .LVU1507
 710:Src/mpu6050.c ****         return -1;
 4938              		.loc 1 710 9 is_stmt 0 view .LVU1508
 4939 0084 2A20     		movs	r0, #42
 4940 0086 FFF7FEFF 		bl	mpu_set_lpf
 4941              	.LVL306:
 710:Src/mpu6050.c ****         return -1;
 4942              		.loc 1 710 8 view .LVU1509
ARM GAS  /tmp/ccNfEN49.s 			page 150


 4943 008a 0028     		cmp	r0, #0
 4944 008c C7D1     		bne	.L429
 712:Src/mpu6050.c ****         return -1;
 4945              		.loc 1 712 5 is_stmt 1 view .LVU1510
 712:Src/mpu6050.c ****         return -1;
 4946              		.loc 1 712 9 is_stmt 0 view .LVU1511
 4947 008e 3220     		movs	r0, #50
 4948 0090 FFF7FEFF 		bl	mpu_set_sample_rate
 4949              	.LVL307:
 712:Src/mpu6050.c ****         return -1;
 4950              		.loc 1 712 8 view .LVU1512
 4951 0094 0028     		cmp	r0, #0
 4952 0096 C2D1     		bne	.L429
 714:Src/mpu6050.c ****         return -1;
 4953              		.loc 1 714 5 is_stmt 1 view .LVU1513
 714:Src/mpu6050.c ****         return -1;
 4954              		.loc 1 714 9 is_stmt 0 view .LVU1514
 4955 0098 FFF7FEFF 		bl	mpu_configure_fifo
 4956              	.LVL308:
 714:Src/mpu6050.c ****         return -1;
 4957              		.loc 1 714 8 view .LVU1515
 4958 009c 0028     		cmp	r0, #0
 4959 009e BED1     		bne	.L429
 723:Src/mpu6050.c ****         return -1;
 4960              		.loc 1 723 5 is_stmt 1 view .LVU1516
 723:Src/mpu6050.c ****         return -1;
 4961              		.loc 1 723 9 is_stmt 0 view .LVU1517
 4962 00a0 FFF7FEFF 		bl	mpu_set_bypass
 4963              	.LVL309:
 723:Src/mpu6050.c ****         return -1;
 4964              		.loc 1 723 8 view .LVU1518
 4965 00a4 0446     		mov	r4, r0
 4966 00a6 0028     		cmp	r0, #0
 4967 00a8 B9D1     		bne	.L429
 727:Src/mpu6050.c ****     return 0;
 4968              		.loc 1 727 5 is_stmt 1 view .LVU1519
 4969 00aa FFF7FEFF 		bl	mpu_set_sensors
 4970              	.LVL310:
 728:Src/mpu6050.c **** }
 4971              		.loc 1 728 5 view .LVU1520
 728:Src/mpu6050.c **** }
 4972              		.loc 1 728 12 is_stmt 0 view .LVU1521
 4973 00ae B8E7     		b	.L426
 4974              	.L431:
 4975              		.align	2
 4976              	.L430:
 4977 00b0 00000000 		.word	.LANCHOR0
 4978              		.cfi_endproc
 4979              	.LFE62:
 4981              		.section	.text.mpu_write_mem,"ax",%progbits
 4982              		.align	1
 4983              		.global	mpu_write_mem
 4984              		.syntax unified
 4985              		.thumb
 4986              		.thumb_func
 4987              		.fpu softvfp
 4989              	mpu_write_mem:
ARM GAS  /tmp/ccNfEN49.s 			page 151


 4990              	.LVL311:
 4991              	.LFB101:
2131:Src/mpu6050.c **** 
2132:Src/mpu6050.c **** #ifdef MPU6500
2133:Src/mpu6050.c **** #define REG_6500_XG_ST_DATA     0x0
2134:Src/mpu6050.c **** #define REG_6500_XA_ST_DATA     0xD
2135:Src/mpu6050.c **** static const unsigned short mpu_6500_st_tb[256] = {
2136:Src/mpu6050.c ****     2620,2646,2672,2699,2726,2753,2781,2808, //7
2137:Src/mpu6050.c ****     2837,2865,2894,2923,2952,2981,3011,3041, //15
2138:Src/mpu6050.c ****     3072,3102,3133,3165,3196,3228,3261,3293, //23
2139:Src/mpu6050.c ****     3326,3359,3393,3427,3461,3496,3531,3566, //31
2140:Src/mpu6050.c ****     3602,3638,3674,3711,3748,3786,3823,3862, //39
2141:Src/mpu6050.c ****     3900,3939,3979,4019,4059,4099,4140,4182, //47
2142:Src/mpu6050.c ****     4224,4266,4308,4352,4395,4439,4483,4528, //55
2143:Src/mpu6050.c ****     4574,4619,4665,4712,4759,4807,4855,4903, //63
2144:Src/mpu6050.c ****     4953,5002,5052,5103,5154,5205,5257,5310, //71
2145:Src/mpu6050.c ****     5363,5417,5471,5525,5581,5636,5693,5750, //79
2146:Src/mpu6050.c ****     5807,5865,5924,5983,6043,6104,6165,6226, //87
2147:Src/mpu6050.c ****     6289,6351,6415,6479,6544,6609,6675,6742, //95
2148:Src/mpu6050.c ****     6810,6878,6946,7016,7086,7157,7229,7301, //103
2149:Src/mpu6050.c ****     7374,7448,7522,7597,7673,7750,7828,7906, //111
2150:Src/mpu6050.c ****     7985,8065,8145,8227,8309,8392,8476,8561, //119
2151:Src/mpu6050.c ****     8647,8733,8820,8909,8998,9088,9178,9270,
2152:Src/mpu6050.c ****     9363,9457,9551,9647,9743,9841,9939,10038,
2153:Src/mpu6050.c ****     10139,10240,10343,10446,10550,10656,10763,10870,
2154:Src/mpu6050.c ****     10979,11089,11200,11312,11425,11539,11654,11771,
2155:Src/mpu6050.c ****     11889,12008,12128,12249,12371,12495,12620,12746,
2156:Src/mpu6050.c ****     12874,13002,13132,13264,13396,13530,13666,13802,
2157:Src/mpu6050.c ****     13940,14080,14221,14363,14506,14652,14798,14946,
2158:Src/mpu6050.c ****     15096,15247,15399,15553,15709,15866,16024,16184,
2159:Src/mpu6050.c ****     16346,16510,16675,16842,17010,17180,17352,17526,
2160:Src/mpu6050.c ****     17701,17878,18057,18237,18420,18604,18790,18978,
2161:Src/mpu6050.c ****     19167,19359,19553,19748,19946,20145,20347,20550,
2162:Src/mpu6050.c ****     20756,20963,21173,21385,21598,21814,22033,22253,
2163:Src/mpu6050.c ****     22475,22700,22927,23156,23388,23622,23858,24097,
2164:Src/mpu6050.c ****     24338,24581,24827,25075,25326,25579,25835,26093,
2165:Src/mpu6050.c ****     26354,26618,26884,27153,27424,27699,27976,28255,
2166:Src/mpu6050.c ****     28538,28823,29112,29403,29697,29994,30294,30597,
2167:Src/mpu6050.c ****     30903,31212,31524,31839,32157,32479,32804,33132
2168:Src/mpu6050.c **** };
2169:Src/mpu6050.c **** static int accel_6500_self_test(long *bias_regular, long *bias_st, int debug)
2170:Src/mpu6050.c **** {
2171:Src/mpu6050.c ****     int i, result = 0, otp_value_zero = 0;
2172:Src/mpu6050.c ****     float accel_st_al_min, accel_st_al_max;
2173:Src/mpu6050.c ****     float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], accel_offset_max;
2174:Src/mpu6050.c ****     unsigned char regs[3];
2175:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, REG_6500_XA_ST_DATA, 3, regs)) {
2176:Src/mpu6050.c ****         if(debug)
2177:Src/mpu6050.c ****             log_i("Reading OTP Register Error\r\n");
2178:Src/mpu6050.c ****         return 0x07;
2179:Src/mpu6050.c ****     }
2180:Src/mpu6050.c ****     if(debug)
2181:Src/mpu6050.c ****         log_i("Accel OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
2182:Src/mpu6050.c ****     for (i = 0; i < 3; i++) {
2183:Src/mpu6050.c ****         if (regs[i] != 0) {
2184:Src/mpu6050.c ****             ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
2185:Src/mpu6050.c ****             ct_shift_prod[i] *= 65536.f;
ARM GAS  /tmp/ccNfEN49.s 			page 152


2186:Src/mpu6050.c ****             ct_shift_prod[i] /= test.accel_sens;
2187:Src/mpu6050.c ****         }
2188:Src/mpu6050.c ****         else {
2189:Src/mpu6050.c ****             ct_shift_prod[i] = 0;
2190:Src/mpu6050.c ****             otp_value_zero = 1;
2191:Src/mpu6050.c ****         }
2192:Src/mpu6050.c ****     }
2193:Src/mpu6050.c ****     if(otp_value_zero == 0) {
2194:Src/mpu6050.c ****         if(debug)
2195:Src/mpu6050.c ****             log_i("ACCEL:CRITERIA A\r\n");
2196:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2197:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2198:Src/mpu6050.c ****             if(debug) {
2199:Src/mpu6050.c ****                 log_i("Bias_Shift=%ld, Bias_Reg=%ld, Bias_HWST=%ld\r\n",
2200:Src/mpu6050.c ****                         (long)st_shift_cust[i], bias_regular[i],
2201:Src/mpu6050.c ****                         bias_st[i]);
2202:Src/mpu6050.c ****                 log_i("OTP value: %ld\r\n", (long)ct_shift_prod[i]);
2203:Src/mpu6050.c ****             }
2204:Src/mpu6050.c **** 
2205:Src/mpu6050.c ****             st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i] - 1.f;
2206:Src/mpu6050.c **** 
2207:Src/mpu6050.c ****             if(debug)
2208:Src/mpu6050.c ****                 log_i("ratio=%ld, threshold=%ld\r\n", (long)st_shift_ratio[i],
2209:Src/mpu6050.c ****                             (long)test.max_accel_var);
2210:Src/mpu6050.c **** 
2211:Src/mpu6050.c ****             if (fabs(st_shift_ratio[i]) > test.max_accel_var) {
2212:Src/mpu6050.c ****                 if(debug)
2213:Src/mpu6050.c ****                     log_i("ACCEL Fail Axis = %d\r\n", i);
2214:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2215:Src/mpu6050.c ****             }
2216:Src/mpu6050.c ****         }
2217:Src/mpu6050.c ****     }
2218:Src/mpu6050.c ****     else {
2219:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria B */
2220:Src/mpu6050.c ****         accel_st_al_min = test.min_g * 65536.f;
2221:Src/mpu6050.c ****         accel_st_al_max = test.max_g * 65536.f;
2222:Src/mpu6050.c **** 
2223:Src/mpu6050.c ****         if(debug) {
2224:Src/mpu6050.c ****             log_i("ACCEL:CRITERIA B\r\n");
2225:Src/mpu6050.c ****             log_i("Min MG: %ld\r\n", (long)accel_st_al_min);
2226:Src/mpu6050.c ****             log_i("Max MG: %ld\r\n", (long)accel_st_al_max);
2227:Src/mpu6050.c ****         }
2228:Src/mpu6050.c **** 
2229:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2230:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2231:Src/mpu6050.c **** 
2232:Src/mpu6050.c ****             if(debug)
2233:Src/mpu6050.c ****                 log_i("Bias_shift=%ld, st=%ld, reg=%ld\r\n", (long)st_shift_cust[i], bias_st[i], bi
2234:Src/mpu6050.c ****             if(st_shift_cust[i] < accel_st_al_min || st_shift_cust[i] > accel_st_al_max) {
2235:Src/mpu6050.c ****                 if(debug)
2236:Src/mpu6050.c ****                     log_i("Accel FAIL axis:%d <= 225mg or >= 675mg\r\n", i);
2237:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2238:Src/mpu6050.c ****             }
2239:Src/mpu6050.c ****         }
2240:Src/mpu6050.c ****     }
2241:Src/mpu6050.c **** 
2242:Src/mpu6050.c ****     if(result == 0) {
ARM GAS  /tmp/ccNfEN49.s 			page 153


2243:Src/mpu6050.c ****     /* Self Test Pass/Fail Criteria C */
2244:Src/mpu6050.c ****         accel_offset_max = test.max_g_offset * 65536.f;
2245:Src/mpu6050.c ****         if(debug)
2246:Src/mpu6050.c ****             log_i("Accel:CRITERIA C: bias less than %ld\n", (long)accel_offset_max);
2247:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2248:Src/mpu6050.c ****             if(fabs(bias_regular[i]) > accel_offset_max) {
2249:Src/mpu6050.c ****                 if(debug)
2250:Src/mpu6050.c ****                     log_i("FAILED: Accel axis:%d = %ld > 500mg\n", i, bias_regular[i]);
2251:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2252:Src/mpu6050.c ****             }
2253:Src/mpu6050.c ****         }
2254:Src/mpu6050.c ****     }
2255:Src/mpu6050.c **** 
2256:Src/mpu6050.c ****     return result;
2257:Src/mpu6050.c **** }
2258:Src/mpu6050.c **** 
2259:Src/mpu6050.c **** static int gyro_6500_self_test(long *bias_regular, long *bias_st, int debug)
2260:Src/mpu6050.c **** {
2261:Src/mpu6050.c ****     int i, result = 0, otp_value_zero = 0;
2262:Src/mpu6050.c ****     float gyro_st_al_max;
2263:Src/mpu6050.c ****     float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], gyro_offset_max;
2264:Src/mpu6050.c ****     unsigned char regs[3];
2265:Src/mpu6050.c **** 
2266:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, REG_6500_XG_ST_DATA, 3, regs)) {
2267:Src/mpu6050.c ****         if(debug)
2268:Src/mpu6050.c ****             log_i("Reading OTP Register Error.\n");
2269:Src/mpu6050.c ****         return 0x07;
2270:Src/mpu6050.c ****     }
2271:Src/mpu6050.c **** 
2272:Src/mpu6050.c ****     if(debug)
2273:Src/mpu6050.c ****         log_i("Gyro OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
2274:Src/mpu6050.c **** 
2275:Src/mpu6050.c ****     for (i = 0; i < 3; i++) {
2276:Src/mpu6050.c ****         if (regs[i] != 0) {
2277:Src/mpu6050.c ****             ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
2278:Src/mpu6050.c ****             ct_shift_prod[i] *= 65536.f;
2279:Src/mpu6050.c ****             ct_shift_prod[i] /= test.gyro_sens;
2280:Src/mpu6050.c ****         }
2281:Src/mpu6050.c ****         else {
2282:Src/mpu6050.c ****             ct_shift_prod[i] = 0;
2283:Src/mpu6050.c ****             otp_value_zero = 1;
2284:Src/mpu6050.c ****         }
2285:Src/mpu6050.c ****     }
2286:Src/mpu6050.c **** 
2287:Src/mpu6050.c ****     if(otp_value_zero == 0) {
2288:Src/mpu6050.c ****         if(debug)
2289:Src/mpu6050.c ****             log_i("GYRO:CRITERIA A\n");
2290:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria A */
2291:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2292:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2293:Src/mpu6050.c **** 
2294:Src/mpu6050.c ****             if(debug) {
2295:Src/mpu6050.c ****                 log_i("Bias_Shift=%ld, Bias_Reg=%ld, Bias_HWST=%ld\r\n",
2296:Src/mpu6050.c ****                         (long)st_shift_cust[i], bias_regular[i],
2297:Src/mpu6050.c ****                         bias_st[i]);
2298:Src/mpu6050.c ****                 log_i("OTP value: %ld\r\n", (long)ct_shift_prod[i]);
2299:Src/mpu6050.c ****             }
ARM GAS  /tmp/ccNfEN49.s 			page 154


2300:Src/mpu6050.c **** 
2301:Src/mpu6050.c ****             st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i];
2302:Src/mpu6050.c **** 
2303:Src/mpu6050.c ****             if(debug)
2304:Src/mpu6050.c ****                 log_i("ratio=%ld, threshold=%ld\r\n", (long)st_shift_ratio[i],
2305:Src/mpu6050.c ****                             (long)test.max_gyro_var);
2306:Src/mpu6050.c **** 
2307:Src/mpu6050.c ****             if (fabs(st_shift_ratio[i]) < test.max_gyro_var) {
2308:Src/mpu6050.c ****                 if(debug)
2309:Src/mpu6050.c ****                     log_i("Gyro Fail Axis = %d\n", i);
2310:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2311:Src/mpu6050.c ****             }
2312:Src/mpu6050.c ****         }
2313:Src/mpu6050.c ****     }
2314:Src/mpu6050.c ****     else {
2315:Src/mpu6050.c ****         /* Self Test Pass/Fail Criteria B */
2316:Src/mpu6050.c ****         gyro_st_al_max = test.max_dps * 65536.f;
2317:Src/mpu6050.c **** 
2318:Src/mpu6050.c ****         if(debug) {
2319:Src/mpu6050.c ****             log_i("GYRO:CRITERIA B\r\n");
2320:Src/mpu6050.c ****             log_i("Max DPS: %ld\r\n", (long)gyro_st_al_max);
2321:Src/mpu6050.c ****         }
2322:Src/mpu6050.c **** 
2323:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2324:Src/mpu6050.c ****             st_shift_cust[i] = bias_st[i] - bias_regular[i];
2325:Src/mpu6050.c **** 
2326:Src/mpu6050.c ****             if(debug)
2327:Src/mpu6050.c ****                 log_i("Bias_shift=%ld, st=%ld, reg=%ld\r\n", (long)st_shift_cust[i], bias_st[i], bi
2328:Src/mpu6050.c ****             if(st_shift_cust[i] < gyro_st_al_max) {
2329:Src/mpu6050.c ****                 if(debug)
2330:Src/mpu6050.c ****                     log_i("GYRO FAIL axis:%d greater than 60dps\r\n", i);
2331:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2332:Src/mpu6050.c ****             }
2333:Src/mpu6050.c ****         }
2334:Src/mpu6050.c ****     }
2335:Src/mpu6050.c **** 
2336:Src/mpu6050.c ****     if(result == 0) {
2337:Src/mpu6050.c ****     /* Self Test Pass/Fail Criteria C */
2338:Src/mpu6050.c ****         gyro_offset_max = test.min_dps * 65536.f;
2339:Src/mpu6050.c ****         if(debug)
2340:Src/mpu6050.c ****             log_i("Gyro:CRITERIA C: bias less than %ld\r\n", (long)gyro_offset_max);
2341:Src/mpu6050.c ****         for (i = 0; i < 3; i++) {
2342:Src/mpu6050.c ****             if(fabs(bias_regular[i]) > gyro_offset_max) {
2343:Src/mpu6050.c ****                 if(debug)
2344:Src/mpu6050.c ****                     log_i("FAILED: Gyro axis:%d = %ld > 20dps\r\n", i, bias_regular[i]);
2345:Src/mpu6050.c ****                 result |= 1 << i;	//Error condition
2346:Src/mpu6050.c ****             }
2347:Src/mpu6050.c ****         }
2348:Src/mpu6050.c ****     }
2349:Src/mpu6050.c ****     return result;
2350:Src/mpu6050.c **** }
2351:Src/mpu6050.c **** 
2352:Src/mpu6050.c **** static int get_st_6500_biases(long *gyro, long *accel, unsigned char hw_test, int debug)
2353:Src/mpu6050.c **** {
2354:Src/mpu6050.c ****     unsigned char data[HWST_MAX_PACKET_LENGTH];
2355:Src/mpu6050.c ****     unsigned char packet_count, ii;
2356:Src/mpu6050.c ****     unsigned short fifo_count;
ARM GAS  /tmp/ccNfEN49.s 			page 155


2357:Src/mpu6050.c ****     int s = 0, read_size = 0, ind;
2358:Src/mpu6050.c **** 
2359:Src/mpu6050.c ****     data[0] = 0x01;
2360:Src/mpu6050.c ****     data[1] = 0;
2361:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
2362:Src/mpu6050.c ****         return -1;
2363:Src/mpu6050.c ****     delay_ms(200);
2364:Src/mpu6050.c ****     data[0] = 0;
2365:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
2366:Src/mpu6050.c ****         return -1;
2367:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2368:Src/mpu6050.c ****         return -1;
2369:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
2370:Src/mpu6050.c ****         return -1;
2371:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2372:Src/mpu6050.c ****         return -1;
2373:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2374:Src/mpu6050.c ****         return -1;
2375:Src/mpu6050.c ****     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
2376:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2377:Src/mpu6050.c ****         return -1;
2378:Src/mpu6050.c ****     delay_ms(15);
2379:Src/mpu6050.c ****     data[0] = st.test->reg_lpf;
2380:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
2381:Src/mpu6050.c ****         return -1;
2382:Src/mpu6050.c ****     data[0] = st.test->reg_rate_div;
2383:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
2384:Src/mpu6050.c ****         return -1;
2385:Src/mpu6050.c ****     if (hw_test)
2386:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr | 0xE0;
2387:Src/mpu6050.c ****     else
2388:Src/mpu6050.c ****         data[0] = st.test->reg_gyro_fsr;
2389:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
2390:Src/mpu6050.c ****         return -1;
2391:Src/mpu6050.c **** 
2392:Src/mpu6050.c ****     if (hw_test)
2393:Src/mpu6050.c ****         data[0] = st.test->reg_accel_fsr | 0xE0;
2394:Src/mpu6050.c ****     else
2395:Src/mpu6050.c ****         data[0] = test.reg_accel_fsr;
2396:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
2397:Src/mpu6050.c ****         return -1;
2398:Src/mpu6050.c **** 
2399:Src/mpu6050.c ****     delay_ms(test.wait_ms);  //wait 200ms for sensors to stabilize
2400:Src/mpu6050.c **** 
2401:Src/mpu6050.c ****     /* Enable FIFO */
2402:Src/mpu6050.c ****     data[0] = BIT_FIFO_EN;
2403:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
2404:Src/mpu6050.c ****         return -1;
2405:Src/mpu6050.c ****     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
2406:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2407:Src/mpu6050.c ****         return -1;
2408:Src/mpu6050.c **** 
2409:Src/mpu6050.c ****     //initialize the bias return values
2410:Src/mpu6050.c ****     gyro[0] = gyro[1] = gyro[2] = 0;
2411:Src/mpu6050.c ****     accel[0] = accel[1] = accel[2] = 0;
2412:Src/mpu6050.c **** 
2413:Src/mpu6050.c ****     if(debug)
ARM GAS  /tmp/ccNfEN49.s 			page 156


2414:Src/mpu6050.c ****         log_i("Starting Bias Loop Reads\r\n");
2415:Src/mpu6050.c **** 
2416:Src/mpu6050.c ****     //start reading samples
2417:Src/mpu6050.c ****     while (s < test.packet_thresh) {
2418:Src/mpu6050.c ****         delay_ms(test.sample_wait_ms); //wait 10ms to fill FIFO
2419:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
2420:Src/mpu6050.c ****             return -1;
2421:Src/mpu6050.c ****         fifo_count = (data[0] << 8) | data[1];
2422:Src/mpu6050.c ****         packet_count = fifo_count / MAX_PACKET_LENGTH;
2423:Src/mpu6050.c ****         if ((test.packet_thresh - s) < packet_count)
2424:Src/mpu6050.c ****                     packet_count = test.packet_thresh - s;
2425:Src/mpu6050.c ****         read_size = packet_count * MAX_PACKET_LENGTH;
2426:Src/mpu6050.c **** 
2427:Src/mpu6050.c ****         //burst read from FIFO
2428:Src/mpu6050.c ****         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, read_size, data))
2429:Src/mpu6050.c ****                         return -1;
2430:Src/mpu6050.c ****         ind = 0;
2431:Src/mpu6050.c ****         for (ii = 0; ii < packet_count; ii++) {
2432:Src/mpu6050.c ****             short accel_cur[3], gyro_cur[3];
2433:Src/mpu6050.c ****             accel_cur[0] = ((short)data[ind + 0] << 8) | data[ind + 1];
2434:Src/mpu6050.c ****             accel_cur[1] = ((short)data[ind + 2] << 8) | data[ind + 3];
2435:Src/mpu6050.c ****             accel_cur[2] = ((short)data[ind + 4] << 8) | data[ind + 5];
2436:Src/mpu6050.c ****             accel[0] += (long)accel_cur[0];
2437:Src/mpu6050.c ****             accel[1] += (long)accel_cur[1];
2438:Src/mpu6050.c ****             accel[2] += (long)accel_cur[2];
2439:Src/mpu6050.c ****             gyro_cur[0] = (((short)data[ind + 6] << 8) | data[ind + 7]);
2440:Src/mpu6050.c ****             gyro_cur[1] = (((short)data[ind + 8] << 8) | data[ind + 9]);
2441:Src/mpu6050.c ****             gyro_cur[2] = (((short)data[ind + 10] << 8) | data[ind + 11]);
2442:Src/mpu6050.c ****             gyro[0] += (long)gyro_cur[0];
2443:Src/mpu6050.c ****             gyro[1] += (long)gyro_cur[1];
2444:Src/mpu6050.c ****             gyro[2] += (long)gyro_cur[2];
2445:Src/mpu6050.c ****             ind += MAX_PACKET_LENGTH;
2446:Src/mpu6050.c ****         }
2447:Src/mpu6050.c ****         s += packet_count;
2448:Src/mpu6050.c ****     }
2449:Src/mpu6050.c **** 
2450:Src/mpu6050.c ****     if(debug)
2451:Src/mpu6050.c ****         log_i("Samples: %d\r\n", s);
2452:Src/mpu6050.c **** 
2453:Src/mpu6050.c ****     //stop FIFO
2454:Src/mpu6050.c ****     data[0] = 0;
2455:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
2456:Src/mpu6050.c ****         return -1;
2457:Src/mpu6050.c **** 
2458:Src/mpu6050.c ****     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / s);
2459:Src/mpu6050.c ****     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / s);
2460:Src/mpu6050.c ****     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / s);
2461:Src/mpu6050.c ****     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens / s);
2462:Src/mpu6050.c ****     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens / s);
2463:Src/mpu6050.c ****     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens / s);
2464:Src/mpu6050.c ****     /* remove gravity from bias calculation */
2465:Src/mpu6050.c ****     if (accel[2] > 0L)
2466:Src/mpu6050.c ****         accel[2] -= 65536L;
2467:Src/mpu6050.c ****     else
2468:Src/mpu6050.c ****         accel[2] += 65536L;
2469:Src/mpu6050.c **** 
2470:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 157


2471:Src/mpu6050.c ****     if(debug) {
2472:Src/mpu6050.c ****         log_i("Accel offset data HWST bit=%d: %ld %ld %ld\r\n", hw_test, accel[0], accel[1], accel[
2473:Src/mpu6050.c ****         log_i("Gyro offset data HWST bit=%d: %ld %ld %ld\r\n", hw_test, gyro[0], gyro[1], gyro[2]);
2474:Src/mpu6050.c ****     }
2475:Src/mpu6050.c **** 
2476:Src/mpu6050.c ****     return 0;
2477:Src/mpu6050.c **** }
2478:Src/mpu6050.c **** /**
2479:Src/mpu6050.c ****  *  @brief      Trigger gyro/accel/compass self-test for MPU6500/MPU9250
2480:Src/mpu6050.c ****  *  On success/error, the self-test returns a mask representing the sensor(s)
2481:Src/mpu6050.c ****  *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
2482:Src/mpu6050.c ****  *  a zero (0) indicates a failure.
2483:Src/mpu6050.c ****  *
2484:Src/mpu6050.c ****  *  \n The mask is defined as follows:
2485:Src/mpu6050.c ****  *  \n Bit 0:   Gyro.
2486:Src/mpu6050.c ****  *  \n Bit 1:   Accel.
2487:Src/mpu6050.c ****  *  \n Bit 2:   Compass.
2488:Src/mpu6050.c ****  *
2489:Src/mpu6050.c ****  *  @param[out] gyro        Gyro biases in q16 format.
2490:Src/mpu6050.c ****  *  @param[out] accel       Accel biases (if applicable) in q16 format.
2491:Src/mpu6050.c ****  *  @param[in]  debug       Debug flag used to print out more detailed logs. Must first set up logg
2492:Src/mpu6050.c ****  *  @return     Result mask (see above).
2493:Src/mpu6050.c ****  */
2494:Src/mpu6050.c **** int mpu_run_6500_self_test(long *gyro, long *accel, unsigned char debug)
2495:Src/mpu6050.c **** {
2496:Src/mpu6050.c ****     const unsigned char tries = 2;
2497:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
2498:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
2499:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2500:Src/mpu6050.c ****     unsigned char compass_result;
2501:Src/mpu6050.c **** #endif
2502:Src/mpu6050.c ****     int ii;
2503:Src/mpu6050.c **** 
2504:Src/mpu6050.c ****     int result;
2505:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
2506:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
2507:Src/mpu6050.c ****     unsigned char dmp_was_on;
2508:Src/mpu6050.c **** 
2509:Src/mpu6050.c **** 
2510:Src/mpu6050.c **** 
2511:Src/mpu6050.c ****     if(debug)
2512:Src/mpu6050.c ****         log_i("Starting MPU6500 HWST!\r\n");
2513:Src/mpu6050.c **** 
2514:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
2515:Src/mpu6050.c ****         mpu_set_dmp_state(0);
2516:Src/mpu6050.c ****         dmp_was_on = 1;
2517:Src/mpu6050.c ****     } else
2518:Src/mpu6050.c ****         dmp_was_on = 0;
2519:Src/mpu6050.c **** 
2520:Src/mpu6050.c ****     /* Get initial settings. */
2521:Src/mpu6050.c ****     mpu_get_gyro_fsr(&gyro_fsr);
2522:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
2523:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
2524:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
2525:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
2526:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
2527:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 158


2528:Src/mpu6050.c ****     if(debug)
2529:Src/mpu6050.c ****         log_i("Retrieving Biases\r\n");
2530:Src/mpu6050.c **** 
2531:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2532:Src/mpu6050.c ****         if (!get_st_6500_biases(gyro, accel, 0, debug))
2533:Src/mpu6050.c ****             break;
2534:Src/mpu6050.c ****     if (ii == tries) {
2535:Src/mpu6050.c ****         /* If we reach this point, we most likely encountered an I2C error.
2536:Src/mpu6050.c ****          * We'll just report an error for all three sensors.
2537:Src/mpu6050.c ****          */
2538:Src/mpu6050.c ****         if(debug)
2539:Src/mpu6050.c ****             log_i("Retrieving Biases Error - possible I2C error\r\n");
2540:Src/mpu6050.c **** 
2541:Src/mpu6050.c ****         result = 0;
2542:Src/mpu6050.c ****         goto restore;
2543:Src/mpu6050.c ****     }
2544:Src/mpu6050.c **** 
2545:Src/mpu6050.c ****     if(debug)
2546:Src/mpu6050.c ****         log_i("Retrieving ST Biases\r\n");
2547:Src/mpu6050.c **** 
2548:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2549:Src/mpu6050.c ****         if (!get_st_6500_biases(gyro_st, accel_st, 1, debug))
2550:Src/mpu6050.c ****             break;
2551:Src/mpu6050.c ****     if (ii == tries) {
2552:Src/mpu6050.c **** 
2553:Src/mpu6050.c ****         if(debug)
2554:Src/mpu6050.c ****             log_i("Retrieving ST Biases Error - possible I2C error\r\n");
2555:Src/mpu6050.c **** 
2556:Src/mpu6050.c ****         /* Again, probably an I2C error. */
2557:Src/mpu6050.c ****         result = 0;
2558:Src/mpu6050.c ****         goto restore;
2559:Src/mpu6050.c ****     }
2560:Src/mpu6050.c **** 
2561:Src/mpu6050.c ****     accel_result = accel_6500_self_test(accel, accel_st, debug);
2562:Src/mpu6050.c ****     if(debug)
2563:Src/mpu6050.c ****         log_i("Accel Self Test Results: %d\r\n", accel_result);
2564:Src/mpu6050.c **** 
2565:Src/mpu6050.c ****     gyro_result = gyro_6500_self_test(gyro, gyro_st, debug);
2566:Src/mpu6050.c ****     if(debug)
2567:Src/mpu6050.c ****         log_i("Gyro Self Test Results: %d\r\n", gyro_result);
2568:Src/mpu6050.c **** 
2569:Src/mpu6050.c ****     result = 0;
2570:Src/mpu6050.c ****     if (!gyro_result)
2571:Src/mpu6050.c ****         result |= 0x01;
2572:Src/mpu6050.c ****     if (!accel_result)
2573:Src/mpu6050.c ****         result |= 0x02;
2574:Src/mpu6050.c **** 
2575:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2576:Src/mpu6050.c ****     compass_result = compass_self_test();
2577:Src/mpu6050.c ****     if(debug)
2578:Src/mpu6050.c ****         log_i("Compass Self Test Results: %d\r\n", compass_result);
2579:Src/mpu6050.c ****     if (!compass_result)
2580:Src/mpu6050.c ****         result |= 0x04;
2581:Src/mpu6050.c **** #else
2582:Src/mpu6050.c ****     result |= 0x04;
2583:Src/mpu6050.c **** #endif
2584:Src/mpu6050.c **** restore:
ARM GAS  /tmp/ccNfEN49.s 			page 159


2585:Src/mpu6050.c ****     if(debug)
2586:Src/mpu6050.c ****         log_i("Exiting HWST\r\n");
2587:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
2588:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
2589:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
2590:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
2591:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
2592:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
2593:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
2594:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
2595:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
2596:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
2597:Src/mpu6050.c ****     mpu_set_lpf(lpf);
2598:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
2599:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
2600:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
2601:Src/mpu6050.c **** 
2602:Src/mpu6050.c ****     if (dmp_was_on)
2603:Src/mpu6050.c ****         mpu_set_dmp_state(1);
2604:Src/mpu6050.c **** 
2605:Src/mpu6050.c ****     return result;
2606:Src/mpu6050.c **** }
2607:Src/mpu6050.c **** #endif
2608:Src/mpu6050.c ****  /*
2609:Src/mpu6050.c ****  *  \n This function must be called with the device either face-up or face-down
2610:Src/mpu6050.c ****  *  (z-axis is parallel to gravity).
2611:Src/mpu6050.c ****  *  @param[out] gyro        Gyro biases in q16 format.
2612:Src/mpu6050.c ****  *  @param[out] accel       Accel biases (if applicable) in q16 format.
2613:Src/mpu6050.c ****  *  @return     Result mask (see above).
2614:Src/mpu6050.c ****  */
2615:Src/mpu6050.c **** int mpu_run_self_test(long *gyro, long *accel)
2616:Src/mpu6050.c **** {
2617:Src/mpu6050.c **** #ifdef MPU6050
2618:Src/mpu6050.c ****     const unsigned char tries = 2;
2619:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
2620:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
2621:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2622:Src/mpu6050.c ****     unsigned char compass_result;
2623:Src/mpu6050.c **** #endif
2624:Src/mpu6050.c ****     int ii;
2625:Src/mpu6050.c **** #endif
2626:Src/mpu6050.c ****     int result;
2627:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
2628:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
2629:Src/mpu6050.c ****     unsigned char dmp_was_on;
2630:Src/mpu6050.c **** 
2631:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on) {
2632:Src/mpu6050.c ****         mpu_set_dmp_state(0);
2633:Src/mpu6050.c ****         dmp_was_on = 1;
2634:Src/mpu6050.c ****     } else
2635:Src/mpu6050.c ****         dmp_was_on = 0;
2636:Src/mpu6050.c **** 
2637:Src/mpu6050.c ****     /* Get initial settings. */
2638:Src/mpu6050.c ****     mpu_get_gyro_fsr(&gyro_fsr);
2639:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
2640:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
2641:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
ARM GAS  /tmp/ccNfEN49.s 			page 160


2642:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
2643:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
2644:Src/mpu6050.c **** 
2645:Src/mpu6050.c ****     /* For older chips, the self-test will be different. */
2646:Src/mpu6050.c **** #if defined MPU6050
2647:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2648:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
2649:Src/mpu6050.c ****             break;
2650:Src/mpu6050.c ****     if (ii == tries) {
2651:Src/mpu6050.c ****         /* If we reach this point, we most likely encountered an I2C error.
2652:Src/mpu6050.c ****          * We'll just report an error for all three sensors.
2653:Src/mpu6050.c ****          */
2654:Src/mpu6050.c ****         result = 0;
2655:Src/mpu6050.c ****         goto restore;
2656:Src/mpu6050.c ****     }
2657:Src/mpu6050.c ****     for (ii = 0; ii < tries; ii++)
2658:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
2659:Src/mpu6050.c ****             break;
2660:Src/mpu6050.c ****     if (ii == tries) {
2661:Src/mpu6050.c ****         /* Again, probably an I2C error. */
2662:Src/mpu6050.c ****         result = 0;
2663:Src/mpu6050.c ****         goto restore;
2664:Src/mpu6050.c ****     }
2665:Src/mpu6050.c ****     accel_result = accel_self_test(accel, accel_st);
2666:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
2667:Src/mpu6050.c **** 
2668:Src/mpu6050.c ****     result = 0;
2669:Src/mpu6050.c ****     if (!gyro_result)
2670:Src/mpu6050.c ****         result |= 0x01;
2671:Src/mpu6050.c ****     if (!accel_result)
2672:Src/mpu6050.c ****         result |= 0x02;
2673:Src/mpu6050.c **** 
2674:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2675:Src/mpu6050.c ****     compass_result = compass_self_test();
2676:Src/mpu6050.c ****     if (!compass_result)
2677:Src/mpu6050.c ****         result |= 0x04;
2678:Src/mpu6050.c **** #else
2679:Src/mpu6050.c ****         result |= 0x04;
2680:Src/mpu6050.c **** #endif
2681:Src/mpu6050.c **** restore:
2682:Src/mpu6050.c **** #elif defined MPU6500
2683:Src/mpu6050.c ****     /* For now, this function will return a "pass" result for all three sensors
2684:Src/mpu6050.c ****      * for compatibility with current test applications.
2685:Src/mpu6050.c ****      */
2686:Src/mpu6050.c ****     get_st_biases(gyro, accel, 0);
2687:Src/mpu6050.c ****     result = 0x7;
2688:Src/mpu6050.c **** #endif
2689:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
2690:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
2691:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
2692:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
2693:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
2694:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
2695:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
2696:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
2697:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
2698:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
ARM GAS  /tmp/ccNfEN49.s 			page 161


2699:Src/mpu6050.c ****     mpu_set_lpf(lpf);
2700:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
2701:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
2702:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
2703:Src/mpu6050.c **** 
2704:Src/mpu6050.c ****     if (dmp_was_on)
2705:Src/mpu6050.c ****         mpu_set_dmp_state(1);
2706:Src/mpu6050.c **** 
2707:Src/mpu6050.c ****     return result;
2708:Src/mpu6050.c **** }
2709:Src/mpu6050.c **** 
2710:Src/mpu6050.c **** /**
2711:Src/mpu6050.c ****  *  @brief      Write to the DMP memory.
2712:Src/mpu6050.c ****  *  This function prevents I2C writes past the bank boundaries. The DMP memory
2713:Src/mpu6050.c ****  *  is only accessible when the chip is awake.
2714:Src/mpu6050.c ****  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2715:Src/mpu6050.c ****  *  @param[in]  length      Number of bytes to write.
2716:Src/mpu6050.c ****  *  @param[in]  data        Bytes to write to memory.
2717:Src/mpu6050.c ****  *  @return     0 if successful.
2718:Src/mpu6050.c ****  */
2719:Src/mpu6050.c **** int mpu_write_mem(unsigned short mem_addr, unsigned short length,
2720:Src/mpu6050.c ****         unsigned char *data)
2721:Src/mpu6050.c **** {
 4992              		.loc 1 2721 1 is_stmt 1 view -0
 4993              		.cfi_startproc
 4994              		@ args = 0, pretend = 0, frame = 8
 4995              		@ frame_needed = 0, uses_anonymous_args = 0
2722:Src/mpu6050.c ****     unsigned char tmp[2];
 4996              		.loc 1 2722 5 view .LVU1523
2723:Src/mpu6050.c **** 
2724:Src/mpu6050.c ****     if (!data)
 4997              		.loc 1 2724 5 view .LVU1524
2721:Src/mpu6050.c ****     unsigned char tmp[2];
 4998              		.loc 1 2721 1 is_stmt 0 view .LVU1525
 4999 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 5000              	.LCFI80:
 5001              		.cfi_def_cfa_offset 32
 5002              		.cfi_offset 4, -20
 5003              		.cfi_offset 5, -16
 5004              		.cfi_offset 6, -12
 5005              		.cfi_offset 7, -8
 5006              		.cfi_offset 14, -4
2721:Src/mpu6050.c ****     unsigned char tmp[2];
 5007              		.loc 1 2721 1 view .LVU1526
 5008 0002 0D46     		mov	r5, r1
 5009              		.loc 1 2724 8 view .LVU1527
 5010 0004 1646     		mov	r6, r2
 5011 0006 1AB9     		cbnz	r2, .L433
 5012              	.LVL312:
 5013              	.L435:
2725:Src/mpu6050.c ****         return -1;
 5014              		.loc 1 2725 16 view .LVU1528
 5015 0008 4FF0FF30 		mov	r0, #-1
 5016              	.L432:
2726:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
2727:Src/mpu6050.c ****         return -1;
2728:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 162


2729:Src/mpu6050.c ****     tmp[0] = (unsigned char)(mem_addr >> 8);
2730:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
2731:Src/mpu6050.c **** 
2732:Src/mpu6050.c ****     /* Check bank boundaries. */
2733:Src/mpu6050.c ****     if (tmp[1] + length > st.hw->bank_size)
2734:Src/mpu6050.c ****         return -1;
2735:Src/mpu6050.c **** 
2736:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2737:Src/mpu6050.c ****         return -1;
2738:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
2739:Src/mpu6050.c ****         return -1;
2740:Src/mpu6050.c ****     return 0;
2741:Src/mpu6050.c **** }
 5017              		.loc 1 2741 1 view .LVU1529
 5018 000c 03B0     		add	sp, sp, #12
 5019              	.LCFI81:
 5020              		.cfi_remember_state
 5021              		.cfi_def_cfa_offset 20
 5022              		@ sp needed
 5023 000e F0BD     		pop	{r4, r5, r6, r7, pc}
 5024              	.LVL313:
 5025              	.L433:
 5026              	.LCFI82:
 5027              		.cfi_restore_state
2726:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5028              		.loc 1 2726 5 is_stmt 1 view .LVU1530
2726:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5029              		.loc 1 2726 21 is_stmt 0 view .LVU1531
 5030 0010 124C     		ldr	r4, .L439
2726:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5031              		.loc 1 2726 8 view .LVU1532
 5032 0012 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 5033 0014 002B     		cmp	r3, #0
 5034 0016 F7D0     		beq	.L435
2729:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5035              		.loc 1 2729 5 is_stmt 1 view .LVU1533
2733:Src/mpu6050.c ****         return -1;
 5036              		.loc 1 2733 29 is_stmt 0 view .LVU1534
 5037 0018 6768     		ldr	r7, [r4, #4]
2729:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5038              		.loc 1 2729 14 view .LVU1535
 5039 001a 030A     		lsrs	r3, r0, #8
 5040 001c 8DF80430 		strb	r3, [sp, #4]
2730:Src/mpu6050.c **** 
 5041              		.loc 1 2730 5 is_stmt 1 view .LVU1536
2730:Src/mpu6050.c **** 
 5042              		.loc 1 2730 14 is_stmt 0 view .LVU1537
 5043 0020 C0B2     		uxtb	r0, r0
 5044              	.LVL314:
2733:Src/mpu6050.c ****         return -1;
 5045              		.loc 1 2733 32 view .LVU1538
 5046 0022 7B89     		ldrh	r3, [r7, #10]
2730:Src/mpu6050.c **** 
 5047              		.loc 1 2730 12 view .LVU1539
 5048 0024 8DF80500 		strb	r0, [sp, #5]
2733:Src/mpu6050.c ****         return -1;
 5049              		.loc 1 2733 5 is_stmt 1 view .LVU1540
ARM GAS  /tmp/ccNfEN49.s 			page 163


2733:Src/mpu6050.c ****         return -1;
 5050              		.loc 1 2733 16 is_stmt 0 view .LVU1541
 5051 0028 0844     		add	r0, r0, r1
2733:Src/mpu6050.c ****         return -1;
 5052              		.loc 1 2733 8 view .LVU1542
 5053 002a 9842     		cmp	r0, r3
 5054 002c ECDC     		bgt	.L435
2736:Src/mpu6050.c ****         return -1;
 5055              		.loc 1 2736 5 is_stmt 1 view .LVU1543
2736:Src/mpu6050.c ****         return -1;
 5056              		.loc 1 2736 9 is_stmt 0 view .LVU1544
 5057 002e 2168     		ldr	r1, [r4]
 5058              	.LVL315:
2736:Src/mpu6050.c ****         return -1;
 5059              		.loc 1 2736 9 view .LVU1545
 5060 0030 0222     		movs	r2, #2
 5061              	.LVL316:
2736:Src/mpu6050.c ****         return -1;
 5062              		.loc 1 2736 9 view .LVU1546
 5063 0032 C97E     		ldrb	r1, [r1, #27]	@ zero_extendqisi2
 5064 0034 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5065 0036 01AB     		add	r3, sp, #4
 5066 0038 FFF7FEFF 		bl	i2c_writeBytes
 5067              	.LVL317:
2736:Src/mpu6050.c ****         return -1;
 5068              		.loc 1 2736 8 view .LVU1547
 5069 003c 0028     		cmp	r0, #0
 5070 003e E3D1     		bne	.L435
2738:Src/mpu6050.c ****         return -1;
 5071              		.loc 1 2738 5 is_stmt 1 view .LVU1548
2738:Src/mpu6050.c ****         return -1;
 5072              		.loc 1 2738 9 is_stmt 0 view .LVU1549
 5073 0040 D4E90010 		ldrd	r1, r0, [r4]
 5074 0044 3346     		mov	r3, r6
 5075 0046 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 5076 0048 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5077 004a EAB2     		uxtb	r2, r5
 5078 004c FFF7FEFF 		bl	i2c_writeBytes
 5079              	.LVL318:
2738:Src/mpu6050.c ****         return -1;
 5080              		.loc 1 2738 8 view .LVU1550
 5081 0050 0038     		subs	r0, r0, #0
 5082 0052 18BF     		it	ne
 5083 0054 0120     		movne	r0, #1
 5084 0056 4042     		rsbs	r0, r0, #0
 5085 0058 D8E7     		b	.L432
 5086              	.L440:
 5087 005a 00BF     		.align	2
 5088              	.L439:
 5089 005c 00000000 		.word	.LANCHOR0
 5090              		.cfi_endproc
 5091              	.LFE101:
 5093              		.section	.text.mpu_read_mem,"ax",%progbits
 5094              		.align	1
 5095              		.global	mpu_read_mem
 5096              		.syntax unified
 5097              		.thumb
ARM GAS  /tmp/ccNfEN49.s 			page 164


 5098              		.thumb_func
 5099              		.fpu softvfp
 5101              	mpu_read_mem:
 5102              	.LVL319:
 5103              	.LFB102:
2742:Src/mpu6050.c **** 
2743:Src/mpu6050.c **** /**
2744:Src/mpu6050.c ****  *  @brief      Read from the DMP memory.
2745:Src/mpu6050.c ****  *  This function prevents I2C reads past the bank boundaries. The DMP memory
2746:Src/mpu6050.c ****  *  is only accessible when the chip is awake.
2747:Src/mpu6050.c ****  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
2748:Src/mpu6050.c ****  *  @param[in]  length      Number of bytes to read.
2749:Src/mpu6050.c ****  *  @param[out] data        Bytes read from memory.
2750:Src/mpu6050.c ****  *  @return     0 if successful.
2751:Src/mpu6050.c ****  */
2752:Src/mpu6050.c **** int mpu_read_mem(unsigned short mem_addr, unsigned short length,
2753:Src/mpu6050.c ****         unsigned char *data)
2754:Src/mpu6050.c **** {
 5104              		.loc 1 2754 1 is_stmt 1 view -0
 5105              		.cfi_startproc
 5106              		@ args = 0, pretend = 0, frame = 8
 5107              		@ frame_needed = 0, uses_anonymous_args = 0
2755:Src/mpu6050.c ****     unsigned char tmp[2];
 5108              		.loc 1 2755 5 view .LVU1552
2756:Src/mpu6050.c **** 
2757:Src/mpu6050.c ****     if (!data)
 5109              		.loc 1 2757 5 view .LVU1553
2754:Src/mpu6050.c ****     unsigned char tmp[2];
 5110              		.loc 1 2754 1 is_stmt 0 view .LVU1554
 5111 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 5112              	.LCFI83:
 5113              		.cfi_def_cfa_offset 32
 5114              		.cfi_offset 4, -20
 5115              		.cfi_offset 5, -16
 5116              		.cfi_offset 6, -12
 5117              		.cfi_offset 7, -8
 5118              		.cfi_offset 14, -4
2754:Src/mpu6050.c ****     unsigned char tmp[2];
 5119              		.loc 1 2754 1 view .LVU1555
 5120 0002 0D46     		mov	r5, r1
 5121              		.loc 1 2757 8 view .LVU1556
 5122 0004 1646     		mov	r6, r2
 5123 0006 1AB9     		cbnz	r2, .L442
 5124              	.LVL320:
 5125              	.L444:
2758:Src/mpu6050.c ****         return -1;
 5126              		.loc 1 2758 16 view .LVU1557
 5127 0008 4FF0FF30 		mov	r0, #-1
 5128              	.L441:
2759:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
2760:Src/mpu6050.c ****         return -1;
2761:Src/mpu6050.c **** 
2762:Src/mpu6050.c ****     tmp[0] = (unsigned char)(mem_addr >> 8);
2763:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
2764:Src/mpu6050.c **** 
2765:Src/mpu6050.c ****     /* Check bank boundaries. */
2766:Src/mpu6050.c ****     if (tmp[1] + length > st.hw->bank_size)
ARM GAS  /tmp/ccNfEN49.s 			page 165


2767:Src/mpu6050.c ****         return -1;
2768:Src/mpu6050.c **** 
2769:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
2770:Src/mpu6050.c ****         return -1;
2771:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
2772:Src/mpu6050.c ****         return -1;
2773:Src/mpu6050.c ****     return 0;
2774:Src/mpu6050.c **** }
 5129              		.loc 1 2774 1 view .LVU1558
 5130 000c 03B0     		add	sp, sp, #12
 5131              	.LCFI84:
 5132              		.cfi_remember_state
 5133              		.cfi_def_cfa_offset 20
 5134              		@ sp needed
 5135 000e F0BD     		pop	{r4, r5, r6, r7, pc}
 5136              	.LVL321:
 5137              	.L442:
 5138              	.LCFI85:
 5139              		.cfi_restore_state
2759:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5140              		.loc 1 2759 5 is_stmt 1 view .LVU1559
2759:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5141              		.loc 1 2759 21 is_stmt 0 view .LVU1560
 5142 0010 124C     		ldr	r4, .L448
2759:Src/mpu6050.c ****     if (!st.chip_cfg.sensors)
 5143              		.loc 1 2759 8 view .LVU1561
 5144 0012 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 5145 0014 002B     		cmp	r3, #0
 5146 0016 F7D0     		beq	.L444
2762:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5147              		.loc 1 2762 5 is_stmt 1 view .LVU1562
2766:Src/mpu6050.c ****         return -1;
 5148              		.loc 1 2766 29 is_stmt 0 view .LVU1563
 5149 0018 6768     		ldr	r7, [r4, #4]
2762:Src/mpu6050.c ****     tmp[1] = (unsigned char)(mem_addr & 0xFF);
 5150              		.loc 1 2762 14 view .LVU1564
 5151 001a 030A     		lsrs	r3, r0, #8
 5152 001c 8DF80430 		strb	r3, [sp, #4]
2763:Src/mpu6050.c **** 
 5153              		.loc 1 2763 5 is_stmt 1 view .LVU1565
2763:Src/mpu6050.c **** 
 5154              		.loc 1 2763 14 is_stmt 0 view .LVU1566
 5155 0020 C0B2     		uxtb	r0, r0
 5156              	.LVL322:
2766:Src/mpu6050.c ****         return -1;
 5157              		.loc 1 2766 32 view .LVU1567
 5158 0022 7B89     		ldrh	r3, [r7, #10]
2763:Src/mpu6050.c **** 
 5159              		.loc 1 2763 12 view .LVU1568
 5160 0024 8DF80500 		strb	r0, [sp, #5]
2766:Src/mpu6050.c ****         return -1;
 5161              		.loc 1 2766 5 is_stmt 1 view .LVU1569
2766:Src/mpu6050.c ****         return -1;
 5162              		.loc 1 2766 16 is_stmt 0 view .LVU1570
 5163 0028 0844     		add	r0, r0, r1
2766:Src/mpu6050.c ****         return -1;
 5164              		.loc 1 2766 8 view .LVU1571
ARM GAS  /tmp/ccNfEN49.s 			page 166


 5165 002a 9842     		cmp	r0, r3
 5166 002c ECDC     		bgt	.L444
2769:Src/mpu6050.c ****         return -1;
 5167              		.loc 1 2769 5 is_stmt 1 view .LVU1572
2769:Src/mpu6050.c ****         return -1;
 5168              		.loc 1 2769 9 is_stmt 0 view .LVU1573
 5169 002e 2168     		ldr	r1, [r4]
 5170              	.LVL323:
2769:Src/mpu6050.c ****         return -1;
 5171              		.loc 1 2769 9 view .LVU1574
 5172 0030 0222     		movs	r2, #2
 5173              	.LVL324:
2769:Src/mpu6050.c ****         return -1;
 5174              		.loc 1 2769 9 view .LVU1575
 5175 0032 C97E     		ldrb	r1, [r1, #27]	@ zero_extendqisi2
 5176 0034 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5177 0036 01AB     		add	r3, sp, #4
 5178 0038 FFF7FEFF 		bl	i2c_writeBytes
 5179              	.LVL325:
2769:Src/mpu6050.c ****         return -1;
 5180              		.loc 1 2769 8 view .LVU1576
 5181 003c 0028     		cmp	r0, #0
 5182 003e E3D1     		bne	.L444
2771:Src/mpu6050.c ****         return -1;
 5183              		.loc 1 2771 5 is_stmt 1 view .LVU1577
2771:Src/mpu6050.c ****         return -1;
 5184              		.loc 1 2771 9 is_stmt 0 view .LVU1578
 5185 0040 D4E90010 		ldrd	r1, r0, [r4]
 5186 0044 3346     		mov	r3, r6
 5187 0046 097E     		ldrb	r1, [r1, #24]	@ zero_extendqisi2
 5188 0048 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5189 004a EAB2     		uxtb	r2, r5
 5190 004c FFF7FEFF 		bl	i2c_readBytes
 5191              	.LVL326:
2771:Src/mpu6050.c ****         return -1;
 5192              		.loc 1 2771 8 view .LVU1579
 5193 0050 0038     		subs	r0, r0, #0
 5194 0052 18BF     		it	ne
 5195 0054 0120     		movne	r0, #1
 5196 0056 4042     		rsbs	r0, r0, #0
 5197 0058 D8E7     		b	.L441
 5198              	.L449:
 5199 005a 00BF     		.align	2
 5200              	.L448:
 5201 005c 00000000 		.word	.LANCHOR0
 5202              		.cfi_endproc
 5203              	.LFE102:
 5205              		.section	.text.mpu_load_firmware,"ax",%progbits
 5206              		.align	1
 5207              		.global	mpu_load_firmware
 5208              		.syntax unified
 5209              		.thumb
 5210              		.thumb_func
 5211              		.fpu softvfp
 5213              	mpu_load_firmware:
 5214              	.LVL327:
 5215              	.LFB103:
ARM GAS  /tmp/ccNfEN49.s 			page 167


2775:Src/mpu6050.c **** 
2776:Src/mpu6050.c **** /**
2777:Src/mpu6050.c ****  *  @brief      Load and verify DMP image.
2778:Src/mpu6050.c ****  *  @param[in]  length      Length of DMP image.
2779:Src/mpu6050.c ****  *  @param[in]  firmware    DMP code.
2780:Src/mpu6050.c ****  *  @param[in]  start_addr  Starting address of DMP code memory.
2781:Src/mpu6050.c ****  *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
2782:Src/mpu6050.c ****  *  @return     0 if successful.
2783:Src/mpu6050.c ****  */
2784:Src/mpu6050.c **** int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
2785:Src/mpu6050.c ****     unsigned short start_addr, unsigned short sample_rate)
2786:Src/mpu6050.c **** {
 5216              		.loc 1 2786 1 is_stmt 1 view -0
 5217              		.cfi_startproc
 5218              		@ args = 0, pretend = 0, frame = 32
 5219              		@ frame_needed = 0, uses_anonymous_args = 0
2787:Src/mpu6050.c ****     unsigned short ii;
 5220              		.loc 1 2787 5 view .LVU1581
2788:Src/mpu6050.c ****     unsigned short this_write;
 5221              		.loc 1 2788 5 view .LVU1582
2789:Src/mpu6050.c ****     /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
2790:Src/mpu6050.c **** #define LOAD_CHUNK  (16)
2791:Src/mpu6050.c ****     unsigned char cur[LOAD_CHUNK], tmp[2];
 5222              		.loc 1 2791 5 view .LVU1583
2792:Src/mpu6050.c **** 
2793:Src/mpu6050.c ****     if (st.chip_cfg.dmp_loaded)
 5223              		.loc 1 2793 5 view .LVU1584
2786:Src/mpu6050.c ****     unsigned short ii;
 5224              		.loc 1 2786 1 is_stmt 0 view .LVU1585
 5225 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5226              	.LCFI86:
 5227              		.cfi_def_cfa_offset 36
 5228              		.cfi_offset 4, -36
 5229              		.cfi_offset 5, -32
 5230              		.cfi_offset 6, -28
 5231              		.cfi_offset 7, -24
 5232              		.cfi_offset 8, -20
 5233              		.cfi_offset 9, -16
 5234              		.cfi_offset 10, -12
 5235              		.cfi_offset 11, -8
 5236              		.cfi_offset 14, -4
 5237              		.loc 1 2793 20 view .LVU1586
 5238 0004 254D     		ldr	r5, .L460
2786:Src/mpu6050.c ****     unsigned short ii;
 5239              		.loc 1 2786 1 view .LVU1587
 5240 0006 89B0     		sub	sp, sp, #36
 5241              	.LCFI87:
 5242              		.cfi_def_cfa_offset 72
 5243              		.loc 1 2793 8 view .LVU1588
 5244 0008 95F82540 		ldrb	r4, [r5, #37]	@ zero_extendqisi2
2786:Src/mpu6050.c ****     unsigned short ii;
 5245              		.loc 1 2786 1 view .LVU1589
 5246 000c 8146     		mov	r9, r0
 5247 000e 8A46     		mov	r10, r1
 5248 0010 1746     		mov	r7, r2
 5249 0012 0193     		str	r3, [sp, #4]
 5250              		.loc 1 2793 8 view .LVU1590
ARM GAS  /tmp/ccNfEN49.s 			page 168


 5251 0014 24B1     		cbz	r4, .L451
 5252              	.LVL328:
 5253              	.L453:
2794:Src/mpu6050.c ****         /* DMP should only be loaded once. */
2795:Src/mpu6050.c ****         return -1;
 5254              		.loc 1 2795 16 view .LVU1591
 5255 0016 4FF0FF30 		mov	r0, #-1
 5256              	.L450:
2796:Src/mpu6050.c **** 
2797:Src/mpu6050.c ****     if (!firmware)
2798:Src/mpu6050.c ****         return -1;
2799:Src/mpu6050.c ****     for (ii = 0; ii < length; ii += this_write) {
2800:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
2801:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
2802:Src/mpu6050.c ****             return -1;
2803:Src/mpu6050.c ****         if (mpu_read_mem(ii, this_write, cur))
2804:Src/mpu6050.c ****             return -1;
2805:Src/mpu6050.c ****         if (memcmp(firmware+ii, cur, this_write))
2806:Src/mpu6050.c ****             return -2;
2807:Src/mpu6050.c ****     }
2808:Src/mpu6050.c **** 
2809:Src/mpu6050.c ****     /* Set program start address. */
2810:Src/mpu6050.c ****     tmp[0] = start_addr >> 8;
2811:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
2812:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
2813:Src/mpu6050.c ****         return -1;
2814:Src/mpu6050.c **** 
2815:Src/mpu6050.c ****     st.chip_cfg.dmp_loaded = 1;
2816:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
2817:Src/mpu6050.c ****     return 0;
2818:Src/mpu6050.c **** }
 5257              		.loc 1 2818 1 view .LVU1592
 5258 001a 09B0     		add	sp, sp, #36
 5259              	.LCFI88:
 5260              		.cfi_remember_state
 5261              		.cfi_def_cfa_offset 36
 5262              		@ sp needed
 5263 001c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5264              	.LVL329:
 5265              	.L451:
 5266              	.LCFI89:
 5267              		.cfi_restore_state
2797:Src/mpu6050.c ****         return -1;
 5268              		.loc 1 2797 5 is_stmt 1 view .LVU1593
2797:Src/mpu6050.c ****         return -1;
 5269              		.loc 1 2797 8 is_stmt 0 view .LVU1594
 5270 0020 0029     		cmp	r1, #0
 5271 0022 F8D0     		beq	.L453
 5272              	.LVL330:
 5273              	.L454:
2799:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5274              		.loc 1 2799 18 is_stmt 1 discriminator 1 view .LVU1595
2799:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5275              		.loc 1 2799 5 is_stmt 0 discriminator 1 view .LVU1596
 5276 0024 4C45     		cmp	r4, r9
 5277 0026 14D3     		bcc	.L455
2810:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
ARM GAS  /tmp/ccNfEN49.s 			page 169


 5278              		.loc 1 2810 5 is_stmt 1 view .LVU1597
2810:Src/mpu6050.c ****     tmp[1] = start_addr & 0xFF;
 5279              		.loc 1 2810 12 is_stmt 0 view .LVU1598
 5280 0028 3B0A     		lsrs	r3, r7, #8
 5281 002a 8DF80C30 		strb	r3, [sp, #12]
2811:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
 5282              		.loc 1 2811 5 is_stmt 1 view .LVU1599
2811:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
 5283              		.loc 1 2811 12 is_stmt 0 view .LVU1600
 5284 002e 8DF80D70 		strb	r7, [sp, #13]
2812:Src/mpu6050.c ****         return -1;
 5285              		.loc 1 2812 5 is_stmt 1 view .LVU1601
2812:Src/mpu6050.c ****         return -1;
 5286              		.loc 1 2812 9 is_stmt 0 view .LVU1602
 5287 0032 D5E90010 		ldrd	r1, r0, [r5]
 5288 0036 0222     		movs	r2, #2
 5289 0038 497F     		ldrb	r1, [r1, #29]	@ zero_extendqisi2
 5290 003a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5291 003c 03AB     		add	r3, sp, #12
 5292 003e FFF7FEFF 		bl	i2c_writeBytes
 5293              	.LVL331:
2812:Src/mpu6050.c ****         return -1;
 5294              		.loc 1 2812 8 view .LVU1603
 5295 0042 0028     		cmp	r0, #0
 5296 0044 E7D1     		bne	.L453
2815:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
 5297              		.loc 1 2815 5 is_stmt 1 view .LVU1604
2815:Src/mpu6050.c ****     st.chip_cfg.dmp_sample_rate = sample_rate;
 5298              		.loc 1 2815 28 is_stmt 0 view .LVU1605
 5299 0046 0123     		movs	r3, #1
 5300 0048 85F82530 		strb	r3, [r5, #37]
2816:Src/mpu6050.c ****     return 0;
 5301              		.loc 1 2816 5 is_stmt 1 view .LVU1606
2816:Src/mpu6050.c ****     return 0;
 5302              		.loc 1 2816 33 is_stmt 0 view .LVU1607
 5303 004c 019B     		ldr	r3, [sp, #4]
 5304 004e EB84     		strh	r3, [r5, #38]	@ movhi
2817:Src/mpu6050.c **** }
 5305              		.loc 1 2817 5 is_stmt 1 view .LVU1608
2817:Src/mpu6050.c **** }
 5306              		.loc 1 2817 12 is_stmt 0 view .LVU1609
 5307 0050 E3E7     		b	.L450
 5308              	.L455:
2800:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5309              		.loc 1 2800 9 is_stmt 1 view .LVU1610
2800:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5310              		.loc 1 2800 22 is_stmt 0 view .LVU1611
 5311 0052 A9EB040B 		sub	fp, r9, r4
 5312 0056 BBF1100F 		cmp	fp, #16
 5313 005a A8BF     		it	ge
 5314 005c 4FF0100B 		movge	fp, #16
2801:Src/mpu6050.c ****             return -1;
 5315              		.loc 1 2801 59 view .LVU1612
 5316 0060 0AEB0408 		add	r8, r10, r4
2800:Src/mpu6050.c ****         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
 5317              		.loc 1 2800 20 view .LVU1613
 5318 0064 1FFA8BF6 		uxth	r6, fp
ARM GAS  /tmp/ccNfEN49.s 			page 170


 5319              	.LVL332:
2801:Src/mpu6050.c ****             return -1;
 5320              		.loc 1 2801 9 is_stmt 1 view .LVU1614
2801:Src/mpu6050.c ****             return -1;
 5321              		.loc 1 2801 13 is_stmt 0 view .LVU1615
 5322 0068 4246     		mov	r2, r8
 5323 006a 3146     		mov	r1, r6
 5324 006c 2046     		mov	r0, r4
 5325 006e FFF7FEFF 		bl	mpu_write_mem
 5326              	.LVL333:
2801:Src/mpu6050.c ****             return -1;
 5327              		.loc 1 2801 12 view .LVU1616
 5328 0072 0028     		cmp	r0, #0
 5329 0074 CFD1     		bne	.L453
2803:Src/mpu6050.c ****             return -1;
 5330              		.loc 1 2803 9 is_stmt 1 view .LVU1617
2803:Src/mpu6050.c ****             return -1;
 5331              		.loc 1 2803 13 is_stmt 0 view .LVU1618
 5332 0076 3146     		mov	r1, r6
 5333 0078 2046     		mov	r0, r4
 5334 007a 04AA     		add	r2, sp, #16
 5335 007c FFF7FEFF 		bl	mpu_read_mem
 5336              	.LVL334:
2803:Src/mpu6050.c ****             return -1;
 5337              		.loc 1 2803 12 view .LVU1619
 5338 0080 0028     		cmp	r0, #0
 5339 0082 C8D1     		bne	.L453
2805:Src/mpu6050.c ****             return -2;
 5340              		.loc 1 2805 9 is_stmt 1 view .LVU1620
2805:Src/mpu6050.c ****             return -2;
 5341              		.loc 1 2805 13 is_stmt 0 view .LVU1621
 5342 0084 3246     		mov	r2, r6
 5343 0086 4046     		mov	r0, r8
 5344 0088 04A9     		add	r1, sp, #16
 5345 008a FFF7FEFF 		bl	memcmp
 5346              	.LVL335:
2805:Src/mpu6050.c ****             return -2;
 5347              		.loc 1 2805 12 view .LVU1622
 5348 008e 10B9     		cbnz	r0, .L456
2799:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5349              		.loc 1 2799 31 is_stmt 1 discriminator 2 view .LVU1623
2799:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5350              		.loc 1 2799 34 is_stmt 0 discriminator 2 view .LVU1624
 5351 0090 3444     		add	r4, r4, r6
 5352              	.LVL336:
2799:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5353              		.loc 1 2799 34 discriminator 2 view .LVU1625
 5354 0092 A4B2     		uxth	r4, r4
 5355              	.LVL337:
2799:Src/mpu6050.c ****         this_write = min(LOAD_CHUNK, length - ii);
 5356              		.loc 1 2799 34 discriminator 2 view .LVU1626
 5357 0094 C6E7     		b	.L454
 5358              	.L456:
2806:Src/mpu6050.c ****     }
 5359              		.loc 1 2806 20 view .LVU1627
 5360 0096 6FF00100 		mvn	r0, #1
 5361 009a BEE7     		b	.L450
ARM GAS  /tmp/ccNfEN49.s 			page 171


 5362              	.L461:
 5363              		.align	2
 5364              	.L460:
 5365 009c 00000000 		.word	.LANCHOR0
 5366              		.cfi_endproc
 5367              	.LFE103:
 5369              		.section	.text.mpu_set_dmp_state,"ax",%progbits
 5370              		.align	1
 5371              		.global	mpu_set_dmp_state
 5372              		.syntax unified
 5373              		.thumb
 5374              		.thumb_func
 5375              		.fpu softvfp
 5377              	mpu_set_dmp_state:
 5378              	.LVL338:
 5379              	.LFB104:
2819:Src/mpu6050.c **** 
2820:Src/mpu6050.c **** /**
2821:Src/mpu6050.c ****  *  @brief      Enable/disable DMP support.
2822:Src/mpu6050.c ****  *  @param[in]  enable  1 to turn on the DMP.
2823:Src/mpu6050.c ****  *  @return     0 if successful.
2824:Src/mpu6050.c ****  */
2825:Src/mpu6050.c **** int mpu_set_dmp_state(unsigned char enable)
2826:Src/mpu6050.c **** {
 5380              		.loc 1 2826 1 is_stmt 1 view -0
 5381              		.cfi_startproc
 5382              		@ args = 0, pretend = 0, frame = 8
 5383              		@ frame_needed = 0, uses_anonymous_args = 0
2827:Src/mpu6050.c ****     unsigned char tmp;
 5384              		.loc 1 2827 5 view .LVU1629
2828:Src/mpu6050.c ****     if (st.chip_cfg.dmp_on == enable)
 5385              		.loc 1 2828 5 view .LVU1630
2826:Src/mpu6050.c ****     unsigned char tmp;
 5386              		.loc 1 2826 1 is_stmt 0 view .LVU1631
 5387 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 5388              	.LCFI90:
 5389              		.cfi_def_cfa_offset 24
 5390              		.cfi_offset 4, -12
 5391              		.cfi_offset 5, -8
 5392              		.cfi_offset 14, -4
 5393              		.loc 1 2828 20 view .LVU1632
 5394 0002 1D4D     		ldr	r5, .L468
2826:Src/mpu6050.c ****     unsigned char tmp;
 5395              		.loc 1 2826 1 view .LVU1633
 5396 0004 0446     		mov	r4, r0
 5397              		.loc 1 2828 8 view .LVU1634
 5398 0006 95F82430 		ldrb	r3, [r5, #36]	@ zero_extendqisi2
 5399 000a 8342     		cmp	r3, r0
 5400 000c 1ED0     		beq	.L465
2829:Src/mpu6050.c ****         return 0;
2830:Src/mpu6050.c **** 
2831:Src/mpu6050.c ****     if (enable) {
 5401              		.loc 1 2831 5 is_stmt 1 view .LVU1635
 5402              		.loc 1 2831 8 is_stmt 0 view .LVU1636
 5403 000e 00B3     		cbz	r0, .L464
2832:Src/mpu6050.c ****         if (!st.chip_cfg.dmp_loaded)
 5404              		.loc 1 2832 9 is_stmt 1 view .LVU1637
ARM GAS  /tmp/ccNfEN49.s 			page 172


 5405              		.loc 1 2832 12 is_stmt 0 view .LVU1638
 5406 0010 95F82530 		ldrb	r3, [r5, #37]	@ zero_extendqisi2
 5407 0014 6BB3     		cbz	r3, .L466
 5408              	.LBB10:
 5409              	.LBI10:
2825:Src/mpu6050.c **** {
 5410              		.loc 1 2825 5 is_stmt 1 view .LVU1639
 5411              	.LVL339:
 5412              	.LBB11:
2833:Src/mpu6050.c ****             return -1;
2834:Src/mpu6050.c ****         /* Disable data ready interrupt. */
2835:Src/mpu6050.c ****         set_int_enable(0);
 5413              		.loc 1 2835 9 view .LVU1640
2836:Src/mpu6050.c ****         /* Disable bypass mode. */
2837:Src/mpu6050.c ****         mpu_set_bypass(0);
2838:Src/mpu6050.c ****         /* Keep constant sample rate, FIFO rate controlled by DMP. */
2839:Src/mpu6050.c ****         mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
2840:Src/mpu6050.c ****         /* Remove FIFO elements. */
2841:Src/mpu6050.c ****         tmp = 0;
 5414              		.loc 1 2841 13 is_stmt 0 view .LVU1641
 5415 0016 0024     		movs	r4, #0
2835:Src/mpu6050.c ****         /* Disable bypass mode. */
 5416              		.loc 1 2835 9 view .LVU1642
 5417 0018 0020     		movs	r0, #0
 5418              	.LVL340:
2835:Src/mpu6050.c ****         /* Disable bypass mode. */
 5419              		.loc 1 2835 9 view .LVU1643
 5420 001a FFF7FEFF 		bl	set_int_enable.isra.0
 5421              	.LVL341:
2837:Src/mpu6050.c ****         /* Keep constant sample rate, FIFO rate controlled by DMP. */
 5422              		.loc 1 2837 9 is_stmt 1 view .LVU1644
 5423 001e 0020     		movs	r0, #0
 5424 0020 FFF7FEFF 		bl	mpu_set_bypass
 5425              	.LVL342:
2839:Src/mpu6050.c ****         /* Remove FIFO elements. */
 5426              		.loc 1 2839 9 view .LVU1645
 5427 0024 E88C     		ldrh	r0, [r5, #38]
 5428 0026 FFF7FEFF 		bl	mpu_set_sample_rate
 5429              	.LVL343:
 5430              		.loc 1 2841 9 view .LVU1646
2842:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5431              		.loc 1 2842 9 is_stmt 0 view .LVU1647
 5432 002a 6868     		ldr	r0, [r5, #4]
2841:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5433              		.loc 1 2841 13 view .LVU1648
 5434 002c 8DF80740 		strb	r4, [sp, #7]
 5435              		.loc 1 2842 9 is_stmt 1 view .LVU1649
 5436 0030 0122     		movs	r2, #1
 5437 0032 2321     		movs	r1, #35
 5438 0034 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5439 0036 0DF10703 		add	r3, sp, #7
 5440 003a FFF7FEFF 		bl	i2c_writeBytes
 5441              	.LVL344:
2843:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 1;
 5442              		.loc 1 2843 9 view .LVU1650
 5443              		.loc 1 2843 28 is_stmt 0 view .LVU1651
 5444 003e 0120     		movs	r0, #1
ARM GAS  /tmp/ccNfEN49.s 			page 173


 5445 0040 85F82400 		strb	r0, [r5, #36]
2844:Src/mpu6050.c ****         /* Enable DMP interrupt. */
2845:Src/mpu6050.c ****         set_int_enable(1);
 5446              		.loc 1 2845 9 is_stmt 1 view .LVU1652
 5447 0044 FFF7FEFF 		bl	set_int_enable.isra.0
 5448              	.LVL345:
2846:Src/mpu6050.c ****         mpu_reset_fifo();
 5449              		.loc 1 2846 9 view .LVU1653
 5450              	.L467:
 5451              		.loc 1 2846 9 is_stmt 0 view .LVU1654
 5452              	.LBE11:
 5453              	.LBE10:
2847:Src/mpu6050.c ****     } else {
2848:Src/mpu6050.c ****         /* Disable DMP interrupt. */
2849:Src/mpu6050.c ****         set_int_enable(0);
2850:Src/mpu6050.c ****         /* Restore FIFO settings. */
2851:Src/mpu6050.c ****         tmp = st.chip_cfg.fifo_enable;
2852:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
2853:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
2854:Src/mpu6050.c ****         mpu_reset_fifo();
 5454              		.loc 1 2854 9 is_stmt 1 view .LVU1655
 5455 0048 FFF7FEFF 		bl	mpu_reset_fifo
 5456              	.LVL346:
 5457              	.L465:
2829:Src/mpu6050.c **** 
 5458              		.loc 1 2829 16 is_stmt 0 view .LVU1656
 5459 004c 0020     		movs	r0, #0
 5460              	.L462:
2855:Src/mpu6050.c ****     }
2856:Src/mpu6050.c ****     return 0;
2857:Src/mpu6050.c **** }
 5461              		.loc 1 2857 1 view .LVU1657
 5462 004e 03B0     		add	sp, sp, #12
 5463              	.LCFI91:
 5464              		.cfi_remember_state
 5465              		.cfi_def_cfa_offset 12
 5466              		@ sp needed
 5467 0050 30BD     		pop	{r4, r5, pc}
 5468              	.LVL347:
 5469              	.L464:
 5470              	.LCFI92:
 5471              		.cfi_restore_state
2849:Src/mpu6050.c ****         /* Restore FIFO settings. */
 5472              		.loc 1 2849 9 is_stmt 1 view .LVU1658
 5473 0052 FFF7FEFF 		bl	set_int_enable.isra.0
 5474              	.LVL348:
2851:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5475              		.loc 1 2851 9 view .LVU1659
2851:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5476              		.loc 1 2851 13 is_stmt 0 view .LVU1660
 5477 0056 2B7C     		ldrb	r3, [r5, #16]	@ zero_extendqisi2
2852:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
 5478              		.loc 1 2852 9 view .LVU1661
 5479 0058 6868     		ldr	r0, [r5, #4]
2851:Src/mpu6050.c ****         i2c_write(st.hw->addr, 0x23, 1, &tmp);
 5480              		.loc 1 2851 13 view .LVU1662
 5481 005a 8DF80730 		strb	r3, [sp, #7]
ARM GAS  /tmp/ccNfEN49.s 			page 174


2852:Src/mpu6050.c ****         st.chip_cfg.dmp_on = 0;
 5482              		.loc 1 2852 9 is_stmt 1 view .LVU1663
 5483 005e 0122     		movs	r2, #1
 5484 0060 2321     		movs	r1, #35
 5485 0062 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5486 0064 0DF10703 		add	r3, sp, #7
 5487 0068 FFF7FEFF 		bl	i2c_writeBytes
 5488              	.LVL349:
2853:Src/mpu6050.c ****         mpu_reset_fifo();
 5489              		.loc 1 2853 9 view .LVU1664
2853:Src/mpu6050.c ****         mpu_reset_fifo();
 5490              		.loc 1 2853 28 is_stmt 0 view .LVU1665
 5491 006c 85F82440 		strb	r4, [r5, #36]
 5492 0070 EAE7     		b	.L467
 5493              	.LVL350:
 5494              	.L466:
2833:Src/mpu6050.c ****         /* Disable data ready interrupt. */
 5495              		.loc 1 2833 20 view .LVU1666
 5496 0072 4FF0FF30 		mov	r0, #-1
 5497              	.LVL351:
2833:Src/mpu6050.c ****         /* Disable data ready interrupt. */
 5498              		.loc 1 2833 20 view .LVU1667
 5499 0076 EAE7     		b	.L462
 5500              	.L469:
 5501              		.align	2
 5502              	.L468:
 5503 0078 00000000 		.word	.LANCHOR0
 5504              		.cfi_endproc
 5505              	.LFE104:
 5507              		.global	__aeabi_fcmpeq
 5508              		.global	__aeabi_fcmpgt
 5509              		.global	__aeabi_fcmplt
 5510              		.section	.text.mpu_run_self_test,"ax",%progbits
 5511              		.align	1
 5512              		.global	mpu_run_self_test
 5513              		.syntax unified
 5514              		.thumb
 5515              		.thumb_func
 5516              		.fpu softvfp
 5518              	mpu_run_self_test:
 5519              	.LVL352:
 5520              	.LFB100:
2616:Src/mpu6050.c **** #ifdef MPU6050
 5521              		.loc 1 2616 1 is_stmt 1 view -0
 5522              		.cfi_startproc
 5523              		@ args = 0, pretend = 0, frame = 80
 5524              		@ frame_needed = 0, uses_anonymous_args = 0
2618:Src/mpu6050.c ****     long gyro_st[3], accel_st[3];
 5525              		.loc 1 2618 5 view .LVU1669
2619:Src/mpu6050.c ****     unsigned char accel_result, gyro_result;
 5526              		.loc 1 2619 5 view .LVU1670
2620:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
 5527              		.loc 1 2620 5 view .LVU1671
2624:Src/mpu6050.c **** #endif
 5528              		.loc 1 2624 5 view .LVU1672
2626:Src/mpu6050.c ****     unsigned char accel_fsr, fifo_sensors, sensors_on;
 5529              		.loc 1 2626 5 view .LVU1673
ARM GAS  /tmp/ccNfEN49.s 			page 175


2627:Src/mpu6050.c ****     unsigned short gyro_fsr, sample_rate, lpf;
 5530              		.loc 1 2627 5 view .LVU1674
2628:Src/mpu6050.c ****     unsigned char dmp_was_on;
 5531              		.loc 1 2628 5 view .LVU1675
2629:Src/mpu6050.c **** 
 5532              		.loc 1 2629 5 view .LVU1676
2631:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5533              		.loc 1 2631 5 view .LVU1677
2616:Src/mpu6050.c **** #ifdef MPU6050
 5534              		.loc 1 2616 1 is_stmt 0 view .LVU1678
 5535 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5536              	.LCFI93:
 5537              		.cfi_def_cfa_offset 36
 5538              		.cfi_offset 4, -36
 5539              		.cfi_offset 5, -32
 5540              		.cfi_offset 6, -28
 5541              		.cfi_offset 7, -24
 5542              		.cfi_offset 8, -20
 5543              		.cfi_offset 9, -16
 5544              		.cfi_offset 10, -12
 5545              		.cfi_offset 11, -8
 5546              		.cfi_offset 14, -4
2631:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5547              		.loc 1 2631 20 view .LVU1679
 5548 0004 B94C     		ldr	r4, .L534
2616:Src/mpu6050.c **** #ifdef MPU6050
 5549              		.loc 1 2616 1 view .LVU1680
 5550 0006 95B0     		sub	sp, sp, #84
 5551              	.LCFI94:
 5552              		.cfi_def_cfa_offset 120
2631:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5553              		.loc 1 2631 20 view .LVU1681
 5554 0008 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
2616:Src/mpu6050.c **** #ifdef MPU6050
 5555              		.loc 1 2616 1 view .LVU1682
 5556 000c 0746     		mov	r7, r0
 5557 000e 8846     		mov	r8, r1
2631:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5558              		.loc 1 2631 20 view .LVU1683
 5559 0010 0093     		str	r3, [sp]
2631:Src/mpu6050.c ****         mpu_set_dmp_state(0);
 5560              		.loc 1 2631 8 view .LVU1684
 5561 0012 23B1     		cbz	r3, .L471
2632:Src/mpu6050.c ****         dmp_was_on = 1;
 5562              		.loc 1 2632 9 is_stmt 1 view .LVU1685
 5563 0014 0020     		movs	r0, #0
 5564              	.LVL353:
2632:Src/mpu6050.c ****         dmp_was_on = 1;
 5565              		.loc 1 2632 9 is_stmt 0 view .LVU1686
 5566 0016 FFF7FEFF 		bl	mpu_set_dmp_state
 5567              	.LVL354:
2633:Src/mpu6050.c ****     } else
 5568              		.loc 1 2633 9 is_stmt 1 view .LVU1687
2633:Src/mpu6050.c ****     } else
 5569              		.loc 1 2633 20 is_stmt 0 view .LVU1688
 5570 001a 0123     		movs	r3, #1
 5571 001c 0093     		str	r3, [sp]
ARM GAS  /tmp/ccNfEN49.s 			page 176


 5572              	.LVL355:
 5573              	.L471:
2638:Src/mpu6050.c ****     mpu_get_accel_fsr(&accel_fsr);
 5574              		.loc 1 2638 5 is_stmt 1 view .LVU1689
 5575 001e 0DF11E00 		add	r0, sp, #30
 5576 0022 FFF7FEFF 		bl	mpu_get_gyro_fsr
 5577              	.LVL356:
2639:Src/mpu6050.c ****     mpu_get_lpf(&lpf);
 5578              		.loc 1 2639 5 view .LVU1690
 5579 0026 0DF11D00 		add	r0, sp, #29
 5580 002a FFF7FEFF 		bl	mpu_get_accel_fsr
 5581              	.LVL357:
2640:Src/mpu6050.c ****     mpu_get_sample_rate(&sample_rate);
 5582              		.loc 1 2640 5 view .LVU1691
 5583 002e 0DF12200 		add	r0, sp, #34
 5584 0032 FFF7FEFF 		bl	mpu_get_lpf
 5585              	.LVL358:
2641:Src/mpu6050.c ****     sensors_on = st.chip_cfg.sensors;
 5586              		.loc 1 2641 5 view .LVU1692
 5587 0036 08A8     		add	r0, sp, #32
 5588 0038 FFF7FEFF 		bl	mpu_get_sample_rate
 5589              	.LVL359:
2642:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5590              		.loc 1 2642 5 view .LVU1693
2642:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5591              		.loc 1 2642 16 is_stmt 0 view .LVU1694
 5592 003c A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
2648:Src/mpu6050.c ****             break;
 5593              		.loc 1 2648 14 view .LVU1695
 5594 003e 0022     		movs	r2, #0
2642:Src/mpu6050.c ****     mpu_get_fifo_config(&fifo_sensors);
 5595              		.loc 1 2642 16 view .LVU1696
 5596 0040 0393     		str	r3, [sp, #12]
 5597              	.LVL360:
2643:Src/mpu6050.c **** 
 5598              		.loc 1 2643 5 is_stmt 1 view .LVU1697
 5599              	.LBB20:
 5600              	.LBI20:
1486:Src/mpu6050.c **** {
 5601              		.loc 1 1486 5 view .LVU1698
 5602              	.LBB21:
1488:Src/mpu6050.c ****     return 0;
 5603              		.loc 1 1488 5 view .LVU1699
1488:Src/mpu6050.c ****     return 0;
 5604              		.loc 1 1488 29 is_stmt 0 view .LVU1700
 5605 0042 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 5606              	.LBE21:
 5607              	.LBE20:
2648:Src/mpu6050.c ****             break;
 5608              		.loc 1 2648 14 view .LVU1701
 5609 0044 4146     		mov	r1, r8
 5610 0046 3846     		mov	r0, r7
 5611              	.LBB23:
 5612              	.LBB22:
1488:Src/mpu6050.c ****     return 0;
 5613              		.loc 1 1488 29 view .LVU1702
 5614 0048 0493     		str	r3, [sp, #16]
ARM GAS  /tmp/ccNfEN49.s 			page 177


 5615              	.LVL361:
1489:Src/mpu6050.c **** }
 5616              		.loc 1 1489 5 is_stmt 1 view .LVU1703
1489:Src/mpu6050.c **** }
 5617              		.loc 1 1489 5 is_stmt 0 view .LVU1704
 5618              	.LBE22:
 5619              	.LBE23:
2647:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5620              		.loc 1 2647 5 is_stmt 1 view .LVU1705
2647:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5621              		.loc 1 2647 18 view .LVU1706
2648:Src/mpu6050.c ****             break;
 5622              		.loc 1 2648 9 view .LVU1707
2648:Src/mpu6050.c ****             break;
 5623              		.loc 1 2648 14 is_stmt 0 view .LVU1708
 5624 004a FFF7FEFF 		bl	get_st_biases
 5625              	.LVL362:
2648:Src/mpu6050.c ****             break;
 5626              		.loc 1 2648 12 view .LVU1709
 5627 004e 0028     		cmp	r0, #0
 5628 0050 40F08B80 		bne	.L472
 5629              	.LVL363:
 5630              	.L475:
2657:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5631              		.loc 1 2657 18 is_stmt 1 view .LVU1710
2658:Src/mpu6050.c ****             break;
 5632              		.loc 1 2658 9 view .LVU1711
2658:Src/mpu6050.c ****             break;
 5633              		.loc 1 2658 14 is_stmt 0 view .LVU1712
 5634 0054 0122     		movs	r2, #1
 5635 0056 0EA9     		add	r1, sp, #56
 5636 0058 0BA8     		add	r0, sp, #44
 5637 005a FFF7FEFF 		bl	get_st_biases
 5638              	.LVL364:
2658:Src/mpu6050.c ****             break;
 5639              		.loc 1 2658 12 view .LVU1713
 5640 005e 0028     		cmp	r0, #0
 5641 0060 40F0B480 		bne	.L526
 5642              	.LVL365:
 5643              	.L473:
2665:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5644              		.loc 1 2665 5 is_stmt 1 view .LVU1714
 5645              	.LBB24:
 5646              	.LBI24:
1897:Src/mpu6050.c **** {
 5647              		.loc 1 1897 12 view .LVU1715
 5648              	.LBB25:
1899:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
 5649              		.loc 1 1899 5 view .LVU1716
1900:Src/mpu6050.c **** 
 5650              		.loc 1 1900 5 view .LVU1717
1902:Src/mpu6050.c ****     for(jj = 0; jj < 3; jj++) {
 5651              		.loc 1 1902 5 view .LVU1718
 5652              	.LBB26:
 5653              	.LBI26:
1872:Src/mpu6050.c **** {
 5654              		.loc 1 1872 12 view .LVU1719
ARM GAS  /tmp/ccNfEN49.s 			page 178


 5655              	.LBB27:
1874:Src/mpu6050.c **** 
 5656              		.loc 1 1874 5 view .LVU1720
1876:Src/mpu6050.c ****         return 0x07;
 5657              		.loc 1 1876 5 view .LVU1721
1876:Src/mpu6050.c ****         return 0x07;
 5658              		.loc 1 1876 9 is_stmt 0 view .LVU1722
 5659 0064 6068     		ldr	r0, [r4, #4]
 5660 0066 0422     		movs	r2, #4
 5661 0068 0D21     		movs	r1, #13
 5662 006a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5663 006c 0AAB     		add	r3, sp, #40
 5664 006e FFF7FEFF 		bl	i2c_readBytes
 5665              	.LVL366:
1876:Src/mpu6050.c ****         return 0x07;
 5666              		.loc 1 1876 8 view .LVU1723
 5667 0072 0546     		mov	r5, r0
 5668 0074 0028     		cmp	r0, #0
 5669 0076 00F0B180 		beq	.L527
 5670              	.L477:
 5671              	.LVL367:
1876:Src/mpu6050.c ****         return 0x07;
 5672              		.loc 1 1876 8 view .LVU1724
 5673              	.LBE27:
 5674              	.LBE26:
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5675              		.loc 1 1903 17 is_stmt 1 view .LVU1725
1899:Src/mpu6050.c ****     float st_shift[3], st_shift_cust, st_shift_var;
 5676              		.loc 1 1899 13 is_stmt 0 view .LVU1726
 5677 007a 0026     		movs	r6, #0
1911:Src/mpu6050.c ****     }
 5678              		.loc 1 1911 25 view .LVU1727
 5679 007c 4FF00109 		mov	r9, #1
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5680              		.loc 1 1903 12 view .LVU1728
 5681 0080 3546     		mov	r5, r6
 5682 0082 0EAB     		add	r3, sp, #56
 5683              	.LVL368:
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5684              		.loc 1 1903 12 view .LVU1729
 5685 0084 0293     		str	r3, [sp, #8]
1907:Src/mpu6050.c ****                 result |= 1 << jj;
 5686              		.loc 1 1907 16 view .LVU1730
 5687 0086 DFF868B2 		ldr	fp, .L534+4
 5688 008a 11AB     		add	r3, sp, #68
 5689              	.LVL369:
1907:Src/mpu6050.c ****                 result |= 1 << jj;
 5690              		.loc 1 1907 16 view .LVU1731
 5691 008c 0193     		str	r3, [sp, #4]
 5692              	.LVL370:
 5693              	.L480:
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5694              		.loc 1 1904 9 is_stmt 1 view .LVU1732
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5695              		.loc 1 1904 56 is_stmt 0 view .LVU1733
 5696 008e 029A     		ldr	r2, [sp, #8]
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
ARM GAS  /tmp/ccNfEN49.s 			page 179


 5697              		.loc 1 1904 47 view .LVU1734
 5698 0090 58F82500 		ldr	r0, [r8, r5, lsl #2]
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5699              		.loc 1 1904 56 view .LVU1735
 5700 0094 52F8043B 		ldr	r3, [r2], #4
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5701              		.loc 1 1904 47 view .LVU1736
 5702 0098 C01A     		subs	r0, r0, r3
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5703              		.loc 1 1904 62 view .LVU1737
 5704 009a 0028     		cmp	r0, #0
 5705 009c B8BF     		it	lt
 5706 009e 4042     		rsblt	r0, r0, #0
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5707              		.loc 1 1904 56 view .LVU1738
 5708 00a0 0292     		str	r2, [sp, #8]
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5709              		.loc 1 1904 62 view .LVU1739
 5710 00a2 FFF7FEFF 		bl	__aeabi_i2f
 5711              	.LVL371:
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5712              		.loc 1 1904 23 view .LVU1740
 5713 00a6 4FF05E51 		mov	r1, #931135488
 5714 00aa FFF7FEFF 		bl	__aeabi_fmul
 5715              	.LVL372:
1905:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5716              		.loc 1 1905 21 view .LVU1741
 5717 00ae 019B     		ldr	r3, [sp, #4]
1904:Src/mpu6050.c ****         if (st_shift[jj]) {
 5718              		.loc 1 1904 23 view .LVU1742
 5719 00b0 8246     		mov	r10, r0
 5720              	.LVL373:
1905:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5721              		.loc 1 1905 9 is_stmt 1 view .LVU1743
1905:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5722              		.loc 1 1905 21 is_stmt 0 view .LVU1744
 5723 00b2 53F8042B 		ldr	r2, [r3], #4	@ float
1905:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5724              		.loc 1 1905 12 view .LVU1745
 5725 00b6 0021     		movs	r1, #0
 5726 00b8 1046     		mov	r0, r2
 5727              	.LVL374:
1905:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5728              		.loc 1 1905 21 view .LVU1746
 5729 00ba 0193     		str	r3, [sp, #4]
1905:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
 5730              		.loc 1 1905 12 view .LVU1747
 5731 00bc 0592     		str	r2, [sp, #20]
 5732 00be FFF7FEFF 		bl	__aeabi_fcmpeq
 5733              	.LVL375:
 5734 00c2 0028     		cmp	r0, #0
 5735 00c4 40F0D280 		bne	.L528
1906:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5736              		.loc 1 1906 13 is_stmt 1 view .LVU1748
 5737              	.LVL376:
1907:Src/mpu6050.c ****                 result |= 1 << jj;
 5738              		.loc 1 1907 13 view .LVU1749
ARM GAS  /tmp/ccNfEN49.s 			page 180


1906:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5739              		.loc 1 1906 42 is_stmt 0 view .LVU1750
 5740 00c8 059A     		ldr	r2, [sp, #20]
 5741 00ca 5046     		mov	r0, r10
 5742 00cc 1146     		mov	r1, r2
 5743 00ce FFF7FEFF 		bl	__aeabi_fdiv
 5744              	.LVL377:
1906:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_accel_var)
 5745              		.loc 1 1906 26 view .LVU1751
 5746 00d2 4FF07E51 		mov	r1, #1065353216
 5747 00d6 FFF7FEFF 		bl	__aeabi_fsub
 5748              	.LVL378:
1907:Src/mpu6050.c ****                 result |= 1 << jj;
 5749              		.loc 1 1907 16 view .LVU1752
 5750 00da 5946     		mov	r1, fp
1907:Src/mpu6050.c ****                 result |= 1 << jj;
 5751              		.loc 1 1907 17 view .LVU1753
 5752 00dc 20F00040 		bic	r0, r0, #-2147483648
 5753              	.LVL379:
 5754              	.L531:
1909:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 5755              		.loc 1 1909 49 view .LVU1754
 5756 00e0 FFF7FEFF 		bl	__aeabi_fcmpgt
 5757              	.LVL380:
 5758 00e4 10B1     		cbz	r0, .L488
 5759              	.L490:
1911:Src/mpu6050.c ****     }
 5760              		.loc 1 1911 13 is_stmt 1 view .LVU1755
1911:Src/mpu6050.c ****     }
 5761              		.loc 1 1911 25 is_stmt 0 view .LVU1756
 5762 00e6 09FA05F3 		lsl	r3, r9, r5
1911:Src/mpu6050.c ****     }
 5763              		.loc 1 1911 20 view .LVU1757
 5764 00ea 1E43     		orrs	r6, r6, r3
 5765              	.LVL381:
 5766              	.L488:
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5767              		.loc 1 1903 25 is_stmt 1 view .LVU1758
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5768              		.loc 1 1903 27 is_stmt 0 view .LVU1759
 5769 00ec 0135     		adds	r5, r5, #1
 5770              	.LVL382:
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5771              		.loc 1 1903 17 is_stmt 1 view .LVU1760
1903:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5772              		.loc 1 1903 5 is_stmt 0 view .LVU1761
 5773 00ee 032D     		cmp	r5, #3
 5774 00f0 CDD1     		bne	.L480
1914:Src/mpu6050.c **** }
 5775              		.loc 1 1914 5 is_stmt 1 view .LVU1762
 5776              	.LVL383:
1914:Src/mpu6050.c **** }
 5777              		.loc 1 1914 5 is_stmt 0 view .LVU1763
 5778              	.LBE25:
 5779              	.LBE24:
 5780              	.LBB31:
 5781              	.LBB32:
ARM GAS  /tmp/ccNfEN49.s 			page 181


1923:Src/mpu6050.c ****         return 0x07;
 5782              		.loc 1 1923 9 view .LVU1764
 5783 00f2 6068     		ldr	r0, [r4, #4]
 5784              	.LBE32:
 5785              	.LBE31:
2665:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5786              		.loc 1 2665 18 view .LVU1765
 5787 00f4 F3B2     		uxtb	r3, r6
 5788              	.LBB37:
 5789              	.LBB33:
1923:Src/mpu6050.c ****         return 0x07;
 5790              		.loc 1 1923 9 view .LVU1766
 5791 00f6 2A46     		mov	r2, r5
 5792              	.LBE33:
 5793              	.LBE37:
2665:Src/mpu6050.c ****     gyro_result = gyro_self_test(gyro, gyro_st);
 5794              		.loc 1 2665 18 view .LVU1767
 5795 00f8 0193     		str	r3, [sp, #4]
 5796              	.LVL384:
2666:Src/mpu6050.c **** 
 5797              		.loc 1 2666 5 is_stmt 1 view .LVU1768
 5798              	.LBB38:
 5799              	.LBI31:
1917:Src/mpu6050.c **** {
 5800              		.loc 1 1917 12 view .LVU1769
 5801              	.LBB34:
1919:Src/mpu6050.c ****     unsigned char tmp[3];
 5802              		.loc 1 1919 5 view .LVU1770
1920:Src/mpu6050.c ****     float st_shift, st_shift_cust, st_shift_var;
 5803              		.loc 1 1920 5 view .LVU1771
1921:Src/mpu6050.c **** 
 5804              		.loc 1 1921 5 view .LVU1772
1923:Src/mpu6050.c ****         return 0x07;
 5805              		.loc 1 1923 5 view .LVU1773
1923:Src/mpu6050.c ****         return 0x07;
 5806              		.loc 1 1923 9 is_stmt 0 view .LVU1774
 5807 00fa 0D21     		movs	r1, #13
 5808 00fc 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 5809 00fe 11AB     		add	r3, sp, #68
 5810 0100 FFF7FEFF 		bl	i2c_readBytes
 5811              	.LVL385:
1923:Src/mpu6050.c ****         return 0x07;
 5812              		.loc 1 1923 8 view .LVU1775
 5813 0104 0546     		mov	r5, r0
 5814 0106 0028     		cmp	r0, #0
 5815 0108 40F0ED80 		bne	.L503
1926:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5816              		.loc 1 1926 5 is_stmt 1 view .LVU1776
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5817              		.loc 1 1930 13 is_stmt 0 view .LVU1777
 5818 010c 0646     		mov	r6, r0
1941:Src/mpu6050.c ****     }
 5819              		.loc 1 1941 25 view .LVU1778
 5820 010e 4FF00109 		mov	r9, #1
1926:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5821              		.loc 1 1926 12 view .LVU1779
 5822 0112 9DF84430 		ldrb	r3, [sp, #68]	@ zero_extendqisi2
ARM GAS  /tmp/ccNfEN49.s 			page 182


 5823 0116 0DF12C0A 		add	r10, sp, #44
 5824              	.LVL386:
1926:Src/mpu6050.c ****     tmp[1] &= 0x1F;
 5825              		.loc 1 1926 12 view .LVU1780
 5826 011a 03F01F03 		and	r3, r3, #31
 5827 011e 8DF84430 		strb	r3, [sp, #68]
1927:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5828              		.loc 1 1927 5 is_stmt 1 view .LVU1781
1927:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5829              		.loc 1 1927 12 is_stmt 0 view .LVU1782
 5830 0122 9DF84530 		ldrb	r3, [sp, #69]	@ zero_extendqisi2
 5831 0126 0DF14408 		add	r8, sp, #68
 5832              	.LVL387:
1927:Src/mpu6050.c ****     tmp[2] &= 0x1F;
 5833              		.loc 1 1927 12 view .LVU1783
 5834 012a 03F01F03 		and	r3, r3, #31
 5835 012e 8DF84530 		strb	r3, [sp, #69]
1928:Src/mpu6050.c **** 
 5836              		.loc 1 1928 5 is_stmt 1 view .LVU1784
1928:Src/mpu6050.c **** 
 5837              		.loc 1 1928 12 is_stmt 0 view .LVU1785
 5838 0132 9DF84630 		ldrb	r3, [sp, #70]	@ zero_extendqisi2
 5839 0136 03F01F03 		and	r3, r3, #31
 5840 013a 8DF84630 		strb	r3, [sp, #70]
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5841              		.loc 1 1930 5 is_stmt 1 view .LVU1786
 5842              	.LVL388:
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 5843              		.loc 1 1930 18 view .LVU1787
 5844              	.L500:
1931:Src/mpu6050.c ****         if (tmp[jj]) {
 5845              		.loc 1 1931 9 view .LVU1788
1931:Src/mpu6050.c ****         if (tmp[jj]) {
 5846              		.loc 1 1931 56 is_stmt 0 view .LVU1789
 5847 013e 5AF8043B 		ldr	r3, [r10], #4
1931:Src/mpu6050.c ****         if (tmp[jj]) {
 5848              		.loc 1 1931 47 view .LVU1790
 5849 0142 57F82600 		ldr	r0, [r7, r6, lsl #2]
 5850 0146 C01A     		subs	r0, r0, r3
1931:Src/mpu6050.c ****         if (tmp[jj]) {
 5851              		.loc 1 1931 62 view .LVU1791
 5852 0148 0028     		cmp	r0, #0
 5853 014a B8BF     		it	lt
 5854 014c 4042     		rsblt	r0, r0, #0
 5855 014e FFF7FEFF 		bl	__aeabi_i2f
 5856              	.LVL389:
1931:Src/mpu6050.c ****         if (tmp[jj]) {
 5857              		.loc 1 1931 23 view .LVU1792
 5858 0152 4FF05E51 		mov	r1, #931135488
 5859 0156 FFF7FEFF 		bl	__aeabi_fmul
 5860              	.LVL390:
1932:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 5861              		.loc 1 1932 16 view .LVU1793
 5862 015a 18F8013B 		ldrb	r3, [r8], #1	@ zero_extendqisi2
1931:Src/mpu6050.c ****         if (tmp[jj]) {
 5863              		.loc 1 1931 23 view .LVU1794
 5864 015e 8346     		mov	fp, r0
ARM GAS  /tmp/ccNfEN49.s 			page 183


 5865              	.LVL391:
1932:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 5866              		.loc 1 1932 9 is_stmt 1 view .LVU1795
1932:Src/mpu6050.c ****             st_shift = 3275.f / test.gyro_sens;
 5867              		.loc 1 1932 12 is_stmt 0 view .LVU1796
 5868 0160 002B     		cmp	r3, #0
 5869 0162 00F0B880 		beq	.L529
1933:Src/mpu6050.c ****             while (--tmp[jj])
 5870              		.loc 1 1933 22 view .LVU1797
 5871 0166 6348     		ldr	r0, .L534+8
 5872              	.LVL392:
1933:Src/mpu6050.c ****             while (--tmp[jj])
 5873              		.loc 1 1933 22 view .LVU1798
 5874 0168 8FE0     		b	.L493
 5875              	.LVL393:
 5876              	.L472:
1933:Src/mpu6050.c ****             while (--tmp[jj])
 5877              		.loc 1 1933 22 view .LVU1799
 5878              	.LBE34:
 5879              	.LBE38:
2647:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5880              		.loc 1 2647 30 is_stmt 1 view .LVU1800
2647:Src/mpu6050.c ****         if (!get_st_biases(gyro, accel, 0))
 5881              		.loc 1 2647 18 view .LVU1801
2648:Src/mpu6050.c ****             break;
 5882              		.loc 1 2648 9 view .LVU1802
2648:Src/mpu6050.c ****             break;
 5883              		.loc 1 2648 14 is_stmt 0 view .LVU1803
 5884 016a 0022     		movs	r2, #0
 5885 016c 4146     		mov	r1, r8
 5886 016e 3846     		mov	r0, r7
 5887 0170 FFF7FEFF 		bl	get_st_biases
 5888              	.LVL394:
2648:Src/mpu6050.c ****             break;
 5889              		.loc 1 2648 12 view .LVU1804
 5890 0174 0028     		cmp	r0, #0
 5891 0176 3FF46DAF 		beq	.L475
 5892              	.L479:
2654:Src/mpu6050.c ****         goto restore;
 5893              		.loc 1 2654 16 view .LVU1805
 5894 017a 0025     		movs	r5, #0
 5895              	.LVL395:
 5896              	.L476:
2690:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5897              		.loc 1 2690 5 is_stmt 1 view .LVU1806
2691:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 5898              		.loc 1 2691 5 view .LVU1807
2692:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 5899              		.loc 1 2692 5 view .LVU1808
2693:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 5900              		.loc 1 2693 5 view .LVU1809
2693:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 5901              		.loc 1 2693 29 is_stmt 0 view .LVU1810
 5902 017c 4FF6FF73 		movw	r3, #65535
2696:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 5903              		.loc 1 2696 25 view .LVU1811
 5904 0180 0126     		movs	r6, #1
ARM GAS  /tmp/ccNfEN49.s 			page 184


2693:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 5905              		.loc 1 2693 29 view .LVU1812
 5906 0182 E381     		strh	r3, [r4, #14]	@ movhi
2694:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
 5907              		.loc 1 2694 5 is_stmt 1 view .LVU1813
2695:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 5908              		.loc 1 2695 5 view .LVU1814
2695:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 5909              		.loc 1 2695 29 is_stmt 0 view .LVU1815
 5910 0184 2374     		strb	r3, [r4, #16]
2696:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 5911              		.loc 1 2696 5 is_stmt 1 view .LVU1816
2690:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5912              		.loc 1 2690 26 is_stmt 0 view .LVU1817
 5913 0186 4FF0FF33 		mov	r3, #-1
2697:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
 5914              		.loc 1 2697 5 view .LVU1818
 5915 018a BDF81E00 		ldrh	r0, [sp, #30]
2690:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 5916              		.loc 1 2690 26 view .LVU1819
 5917 018e A360     		str	r3, [r4, #8]
2696:Src/mpu6050.c ****     mpu_set_gyro_fsr(gyro_fsr);
 5918              		.loc 1 2696 25 view .LVU1820
 5919 0190 2673     		strb	r6, [r4, #12]
2697:Src/mpu6050.c ****     mpu_set_accel_fsr(accel_fsr);
 5920              		.loc 1 2697 5 is_stmt 1 view .LVU1821
 5921 0192 FFF7FEFF 		bl	mpu_set_gyro_fsr
 5922              	.LVL396:
2698:Src/mpu6050.c ****     mpu_set_lpf(lpf);
 5923              		.loc 1 2698 5 view .LVU1822
 5924 0196 9DF81D00 		ldrb	r0, [sp, #29]	@ zero_extendqisi2
 5925 019a FFF7FEFF 		bl	mpu_set_accel_fsr
 5926              	.LVL397:
2699:Src/mpu6050.c ****     mpu_set_sample_rate(sample_rate);
 5927              		.loc 1 2699 5 view .LVU1823
 5928 019e BDF82200 		ldrh	r0, [sp, #34]
 5929 01a2 FFF7FEFF 		bl	mpu_set_lpf
 5930              	.LVL398:
2700:Src/mpu6050.c ****     mpu_set_sensors(sensors_on);
 5931              		.loc 1 2700 5 view .LVU1824
 5932 01a6 BDF82000 		ldrh	r0, [sp, #32]
 5933 01aa FFF7FEFF 		bl	mpu_set_sample_rate
 5934              	.LVL399:
2701:Src/mpu6050.c ****     mpu_configure_fifo(fifo_sensors);
 5935              		.loc 1 2701 5 view .LVU1825
 5936 01ae 0398     		ldr	r0, [sp, #12]
 5937 01b0 FFF7FEFF 		bl	mpu_set_sensors
 5938              	.LVL400:
2702:Src/mpu6050.c **** 
 5939              		.loc 1 2702 5 view .LVU1826
 5940 01b4 0498     		ldr	r0, [sp, #16]
 5941 01b6 FFF7FEFF 		bl	mpu_configure_fifo
 5942              	.LVL401:
2704:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 5943              		.loc 1 2704 5 view .LVU1827
2704:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 5944              		.loc 1 2704 8 is_stmt 0 view .LVU1828
ARM GAS  /tmp/ccNfEN49.s 			page 185


 5945 01ba 009B     		ldr	r3, [sp]
 5946 01bc 13B1     		cbz	r3, .L470
2705:Src/mpu6050.c **** 
 5947              		.loc 1 2705 9 is_stmt 1 view .LVU1829
 5948 01be 3046     		mov	r0, r6
 5949 01c0 FFF7FEFF 		bl	mpu_set_dmp_state
 5950              	.LVL402:
2707:Src/mpu6050.c **** }
 5951              		.loc 1 2707 5 view .LVU1830
 5952              	.L470:
2708:Src/mpu6050.c **** 
 5953              		.loc 1 2708 1 is_stmt 0 view .LVU1831
 5954 01c4 2846     		mov	r0, r5
 5955 01c6 15B0     		add	sp, sp, #84
 5956              	.LCFI95:
 5957              		.cfi_remember_state
 5958              		.cfi_def_cfa_offset 36
 5959              	.LVL403:
2708:Src/mpu6050.c **** 
 5960              		.loc 1 2708 1 view .LVU1832
 5961              		@ sp needed
 5962 01c8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5963              	.LVL404:
 5964              	.L526:
 5965              	.LCFI96:
 5966              		.cfi_restore_state
2657:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5967              		.loc 1 2657 30 is_stmt 1 view .LVU1833
2657:Src/mpu6050.c ****         if (!get_st_biases(gyro_st, accel_st, 1))
 5968              		.loc 1 2657 18 view .LVU1834
2658:Src/mpu6050.c ****             break;
 5969              		.loc 1 2658 9 view .LVU1835
2658:Src/mpu6050.c ****             break;
 5970              		.loc 1 2658 14 is_stmt 0 view .LVU1836
 5971 01cc 0122     		movs	r2, #1
 5972 01ce 0EA9     		add	r1, sp, #56
 5973 01d0 0BA8     		add	r0, sp, #44
 5974 01d2 FFF7FEFF 		bl	get_st_biases
 5975              	.LVL405:
2658:Src/mpu6050.c ****             break;
 5976              		.loc 1 2658 12 view .LVU1837
 5977 01d6 0028     		cmp	r0, #0
 5978 01d8 CFD1     		bne	.L479
 5979 01da 43E7     		b	.L473
 5980              	.LVL406:
 5981              	.L527:
 5982              	.LBB39:
 5983              	.LBB30:
 5984              	.LBB29:
 5985              	.LBB28:
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5986              		.loc 1 1879 5 is_stmt 1 view .LVU1838
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5987              		.loc 1 1879 38 is_stmt 0 view .LVU1839
 5988 01dc 9DF82830 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5989              		.loc 1 1879 51 view .LVU1840
ARM GAS  /tmp/ccNfEN49.s 			page 186


 5990 01e0 9DF82B10 		ldrb	r1, [sp, #43]	@ zero_extendqisi2
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5991              		.loc 1 1879 38 view .LVU1841
 5992 01e4 DB10     		asrs	r3, r3, #3
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5993              		.loc 1 1879 63 view .LVU1842
 5994 01e6 C1F30112 		ubfx	r2, r1, #4, #2
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5995              		.loc 1 1879 38 view .LVU1843
 5996 01ea 03F01C03 		and	r3, r3, #28
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 5997              		.loc 1 1879 44 view .LVU1844
 5998 01ee 1343     		orrs	r3, r3, r2
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 5999              		.loc 1 1880 38 view .LVU1845
 6000 01f0 9DF82920 		ldrb	r2, [sp, #41]	@ zero_extendqisi2
1879:Src/mpu6050.c ****     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
 6001              		.loc 1 1879 19 view .LVU1846
 6002 01f4 8DF82430 		strb	r3, [sp, #36]
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6003              		.loc 1 1880 5 is_stmt 1 view .LVU1847
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6004              		.loc 1 1880 38 is_stmt 0 view .LVU1848
 6005 01f8 D210     		asrs	r2, r2, #3
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6006              		.loc 1 1880 63 view .LVU1849
 6007 01fa C1F38103 		ubfx	r3, r1, #2, #2
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6008              		.loc 1 1880 38 view .LVU1850
 6009 01fe 02F01C02 		and	r2, r2, #28
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6010              		.loc 1 1880 44 view .LVU1851
 6011 0202 1A43     		orrs	r2, r2, r3
1881:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6012              		.loc 1 1881 38 view .LVU1852
 6013 0204 9DF82A30 		ldrb	r3, [sp, #42]	@ zero_extendqisi2
1881:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6014              		.loc 1 1881 54 view .LVU1853
 6015 0208 01F00301 		and	r1, r1, #3
1881:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6016              		.loc 1 1881 38 view .LVU1854
 6017 020c DB10     		asrs	r3, r3, #3
 6018 020e 03F01C03 		and	r3, r3, #28
1881:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6019              		.loc 1 1881 44 view .LVU1855
 6020 0212 0B43     		orrs	r3, r3, r1
1881:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6021              		.loc 1 1881 19 view .LVU1856
 6022 0214 8DF82630 		strb	r3, [sp, #38]
1884:Src/mpu6050.c ****             continue;
 6023              		.loc 1 1884 26 view .LVU1857
 6024 0218 0023     		movs	r3, #0
1890:Src/mpu6050.c ****         while (--shift_code[ii])
 6025              		.loc 1 1890 22 view .LVU1858
 6026 021a DFF8DCB0 		ldr	fp, .L534+12
1892:Src/mpu6050.c ****     }
 6027              		.loc 1 1892 26 view .LVU1859
ARM GAS  /tmp/ccNfEN49.s 			page 187


 6028 021e 3749     		ldr	r1, .L534+16
1880:Src/mpu6050.c ****     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
 6029              		.loc 1 1880 19 view .LVU1860
 6030 0220 8DF82520 		strb	r2, [sp, #37]
1881:Src/mpu6050.c ****     for (ii = 0; ii < 3; ii++) {
 6031              		.loc 1 1881 5 is_stmt 1 view .LVU1861
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6032              		.loc 1 1882 5 view .LVU1862
 6033              	.LVL407:
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6034              		.loc 1 1882 18 view .LVU1863
 6035 0224 0DF1240A 		add	r10, sp, #36
 6036 0228 0DF14409 		add	r9, sp, #68
 6037              	.LVL408:
 6038              	.L485:
1883:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6039              		.loc 1 1883 9 view .LVU1864
1883:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6040              		.loc 1 1883 24 is_stmt 0 view .LVU1865
 6041 022c 1AF8016B 		ldrb	r6, [r10], #1	@ zero_extendqisi2
1883:Src/mpu6050.c ****             st_shift[ii] = 0.f;
 6042              		.loc 1 1883 12 view .LVU1866
 6043 0230 46B9     		cbnz	r6, .L481
1884:Src/mpu6050.c ****             continue;
 6044              		.loc 1 1884 13 is_stmt 1 view .LVU1867
1884:Src/mpu6050.c ****             continue;
 6045              		.loc 1 1884 26 is_stmt 0 view .LVU1868
 6046 0232 C9F80030 		str	r3, [r9]	@ float
1885:Src/mpu6050.c ****         }
 6047              		.loc 1 1885 13 is_stmt 1 view .LVU1869
 6048              	.L482:
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6049              		.loc 1 1882 26 view .LVU1870
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6050              		.loc 1 1882 28 is_stmt 0 view .LVU1871
 6051 0236 0135     		adds	r5, r5, #1
 6052              	.LVL409:
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6053              		.loc 1 1882 28 view .LVU1872
 6054 0238 EDB2     		uxtb	r5, r5
 6055              	.LVL410:
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6056              		.loc 1 1882 18 is_stmt 1 view .LVU1873
1882:Src/mpu6050.c ****         if (!shift_code[ii]) {
 6057              		.loc 1 1882 5 is_stmt 0 view .LVU1874
 6058 023a 032D     		cmp	r5, #3
 6059 023c 09F10409 		add	r9, r9, #4
 6060 0240 F4D1     		bne	.L485
 6061 0242 1AE7     		b	.L477
 6062              	.L481:
1890:Src/mpu6050.c ****         while (--shift_code[ii])
 6063              		.loc 1 1890 9 is_stmt 1 view .LVU1875
1890:Src/mpu6050.c ****         while (--shift_code[ii])
 6064              		.loc 1 1890 22 is_stmt 0 view .LVU1876
 6065 0244 C9F800B0 		str	fp, [r9]	@ float
1891:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6066              		.loc 1 1891 9 is_stmt 1 view .LVU1877
ARM GAS  /tmp/ccNfEN49.s 			page 188


 6067              	.L483:
1891:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6068              		.loc 1 1891 15 view .LVU1878
1891:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6069              		.loc 1 1891 16 is_stmt 0 view .LVU1879
 6070 0248 013E     		subs	r6, r6, #1
1891:Src/mpu6050.c ****             st_shift[ii] *= 1.034f;
 6071              		.loc 1 1891 15 view .LVU1880
 6072 024a 16F0FF06 		ands	r6, r6, #255
 6073 024e 02D1     		bne	.L484
 6074 0250 0AF8016C 		strb	r6, [r10, #-1]
 6075 0254 EFE7     		b	.L482
 6076              	.L484:
1892:Src/mpu6050.c ****     }
 6077              		.loc 1 1892 26 view .LVU1881
 6078 0256 D9F80000 		ldr	r0, [r9]	@ float
 6079 025a CDE90113 		strd	r1, r3, [sp, #4]
 6080 025e FFF7FEFF 		bl	__aeabi_fmul
 6081              	.LVL411:
 6082 0262 DDE90113 		ldrd	r1, r3, [sp, #4]
 6083 0266 C9F80000 		str	r0, [r9]	@ float
 6084 026a EDE7     		b	.L483
 6085              	.LVL412:
 6086              	.L528:
1892:Src/mpu6050.c ****     }
 6087              		.loc 1 1892 26 view .LVU1882
 6088              	.LBE28:
 6089              	.LBE29:
1909:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6090              		.loc 1 1909 16 is_stmt 1 view .LVU1883
1909:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6091              		.loc 1 1909 19 is_stmt 0 view .LVU1884
 6092 026c 5046     		mov	r0, r10
 6093 026e 2449     		ldr	r1, .L534+20
 6094 0270 FFF7FEFF 		bl	__aeabi_fcmplt
 6095              	.LVL413:
 6096 0274 0028     		cmp	r0, #0
 6097 0276 7FF436AF 		bne	.L490
1909:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6098              		.loc 1 1909 49 view .LVU1885
 6099 027a 5046     		mov	r0, r10
 6100 027c 2149     		ldr	r1, .L534+24
 6101 027e 2FE7     		b	.L531
 6102              	.LVL414:
 6103              	.L495:
1909:Src/mpu6050.c ****             (st_shift_cust > test.max_g))
 6104              		.loc 1 1909 49 view .LVU1886
 6105              	.LBE30:
 6106              	.LBE39:
 6107              	.LBB40:
 6108              	.LBB35:
1935:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6109              		.loc 1 1935 26 view .LVU1887
 6110 0280 2149     		ldr	r1, .L534+28
 6111 0282 0293     		str	r3, [sp, #8]
1935:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6112              		.loc 1 1935 17 is_stmt 1 view .LVU1888
ARM GAS  /tmp/ccNfEN49.s 			page 189


1935:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6113              		.loc 1 1935 26 is_stmt 0 view .LVU1889
 6114 0284 FFF7FEFF 		bl	__aeabi_fmul
 6115              	.LVL415:
1935:Src/mpu6050.c ****             st_shift_var = st_shift_cust / st_shift - 1.f;
 6116              		.loc 1 1935 26 view .LVU1890
 6117 0288 029B     		ldr	r3, [sp, #8]
 6118              	.LVL416:
 6119              	.L493:
1934:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6120              		.loc 1 1934 19 is_stmt 1 view .LVU1891
1934:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6121              		.loc 1 1934 20 is_stmt 0 view .LVU1892
 6122 028a 013B     		subs	r3, r3, #1
1934:Src/mpu6050.c ****                 st_shift *= 1.046f;
 6123              		.loc 1 1934 19 view .LVU1893
 6124 028c 13F0FF03 		ands	r3, r3, #255
 6125 0290 F6D1     		bne	.L495
1936:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6126              		.loc 1 1936 42 view .LVU1894
 6127 0292 0146     		mov	r1, r0
 6128 0294 08F8013C 		strb	r3, [r8, #-1]
1936:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6129              		.loc 1 1936 13 is_stmt 1 view .LVU1895
 6130              	.LVL417:
1937:Src/mpu6050.c ****                 result |= 1 << jj;
 6131              		.loc 1 1937 13 view .LVU1896
1936:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6132              		.loc 1 1936 42 is_stmt 0 view .LVU1897
 6133 0298 5846     		mov	r0, fp
 6134              	.LVL418:
1936:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6135              		.loc 1 1936 42 view .LVU1898
 6136 029a FFF7FEFF 		bl	__aeabi_fdiv
 6137              	.LVL419:
1936:Src/mpu6050.c ****             if (fabs(st_shift_var) > test.max_gyro_var)
 6138              		.loc 1 1936 26 view .LVU1899
 6139 029e 4FF07E51 		mov	r1, #1065353216
 6140 02a2 FFF7FEFF 		bl	__aeabi_fsub
 6141              	.LVL420:
1937:Src/mpu6050.c ****                 result |= 1 << jj;
 6142              		.loc 1 1937 16 view .LVU1900
 6143 02a6 1249     		ldr	r1, .L534+4
1937:Src/mpu6050.c ****                 result |= 1 << jj;
 6144              		.loc 1 1937 17 view .LVU1901
 6145 02a8 20F00040 		bic	r0, r0, #-2147483648
 6146              	.L533:
1939:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6147              		.loc 1 1939 51 view .LVU1902
 6148 02ac FFF7FEFF 		bl	__aeabi_fcmpgt
 6149              	.LVL421:
 6150 02b0 10B1     		cbz	r0, .L496
 6151              	.L498:
1941:Src/mpu6050.c ****     }
 6152              		.loc 1 1941 13 is_stmt 1 view .LVU1903
1941:Src/mpu6050.c ****     }
 6153              		.loc 1 1941 25 is_stmt 0 view .LVU1904
ARM GAS  /tmp/ccNfEN49.s 			page 190


 6154 02b2 09FA06F3 		lsl	r3, r9, r6
1941:Src/mpu6050.c ****     }
 6155              		.loc 1 1941 20 view .LVU1905
 6156 02b6 1D43     		orrs	r5, r5, r3
 6157              	.LVL422:
 6158              	.L496:
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6159              		.loc 1 1930 26 is_stmt 1 view .LVU1906
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6160              		.loc 1 1930 28 is_stmt 0 view .LVU1907
 6161 02b8 0136     		adds	r6, r6, #1
 6162              	.LVL423:
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6163              		.loc 1 1930 18 is_stmt 1 view .LVU1908
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6164              		.loc 1 1930 5 is_stmt 0 view .LVU1909
 6165 02ba 032E     		cmp	r6, #3
 6166 02bc 7FF43FAF 		bne	.L500
 6167              	.LVL424:
 6168              	.L492:
1930:Src/mpu6050.c ****         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
 6169              		.loc 1 1930 5 view .LVU1910
 6170              	.LBE35:
 6171              	.LBE40:
2668:Src/mpu6050.c ****     if (!gyro_result)
 6172              		.loc 1 2668 5 is_stmt 1 view .LVU1911
2669:Src/mpu6050.c ****         result |= 0x01;
 6173              		.loc 1 2669 5 view .LVU1912
2669:Src/mpu6050.c ****         result |= 0x01;
 6174              		.loc 1 2669 8 is_stmt 0 view .LVU1913
 6175 02c0 EDB2     		uxtb	r5, r5
2669:Src/mpu6050.c ****         result |= 0x01;
 6176              		.loc 1 2669 8 view .LVU1914
 6177 02c2 B5FA85F5 		clz	r5, r5
 6178              	.LVL425:
2671:Src/mpu6050.c ****         result |= 0x02;
 6179              		.loc 1 2671 8 view .LVU1915
 6180 02c6 019B     		ldr	r3, [sp, #4]
2669:Src/mpu6050.c ****         result |= 0x01;
 6181              		.loc 1 2669 8 view .LVU1916
 6182 02c8 6D09     		lsrs	r5, r5, #5
 6183              	.LVL426:
2671:Src/mpu6050.c ****         result |= 0x02;
 6184              		.loc 1 2671 5 is_stmt 1 view .LVU1917
2671:Src/mpu6050.c ****         result |= 0x02;
 6185              		.loc 1 2671 8 is_stmt 0 view .LVU1918
 6186 02ca 0BB9     		cbnz	r3, .L501
2672:Src/mpu6050.c **** 
 6187              		.loc 1 2672 9 is_stmt 1 view .LVU1919
2672:Src/mpu6050.c **** 
 6188              		.loc 1 2672 16 is_stmt 0 view .LVU1920
 6189 02cc 45F00205 		orr	r5, r5, #2
 6190              	.LVL427:
 6191              	.L501:
2679:Src/mpu6050.c **** #endif
 6192              		.loc 1 2679 9 is_stmt 1 view .LVU1921
2679:Src/mpu6050.c **** #endif
ARM GAS  /tmp/ccNfEN49.s 			page 191


 6193              		.loc 1 2679 16 is_stmt 0 view .LVU1922
 6194 02d0 45F00405 		orr	r5, r5, #4
 6195              	.LVL428:
2679:Src/mpu6050.c **** #endif
 6196              		.loc 1 2679 16 view .LVU1923
 6197 02d4 52E7     		b	.L476
 6198              	.LVL429:
 6199              	.L529:
 6200              	.LBB41:
 6201              	.LBB36:
1939:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6202              		.loc 1 1939 16 is_stmt 1 view .LVU1924
1939:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6203              		.loc 1 1939 19 is_stmt 0 view .LVU1925
 6204 02d6 0D49     		ldr	r1, .L534+32
 6205 02d8 FFF7FEFF 		bl	__aeabi_fcmplt
 6206              	.LVL430:
1939:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6207              		.loc 1 1939 19 view .LVU1926
 6208 02dc 0028     		cmp	r0, #0
 6209 02de E8D1     		bne	.L498
1939:Src/mpu6050.c ****             (st_shift_cust > test.max_dps))
 6210              		.loc 1 1939 51 view .LVU1927
 6211 02e0 5846     		mov	r0, fp
 6212 02e2 0B49     		ldr	r1, .L534+36
 6213 02e4 E2E7     		b	.L533
 6214              	.LVL431:
 6215              	.L503:
1924:Src/mpu6050.c **** 
 6216              		.loc 1 1924 16 view .LVU1928
 6217 02e6 0725     		movs	r5, #7
 6218 02e8 EAE7     		b	.L492
 6219              	.L535:
 6220 02ea 00BF     		.align	2
 6221              	.L534:
 6222 02ec 00000000 		.word	.LANCHOR0
 6223 02f0 295C0F3E 		.word	1041194025
 6224 02f4 0000C841 		.word	1103626240
 6225 02f8 7B14AE3E 		.word	1051595899
 6226 02fc 1D5A843F 		.word	1065638429
 6227 0300 9A99993E 		.word	1050253722
 6228 0304 3333733F 		.word	1064514355
 6229 0308 54E3853F 		.word	1065739092
 6230 030c 00002041 		.word	1092616192
 6231 0310 0000D242 		.word	1121058816
 6232              	.LBE36:
 6233              	.LBE41:
 6234              		.cfi_endproc
 6235              	.LFE100:
 6237              		.section	.text.mpu_get_dmp_state,"ax",%progbits
 6238              		.align	1
 6239              		.global	mpu_get_dmp_state
 6240              		.syntax unified
 6241              		.thumb
 6242              		.thumb_func
 6243              		.fpu softvfp
 6245              	mpu_get_dmp_state:
ARM GAS  /tmp/ccNfEN49.s 			page 192


 6246              	.LVL432:
 6247              	.LFB105:
2858:Src/mpu6050.c **** 
2859:Src/mpu6050.c **** /**
2860:Src/mpu6050.c ****  *  @brief      Get DMP state.
2861:Src/mpu6050.c ****  *  @param[out] enabled 1 if enabled.
2862:Src/mpu6050.c ****  *  @return     0 if successful.
2863:Src/mpu6050.c ****  */
2864:Src/mpu6050.c **** int mpu_get_dmp_state(unsigned char *enabled)
2865:Src/mpu6050.c **** {
 6248              		.loc 1 2865 1 is_stmt 1 view -0
 6249              		.cfi_startproc
 6250              		@ args = 0, pretend = 0, frame = 0
 6251              		@ frame_needed = 0, uses_anonymous_args = 0
 6252              		@ link register save eliminated.
2866:Src/mpu6050.c ****     enabled[0] = st.chip_cfg.dmp_on;
 6253              		.loc 1 2866 5 view .LVU1930
 6254              		.loc 1 2866 29 is_stmt 0 view .LVU1931
 6255 0000 024B     		ldr	r3, .L537
 6256 0002 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 6257              		.loc 1 2866 16 view .LVU1932
 6258 0006 0370     		strb	r3, [r0]
2867:Src/mpu6050.c ****     return 0;
 6259              		.loc 1 2867 5 is_stmt 1 view .LVU1933
2868:Src/mpu6050.c **** }
 6260              		.loc 1 2868 1 is_stmt 0 view .LVU1934
 6261 0008 0020     		movs	r0, #0
 6262              	.LVL433:
 6263              		.loc 1 2868 1 view .LVU1935
 6264 000a 7047     		bx	lr
 6265              	.L538:
 6266              		.align	2
 6267              	.L537:
 6268 000c 00000000 		.word	.LANCHOR0
 6269              		.cfi_endproc
 6270              	.LFE105:
 6272              		.section	.text.mpu_get_compass_reg,"ax",%progbits
 6273              		.align	1
 6274              		.global	mpu_get_compass_reg
 6275              		.syntax unified
 6276              		.thumb
 6277              		.thumb_func
 6278              		.fpu softvfp
 6280              	mpu_get_compass_reg:
 6281              	.LVL434:
 6282              	.LFB106:
2869:Src/mpu6050.c **** 
2870:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2871:Src/mpu6050.c **** /* This initialization is similar to the one in ak8975.c. */
2872:Src/mpu6050.c **** static int setup_compass(void)
2873:Src/mpu6050.c **** {
2874:Src/mpu6050.c ****     unsigned char data[4], akm_addr;
2875:Src/mpu6050.c **** 
2876:Src/mpu6050.c ****     mpu_set_bypass(1);
2877:Src/mpu6050.c **** 
2878:Src/mpu6050.c ****     /* Find compass. Possible addresses range from 0x0C to 0x0F. */
2879:Src/mpu6050.c ****     for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
ARM GAS  /tmp/ccNfEN49.s 			page 193


2880:Src/mpu6050.c ****         int result;
2881:Src/mpu6050.c ****         result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
2882:Src/mpu6050.c ****         if (!result && (data[0] == AKM_WHOAMI))
2883:Src/mpu6050.c ****             break;
2884:Src/mpu6050.c ****     }
2885:Src/mpu6050.c **** 
2886:Src/mpu6050.c ****     if (akm_addr > 0x0F) {
2887:Src/mpu6050.c ****         /* TODO: Handle this case in all compass-related functions. */
2888:Src/mpu6050.c ****         #ifdef SERIAL_DEBUG
2889:Src/mpu6050.c ****             log_i("Compass not found\r\n");
2890:Src/mpu6050.c ****         #endif
2891:Src/mpu6050.c ****         return -1;
2892:Src/mpu6050.c ****     }
2893:Src/mpu6050.c **** 
2894:Src/mpu6050.c ****     st.chip_cfg.compass_addr = akm_addr;
2895:Src/mpu6050.c **** 
2896:Src/mpu6050.c ****     data[0] = AKM_POWER_DOWN;
2897:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2898:Src/mpu6050.c ****         return -1;
2899:Src/mpu6050.c ****     delay_ms(1);
2900:Src/mpu6050.c **** 
2901:Src/mpu6050.c ****     data[0] = AKM_FUSE_ROM_ACCESS;
2902:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2903:Src/mpu6050.c ****         return -1;
2904:Src/mpu6050.c ****     delay_ms(1);
2905:Src/mpu6050.c **** 
2906:Src/mpu6050.c ****     /* Get sensitivity adjustment data from fuse ROM. */
2907:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
2908:Src/mpu6050.c ****         return -1;
2909:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
2910:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
2911:Src/mpu6050.c ****     st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
2912:Src/mpu6050.c **** 
2913:Src/mpu6050.c ****     data[0] = AKM_POWER_DOWN;
2914:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
2915:Src/mpu6050.c ****         return -1;
2916:Src/mpu6050.c ****     delay_ms(1);
2917:Src/mpu6050.c **** 
2918:Src/mpu6050.c ****     mpu_set_bypass(0);
2919:Src/mpu6050.c **** 
2920:Src/mpu6050.c ****     /* Set up master mode, master clock, and ES bit. */
2921:Src/mpu6050.c ****     data[0] = 0x40;
2922:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
2923:Src/mpu6050.c ****         return -1;
2924:Src/mpu6050.c **** 
2925:Src/mpu6050.c ****     /* Slave 0 reads from AKM data registers. */
2926:Src/mpu6050.c ****     data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
2927:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
2928:Src/mpu6050.c ****         return -1;
2929:Src/mpu6050.c **** 
2930:Src/mpu6050.c ****     /* Compass reads start at this register. */
2931:Src/mpu6050.c ****     data[0] = AKM_REG_ST1;
2932:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
2933:Src/mpu6050.c ****         return -1;
2934:Src/mpu6050.c **** 
2935:Src/mpu6050.c ****     /* Enable slave 0, 8-byte reads. */
2936:Src/mpu6050.c ****     data[0] = BIT_SLAVE_EN | 8;
ARM GAS  /tmp/ccNfEN49.s 			page 194


2937:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
2938:Src/mpu6050.c ****         return -1;
2939:Src/mpu6050.c **** 
2940:Src/mpu6050.c ****     /* Slave 1 changes AKM measurement mode. */
2941:Src/mpu6050.c ****     data[0] = st.chip_cfg.compass_addr;
2942:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
2943:Src/mpu6050.c ****         return -1;
2944:Src/mpu6050.c **** 
2945:Src/mpu6050.c ****     /* AKM measurement mode register. */
2946:Src/mpu6050.c ****     data[0] = AKM_REG_CNTL;
2947:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
2948:Src/mpu6050.c ****         return -1;
2949:Src/mpu6050.c **** 
2950:Src/mpu6050.c ****     /* Enable slave 1, 1-byte writes. */
2951:Src/mpu6050.c ****     data[0] = BIT_SLAVE_EN | 1;
2952:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
2953:Src/mpu6050.c ****         return -1;
2954:Src/mpu6050.c **** 
2955:Src/mpu6050.c ****     /* Set slave 1 data. */
2956:Src/mpu6050.c ****     data[0] = AKM_SINGLE_MEASUREMENT;
2957:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
2958:Src/mpu6050.c ****         return -1;
2959:Src/mpu6050.c **** 
2960:Src/mpu6050.c ****     /* Trigger slave 0 and slave 1 actions at each sample. */
2961:Src/mpu6050.c ****     data[0] = 0x03;
2962:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
2963:Src/mpu6050.c ****         return -1;
2964:Src/mpu6050.c **** 
2965:Src/mpu6050.c **** #ifdef MPU9150
2966:Src/mpu6050.c ****     /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
2967:Src/mpu6050.c ****     data[0] = BIT_I2C_MST_VDDIO;
2968:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
2969:Src/mpu6050.c ****         return -1;
2970:Src/mpu6050.c **** #endif
2971:Src/mpu6050.c **** 
2972:Src/mpu6050.c ****     return 0;
2973:Src/mpu6050.c **** }
2974:Src/mpu6050.c **** #endif
2975:Src/mpu6050.c **** 
2976:Src/mpu6050.c **** /**
2977:Src/mpu6050.c ****  *  @brief      Read raw compass data.
2978:Src/mpu6050.c ****  *  @param[out] data        Raw data in hardware units.
2979:Src/mpu6050.c ****  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
2980:Src/mpu6050.c ****  *  @return     0 if successful.
2981:Src/mpu6050.c ****  */
2982:Src/mpu6050.c **** int mpu_get_compass_reg(short *data, unsigned long *timestamp)
2983:Src/mpu6050.c **** {
 6283              		.loc 1 2983 1 is_stmt 1 view -0
 6284              		.cfi_startproc
 6285              		@ args = 0, pretend = 0, frame = 0
 6286              		@ frame_needed = 0, uses_anonymous_args = 0
 6287              		@ link register save eliminated.
2984:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
2985:Src/mpu6050.c ****     unsigned char tmp[9];
2986:Src/mpu6050.c **** 
2987:Src/mpu6050.c ****     if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
2988:Src/mpu6050.c ****         return -1;
ARM GAS  /tmp/ccNfEN49.s 			page 195


2989:Src/mpu6050.c **** 
2990:Src/mpu6050.c **** #ifdef AK89xx_BYPASS
2991:Src/mpu6050.c ****     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
2992:Src/mpu6050.c ****         return -1;
2993:Src/mpu6050.c ****     tmp[8] = AKM_SINGLE_MEASUREMENT;
2994:Src/mpu6050.c ****     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
2995:Src/mpu6050.c ****         return -1;
2996:Src/mpu6050.c **** #else
2997:Src/mpu6050.c ****     if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
2998:Src/mpu6050.c ****         return -1;
2999:Src/mpu6050.c **** #endif
3000:Src/mpu6050.c **** 
3001:Src/mpu6050.c **** #if defined AK8975_SECONDARY
3002:Src/mpu6050.c ****     /* AK8975 doesn't have the overrun error bit. */
3003:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY))
3004:Src/mpu6050.c ****         return -2;
3005:Src/mpu6050.c ****     if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
3006:Src/mpu6050.c ****         return -3;
3007:Src/mpu6050.c **** #elif defined AK8963_SECONDARY
3008:Src/mpu6050.c ****     /* AK8963 doesn't have the data read error bit. */
3009:Src/mpu6050.c ****     if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
3010:Src/mpu6050.c ****         return -2;
3011:Src/mpu6050.c ****     if (tmp[7] & AKM_OVERFLOW)
3012:Src/mpu6050.c ****         return -3;
3013:Src/mpu6050.c **** #endif
3014:Src/mpu6050.c ****     data[0] = (tmp[2] << 8) | tmp[1];
3015:Src/mpu6050.c ****     data[1] = (tmp[4] << 8) | tmp[3];
3016:Src/mpu6050.c ****     data[2] = (tmp[6] << 8) | tmp[5];
3017:Src/mpu6050.c **** 
3018:Src/mpu6050.c ****     data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
3019:Src/mpu6050.c ****     data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
3020:Src/mpu6050.c ****     data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
3021:Src/mpu6050.c **** 
3022:Src/mpu6050.c ****     if (timestamp)
3023:Src/mpu6050.c ****         get_ms(timestamp);
3024:Src/mpu6050.c ****     return 0;
3025:Src/mpu6050.c **** #else
3026:Src/mpu6050.c ****     return -1;
 6288              		.loc 1 3026 5 view .LVU1937
3027:Src/mpu6050.c **** #endif
3028:Src/mpu6050.c **** }
 6289              		.loc 1 3028 1 is_stmt 0 view .LVU1938
 6290 0000 4FF0FF30 		mov	r0, #-1
 6291              	.LVL435:
 6292              		.loc 1 3028 1 view .LVU1939
 6293 0004 7047     		bx	lr
 6294              		.cfi_endproc
 6295              	.LFE106:
 6297              		.section	.text.mpu_get_compass_fsr,"ax",%progbits
 6298              		.align	1
 6299              		.global	mpu_get_compass_fsr
 6300              		.syntax unified
 6301              		.thumb
 6302              		.thumb_func
 6303              		.fpu softvfp
 6305              	mpu_get_compass_fsr:
 6306              	.LVL436:
ARM GAS  /tmp/ccNfEN49.s 			page 196


 6307              	.LFB107:
3029:Src/mpu6050.c **** 
3030:Src/mpu6050.c **** /**
3031:Src/mpu6050.c ****  *  @brief      Get the compass full-scale range.
3032:Src/mpu6050.c ****  *  @param[out] fsr Current full-scale range.
3033:Src/mpu6050.c ****  *  @return     0 if successful.
3034:Src/mpu6050.c ****  */
3035:Src/mpu6050.c **** int mpu_get_compass_fsr(unsigned short *fsr)
3036:Src/mpu6050.c **** {
 6308              		.loc 1 3036 1 is_stmt 1 view -0
 6309              		.cfi_startproc
 6310              		@ args = 0, pretend = 0, frame = 0
 6311              		@ frame_needed = 0, uses_anonymous_args = 0
 6312              		@ link register save eliminated.
3037:Src/mpu6050.c **** #ifdef AK89xx_SECONDARY
3038:Src/mpu6050.c ****     fsr[0] = st.hw->compass_fsr;
3039:Src/mpu6050.c ****     return 0;
3040:Src/mpu6050.c **** #else
3041:Src/mpu6050.c ****     return -1;
 6313              		.loc 1 3041 5 view .LVU1941
3042:Src/mpu6050.c **** #endif
3043:Src/mpu6050.c **** }
 6314              		.loc 1 3043 1 is_stmt 0 view .LVU1942
 6315 0000 4FF0FF30 		mov	r0, #-1
 6316              	.LVL437:
 6317              		.loc 1 3043 1 view .LVU1943
 6318 0004 7047     		bx	lr
 6319              		.cfi_endproc
 6320              	.LFE107:
 6322              		.section	.text.mpu_lp_motion_interrupt,"ax",%progbits
 6323              		.align	1
 6324              		.global	mpu_lp_motion_interrupt
 6325              		.syntax unified
 6326              		.thumb
 6327              		.thumb_func
 6328              		.fpu softvfp
 6330              	mpu_lp_motion_interrupt:
 6331              	.LVL438:
 6332              	.LFB108:
3044:Src/mpu6050.c **** 
3045:Src/mpu6050.c **** /**
3046:Src/mpu6050.c ****  *  @brief      Enters LP accel motion interrupt mode.
3047:Src/mpu6050.c ****  *  The behaviour of this feature is very different between the MPU6050 and the
3048:Src/mpu6050.c ****  *  MPU6500. Each chip's version of this feature is explained below.
3049:Src/mpu6050.c ****  *
3050:Src/mpu6050.c ****  *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
3051:Src/mpu6050.c ****  *  increments.
3052:Src/mpu6050.c ****  *
3053:Src/mpu6050.c ****  *  \n Low-power accel mode supports the following frequencies:
3054:Src/mpu6050.c ****  *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
3055:Src/mpu6050.c ****  *
3056:Src/mpu6050.c ****  *  \n MPU6500:
3057:Src/mpu6050.c ****  *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
3058:Src/mpu6050.c ****  *  sample. The hardware monitors the accel data and detects any large change
3059:Src/mpu6050.c ****  *  over a short period of time.
3060:Src/mpu6050.c ****  *
3061:Src/mpu6050.c ****  *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
ARM GAS  /tmp/ccNfEN49.s 			page 197


3062:Src/mpu6050.c ****  *  increments.
3063:Src/mpu6050.c ****  *
3064:Src/mpu6050.c ****  *  \n MPU6500 Low-power accel mode supports the following frequencies:
3065:Src/mpu6050.c ****  *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
3066:Src/mpu6050.c ****  *
3067:Src/mpu6050.c ****  *  \n\n NOTES:
3068:Src/mpu6050.c ****  *  \n The driver will round down @e thresh to the nearest supported value if
3069:Src/mpu6050.c ****  *  an unsupported threshold is selected.
3070:Src/mpu6050.c ****  *  \n To select a fractional wake-up frequency, round down the value passed to
3071:Src/mpu6050.c ****  *  @e lpa_freq.
3072:Src/mpu6050.c ****  *  \n The MPU6500 does not support a delay parameter. If this function is used
3073:Src/mpu6050.c ****  *  for the MPU6500, the value passed to @e time will be ignored.
3074:Src/mpu6050.c ****  *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
3075:Src/mpu6050.c ****  *  the previous configuration.
3076:Src/mpu6050.c ****  *
3077:Src/mpu6050.c ****  *  @param[in]  thresh      Motion threshold in mg.
3078:Src/mpu6050.c ****  *  @param[in]  time        Duration in milliseconds that the accel data must
3079:Src/mpu6050.c ****  *                          exceed @e thresh before motion is reported.
3080:Src/mpu6050.c ****  *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
3081:Src/mpu6050.c ****  *  @return     0 if successful.
3082:Src/mpu6050.c ****  */
3083:Src/mpu6050.c **** int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time, unsigned short lpa_freq)
3084:Src/mpu6050.c **** {
 6333              		.loc 1 3084 1 is_stmt 1 view -0
 6334              		.cfi_startproc
 6335              		@ args = 0, pretend = 0, frame = 0
 6336              		@ frame_needed = 0, uses_anonymous_args = 0
3085:Src/mpu6050.c **** 
3086:Src/mpu6050.c **** #if defined MPU6500
3087:Src/mpu6050.c ****     unsigned char data[3];
3088:Src/mpu6050.c **** #endif
3089:Src/mpu6050.c ****     if (lpa_freq) {
 6337              		.loc 1 3089 5 view .LVU1945
3084:Src/mpu6050.c **** 
 6338              		.loc 1 3084 1 is_stmt 0 view .LVU1946
 6339 0000 38B5     		push	{r3, r4, r5, lr}
 6340              	.LCFI97:
 6341              		.cfi_def_cfa_offset 16
 6342              		.cfi_offset 3, -16
 6343              		.cfi_offset 4, -12
 6344              		.cfi_offset 5, -8
 6345              		.cfi_offset 14, -4
 6346              		.loc 1 3089 8 view .LVU1947
 6347 0002 002A     		cmp	r2, #0
 6348 0004 3FD0     		beq	.L542
3090:Src/mpu6050.c **** #if defined MPU6500
3091:Src/mpu6050.c ****         unsigned char thresh_hw;
3092:Src/mpu6050.c **** 
3093:Src/mpu6050.c ****         /* 1LSb = 4mg. */
3094:Src/mpu6050.c ****         if (thresh > 1020)
3095:Src/mpu6050.c ****             thresh_hw = 255;
3096:Src/mpu6050.c ****         else if (thresh < 4)
3097:Src/mpu6050.c ****             thresh_hw = 1;
3098:Src/mpu6050.c ****         else
3099:Src/mpu6050.c ****             thresh_hw = thresh >> 2;
3100:Src/mpu6050.c **** #endif
3101:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 198


3102:Src/mpu6050.c ****         if (!time)
 6349              		.loc 1 3102 9 is_stmt 1 view .LVU1948
 6350              	.LVL439:
3103:Src/mpu6050.c ****             /* Minimum duration must be 1ms. */
3104:Src/mpu6050.c ****             time = 1;
3105:Src/mpu6050.c **** 
3106:Src/mpu6050.c **** #if defined MPU6500
3107:Src/mpu6050.c ****         if (lpa_freq > 640)
3108:Src/mpu6050.c ****             /* At this point, the chip has not been re-configured, so the
3109:Src/mpu6050.c ****              * function can safely exit.
3110:Src/mpu6050.c ****              */
3111:Src/mpu6050.c ****             return -1;
3112:Src/mpu6050.c **** #endif
3113:Src/mpu6050.c **** 
3114:Src/mpu6050.c ****         if (!st.chip_cfg.int_motion_only) {
 6351              		.loc 1 3114 9 view .LVU1949
 6352              		.loc 1 3114 25 is_stmt 0 view .LVU1950
 6353 0006 254C     		ldr	r4, .L553
 6354              		.loc 1 3114 12 view .LVU1951
 6355 0008 607D     		ldrb	r0, [r4, #21]	@ zero_extendqisi2
 6356              	.LVL440:
 6357              		.loc 1 3114 12 view .LVU1952
 6358 000a B8B9     		cbnz	r0, .L543
3115:Src/mpu6050.c ****             /* Store current settings for later. */
3116:Src/mpu6050.c ****             if (st.chip_cfg.dmp_on) {
 6359              		.loc 1 3116 13 is_stmt 1 view .LVU1953
 6360              		.loc 1 3116 16 is_stmt 0 view .LVU1954
 6361 000c 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 6362 0010 13B1     		cbz	r3, .L544
3117:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
 6363              		.loc 1 3117 17 is_stmt 1 view .LVU1955
 6364 0012 FFF7FEFF 		bl	mpu_set_dmp_state
 6365              	.LVL441:
3118:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 1;
 6366              		.loc 1 3118 17 view .LVU1956
 6367              		.loc 1 3118 42 is_stmt 0 view .LVU1957
 6368 0016 0123     		movs	r3, #1
 6369              	.L544:
3119:Src/mpu6050.c ****             } else
3120:Src/mpu6050.c ****                 st.chip_cfg.cache.dmp_on = 0;
 6370              		.loc 1 3120 17 is_stmt 1 view .LVU1958
3121:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
 6371              		.loc 1 3121 13 is_stmt 0 view .LVU1959
 6372 0018 2148     		ldr	r0, .L553+4
3120:Src/mpu6050.c ****             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
 6373              		.loc 1 3120 42 view .LVU1960
 6374 001a 84F82030 		strb	r3, [r4, #32]
 6375              		.loc 1 3121 13 is_stmt 1 view .LVU1961
 6376 001e FFF7FEFF 		bl	mpu_get_gyro_fsr
 6377              	.LVL442:
3122:Src/mpu6050.c ****             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
 6378              		.loc 1 3122 13 view .LVU1962
 6379 0022 2048     		ldr	r0, .L553+8
 6380 0024 FFF7FEFF 		bl	mpu_get_accel_fsr
 6381              	.LVL443:
3123:Src/mpu6050.c ****             mpu_get_lpf(&st.chip_cfg.cache.lpf);
 6382              		.loc 1 3123 13 view .LVU1963
ARM GAS  /tmp/ccNfEN49.s 			page 199


 6383 0028 1F48     		ldr	r0, .L553+12
 6384 002a FFF7FEFF 		bl	mpu_get_lpf
 6385              	.LVL444:
3124:Src/mpu6050.c ****             mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
 6386              		.loc 1 3124 13 view .LVU1964
 6387 002e 1F48     		ldr	r0, .L553+16
 6388 0030 FFF7FEFF 		bl	mpu_get_sample_rate
 6389              	.LVL445:
3125:Src/mpu6050.c ****             st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
 6390              		.loc 1 3125 13 view .LVU1965
 6391              		.loc 1 3125 42 is_stmt 0 view .LVU1966
 6392 0034 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 6393 0036 A377     		strb	r3, [r4, #30]
3126:Src/mpu6050.c ****             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
 6394              		.loc 1 3126 13 is_stmt 1 view .LVU1967
 6395              	.LVL446:
 6396              	.LBB42:
 6397              	.LBI42:
1486:Src/mpu6050.c **** {
 6398              		.loc 1 1486 5 view .LVU1968
 6399              	.LBB43:
1488:Src/mpu6050.c ****     return 0;
 6400              		.loc 1 1488 5 view .LVU1969
1488:Src/mpu6050.c ****     return 0;
 6401              		.loc 1 1488 16 is_stmt 0 view .LVU1970
 6402 0038 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 6403 003a E377     		strb	r3, [r4, #31]
1489:Src/mpu6050.c **** }
 6404              		.loc 1 1489 5 is_stmt 1 view .LVU1971
 6405              	.LVL447:
 6406              	.L543:
1489:Src/mpu6050.c **** }
 6407              		.loc 1 1489 5 is_stmt 0 view .LVU1972
 6408              	.LBE43:
 6409              	.LBE42:
3127:Src/mpu6050.c ****         }
3128:Src/mpu6050.c **** 
3129:Src/mpu6050.c **** #if defined MPU6500
3130:Src/mpu6050.c ****         /* Disable hardware interrupts. */
3131:Src/mpu6050.c ****         set_int_enable(0);
3132:Src/mpu6050.c **** 
3133:Src/mpu6050.c ****         /* Enter full-power accel-only mode, no FIFO/DMP. */
3134:Src/mpu6050.c ****         data[0] = 0;
3135:Src/mpu6050.c ****         data[1] = 0;
3136:Src/mpu6050.c ****         data[2] = BIT_STBY_XYZG;
3137:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
3138:Src/mpu6050.c ****             goto lp_int_restore;
3139:Src/mpu6050.c **** 
3140:Src/mpu6050.c ****         /* Set motion threshold. */
3141:Src/mpu6050.c ****         data[0] = thresh_hw;
3142:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
3143:Src/mpu6050.c ****             goto lp_int_restore;
3144:Src/mpu6050.c **** 
3145:Src/mpu6050.c ****         /* Set wake frequency. */
3146:Src/mpu6050.c ****         if (lpa_freq == 1)
3147:Src/mpu6050.c ****             data[0] = INV_LPA_1_25HZ;
3148:Src/mpu6050.c ****         else if (lpa_freq == 2)
ARM GAS  /tmp/ccNfEN49.s 			page 200


3149:Src/mpu6050.c ****             data[0] = INV_LPA_2_5HZ;
3150:Src/mpu6050.c ****         else if (lpa_freq <= 5)
3151:Src/mpu6050.c ****             data[0] = INV_LPA_5HZ;
3152:Src/mpu6050.c ****         else if (lpa_freq <= 10)
3153:Src/mpu6050.c ****             data[0] = INV_LPA_10HZ;
3154:Src/mpu6050.c ****         else if (lpa_freq <= 20)
3155:Src/mpu6050.c ****             data[0] = INV_LPA_20HZ;
3156:Src/mpu6050.c ****         else if (lpa_freq <= 40)
3157:Src/mpu6050.c ****             data[0] = INV_LPA_40HZ;
3158:Src/mpu6050.c ****         else if (lpa_freq <= 80)
3159:Src/mpu6050.c ****             data[0] = INV_LPA_80HZ;
3160:Src/mpu6050.c ****         else if (lpa_freq <= 160)
3161:Src/mpu6050.c ****             data[0] = INV_LPA_160HZ;
3162:Src/mpu6050.c ****         else if (lpa_freq <= 320)
3163:Src/mpu6050.c ****             data[0] = INV_LPA_320HZ;
3164:Src/mpu6050.c ****         else
3165:Src/mpu6050.c ****             data[0] = INV_LPA_640HZ;
3166:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
3167:Src/mpu6050.c ****             goto lp_int_restore;
3168:Src/mpu6050.c **** 
3169:Src/mpu6050.c ****         /* Enable motion interrupt (MPU6500 version). */
3170:Src/mpu6050.c ****         data[0] = BITS_WOM_EN;
3171:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
3172:Src/mpu6050.c ****             goto lp_int_restore;
3173:Src/mpu6050.c **** 
3174:Src/mpu6050.c ****         /* Enable cycle mode. */
3175:Src/mpu6050.c ****         data[0] = BIT_LPA_CYCLE;
3176:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
3177:Src/mpu6050.c ****             goto lp_int_restore;
3178:Src/mpu6050.c **** 
3179:Src/mpu6050.c ****         /* Enable interrupt. */
3180:Src/mpu6050.c ****         data[0] = BIT_MOT_INT_EN;
3181:Src/mpu6050.c ****         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
3182:Src/mpu6050.c ****             goto lp_int_restore;
3183:Src/mpu6050.c **** 
3184:Src/mpu6050.c ****         st.chip_cfg.int_motion_only = 1;
3185:Src/mpu6050.c ****         return 0;
3186:Src/mpu6050.c **** #endif
3187:Src/mpu6050.c ****     } else {
3188:Src/mpu6050.c ****         /* Don't "restore" the previous state if no state has been saved. */
3189:Src/mpu6050.c ****         unsigned int ii;
3190:Src/mpu6050.c ****         char *cache_ptr = (char*)&st.chip_cfg.cache;
3191:Src/mpu6050.c ****         for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
3192:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
3193:Src/mpu6050.c ****                 goto lp_int_restore;
3194:Src/mpu6050.c ****         }
3195:Src/mpu6050.c ****         /* If we reach this point, motion interrupt mode hasn't been used yet. */
3196:Src/mpu6050.c ****         return -1;
3197:Src/mpu6050.c ****     }
3198:Src/mpu6050.c **** lp_int_restore:
3199:Src/mpu6050.c ****     /* Set to invalid values to ensure no I2C writes are skipped. */
3200:Src/mpu6050.c ****     st.chip_cfg.gyro_fsr = 0xFF;
 6410              		.loc 1 3200 5 is_stmt 1 view .LVU1973
3201:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6411              		.loc 1 3201 5 view .LVU1974
3202:Src/mpu6050.c ****     st.chip_cfg.lpf = 0xFF;
 6412              		.loc 1 3202 5 view .LVU1975
ARM GAS  /tmp/ccNfEN49.s 			page 201


3203:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 6413              		.loc 1 3203 5 view .LVU1976
 6414              		.loc 1 3203 29 is_stmt 0 view .LVU1977
 6415 003c 4FF6FF73 		movw	r3, #65535
 6416 0040 164C     		ldr	r4, .L553
3204:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
3205:Src/mpu6050.c ****     st.chip_cfg.fifo_enable = 0xFF;
3206:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6417              		.loc 1 3206 25 view .LVU1978
 6418 0042 0125     		movs	r5, #1
3203:Src/mpu6050.c ****     st.chip_cfg.sample_rate = 0xFFFF;
 6419              		.loc 1 3203 29 view .LVU1979
 6420 0044 E381     		strh	r3, [r4, #14]	@ movhi
3204:Src/mpu6050.c ****     st.chip_cfg.sensors = 0xFF;
 6421              		.loc 1 3204 5 is_stmt 1 view .LVU1980
3205:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6422              		.loc 1 3205 5 view .LVU1981
3205:Src/mpu6050.c ****     st.chip_cfg.clk_src = INV_CLK_PLL;
 6423              		.loc 1 3205 29 is_stmt 0 view .LVU1982
 6424 0046 2374     		strb	r3, [r4, #16]
 6425              		.loc 1 3206 5 is_stmt 1 view .LVU1983
3200:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6426              		.loc 1 3200 26 is_stmt 0 view .LVU1984
 6427 0048 4FF0FF33 		mov	r3, #-1
3207:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6428              		.loc 1 3207 5 view .LVU1985
 6429 004c A07F     		ldrb	r0, [r4, #30]	@ zero_extendqisi2
3200:Src/mpu6050.c ****     st.chip_cfg.accel_fsr = 0xFF;
 6430              		.loc 1 3200 26 view .LVU1986
 6431 004e A360     		str	r3, [r4, #8]
3206:Src/mpu6050.c ****     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
 6432              		.loc 1 3206 25 view .LVU1987
 6433 0050 2573     		strb	r5, [r4, #12]
 6434              		.loc 1 3207 5 is_stmt 1 view .LVU1988
 6435 0052 FFF7FEFF 		bl	mpu_set_sensors
 6436              	.LVL448:
3208:Src/mpu6050.c ****     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
 6437              		.loc 1 3208 5 view .LVU1989
 6438 0056 E08A     		ldrh	r0, [r4, #22]
 6439 0058 FFF7FEFF 		bl	mpu_set_gyro_fsr
 6440              	.LVL449:
3209:Src/mpu6050.c ****     mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
 6441              		.loc 1 3209 5 view .LVU1990
 6442 005c 207E     		ldrb	r0, [r4, #24]	@ zero_extendqisi2
 6443 005e FFF7FEFF 		bl	mpu_set_accel_fsr
 6444              	.LVL450:
3210:Src/mpu6050.c ****     mpu_set_lpf(st.chip_cfg.cache.lpf);
 6445              		.loc 1 3210 5 view .LVU1991
 6446 0062 608B     		ldrh	r0, [r4, #26]
 6447 0064 FFF7FEFF 		bl	mpu_set_lpf
 6448              	.LVL451:
3211:Src/mpu6050.c ****     mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
 6449              		.loc 1 3211 5 view .LVU1992
 6450 0068 A08B     		ldrh	r0, [r4, #28]
 6451 006a FFF7FEFF 		bl	mpu_set_sample_rate
 6452              	.LVL452:
3212:Src/mpu6050.c ****     mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
ARM GAS  /tmp/ccNfEN49.s 			page 202


 6453              		.loc 1 3212 5 view .LVU1993
 6454 006e E07F     		ldrb	r0, [r4, #31]	@ zero_extendqisi2
 6455 0070 FFF7FEFF 		bl	mpu_configure_fifo
 6456              	.LVL453:
3213:Src/mpu6050.c **** 
3214:Src/mpu6050.c ****     if (st.chip_cfg.cache.dmp_on)
 6457              		.loc 1 3214 5 view .LVU1994
 6458              		.loc 1 3214 8 is_stmt 0 view .LVU1995
 6459 0074 94F82030 		ldrb	r3, [r4, #32]	@ zero_extendqisi2
 6460 0078 13B1     		cbz	r3, .L548
3215:Src/mpu6050.c ****         mpu_set_dmp_state(1);
 6461              		.loc 1 3215 9 is_stmt 1 view .LVU1996
 6462 007a 2846     		mov	r0, r5
 6463 007c FFF7FEFF 		bl	mpu_set_dmp_state
 6464              	.LVL454:
 6465              	.L548:
3216:Src/mpu6050.c **** 
3217:Src/mpu6050.c **** #ifdef MPU6500
3218:Src/mpu6050.c ****     /* Disable motion interrupt (MPU6500 version). */
3219:Src/mpu6050.c ****     data[0] = 0;
3220:Src/mpu6050.c ****     if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
3221:Src/mpu6050.c ****         goto lp_int_restore;
3222:Src/mpu6050.c **** #endif
3223:Src/mpu6050.c **** 
3224:Src/mpu6050.c ****     st.chip_cfg.int_motion_only = 0;
 6466              		.loc 1 3224 5 view .LVU1997
 6467              		.loc 1 3224 33 is_stmt 0 view .LVU1998
 6468 0080 0020     		movs	r0, #0
 6469 0082 6075     		strb	r0, [r4, #21]
3225:Src/mpu6050.c ****     return 0;
 6470              		.loc 1 3225 5 is_stmt 1 view .LVU1999
 6471              		.loc 1 3225 12 is_stmt 0 view .LVU2000
 6472 0084 09E0     		b	.L541
 6473              	.LVL455:
 6474              	.L542:
 6475              		.loc 1 3225 12 view .LVU2001
 6476 0086 064B     		ldr	r3, .L553+4
 6477              	.LVL456:
 6478              	.L546:
 6479              	.LBB44:
3192:Src/mpu6050.c ****                 goto lp_int_restore;
 6480              		.loc 1 3192 13 is_stmt 1 view .LVU2002
3192:Src/mpu6050.c ****                 goto lp_int_restore;
 6481              		.loc 1 3192 26 is_stmt 0 view .LVU2003
 6482 0088 13F8011B 		ldrb	r1, [r3], #1	@ zero_extendqisi2
3192:Src/mpu6050.c ****                 goto lp_int_restore;
 6483              		.loc 1 3192 16 view .LVU2004
 6484 008c 0029     		cmp	r1, #0
 6485 008e D5D1     		bne	.L543
3191:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6486              		.loc 1 3191 54 is_stmt 1 discriminator 2 view .LVU2005
3191:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6487              		.loc 1 3191 56 is_stmt 0 discriminator 2 view .LVU2006
 6488 0090 0132     		adds	r2, r2, #1
 6489              	.LVL457:
3191:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6490              		.loc 1 3191 22 is_stmt 1 discriminator 2 view .LVU2007
ARM GAS  /tmp/ccNfEN49.s 			page 203


3191:Src/mpu6050.c ****             if (cache_ptr[ii] != 0)
 6491              		.loc 1 3191 9 is_stmt 0 discriminator 2 view .LVU2008
 6492 0092 0C2A     		cmp	r2, #12
 6493 0094 F8D1     		bne	.L546
3196:Src/mpu6050.c ****     }
 6494              		.loc 1 3196 16 view .LVU2009
 6495 0096 4FF0FF30 		mov	r0, #-1
 6496              	.LVL458:
 6497              	.L541:
3196:Src/mpu6050.c ****     }
 6498              		.loc 1 3196 16 view .LVU2010
 6499              	.LBE44:
3226:Src/mpu6050.c **** }
 6500              		.loc 1 3226 1 view .LVU2011
 6501 009a 38BD     		pop	{r3, r4, r5, pc}
 6502              	.L554:
 6503              		.align	2
 6504              	.L553:
 6505 009c 00000000 		.word	.LANCHOR0
 6506 00a0 16000000 		.word	.LANCHOR0+22
 6507 00a4 18000000 		.word	.LANCHOR0+24
 6508 00a8 1A000000 		.word	.LANCHOR0+26
 6509 00ac 1C000000 		.word	.LANCHOR0+28
 6510              		.cfi_endproc
 6511              	.LFE108:
 6513              		.section	.rodata.mpu_start_self_test.str1.1,"aMS",%progbits,1
 6514              	.LC1:
 6515 0000 50617373 		.ascii	"Passed!\015\012\000"
 6515      6564210D 
 6515      0A00
 6516              	.LC2:
 6517 000a 4779726F 		.ascii	"Gyro failed\015\012\000"
 6517      20666169 
 6517      6C65640D 
 6517      0A00
 6518              	.LC3:
 6519 0018 41636365 		.ascii	"Accel failed\015\012\000"
 6519      6C206661 
 6519      696C6564 
 6519      0D0A00
 6520              	.LC4:
 6521 0027 436F6D70 		.ascii	"Compass failed\015\012\000"
 6521      61737320 
 6521      6661696C 
 6521      65640D0A 
 6521      00
 6522              		.section	.text.mpu_start_self_test,"ax",%progbits
 6523              		.align	1
 6524              		.global	mpu_start_self_test
 6525              		.syntax unified
 6526              		.thumb
 6527              		.thumb_func
 6528              		.fpu softvfp
 6530              	mpu_start_self_test:
 6531              	.LFB109:
3227:Src/mpu6050.c **** 
3228:Src/mpu6050.c **** /*
ARM GAS  /tmp/ccNfEN49.s 			page 204


3229:Src/mpu6050.c ****  *  This function must be called with the device either face-up or face-down
3230:Src/mpu6050.c ****  *  (z-axis is parallel to gravity).
3231:Src/mpu6050.c ****  */
3232:Src/mpu6050.c **** void mpu_start_self_test(void)
3233:Src/mpu6050.c **** {
 6532              		.loc 1 3233 1 is_stmt 1 view -0
 6533              		.cfi_startproc
 6534              		@ args = 0, pretend = 0, frame = 24
 6535              		@ frame_needed = 0, uses_anonymous_args = 0
3234:Src/mpu6050.c ****     int result;
 6536              		.loc 1 3234 5 view .LVU2013
3235:Src/mpu6050.c ****     long gyro[3], accel[3];
 6537              		.loc 1 3235 5 view .LVU2014
3236:Src/mpu6050.c **** 
3237:Src/mpu6050.c **** #if defined (MPU6500) || defined (MPU9250)
3238:Src/mpu6050.c ****     result = mpu_run_6500_self_test(gyro, accel, 0);
3239:Src/mpu6050.c **** #elif defined (MPU6050) || defined (MPU9150)
3240:Src/mpu6050.c ****     result = mpu_run_self_test(gyro, accel);
 6538              		.loc 1 3240 5 view .LVU2015
3233:Src/mpu6050.c ****     int result;
 6539              		.loc 1 3233 1 is_stmt 0 view .LVU2016
 6540 0000 10B5     		push	{r4, lr}
 6541              	.LCFI98:
 6542              		.cfi_def_cfa_offset 8
 6543              		.cfi_offset 4, -8
 6544              		.cfi_offset 14, -4
 6545 0002 86B0     		sub	sp, sp, #24
 6546              	.LCFI99:
 6547              		.cfi_def_cfa_offset 32
 6548              		.loc 1 3240 14 view .LVU2017
 6549 0004 6846     		mov	r0, sp
 6550 0006 03A9     		add	r1, sp, #12
 6551 0008 FFF7FEFF 		bl	mpu_run_self_test
 6552              	.LVL459:
3241:Src/mpu6050.c **** #endif
3242:Src/mpu6050.c ****     #ifdef SERIAL_DEBUG
3243:Src/mpu6050.c ****         log_i("accel: %ld %ld %ld\r\n",
3244:Src/mpu6050.c ****                                 accel[0],
3245:Src/mpu6050.c ****                                 accel[1],
3246:Src/mpu6050.c ****                                 accel[2]);
3247:Src/mpu6050.c ****         log_i("gyro: %ld %ld %ld\r\n",
3248:Src/mpu6050.c ****                                 gyro[0],
3249:Src/mpu6050.c ****                                 gyro[1],
3250:Src/mpu6050.c ****                                 gyro[2]);
3251:Src/mpu6050.c ****     #endif
3252:Src/mpu6050.c ****     if (result == 0x7) {
 6553              		.loc 1 3252 8 view .LVU2018
 6554 000c 0728     		cmp	r0, #7
3240:Src/mpu6050.c **** #endif
 6555              		.loc 1 3240 14 view .LVU2019
 6556 000e 0446     		mov	r4, r0
 6557              	.LVL460:
 6558              		.loc 1 3252 5 is_stmt 1 view .LVU2020
 6559              		.loc 1 3252 8 is_stmt 0 view .LVU2021
 6560 0010 04D1     		bne	.L556
3253:Src/mpu6050.c ****         consoleLog("Passed!\r\n");
 6561              		.loc 1 3253 9 is_stmt 1 view .LVU2022
ARM GAS  /tmp/ccNfEN49.s 			page 205


 6562 0012 0948     		ldr	r0, .L561
 6563              	.LVL461:
 6564              	.L560:
3254:Src/mpu6050.c ****         /* Test passed. We can trust the gyro data here, so now we need to update calibrated data*/
3255:Src/mpu6050.c **** 
3256:Src/mpu6050.c **** #ifdef USE_CAL_HW_REGISTERS
3257:Src/mpu6050.c ****         /*
3258:Src/mpu6050.c ****          * This portion of the code uses the HW offset registers that are in the MPUxxxx devices
3259:Src/mpu6050.c ****          * instead of pushing the cal data to the MPL software library
3260:Src/mpu6050.c ****          */
3261:Src/mpu6050.c ****         unsigned char i = 0;
3262:Src/mpu6050.c **** 
3263:Src/mpu6050.c ****         for(i = 0; i<3; i++) {
3264:Src/mpu6050.c ****             gyro[i] = (long)(gyro[i] * 32.8f); //convert to +-1000dps
3265:Src/mpu6050.c ****             accel[i] *= 2048.f; //convert to +-16G
3266:Src/mpu6050.c ****             accel[i] = accel[i] >> 16;
3267:Src/mpu6050.c ****             gyro[i] = (long)(gyro[i] >> 16);
3268:Src/mpu6050.c ****         }
3269:Src/mpu6050.c **** 
3270:Src/mpu6050.c ****         mpu_set_gyro_bias_reg(gyro);
3271:Src/mpu6050.c **** 
3272:Src/mpu6050.c ****         #if defined (MPU6500) || defined (MPU9250)
3273:Src/mpu6050.c ****                 mpu_set_accel_bias_6500_reg(accel);
3274:Src/mpu6050.c ****         #elif defined (MPU6050) || defined (MPU9150)
3275:Src/mpu6050.c ****                 mpu_set_accel_bias_6050_reg(accel);
3276:Src/mpu6050.c ****         #endif
3277:Src/mpu6050.c **** #endif
3278:Src/mpu6050.c ****     }
3279:Src/mpu6050.c ****     else {
3280:Src/mpu6050.c ****         if (!(result & 0x1))
3281:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
3282:Src/mpu6050.c ****         if (!(result & 0x2))
3283:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
3284:Src/mpu6050.c ****         if (!(result & 0x4))
3285:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6565              		.loc 1 3285 13 is_stmt 0 view .LVU2023
 6566 0014 FFF7FEFF 		bl	consoleLog
 6567              	.LVL462:
 6568              	.L555:
3286:Src/mpu6050.c ****      }
3287:Src/mpu6050.c **** 
3288:Src/mpu6050.c **** }
 6569              		.loc 1 3288 1 view .LVU2024
 6570 0018 06B0     		add	sp, sp, #24
 6571              	.LCFI100:
 6572              		.cfi_remember_state
 6573              		.cfi_def_cfa_offset 8
 6574              		@ sp needed
 6575 001a 10BD     		pop	{r4, pc}
 6576              	.LVL463:
 6577              	.L556:
 6578              	.LCFI101:
 6579              		.cfi_restore_state
3280:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
 6580              		.loc 1 3280 9 is_stmt 1 view .LVU2025
3280:Src/mpu6050.c ****             consoleLog("Gyro failed\r\n");
 6581              		.loc 1 3280 12 is_stmt 0 view .LVU2026
ARM GAS  /tmp/ccNfEN49.s 			page 206


 6582 001c C107     		lsls	r1, r0, #31
 6583 001e 02D4     		bmi	.L558
3281:Src/mpu6050.c ****         if (!(result & 0x2))
 6584              		.loc 1 3281 13 is_stmt 1 view .LVU2027
 6585 0020 0648     		ldr	r0, .L561+4
 6586              	.LVL464:
3281:Src/mpu6050.c ****         if (!(result & 0x2))
 6587              		.loc 1 3281 13 is_stmt 0 view .LVU2028
 6588 0022 FFF7FEFF 		bl	consoleLog
 6589              	.LVL465:
 6590              	.L558:
3282:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
 6591              		.loc 1 3282 9 is_stmt 1 view .LVU2029
3282:Src/mpu6050.c ****             consoleLog("Accel failed\r\n");
 6592              		.loc 1 3282 12 is_stmt 0 view .LVU2030
 6593 0026 A207     		lsls	r2, r4, #30
 6594 0028 02D4     		bmi	.L559
3283:Src/mpu6050.c ****         if (!(result & 0x4))
 6595              		.loc 1 3283 13 is_stmt 1 view .LVU2031
 6596 002a 0548     		ldr	r0, .L561+8
 6597 002c FFF7FEFF 		bl	consoleLog
 6598              	.LVL466:
 6599              	.L559:
3284:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6600              		.loc 1 3284 9 view .LVU2032
3284:Src/mpu6050.c ****             consoleLog("Compass failed\r\n");
 6601              		.loc 1 3284 12 is_stmt 0 view .LVU2033
 6602 0030 6307     		lsls	r3, r4, #29
 6603 0032 F1D4     		bmi	.L555
3285:Src/mpu6050.c ****      }
 6604              		.loc 1 3285 13 is_stmt 1 view .LVU2034
 6605 0034 0348     		ldr	r0, .L561+12
 6606 0036 EDE7     		b	.L560
 6607              	.L562:
 6608              		.align	2
 6609              	.L561:
 6610 0038 00000000 		.word	.LC1
 6611 003c 0A000000 		.word	.LC2
 6612 0040 18000000 		.word	.LC3
 6613 0044 27000000 		.word	.LC4
 6614              		.cfi_endproc
 6615              	.LFE109:
 6617              		.section	.rodata.mpu_setup_gyro.str1.1,"aMS",%progbits,1
 6618              	.LC5:
 6619 0000 41636365 		.ascii	"Accel ON\015\012\000"
 6619      6C204F4E 
 6619      0D0A00
 6620              	.LC6:
 6621 000b 41636365 		.ascii	"Accel OFF\015\012\000"
 6621      6C204F46 
 6621      460D0A00 
 6622              	.LC7:
 6623 0017 4779726F 		.ascii	"Gyro ON\015\012\000"
 6623      204F4E0D 
 6623      0A00
 6624              	.LC8:
 6625 0021 4779726F 		.ascii	"Gyro OFF\015\012\000"
ARM GAS  /tmp/ccNfEN49.s 			page 207


 6625      204F4646 
 6625      0D0A00
 6626              		.section	.text.mpu_setup_gyro,"ax",%progbits
 6627              		.align	1
 6628              		.global	mpu_setup_gyro
 6629              		.syntax unified
 6630              		.thumb
 6631              		.thumb_func
 6632              		.fpu softvfp
 6634              	mpu_setup_gyro:
 6635              	.LFB110:
3289:Src/mpu6050.c **** 
3290:Src/mpu6050.c **** 
3291:Src/mpu6050.c **** 
3292:Src/mpu6050.c **** //=========================================================================================
3293:Src/mpu6050.c **** struct hal_s {
3294:Src/mpu6050.c ****     unsigned char lp_accel_mode;
3295:Src/mpu6050.c ****     unsigned char sensors;
3296:Src/mpu6050.c ****     unsigned char dmp_on;
3297:Src/mpu6050.c ****     unsigned char wait_for_tap;
3298:Src/mpu6050.c ****     volatile unsigned char new_gyro;
3299:Src/mpu6050.c ****     unsigned long no_dmp_hz;
3300:Src/mpu6050.c ****     unsigned long next_pedo_ms;
3301:Src/mpu6050.c ****     unsigned long next_temp_ms;
3302:Src/mpu6050.c ****     unsigned int report;
3303:Src/mpu6050.c ****     unsigned short dmp_features;
3304:Src/mpu6050.c **** };
3305:Src/mpu6050.c **** static struct hal_s hal = {0};
3306:Src/mpu6050.c **** 
3307:Src/mpu6050.c **** 
3308:Src/mpu6050.c **** /* This fuction handle sensor on/off combinations. */
3309:Src/mpu6050.c **** void mpu_setup_gyro(void)
3310:Src/mpu6050.c **** {
 6636              		.loc 1 3310 1 view -0
 6637              		.cfi_startproc
 6638              		@ args = 0, pretend = 0, frame = 8
 6639              		@ frame_needed = 0, uses_anonymous_args = 0
3311:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
 6640              		.loc 1 3311 5 view .LVU2036
 6641              	.LVL467:
3312:Src/mpu6050.c ****     if (hal.sensors & ACCEL_ON) {
 6642              		.loc 1 3312 5 view .LVU2037
3310:Src/mpu6050.c ****     unsigned char mask = 0, lp_accel_was_on = 0;
 6643              		.loc 1 3310 1 is_stmt 0 view .LVU2038
 6644 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 6645              	.LCFI102:
 6646              		.cfi_def_cfa_offset 24
 6647              		.cfi_offset 4, -16
 6648              		.cfi_offset 5, -12
 6649              		.cfi_offset 6, -8
 6650              		.cfi_offset 14, -4
 6651              		.loc 1 3312 12 view .LVU2039
 6652 0002 134E     		ldr	r6, .L573
 6653 0004 7478     		ldrb	r4, [r6, #1]	@ zero_extendqisi2
 6654              		.loc 1 3312 8 view .LVU2040
 6655 0006 14F00104 		ands	r4, r4, #1
 6656 000a 1DD0     		beq	.L564
ARM GAS  /tmp/ccNfEN49.s 			page 208


3313:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6657              		.loc 1 3313 9 is_stmt 1 view .LVU2041
 6658              	.LVL468:
3314:Src/mpu6050.c ****         consoleLog("Accel ON\r\n");
 6659              		.loc 1 3314 9 view .LVU2042
 6660 000c 1148     		ldr	r0, .L573+4
 6661 000e FFF7FEFF 		bl	consoleLog
 6662              	.LVL469:
3313:Src/mpu6050.c ****         mask |= INV_XYZ_ACCEL;
 6663              		.loc 1 3313 14 is_stmt 0 view .LVU2043
 6664 0012 0824     		movs	r4, #8
 6665              	.LVL470:
 6666              	.L565:
3315:Src/mpu6050.c ****     } else {
3316:Src/mpu6050.c ****         consoleLog("Accel OFF\r\n");
3317:Src/mpu6050.c ****     }
3318:Src/mpu6050.c ****     if (hal.sensors & GYRO_ON) {
 6667              		.loc 1 3318 5 is_stmt 1 view .LVU2044
 6668 0014 7578     		ldrb	r5, [r6, #1]	@ zero_extendqisi2
 6669              		.loc 1 3318 8 is_stmt 0 view .LVU2045
 6670 0016 15F00205 		ands	r5, r5, #2
3319:Src/mpu6050.c ****         mask |= INV_XYZ_GYRO;
 6671              		.loc 1 3319 9 is_stmt 1 view .LVU2046
 6672              		.loc 1 3319 14 is_stmt 0 view .LVU2047
 6673 001a 1BBF     		ittet	ne
 6674 001c 44F07004 		orrne	r4, r4, #112
 6675              	.LVL471:
3320:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
 6676              		.loc 1 3320 9 is_stmt 1 view .LVU2048
3321:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6677              		.loc 1 3321 9 is_stmt 0 view .LVU2049
 6678 0020 0D48     		ldrne	r0, .L573+8
3322:Src/mpu6050.c ****     } else {
3323:Src/mpu6050.c ****         consoleLog("Gyro OFF\r\n");
 6679              		.loc 1 3323 9 view .LVU2050
 6680 0022 0E48     		ldreq	r0, .L573+12
3320:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6681              		.loc 1 3320 31 view .LVU2051
 6682 0024 3578     		ldrbne	r5, [r6]	@ zero_extendqisi2
 6683              	.LVL472:
3321:Src/mpu6050.c ****         consoleLog("Gyro ON\r\n");
 6684              		.loc 1 3321 9 is_stmt 1 view .LVU2052
 6685              		.loc 1 3323 9 view .LVU2053
 6686 0026 FFF7FEFF 		bl	consoleLog
 6687              	.LVL473:
3324:Src/mpu6050.c ****     }
3325:Src/mpu6050.c **** #ifdef COMPASS_ENABLED
3326:Src/mpu6050.c ****     if (hal.sensors & COMPASS_ON) {
3327:Src/mpu6050.c ****         mask |= INV_XYZ_COMPASS;
3328:Src/mpu6050.c ****         lp_accel_was_on |= hal.lp_accel_mode;
3329:Src/mpu6050.c ****     }
3330:Src/mpu6050.c **** #endif
3331:Src/mpu6050.c ****     /* If you need a power transition, this function should be called with a
3332:Src/mpu6050.c ****      * mask of the sensors still enabled. The driver turns off any sensors
3333:Src/mpu6050.c ****      * excluded from this mask.
3334:Src/mpu6050.c ****      */
3335:Src/mpu6050.c ****     mpu_set_sensors(mask);
ARM GAS  /tmp/ccNfEN49.s 			page 209


 6688              		.loc 1 3335 5 view .LVU2054
 6689 002a 2046     		mov	r0, r4
 6690 002c FFF7FEFF 		bl	mpu_set_sensors
 6691              	.LVL474:
3336:Src/mpu6050.c ****     mpu_configure_fifo(mask);
 6692              		.loc 1 3336 5 view .LVU2055
 6693 0030 2046     		mov	r0, r4
 6694 0032 FFF7FEFF 		bl	mpu_configure_fifo
 6695              	.LVL475:
3337:Src/mpu6050.c ****     if (lp_accel_was_on) {
 6696              		.loc 1 3337 5 view .LVU2056
 6697              		.loc 1 3337 8 is_stmt 0 view .LVU2057
 6698 0036 2DB1     		cbz	r5, .L563
 6699              	.LBB45:
3338:Src/mpu6050.c ****         unsigned short rate;
 6700              		.loc 1 3338 9 is_stmt 1 view .LVU2058
3339:Src/mpu6050.c ****         hal.lp_accel_mode = 0;
 6701              		.loc 1 3339 9 view .LVU2059
 6702              		.loc 1 3339 27 is_stmt 0 view .LVU2060
 6703 0038 0023     		movs	r3, #0
3340:Src/mpu6050.c ****         /* Switching out of LP accel, notify MPL of new accel sampling rate. */
3341:Src/mpu6050.c ****         mpu_get_sample_rate(&rate);
 6704              		.loc 1 3341 9 view .LVU2061
 6705 003a 0DF10600 		add	r0, sp, #6
3339:Src/mpu6050.c ****         hal.lp_accel_mode = 0;
 6706              		.loc 1 3339 27 view .LVU2062
 6707 003e 3370     		strb	r3, [r6]
 6708              		.loc 1 3341 9 is_stmt 1 view .LVU2063
 6709 0040 FFF7FEFF 		bl	mpu_get_sample_rate
 6710              	.LVL476:
 6711              	.L563:
 6712              	.LBE45:
3342:Src/mpu6050.c ****     }
3343:Src/mpu6050.c **** }
 6713              		.loc 1 3343 1 is_stmt 0 view .LVU2064
 6714 0044 02B0     		add	sp, sp, #8
 6715              	.LCFI103:
 6716              		.cfi_remember_state
 6717              		.cfi_def_cfa_offset 16
 6718              		@ sp needed
 6719 0046 70BD     		pop	{r4, r5, r6, pc}
 6720              	.LVL477:
 6721              	.L564:
 6722              	.LCFI104:
 6723              		.cfi_restore_state
3316:Src/mpu6050.c ****     }
 6724              		.loc 1 3316 9 is_stmt 1 view .LVU2065
 6725 0048 0548     		ldr	r0, .L573+16
 6726 004a FFF7FEFF 		bl	consoleLog
 6727              	.LVL478:
 6728 004e E1E7     		b	.L565
 6729              	.L574:
 6730              		.align	2
 6731              	.L573:
 6732 0050 00000000 		.word	.LANCHOR2
 6733 0054 00000000 		.word	.LC5
 6734 0058 17000000 		.word	.LC7
ARM GAS  /tmp/ccNfEN49.s 			page 210


 6735 005c 21000000 		.word	.LC8
 6736 0060 0B000000 		.word	.LC6
 6737              		.cfi_endproc
 6738              	.LFE110:
 6740              		.section	.text.inv_row_2_scale,"ax",%progbits
 6741              		.align	1
 6742              		.global	inv_row_2_scale
 6743              		.syntax unified
 6744              		.thumb
 6745              		.thumb_func
 6746              		.fpu softvfp
 6748              	inv_row_2_scale:
 6749              	.LVL479:
 6750              	.LFB111:
3344:Src/mpu6050.c **** 
3345:Src/mpu6050.c **** unsigned short inv_row_2_scale(const signed char *row)
3346:Src/mpu6050.c **** {
 6751              		.loc 1 3346 1 view -0
 6752              		.cfi_startproc
 6753              		@ args = 0, pretend = 0, frame = 0
 6754              		@ frame_needed = 0, uses_anonymous_args = 0
 6755              		@ link register save eliminated.
3347:Src/mpu6050.c ****     unsigned short b;
 6756              		.loc 1 3347 5 view .LVU2067
3348:Src/mpu6050.c **** 
3349:Src/mpu6050.c ****     if (row[0] > 0)
 6757              		.loc 1 3349 5 view .LVU2068
 6758              		.loc 1 3349 12 is_stmt 0 view .LVU2069
 6759 0000 90F90030 		ldrsb	r3, [r0]
 6760              		.loc 1 3349 8 view .LVU2070
 6761 0004 002B     		cmp	r3, #0
 6762 0006 0CDC     		bgt	.L577
3350:Src/mpu6050.c ****         b = 0;
3351:Src/mpu6050.c ****     else if (row[0] < 0)
 6763              		.loc 1 3351 10 is_stmt 1 view .LVU2071
 6764              		.loc 1 3351 13 is_stmt 0 view .LVU2072
 6765 0008 0DD1     		bne	.L578
3352:Src/mpu6050.c ****         b = 4;
3353:Src/mpu6050.c ****     else if (row[1] > 0)
 6766              		.loc 1 3353 10 is_stmt 1 view .LVU2073
 6767              		.loc 1 3353 17 is_stmt 0 view .LVU2074
 6768 000a 90F90130 		ldrsb	r3, [r0, #1]
 6769              		.loc 1 3353 13 view .LVU2075
 6770 000e 002B     		cmp	r3, #0
 6771 0010 0BDC     		bgt	.L579
3354:Src/mpu6050.c ****         b = 1;
3355:Src/mpu6050.c ****     else if (row[1] < 0)
 6772              		.loc 1 3355 10 is_stmt 1 view .LVU2076
 6773              		.loc 1 3355 13 is_stmt 0 view .LVU2077
 6774 0012 0CD1     		bne	.L580
 6775              	.LVL480:
 6776              	.LBB48:
 6777              	.LBI48:
3345:Src/mpu6050.c **** {
 6778              		.loc 1 3345 16 is_stmt 1 view .LVU2078
 6779              	.LBB49:
3356:Src/mpu6050.c ****         b = 5;
ARM GAS  /tmp/ccNfEN49.s 			page 211


3357:Src/mpu6050.c ****     else if (row[2] > 0)
 6780              		.loc 1 3357 10 view .LVU2079
 6781              		.loc 1 3357 17 is_stmt 0 view .LVU2080
 6782 0014 90F90230 		ldrsb	r3, [r0, #2]
 6783              		.loc 1 3357 13 view .LVU2081
 6784 0018 002B     		cmp	r3, #0
 6785 001a 0ADC     		bgt	.L581
3358:Src/mpu6050.c ****         b = 2;
3359:Src/mpu6050.c ****     else if (row[2] < 0)
 6786              		.loc 1 3359 10 is_stmt 1 view .LVU2082
 6787              		.loc 1 3359 13 is_stmt 0 view .LVU2083
 6788 001c 0BD1     		bne	.L582
3360:Src/mpu6050.c ****         b = 6;
3361:Src/mpu6050.c ****     else
3362:Src/mpu6050.c ****         b = 7;      // error
 6789              		.loc 1 3362 11 view .LVU2084
 6790 001e 0720     		movs	r0, #7
 6791              	.LVL481:
 6792              		.loc 1 3362 11 view .LVU2085
 6793 0020 7047     		bx	lr
 6794              	.LVL482:
 6795              	.L577:
 6796              		.loc 1 3362 11 view .LVU2086
 6797              	.LBE49:
 6798              	.LBE48:
3350:Src/mpu6050.c ****     else if (row[0] < 0)
 6799              		.loc 1 3350 11 view .LVU2087
 6800 0022 0020     		movs	r0, #0
 6801              	.LVL483:
3350:Src/mpu6050.c ****     else if (row[0] < 0)
 6802              		.loc 1 3350 11 view .LVU2088
 6803 0024 7047     		bx	lr
 6804              	.LVL484:
 6805              	.L578:
3352:Src/mpu6050.c ****     else if (row[1] > 0)
 6806              		.loc 1 3352 11 view .LVU2089
 6807 0026 0420     		movs	r0, #4
 6808              	.LVL485:
3352:Src/mpu6050.c ****     else if (row[1] > 0)
 6809              		.loc 1 3352 11 view .LVU2090
 6810 0028 7047     		bx	lr
 6811              	.LVL486:
 6812              	.L579:
3354:Src/mpu6050.c ****     else if (row[1] < 0)
 6813              		.loc 1 3354 11 view .LVU2091
 6814 002a 0120     		movs	r0, #1
 6815              	.LVL487:
3354:Src/mpu6050.c ****     else if (row[1] < 0)
 6816              		.loc 1 3354 11 view .LVU2092
 6817 002c 7047     		bx	lr
 6818              	.LVL488:
 6819              	.L580:
3356:Src/mpu6050.c ****     else if (row[2] > 0)
 6820              		.loc 1 3356 11 view .LVU2093
 6821 002e 0520     		movs	r0, #5
 6822              	.LVL489:
3356:Src/mpu6050.c ****     else if (row[2] > 0)
ARM GAS  /tmp/ccNfEN49.s 			page 212


 6823              		.loc 1 3356 11 view .LVU2094
 6824 0030 7047     		bx	lr
 6825              	.LVL490:
 6826              	.L581:
 6827              	.LBB51:
 6828              	.LBB50:
3358:Src/mpu6050.c ****     else if (row[2] < 0)
 6829              		.loc 1 3358 11 view .LVU2095
 6830 0032 0220     		movs	r0, #2
 6831              	.LVL491:
3358:Src/mpu6050.c ****     else if (row[2] < 0)
 6832              		.loc 1 3358 11 view .LVU2096
 6833 0034 7047     		bx	lr
 6834              	.LVL492:
 6835              	.L582:
3360:Src/mpu6050.c ****     else
 6836              		.loc 1 3360 11 view .LVU2097
 6837 0036 0620     		movs	r0, #6
 6838              	.LVL493:
3360:Src/mpu6050.c ****     else
 6839              		.loc 1 3360 11 view .LVU2098
 6840              	.LBE50:
 6841              	.LBE51:
3363:Src/mpu6050.c ****     return b;
 6842              		.loc 1 3363 5 is_stmt 1 view .LVU2099
3364:Src/mpu6050.c **** }
 6843              		.loc 1 3364 1 is_stmt 0 view .LVU2100
 6844 0038 7047     		bx	lr
 6845              		.cfi_endproc
 6846              	.LFE111:
 6848              		.section	.text.inv_orientation_matrix_to_scalar,"ax",%progbits
 6849              		.align	1
 6850              		.global	inv_orientation_matrix_to_scalar
 6851              		.syntax unified
 6852              		.thumb
 6853              		.thumb_func
 6854              		.fpu softvfp
 6856              	inv_orientation_matrix_to_scalar:
 6857              	.LVL494:
 6858              	.LFB112:
3365:Src/mpu6050.c **** 
3366:Src/mpu6050.c **** /*
3367:Src/mpu6050.c ****  *  This function converts the Sensor orientation matric to a scalar
3368:Src/mpu6050.c ****  */
3369:Src/mpu6050.c **** unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx)
3370:Src/mpu6050.c **** {
 6859              		.loc 1 3370 1 is_stmt 1 view -0
 6860              		.cfi_startproc
 6861              		@ args = 0, pretend = 0, frame = 0
 6862              		@ frame_needed = 0, uses_anonymous_args = 0
3371:Src/mpu6050.c ****     unsigned short scalar;
 6863              		.loc 1 3371 5 view .LVU2102
3372:Src/mpu6050.c ****     scalar  = inv_row_2_scale(mtx);
 6864              		.loc 1 3372 5 view .LVU2103
3370:Src/mpu6050.c ****     unsigned short scalar;
 6865              		.loc 1 3370 1 is_stmt 0 view .LVU2104
 6866 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/ccNfEN49.s 			page 213


 6867              	.LCFI105:
 6868              		.cfi_def_cfa_offset 8
 6869              		.cfi_offset 4, -8
 6870              		.cfi_offset 14, -4
3370:Src/mpu6050.c ****     unsigned short scalar;
 6871              		.loc 1 3370 1 view .LVU2105
 6872 0002 0246     		mov	r2, r0
 6873              		.loc 1 3372 15 view .LVU2106
 6874 0004 FFF7FEFF 		bl	inv_row_2_scale
 6875              	.LVL495:
 6876              		.loc 1 3372 15 view .LVU2107
 6877 0008 0146     		mov	r1, r0
 6878              	.LVL496:
3373:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 3) << 3;
 6879              		.loc 1 3373 5 is_stmt 1 view .LVU2108
 6880              		.loc 1 3373 15 is_stmt 0 view .LVU2109
 6881 000a D01C     		adds	r0, r2, #3
 6882 000c FFF7FEFF 		bl	inv_row_2_scale
 6883              	.LVL497:
 6884 0010 0446     		mov	r4, r0
 6885              	.LVL498:
3374:Src/mpu6050.c ****     scalar |= inv_row_2_scale(mtx + 6) << 6;
 6886              		.loc 1 3374 5 is_stmt 1 view .LVU2110
 6887              		.loc 1 3374 15 is_stmt 0 view .LVU2111
 6888 0012 901D     		adds	r0, r2, #6
 6889 0014 FFF7FEFF 		bl	inv_row_2_scale
 6890              	.LVL499:
 6891              		.loc 1 3374 40 view .LVU2112
 6892 0018 8301     		lsls	r3, r0, #6
 6893              		.loc 1 3374 12 view .LVU2113
 6894 001a 43EAC403 		orr	r3, r3, r4, lsl #3
 6895 001e 43EA0100 		orr	r0, r3, r1
 6896              	.LVL500:
3375:Src/mpu6050.c **** 
3376:Src/mpu6050.c ****     return scalar;
 6897              		.loc 1 3376 5 is_stmt 1 view .LVU2114
3377:Src/mpu6050.c **** }
 6898              		.loc 1 3377 1 is_stmt 0 view .LVU2115
 6899 0022 80B2     		uxth	r0, r0
 6900              		.loc 1 3377 1 view .LVU2116
 6901 0024 10BD     		pop	{r4, pc}
 6902              		.cfi_endproc
 6903              	.LFE112:
 6905              		.section	.rodata.mpu_config.str1.1,"aMS",%progbits,1
 6906              	.LC9:
 6907 0000 436F6E66 		.ascii	"Configuring MPU6050... \000"
 6907      69677572 
 6907      696E6720 
 6907      4D505536 
 6907      3035302E 
 6908              	.LC10:
 6909 0018 4641494C 		.ascii	"FAIL (MPU)\015\012\000"
 6909      20284D50 
 6909      55290D0A 
 6909      00
 6910              	.LC11:
 6911 0025 204F4B0D 		.ascii	" OK\015\012\000"
ARM GAS  /tmp/ccNfEN49.s 			page 214


 6911      0A00
 6912              		.section	.text.mpu_config,"ax",%progbits
 6913              		.align	1
 6914              		.global	mpu_config
 6915              		.syntax unified
 6916              		.thumb
 6917              		.thumb_func
 6918              		.fpu softvfp
 6920              	mpu_config:
 6921              	.LFB113:
3378:Src/mpu6050.c **** 
3379:Src/mpu6050.c **** 
3380:Src/mpu6050.c **** /**
3381:Src/mpu6050.c ****  *  @}
3382:Src/mpu6050.c ****  */
3383:Src/mpu6050.c **** 
3384:Src/mpu6050.c **** /* =========================== MPU-6050 Configuration =========================== */
3385:Src/mpu6050.c **** int mpu_config(void)
3386:Src/mpu6050.c **** {
 6922              		.loc 1 3386 1 is_stmt 1 view -0
 6923              		.cfi_startproc
 6924              		@ args = 0, pretend = 0, frame = 0
 6925              		@ frame_needed = 0, uses_anonymous_args = 0
3387:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
 6926              		.loc 1 3387 5 view .LVU2118
3386:Src/mpu6050.c ****     consoleLog("Configuring MPU6050... ");	
 6927              		.loc 1 3386 1 is_stmt 0 view .LVU2119
 6928 0000 10B5     		push	{r4, lr}
 6929              	.LCFI106:
 6930              		.cfi_def_cfa_offset 8
 6931              		.cfi_offset 4, -8
 6932              		.cfi_offset 14, -4
 6933              		.loc 1 3387 5 view .LVU2120
 6934 0002 1148     		ldr	r0, .L587
 6935 0004 FFF7FEFF 		bl	consoleLog
 6936              	.LVL501:
3388:Src/mpu6050.c **** 
3389:Src/mpu6050.c ****     if(mpu_init()) {
 6937              		.loc 1 3389 5 is_stmt 1 view .LVU2121
 6938              		.loc 1 3389 8 is_stmt 0 view .LVU2122
 6939 0008 FFF7FEFF 		bl	mpu_init
 6940              	.LVL502:
 6941              		.loc 1 3389 7 view .LVU2123
 6942 000c 0446     		mov	r4, r0
 6943 000e 30B1     		cbz	r0, .L585
3390:Src/mpu6050.c ****         consoleLog("FAIL (MPU)\r\n");
 6944              		.loc 1 3390 9 is_stmt 1 view .LVU2124
 6945 0010 0E48     		ldr	r0, .L587+4
 6946 0012 FFF7FEFF 		bl	consoleLog
 6947              	.LVL503:
3391:Src/mpu6050.c ****         return -1;
 6948              		.loc 1 3391 9 view .LVU2125
 6949              		.loc 1 3391 16 is_stmt 0 view .LVU2126
 6950 0016 4FF0FF34 		mov	r4, #-1
 6951              	.L584:
3392:Src/mpu6050.c ****     }
3393:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 215


3394:Src/mpu6050.c ****     /* Get/set hardware configuration. Start gyro. */
3395:Src/mpu6050.c ****     /* Wake up all sensors. */
3396:Src/mpu6050.c ****     mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL);
3397:Src/mpu6050.c **** 
3398:Src/mpu6050.c ****     /* Push both gyro and accel data into the FIFO. */
3399:Src/mpu6050.c ****     mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);
3400:Src/mpu6050.c ****     mpu_set_sample_rate(MPU_DEFAULT_HZ);
3401:Src/mpu6050.c **** 
3402:Src/mpu6050.c ****     /* Read back configuration in case it was set improperly. */
3403:Src/mpu6050.c ****     // mpu_get_sample_rate(&gyro_rate);
3404:Src/mpu6050.c ****     // mpu_get_gyro_fsr(&gyro_fsr);
3405:Src/mpu6050.c ****     // mpu_get_accel_fsr(&accel_fsr);
3406:Src/mpu6050.c **** 
3407:Src/mpu6050.c ****     /* Initialize HAL state variables. */
3408:Src/mpu6050.c ****     hal.sensors             = ACCEL_ON | GYRO_ON;
3409:Src/mpu6050.c ****     hal.dmp_on              = 0;
3410:Src/mpu6050.c ****     hal.report              = 0;
3411:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
3412:Src/mpu6050.c ****     hal.next_temp_ms        = 0;
3413:Src/mpu6050.c **** 
3414:Src/mpu6050.c **** #ifdef MPU_DMP_ENABLE
3415:Src/mpu6050.c ****     /* To initialize the DMP:
3416:Src/mpu6050.c ****      * 1. Call dmp_load_motion_driver_firmware(). This pushes the DMP image in
3417:Src/mpu6050.c ****      *    inv_mpu_dmp_motion_driver.h into the MPU memory.
3418:Src/mpu6050.c ****      * 2. Push the gyro and accel orientation matrix to the DMP.
3419:Src/mpu6050.c ****      * 3. Register gesture callbacks. Don't worry, these callbacks won't be
3420:Src/mpu6050.c ****      *    executed unless the corresponding feature is enabled.
3421:Src/mpu6050.c ****      * 4. Call dmp_enable_feature(mask) to enable different features.
3422:Src/mpu6050.c ****      * 5. Call dmp_set_fifo_rate(freq) to select a DMP output rate.
3423:Src/mpu6050.c ****      * 6. Call any feature-specific control functions.
3424:Src/mpu6050.c ****      *
3425:Src/mpu6050.c ****      * To enable the DMP, just call mpu_set_dmp_state(1). This function can
3426:Src/mpu6050.c ****      * be called repeatedly to enable and disable the DMP at runtime.
3427:Src/mpu6050.c ****      *
3428:Src/mpu6050.c ****      * The following is a short summary of the features supported in the DMP
3429:Src/mpu6050.c ****      * image provided in inv_mpu_dmp_motion_driver.c:
3430:Src/mpu6050.c ****      * DMP_FEATURE_LP_QUAT: Generate a gyro-only quaternion on the DMP at
3431:Src/mpu6050.c ****      * 200Hz. Integrating the gyro data at higher rates reduces numerical
3432:Src/mpu6050.c ****      * errors (compared to integration on the MCU at a lower sampling rate).
3433:Src/mpu6050.c ****      * DMP_FEATURE_6X_LP_QUAT: Generate a gyro/accel quaternion on the DMP at
3434:Src/mpu6050.c ****      * 200Hz. Cannot be used in combination with DMP_FEATURE_LP_QUAT.
3435:Src/mpu6050.c ****      * DMP_FEATURE_TAP: Detect taps along the X, Y, and Z axes.
3436:Src/mpu6050.c ****      * DMP_FEATURE_ANDROID_ORIENT: Google's screen rotation algorithm. Triggers
3437:Src/mpu6050.c ****      * an event at the four orientations where the screen should rotate.
3438:Src/mpu6050.c ****      * DMP_FEATURE_GYRO_CAL: Calibrates the gyro data after eight seconds of
3439:Src/mpu6050.c ****      * no motion.
3440:Src/mpu6050.c ****      * DMP_FEATURE_SEND_RAW_ACCEL: Add raw accelerometer data to the FIFO.
3441:Src/mpu6050.c ****      * DMP_FEATURE_SEND_RAW_GYRO: Add raw gyro data to the FIFO.
3442:Src/mpu6050.c ****      * DMP_FEATURE_SEND_CAL_GYRO: Add calibrated gyro data to the FIFO. Cannot
3443:Src/mpu6050.c ****      * be used in combination with DMP_FEATURE_SEND_RAW_GYRO.
3444:Src/mpu6050.c ****      */
3445:Src/mpu6050.c ****         consoleLog(" writing DMP... ");
3446:Src/mpu6050.c ****         if (dmp_load_motion_driver_firmware()) {
3447:Src/mpu6050.c ****             consoleLog(" FAIL (DMP)\r\n");
3448:Src/mpu6050.c ****             return -1;
3449:Src/mpu6050.c ****         }
3450:Src/mpu6050.c ****     dmp_set_orientation(inv_orientation_matrix_to_scalar(MPU_ORIENTATION));
ARM GAS  /tmp/ccNfEN49.s 			page 216


3451:Src/mpu6050.c ****     dmp_register_tap_cb(mpu_tap_func);
3452:Src/mpu6050.c ****     dmp_register_android_orient_cb(mpu_android_orient_func);
3453:Src/mpu6050.c ****     /*
3454:Src/mpu6050.c ****      * Known Bug -
3455:Src/mpu6050.c ****      * DMP when enabled will sample sensor data at 200Hz and output to FIFO at the rate
3456:Src/mpu6050.c ****      * specified in the dmp_set_fifo_rate API. The DMP will then sent an interrupt once
3457:Src/mpu6050.c ****      * a sample has been put into the FIFO. Therefore if the dmp_set_fifo_rate is at 25Hz
3458:Src/mpu6050.c ****      * there will be a 25Hz interrupt from the MPU device.
3459:Src/mpu6050.c ****      *
3460:Src/mpu6050.c ****      * There is a known issue in which if you do not enable DMP_FEATURE_TAP
3461:Src/mpu6050.c ****      * then the interrupts will be at 200Hz even if fifo rate
3462:Src/mpu6050.c ****      * is set at a different rate. To avoid this issue include the DMP_FEATURE_TAP
3463:Src/mpu6050.c ****      *
3464:Src/mpu6050.c ****      * DMP sensor fusion works only with gyro at +-2000dps and accel +-2G
3465:Src/mpu6050.c ****      */
3466:Src/mpu6050.c ****     hal.dmp_features = 	DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT |
3467:Src/mpu6050.c ****                         DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_C
3468:Src/mpu6050.c ****     dmp_enable_feature(hal.dmp_features);
3469:Src/mpu6050.c ****     dmp_set_fifo_rate(MPU_DEFAULT_HZ);
3470:Src/mpu6050.c ****     mpu_set_dmp_state(1);
3471:Src/mpu6050.c ****     hal.dmp_on = 1;
3472:Src/mpu6050.c **** #endif
3473:Src/mpu6050.c **** 
3474:Src/mpu6050.c ****     consoleLog(" OK\r\n");	
3475:Src/mpu6050.c ****     return 0;
3476:Src/mpu6050.c **** }
 6952              		.loc 1 3476 1 view .LVU2127
 6953 001a 2046     		mov	r0, r4
 6954 001c 10BD     		pop	{r4, pc}
 6955              	.L585:
3396:Src/mpu6050.c **** 
 6956              		.loc 1 3396 5 is_stmt 1 view .LVU2128
 6957 001e 7820     		movs	r0, #120
 6958 0020 FFF7FEFF 		bl	mpu_set_sensors
 6959              	.LVL504:
3399:Src/mpu6050.c ****     mpu_set_sample_rate(MPU_DEFAULT_HZ);
 6960              		.loc 1 3399 5 view .LVU2129
 6961 0024 7820     		movs	r0, #120
 6962 0026 FFF7FEFF 		bl	mpu_configure_fifo
 6963              	.LVL505:
3400:Src/mpu6050.c **** 
 6964              		.loc 1 3400 5 view .LVU2130
 6965 002a 1420     		movs	r0, #20
 6966 002c FFF7FEFF 		bl	mpu_set_sample_rate
 6967              	.LVL506:
3408:Src/mpu6050.c ****     hal.dmp_on              = 0;
 6968              		.loc 1 3408 5 view .LVU2131
3408:Src/mpu6050.c ****     hal.dmp_on              = 0;
 6969              		.loc 1 3408 29 is_stmt 0 view .LVU2132
 6970 0030 0322     		movs	r2, #3
 6971 0032 074B     		ldr	r3, .L587+8
3474:Src/mpu6050.c ****     return 0;
 6972              		.loc 1 3474 5 view .LVU2133
 6973 0034 0748     		ldr	r0, .L587+12
3412:Src/mpu6050.c **** 
 6974              		.loc 1 3412 29 view .LVU2134
 6975 0036 C3E90344 		strd	r4, r4, [r3, #12]
ARM GAS  /tmp/ccNfEN49.s 			page 217


3408:Src/mpu6050.c ****     hal.dmp_on              = 0;
 6976              		.loc 1 3408 29 view .LVU2135
 6977 003a 5A70     		strb	r2, [r3, #1]
3409:Src/mpu6050.c ****     hal.report              = 0;
 6978              		.loc 1 3409 5 is_stmt 1 view .LVU2136
3409:Src/mpu6050.c ****     hal.report              = 0;
 6979              		.loc 1 3409 29 is_stmt 0 view .LVU2137
 6980 003c 9C70     		strb	r4, [r3, #2]
3410:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
 6981              		.loc 1 3410 5 is_stmt 1 view .LVU2138
3410:Src/mpu6050.c ****     hal.next_pedo_ms        = 0;
 6982              		.loc 1 3410 29 is_stmt 0 view .LVU2139
 6983 003e 5C61     		str	r4, [r3, #20]
3411:Src/mpu6050.c ****     hal.next_temp_ms        = 0;
 6984              		.loc 1 3411 5 is_stmt 1 view .LVU2140
3474:Src/mpu6050.c ****     return 0;
 6985              		.loc 1 3474 5 view .LVU2141
 6986 0040 FFF7FEFF 		bl	consoleLog
 6987              	.LVL507:
3475:Src/mpu6050.c **** }
 6988              		.loc 1 3475 5 view .LVU2142
3475:Src/mpu6050.c **** }
 6989              		.loc 1 3475 12 is_stmt 0 view .LVU2143
 6990 0044 E9E7     		b	.L584
 6991              	.L588:
 6992 0046 00BF     		.align	2
 6993              	.L587:
 6994 0048 00000000 		.word	.LC9
 6995 004c 18000000 		.word	.LC10
 6996 0050 00000000 		.word	.LANCHOR2
 6997 0054 25000000 		.word	.LC11
 6998              		.cfi_endproc
 6999              	.LFE113:
 7001              		.section	.text.mpu_read_gyro_raw,"ax",%progbits
 7002              		.align	1
 7003              		.global	mpu_read_gyro_raw
 7004              		.syntax unified
 7005              		.thumb
 7006              		.thumb_func
 7007              		.fpu softvfp
 7009              	mpu_read_gyro_raw:
 7010              	.LFB115:
3477:Src/mpu6050.c **** 
3478:Src/mpu6050.c **** 
3479:Src/mpu6050.c **** /* =========================== MPU-6050 Get Packet Data =========================== */
3480:Src/mpu6050.c **** 
3481:Src/mpu6050.c **** void mpu_get_data(void)
3482:Src/mpu6050.c **** {
3483:Src/mpu6050.c ****     
3484:Src/mpu6050.c ****     unsigned long sensor_timestamp;
3485:Src/mpu6050.c ****     unsigned long timestamp;
3486:Src/mpu6050.c ****     unsigned char new_data = 0, new_temp = 0;
3487:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
3488:Src/mpu6050.c **** 
3489:Src/mpu6050.c ****     // check for DMP interrupt bit or Data Ready interrupt bit (in case DMP is disabled) -> this in
3490:Src/mpu6050.c ****     i2c_readByte(st.hw->addr, st.reg->int_status, &mpu_int_status);
3491:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
ARM GAS  /tmp/ccNfEN49.s 			page 218


3492:Src/mpu6050.c ****             hal.new_gyro = 1;
3493:Src/mpu6050.c ****     }
3494:Src/mpu6050.c **** 
3495:Src/mpu6050.c ****     get_tick_count_ms(&timestamp);
3496:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
3497:Src/mpu6050.c ****      * Let's make them timer-based.
3498:Src/mpu6050.c ****      */
3499:Src/mpu6050.c ****     if (timestamp > hal.next_temp_ms) {
3500:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
3501:Src/mpu6050.c ****         new_temp = 1;
3502:Src/mpu6050.c ****     }
3503:Src/mpu6050.c **** 
3504:Src/mpu6050.c **** 
3505:Src/mpu6050.c ****     if (hal.new_gyro && hal.dmp_on) {
3506:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
3507:Src/mpu6050.c ****         static long quat[4], temperature;
3508:Src/mpu6050.c ****         unsigned char more;
3509:Src/mpu6050.c ****         /* This function gets new data from the FIFO when the DMP is in
3510:Src/mpu6050.c ****             * use. The FIFO can contain any combination of gyro, accel,
3511:Src/mpu6050.c ****             * quaternion, and gesture data. The sensors parameter tells the
3512:Src/mpu6050.c ****             * caller which data fields were actually populated with new data.
3513:Src/mpu6050.c ****             * For example, if sensors == (INV_XYZ_GYRO | INV_WXYZ_QUAT), then
3514:Src/mpu6050.c ****             * the FIFO isn't being filled with accel data.
3515:Src/mpu6050.c ****             * The driver parses the gesture data to determine if a gesture
3516:Src/mpu6050.c ****             * event has occurred; on an event, the application will be notified
3517:Src/mpu6050.c ****             * via a callback (assuming that a callback function was properly
3518:Src/mpu6050.c ****             * registered). The more parameter is non-zero if there are
3519:Src/mpu6050.c ****             * leftover packets in the FIFO.
3520:Src/mpu6050.c ****             */
3521:Src/mpu6050.c ****         dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors, &more);
3522:Src/mpu6050.c ****         if (!more)
3523:Src/mpu6050.c ****             hal.new_gyro = 0;
3524:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
3525:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
3526:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
3527:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
3528:Src/mpu6050.c ****             new_data = 1;
3529:Src/mpu6050.c ****             if (new_temp) {
3530:Src/mpu6050.c ****                 new_temp = 0;
3531:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
3532:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
3533:Src/mpu6050.c ****             }
3534:Src/mpu6050.c ****         }
3535:Src/mpu6050.c ****         if (sensors & INV_XYZ_ACCEL) {
3536:Src/mpu6050.c ****             mpu.accel.x = accel[0];
3537:Src/mpu6050.c ****             mpu.accel.y = accel[1];
3538:Src/mpu6050.c ****             mpu.accel.z = accel[2];
3539:Src/mpu6050.c ****             new_data = 1;
3540:Src/mpu6050.c ****         }
3541:Src/mpu6050.c ****         if (sensors & INV_WXYZ_QUAT) {
3542:Src/mpu6050.c ****             mpu.quat.w = quat[0];
3543:Src/mpu6050.c ****             mpu.quat.x = quat[1];
3544:Src/mpu6050.c ****             mpu.quat.y = quat[2];
3545:Src/mpu6050.c ****             mpu.quat.z = quat[3];
3546:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
3547:Src/mpu6050.c ****             new_data = 1;
3548:Src/mpu6050.c ****         }
ARM GAS  /tmp/ccNfEN49.s 			page 219


3549:Src/mpu6050.c ****     } else if (hal.new_gyro) {
3550:Src/mpu6050.c ****         short gyro[3], accel[3];
3551:Src/mpu6050.c ****         long temperature;
3552:Src/mpu6050.c ****         unsigned char sensors, more;
3553:Src/mpu6050.c ****         /* This function gets new data from the FIFO. The FIFO can contain
3554:Src/mpu6050.c ****             * gyro, accel, both, or neither. The sensors parameter tells the
3555:Src/mpu6050.c ****             * caller which data fields were actually populated with new data.
3556:Src/mpu6050.c ****             * For example, if sensors == INV_XYZ_GYRO, then the FIFO isn't
3557:Src/mpu6050.c ****             * being filled with accel data. The more parameter is non-zero if
3558:Src/mpu6050.c ****             * there are leftover packets in the FIFO. The HAL can use this
3559:Src/mpu6050.c ****             * information to increase the frequency at which this function is
3560:Src/mpu6050.c ****             * called.
3561:Src/mpu6050.c ****             */
3562:Src/mpu6050.c ****         hal.new_gyro = 0;
3563:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
3564:Src/mpu6050.c ****         if (more)
3565:Src/mpu6050.c ****             hal.new_gyro = 1;
3566:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
3567:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
3568:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
3569:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
3570:Src/mpu6050.c ****             new_data = 1;
3571:Src/mpu6050.c ****             if (new_temp) {
3572:Src/mpu6050.c ****                 new_temp = 0;
3573:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
3574:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
3575:Src/mpu6050.c ****             }
3576:Src/mpu6050.c ****         }
3577:Src/mpu6050.c ****         if (sensors & INV_XYZ_ACCEL) {
3578:Src/mpu6050.c ****             mpu.accel.x = accel[0];
3579:Src/mpu6050.c ****             mpu.accel.y = accel[1];
3580:Src/mpu6050.c ****             mpu.accel.z = accel[2];
3581:Src/mpu6050.c ****             new_data = 1;
3582:Src/mpu6050.c ****         }
3583:Src/mpu6050.c ****     }
3584:Src/mpu6050.c ****     
3585:Src/mpu6050.c ****     if (new_data) {
3586:Src/mpu6050.c ****         // do something if needed
3587:Src/mpu6050.c **** 
3588:Src/mpu6050.c ****         double dt = (sensor_timestamp - last_quat_timestamp) / 1000.0f;  // Convert ms to seconds
3589:Src/mpu6050.c ****         last_quat_timestamp = sensor_timestamp;
3590:Src/mpu6050.c **** 
3591:Src/mpu6050.c ****         madgwick_update(&imu_quaternion,
3592:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
3593:Src/mpu6050.c ****                         (double)mpu.accel.y / ACCEL_TO_G, 
3594:Src/mpu6050.c ****                         (double)mpu.accel.z / ACCEL_TO_G,
3595:Src/mpu6050.c ****                         ( (double)mpu.gyro.x / GYRO_TO_DEG_S )*( M_PI/ 180.00), 
3596:Src/mpu6050.c ****                         ( (double)mpu.gyro.y / GYRO_TO_DEG_S )*( M_PI/ 180.00),  
3597:Src/mpu6050.c ****                         ( (double)mpu.gyro.z / GYRO_TO_DEG_S )*( M_PI/ 180.00),
3598:Src/mpu6050.c ****                         dt
3599:Src/mpu6050.c ****                     );
3600:Src/mpu6050.c ****         quat_to_euler(imu_quaternion, &mpu.euler.roll, &mpu.euler.pitch, &mpu.euler.yaw);
3601:Src/mpu6050.c **** 
3602:Src/mpu6050.c **** 
3603:Src/mpu6050.c ****         mpu.quat.w = imu_quaternion.w;
3604:Src/mpu6050.c ****         mpu.quat.x = imu_quaternion.x;
3605:Src/mpu6050.c ****         mpu.quat.y = imu_quaternion.y;
ARM GAS  /tmp/ccNfEN49.s 			page 220


3606:Src/mpu6050.c ****         mpu.quat.z = imu_quaternion.z;
3607:Src/mpu6050.c ****     }   
3608:Src/mpu6050.c **** }
3609:Src/mpu6050.c **** 
3610:Src/mpu6050.c **** 
3611:Src/mpu6050.c **** /* =========================== MPU-6050 Post-processing Functions =========================== */
3612:Src/mpu6050.c **** 
3613:Src/mpu6050.c **** void mpu_read_gyro_raw(void)
3614:Src/mpu6050.c **** {
 7011              		.loc 1 3614 1 is_stmt 1 view -0
 7012              		.cfi_startproc
 7013              		@ args = 0, pretend = 0, frame = 8
 7014              		@ frame_needed = 0, uses_anonymous_args = 0
3615:Src/mpu6050.c ****     uint8_t buffer[6];
 7015              		.loc 1 3615 5 view .LVU2145
3616:Src/mpu6050.c **** 
3617:Src/mpu6050.c ****     // Read 6 BYTES of data starting from GYRO_XOUT_H register (the MPU-6050 automatically incremen
3618:Src/mpu6050.c ****     i2c_readBytes(st.hw->addr, st.reg->raw_accel, 6, buffer);
 7016              		.loc 1 3618 5 view .LVU2146
3614:Src/mpu6050.c ****     uint8_t buffer[6];
 7017              		.loc 1 3614 1 is_stmt 0 view .LVU2147
 7018 0000 07B5     		push	{r0, r1, r2, lr}
 7019              	.LCFI107:
 7020              		.cfi_def_cfa_offset 16
 7021              		.cfi_offset 14, -4
 7022              		.loc 1 3618 34 view .LVU2148
 7023 0002 0C4B     		ldr	r3, .L590
 7024              		.loc 1 3618 5 view .LVU2149
 7025 0004 0622     		movs	r2, #6
 7026 0006 D3E90010 		ldrd	r1, r0, [r3]
 7027 000a 6B46     		mov	r3, sp
 7028 000c C97B     		ldrb	r1, [r1, #15]	@ zero_extendqisi2
 7029 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 7030 0010 FFF7FEFF 		bl	i2c_readBytes
 7031              	.LVL508:
3619:Src/mpu6050.c **** 
3620:Src/mpu6050.c ****     mpu.gyro.x = (int16_t)(buffer[0] << 8 | buffer[1]);
 7032              		.loc 1 3620 5 is_stmt 1 view .LVU2150
 7033              		.loc 1 3620 16 is_stmt 0 view .LVU2151
 7034 0014 BDF80020 		ldrh	r2, [sp]
 7035 0018 074B     		ldr	r3, .L590+4
 7036 001a 52BA     		rev16	r2, r2
 7037 001c 1A80     		strh	r2, [r3]	@ movhi
3621:Src/mpu6050.c ****     mpu.gyro.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7038              		.loc 1 3621 5 is_stmt 1 view .LVU2152
 7039              		.loc 1 3621 16 is_stmt 0 view .LVU2153
 7040 001e BDF80220 		ldrh	r2, [sp, #2]
 7041 0022 52BA     		rev16	r2, r2
 7042 0024 5A80     		strh	r2, [r3, #2]	@ movhi
3622:Src/mpu6050.c ****     mpu.gyro.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7043              		.loc 1 3622 5 is_stmt 1 view .LVU2154
 7044              		.loc 1 3622 16 is_stmt 0 view .LVU2155
 7045 0026 BDF80420 		ldrh	r2, [sp, #4]
 7046 002a 52BA     		rev16	r2, r2
 7047 002c 9A80     		strh	r2, [r3, #4]	@ movhi
3623:Src/mpu6050.c **** 
3624:Src/mpu6050.c ****     /*** convert the RAW hardware units values into dps (�/s)
ARM GAS  /tmp/ccNfEN49.s 			page 221


3625:Src/mpu6050.c ****          we have to divide according to the Full scale value set in FS_SEL,
3626:Src/mpu6050.c ****          configured to 2000�/s (check MPU_GYRO_FSR). So we need to divide by 16.4 LSB/�/s
3627:Src/mpu6050.c ****          for more details check GYRO_CONFIG Register              ****/
3628:Src/mpu6050.c ****     //Gx = mpu.gyro.x / 16.4;
3629:Src/mpu6050.c ****     //Gy = mpu.gyro.y / 16.4;
3630:Src/mpu6050.c ****     //Gz = mpu.gyro.z / 16.4;
3631:Src/mpu6050.c **** }
 7048              		.loc 1 3631 1 view .LVU2156
 7049 002e 03B0     		add	sp, sp, #12
 7050              	.LCFI108:
 7051              		.cfi_def_cfa_offset 4
 7052              		@ sp needed
 7053 0030 5DF804FB 		ldr	pc, [sp], #4
 7054              	.L591:
 7055              		.align	2
 7056              	.L590:
 7057 0034 00000000 		.word	.LANCHOR0
 7058 0038 00000000 		.word	.LANCHOR3
 7059              		.cfi_endproc
 7060              	.LFE115:
 7062              		.section	.text.mpu_read_accel_raw,"ax",%progbits
 7063              		.align	1
 7064              		.global	mpu_read_accel_raw
 7065              		.syntax unified
 7066              		.thumb
 7067              		.thumb_func
 7068              		.fpu softvfp
 7070              	mpu_read_accel_raw:
 7071              	.LFB116:
3632:Src/mpu6050.c **** 
3633:Src/mpu6050.c **** 
3634:Src/mpu6050.c **** void mpu_read_accel_raw(void)
3635:Src/mpu6050.c **** {
 7072              		.loc 1 3635 1 is_stmt 1 view -0
 7073              		.cfi_startproc
 7074              		@ args = 0, pretend = 0, frame = 8
 7075              		@ frame_needed = 0, uses_anonymous_args = 0
3636:Src/mpu6050.c ****     uint8_t buffer[6];
 7076              		.loc 1 3636 5 view .LVU2158
3637:Src/mpu6050.c **** 
3638:Src/mpu6050.c ****     // Read 6 BYTES of data starting from ACCEL_XOUT_H register (the MPU-6050 automatically increme
3639:Src/mpu6050.c ****     i2c_readBytes(st.hw->addr, st.reg->raw_gyro, 6, buffer);
 7077              		.loc 1 3639 5 view .LVU2159
3635:Src/mpu6050.c ****     uint8_t buffer[6];
 7078              		.loc 1 3635 1 is_stmt 0 view .LVU2160
 7079 0000 07B5     		push	{r0, r1, r2, lr}
 7080              	.LCFI109:
 7081              		.cfi_def_cfa_offset 16
 7082              		.cfi_offset 14, -4
 7083              		.loc 1 3639 34 view .LVU2161
 7084 0002 0C4B     		ldr	r3, .L593
 7085              		.loc 1 3639 5 view .LVU2162
 7086 0004 0622     		movs	r2, #6
 7087 0006 D3E90010 		ldrd	r1, r0, [r3]
 7088 000a 6B46     		mov	r3, sp
 7089 000c 897B     		ldrb	r1, [r1, #14]	@ zero_extendqisi2
 7090 000e 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
ARM GAS  /tmp/ccNfEN49.s 			page 222


 7091 0010 FFF7FEFF 		bl	i2c_readBytes
 7092              	.LVL509:
3640:Src/mpu6050.c ****     
3641:Src/mpu6050.c ****     mpu.accel.x = (int16_t)(buffer[0] << 8 | buffer[1]);
 7093              		.loc 1 3641 5 is_stmt 1 view .LVU2163
 7094              		.loc 1 3641 17 is_stmt 0 view .LVU2164
 7095 0014 BDF80020 		ldrh	r2, [sp]
 7096 0018 074B     		ldr	r3, .L593+4
 7097 001a 52BA     		rev16	r2, r2
 7098 001c DA80     		strh	r2, [r3, #6]	@ movhi
3642:Src/mpu6050.c ****     mpu.accel.y = (int16_t)(buffer[2] << 8 | buffer[3]);
 7099              		.loc 1 3642 5 is_stmt 1 view .LVU2165
 7100              		.loc 1 3642 17 is_stmt 0 view .LVU2166
 7101 001e BDF80220 		ldrh	r2, [sp, #2]
 7102 0022 52BA     		rev16	r2, r2
 7103 0024 1A81     		strh	r2, [r3, #8]	@ movhi
3643:Src/mpu6050.c ****     mpu.accel.z = (int16_t)(buffer[4] << 8 | buffer[5]);
 7104              		.loc 1 3643 5 is_stmt 1 view .LVU2167
 7105              		.loc 1 3643 17 is_stmt 0 view .LVU2168
 7106 0026 BDF80420 		ldrh	r2, [sp, #4]
 7107 002a 52BA     		rev16	r2, r2
 7108 002c 5A81     		strh	r2, [r3, #10]	@ movhi
3644:Src/mpu6050.c **** 
3645:Src/mpu6050.c **** 
3646:Src/mpu6050.c ****     /*** convert the RAW hardware units into acceleration in 'g'
3647:Src/mpu6050.c ****          we have to divide according to the Full scale value set in FS_SEL,
3648:Src/mpu6050.c ****          configured to 2g (check MPU_ACCEL_FSR). So we need to divide by 16384.0 LSB/g
3649:Src/mpu6050.c ****          for more details check ACCEL_CONFIG Register              ****/
3650:Src/mpu6050.c ****     //Ax = mpu.accel.x / 16384.0;
3651:Src/mpu6050.c ****     //Ay = mpu.accel.y / 16384.0;
3652:Src/mpu6050.c ****     //Az = mpu.accel.z / 16384.0;
3653:Src/mpu6050.c **** }
 7109              		.loc 1 3653 1 view .LVU2169
 7110 002e 03B0     		add	sp, sp, #12
 7111              	.LCFI110:
 7112              		.cfi_def_cfa_offset 4
 7113              		@ sp needed
 7114 0030 5DF804FB 		ldr	pc, [sp], #4
 7115              	.L594:
 7116              		.align	2
 7117              	.L593:
 7118 0034 00000000 		.word	.LANCHOR0
 7119 0038 00000000 		.word	.LANCHOR3
 7120              		.cfi_endproc
 7121              	.LFE116:
 7123              		.global	__aeabi_f2d
 7124              		.global	__aeabi_d2f
 7125              		.global	__aeabi_dmul
 7126              		.global	__aeabi_d2iz
 7127              		.section	.text.mpu_calc_euler_angles,"ax",%progbits
 7128              		.align	1
 7129              		.global	mpu_calc_euler_angles
 7130              		.syntax unified
 7131              		.thumb
 7132              		.thumb_func
 7133              		.fpu softvfp
 7135              	mpu_calc_euler_angles:
ARM GAS  /tmp/ccNfEN49.s 			page 223


 7136              	.LFB117:
3654:Src/mpu6050.c **** 
3655:Src/mpu6050.c **** /*
3656:Src/mpu6050.c ****  * Calculate Euler Angles
3657:Src/mpu6050.c ****  * aerospace sequence, to obtain sensor attitude:
3658:Src/mpu6050.c ****  * 1. roll  (x-axis rotation)
3659:Src/mpu6050.c ****  * 2. pitch (y-axis rotation)
3660:Src/mpu6050.c ****  * 3. yaw   (z-axis rotation)
3661:Src/mpu6050.c ****  */
3662:Src/mpu6050.c **** void mpu_calc_euler_angles(void) {
 7137              		.loc 1 3662 34 is_stmt 1 view -0
 7138              		.cfi_startproc
 7139              		@ args = 0, pretend = 0, frame = 16
 7140              		@ frame_needed = 0, uses_anonymous_args = 0
3663:Src/mpu6050.c ****     
3664:Src/mpu6050.c ****     float w, x, y, z;
 7141              		.loc 1 3664 5 view .LVU2171
3665:Src/mpu6050.c ****     float yaw, pitch, roll;
 7142              		.loc 1 3665 5 view .LVU2172
3666:Src/mpu6050.c **** 
3667:Src/mpu6050.c ****     // Convert quaternions[q30] to quaternion[float]
3668:Src/mpu6050.c ****     w = (float)mpu.quat.w / q30;        // q30 = 2^30
 7143              		.loc 1 3668 5 view .LVU2173
3662:Src/mpu6050.c ****     
 7144              		.loc 1 3662 34 is_stmt 0 view .LVU2174
 7145 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7146              	.LCFI111:
 7147              		.cfi_def_cfa_offset 36
 7148              		.cfi_offset 4, -36
 7149              		.cfi_offset 5, -32
 7150              		.cfi_offset 6, -28
 7151              		.cfi_offset 7, -24
 7152              		.cfi_offset 8, -20
 7153              		.cfi_offset 9, -16
 7154              		.cfi_offset 10, -12
 7155              		.cfi_offset 11, -8
 7156              		.cfi_offset 14, -4
 7157              		.loc 1 3668 24 view .LVU2175
 7158 0004 6A4C     		ldr	r4, .L596+8
3662:Src/mpu6050.c ****     
 7159              		.loc 1 3662 34 view .LVU2176
 7160 0006 85B0     		sub	sp, sp, #20
 7161              	.LCFI112:
 7162              		.cfi_def_cfa_offset 56
 7163              		.loc 1 3668 9 view .LVU2177
 7164 0008 E068     		ldr	r0, [r4, #12]
 7165 000a FFF7FEFF 		bl	__aeabi_i2f
 7166              	.LVL510:
 7167              		.loc 1 3668 7 view .LVU2178
 7168 000e 4FF04251 		mov	r1, #813694976
 7169 0012 FFF7FEFF 		bl	__aeabi_fmul
 7170              	.LVL511:
 7171 0016 8246     		mov	r10, r0
 7172              	.LVL512:
3669:Src/mpu6050.c ****     x = (float)mpu.quat.x / q30;
 7173              		.loc 1 3669 5 is_stmt 1 view .LVU2179
 7174              		.loc 1 3669 9 is_stmt 0 view .LVU2180
ARM GAS  /tmp/ccNfEN49.s 			page 224


 7175 0018 2069     		ldr	r0, [r4, #16]
 7176              	.LVL513:
 7177              		.loc 1 3669 9 view .LVU2181
 7178 001a FFF7FEFF 		bl	__aeabi_i2f
 7179              	.LVL514:
 7180              		.loc 1 3669 7 view .LVU2182
 7181 001e 4FF04251 		mov	r1, #813694976
 7182 0022 FFF7FEFF 		bl	__aeabi_fmul
 7183              	.LVL515:
 7184 0026 0546     		mov	r5, r0
 7185              	.LVL516:
3670:Src/mpu6050.c ****     y = (float)mpu.quat.y / q30;
 7186              		.loc 1 3670 5 is_stmt 1 view .LVU2183
 7187              		.loc 1 3670 9 is_stmt 0 view .LVU2184
 7188 0028 6069     		ldr	r0, [r4, #20]
 7189              	.LVL517:
 7190              		.loc 1 3670 9 view .LVU2185
 7191 002a FFF7FEFF 		bl	__aeabi_i2f
 7192              	.LVL518:
 7193              		.loc 1 3670 7 view .LVU2186
 7194 002e 4FF04251 		mov	r1, #813694976
 7195 0032 FFF7FEFF 		bl	__aeabi_fmul
 7196              	.LVL519:
 7197 0036 0646     		mov	r6, r0
 7198              	.LVL520:
3671:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7199              		.loc 1 3671 5 is_stmt 1 view .LVU2187
 7200              		.loc 1 3671 9 is_stmt 0 view .LVU2188
 7201 0038 A069     		ldr	r0, [r4, #24]
 7202              	.LVL521:
 7203              		.loc 1 3671 9 view .LVU2189
 7204 003a FFF7FEFF 		bl	__aeabi_i2f
 7205              	.LVL522:
 7206              		.loc 1 3671 7 view .LVU2190
 7207 003e 4FF04251 		mov	r1, #813694976
 7208 0042 FFF7FEFF 		bl	__aeabi_fmul
 7209              	.LVL523:
3672:Src/mpu6050.c **** 
3673:Src/mpu6050.c ****     // Calculate Euler angles: source <https://en.wikipedia.org/wiki/Conversion_between_quaternions
3674:Src/mpu6050.c ****     roll    = atan2(2*(w*x + y*z), 1 - 2*(x*x + y*y));      // roll  (x-axis rotation)
 7210              		.loc 1 3674 50 view .LVU2191
 7211 0046 3146     		mov	r1, r6
3671:Src/mpu6050.c ****     z = (float)mpu.quat.z / q30;
 7212              		.loc 1 3671 7 view .LVU2192
 7213 0048 0746     		mov	r7, r0
 7214              	.LVL524:
 7215              		.loc 1 3674 5 is_stmt 1 view .LVU2193
 7216              		.loc 1 3674 50 is_stmt 0 view .LVU2194
 7217 004a 3046     		mov	r0, r6
 7218              	.LVL525:
 7219              		.loc 1 3674 50 view .LVU2195
 7220 004c FFF7FEFF 		bl	__aeabi_fmul
 7221              	.LVL526:
 7222 0050 8346     		mov	fp, r0
 7223              		.loc 1 3674 44 view .LVU2196
 7224 0052 2946     		mov	r1, r5
 7225 0054 2846     		mov	r0, r5
ARM GAS  /tmp/ccNfEN49.s 			page 225


 7226 0056 FFF7FEFF 		bl	__aeabi_fmul
 7227              	.LVL527:
 7228              		.loc 1 3674 47 view .LVU2197
 7229 005a 5946     		mov	r1, fp
 7230 005c FFF7FEFF 		bl	__aeabi_fadd
 7231              	.LVL528:
 7232 0060 0146     		mov	r1, r0
 7233              		.loc 1 3674 41 view .LVU2198
 7234 0062 FFF7FEFF 		bl	__aeabi_fadd
 7235              	.LVL529:
 7236 0066 0146     		mov	r1, r0
 7237              		.loc 1 3674 38 view .LVU2199
 7238 0068 4FF07E50 		mov	r0, #1065353216
 7239 006c FFF7FEFF 		bl	__aeabi_fsub
 7240              	.LVL530:
 7241              		.loc 1 3674 15 view .LVU2200
 7242 0070 FFF7FEFF 		bl	__aeabi_f2d
 7243              	.LVL531:
 7244 0074 8046     		mov	r8, r0
 7245 0076 8946     		mov	r9, r1
 7246              		.loc 1 3674 25 view .LVU2201
 7247 0078 5046     		mov	r0, r10
 7248 007a 2946     		mov	r1, r5
 7249 007c FFF7FEFF 		bl	__aeabi_fmul
 7250              	.LVL532:
 7251              		.loc 1 3674 31 view .LVU2202
 7252 0080 3946     		mov	r1, r7
 7253              		.loc 1 3674 25 view .LVU2203
 7254 0082 0090     		str	r0, [sp]
 7255              		.loc 1 3674 31 view .LVU2204
 7256 0084 3046     		mov	r0, r6
 7257 0086 FFF7FEFF 		bl	__aeabi_fmul
 7258              	.LVL533:
 7259              		.loc 1 3674 28 view .LVU2205
 7260 008a 009B     		ldr	r3, [sp]
 7261              		.loc 1 3674 31 view .LVU2206
 7262 008c 0146     		mov	r1, r0
 7263              		.loc 1 3674 28 view .LVU2207
 7264 008e 1846     		mov	r0, r3
 7265 0090 FFF7FEFF 		bl	__aeabi_fadd
 7266              	.LVL534:
 7267 0094 0146     		mov	r1, r0
 7268              		.loc 1 3674 22 view .LVU2208
 7269 0096 FFF7FEFF 		bl	__aeabi_fadd
 7270              	.LVL535:
 7271              		.loc 1 3674 15 view .LVU2209
 7272 009a FFF7FEFF 		bl	__aeabi_f2d
 7273              	.LVL536:
 7274 009e 4246     		mov	r2, r8
 7275 00a0 4B46     		mov	r3, r9
 7276 00a2 FFF7FEFF 		bl	atan2
 7277              	.LVL537:
 7278 00a6 8046     		mov	r8, r0
 7279 00a8 8946     		mov	r9, r1
 7280              	.LVL538:
3675:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7281              		.loc 1 3675 5 is_stmt 1 view .LVU2210
ARM GAS  /tmp/ccNfEN49.s 			page 226


 7282              		.loc 1 3675 24 is_stmt 0 view .LVU2211
 7283 00aa 5046     		mov	r0, r10
 7284 00ac 3146     		mov	r1, r6
 7285 00ae FFF7FEFF 		bl	__aeabi_fmul
 7286              	.LVL539:
 7287              		.loc 1 3675 30 view .LVU2212
 7288 00b2 3946     		mov	r1, r7
 7289              		.loc 1 3675 24 view .LVU2213
 7290 00b4 0090     		str	r0, [sp]
 7291              		.loc 1 3675 30 view .LVU2214
 7292 00b6 2846     		mov	r0, r5
 7293 00b8 FFF7FEFF 		bl	__aeabi_fmul
 7294              	.LVL540:
 7295              		.loc 1 3675 27 view .LVU2215
 7296 00bc 009B     		ldr	r3, [sp]
 7297              		.loc 1 3675 30 view .LVU2216
 7298 00be 0146     		mov	r1, r0
 7299              		.loc 1 3675 27 view .LVU2217
 7300 00c0 1846     		mov	r0, r3
 7301 00c2 FFF7FEFF 		bl	__aeabi_fsub
 7302              	.LVL541:
 7303 00c6 0146     		mov	r1, r0
 7304              		.loc 1 3675 21 view .LVU2218
 7305 00c8 FFF7FEFF 		bl	__aeabi_fadd
 7306              	.LVL542:
 7307              		.loc 1 3675 15 view .LVU2219
 7308 00cc FFF7FEFF 		bl	__aeabi_f2d
 7309              	.LVL543:
 7310 00d0 FFF7FEFF 		bl	asin
 7311              	.LVL544:
 7312 00d4 CDE90001 		strd	r0, [sp]
 7313              	.LVL545:
3676:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7314              		.loc 1 3676 5 is_stmt 1 view .LVU2220
 7315              		.loc 1 3676 50 is_stmt 0 view .LVU2221
 7316 00d8 3946     		mov	r1, r7
 7317 00da 3846     		mov	r0, r7
 7318              	.LVL546:
 7319              		.loc 1 3676 50 view .LVU2222
 7320 00dc FFF7FEFF 		bl	__aeabi_fmul
 7321              	.LVL547:
 7322              		.loc 1 3676 47 view .LVU2223
 7323 00e0 5946     		mov	r1, fp
 7324 00e2 FFF7FEFF 		bl	__aeabi_fadd
 7325              	.LVL548:
 7326 00e6 0146     		mov	r1, r0
 7327              		.loc 1 3676 41 view .LVU2224
 7328 00e8 FFF7FEFF 		bl	__aeabi_fadd
 7329              	.LVL549:
 7330 00ec 0146     		mov	r1, r0
 7331              		.loc 1 3676 38 view .LVU2225
 7332 00ee 4FF07E50 		mov	r0, #1065353216
 7333 00f2 FFF7FEFF 		bl	__aeabi_fsub
 7334              	.LVL550:
 7335              		.loc 1 3676 15 view .LVU2226
 7336 00f6 FFF7FEFF 		bl	__aeabi_f2d
 7337              	.LVL551:
ARM GAS  /tmp/ccNfEN49.s 			page 227


 7338 00fa 0246     		mov	r2, r0
 7339 00fc 0B46     		mov	r3, r1
 7340              		.loc 1 3676 25 view .LVU2227
 7341 00fe 5046     		mov	r0, r10
 7342 0100 3946     		mov	r1, r7
 7343              		.loc 1 3676 15 view .LVU2228
 7344 0102 CDE90223 		strd	r2, [sp, #8]
 7345              		.loc 1 3676 25 view .LVU2229
 7346 0106 FFF7FEFF 		bl	__aeabi_fmul
 7347              	.LVL552:
 7348              		.loc 1 3676 31 view .LVU2230
 7349 010a 3146     		mov	r1, r6
 7350              		.loc 1 3676 25 view .LVU2231
 7351 010c 0746     		mov	r7, r0
 7352              	.LVL553:
 7353              		.loc 1 3676 31 view .LVU2232
 7354 010e 2846     		mov	r0, r5
 7355 0110 FFF7FEFF 		bl	__aeabi_fmul
 7356              	.LVL554:
 7357 0114 0146     		mov	r1, r0
 7358              		.loc 1 3676 28 view .LVU2233
 7359 0116 3846     		mov	r0, r7
 7360 0118 FFF7FEFF 		bl	__aeabi_fadd
 7361              	.LVL555:
 7362 011c 0146     		mov	r1, r0
 7363              		.loc 1 3676 22 view .LVU2234
 7364 011e FFF7FEFF 		bl	__aeabi_fadd
 7365              	.LVL556:
 7366              		.loc 1 3676 15 view .LVU2235
 7367 0122 FFF7FEFF 		bl	__aeabi_f2d
 7368              	.LVL557:
 7369 0126 DDE90223 		ldrd	r2, [sp, #8]
 7370 012a FFF7FEFF 		bl	atan2
 7371              	.LVL558:
 7372 012e 0646     		mov	r6, r0
 7373              	.LVL559:
 7374              		.loc 1 3676 15 view .LVU2236
 7375 0130 0F46     		mov	r7, r1
 7376              	.LVL560:
3677:Src/mpu6050.c **** 
3678:Src/mpu6050.c ****     // Convert [rad] to [deg*100]
3679:Src/mpu6050.c ****     mpu.euler.roll  = (int16_t)(roll  * RAD2DEG * 100);
 7377              		.loc 1 3679 5 is_stmt 1 view .LVU2237
3674:Src/mpu6050.c ****     pitch   = asin(2*(w*y - z*x));                          // pitch (y-axis rotation)
 7378              		.loc 1 3674 13 is_stmt 0 view .LVU2238
 7379 0132 4046     		mov	r0, r8
 7380 0134 4946     		mov	r1, r9
 7381 0136 FFF7FEFF 		bl	__aeabi_d2f
 7382              	.LVL561:
 7383              		.loc 1 3679 39 view .LVU2239
 7384 013a FFF7FEFF 		bl	__aeabi_f2d
 7385              	.LVL562:
 7386 013e 1AA3     		adr	r3, .L596
 7387 0140 D3E90023 		ldrd	r2, [r3]
 7388 0144 FFF7FEFF 		bl	__aeabi_dmul
 7389              	.LVL563:
 7390              		.loc 1 3679 49 view .LVU2240
ARM GAS  /tmp/ccNfEN49.s 			page 228


 7391 0148 0022     		movs	r2, #0
 7392 014a 1A4B     		ldr	r3, .L596+12
 7393 014c FFF7FEFF 		bl	__aeabi_dmul
 7394              	.LVL564:
 7395              		.loc 1 3679 23 view .LVU2241
 7396 0150 FFF7FEFF 		bl	__aeabi_d2iz
 7397              	.LVL565:
 7398 0154 A083     		strh	r0, [r4, #28]	@ movhi
3680:Src/mpu6050.c ****     mpu.euler.pitch = (int16_t)(pitch * RAD2DEG * 100);
 7399              		.loc 1 3680 5 is_stmt 1 view .LVU2242
3675:Src/mpu6050.c ****     yaw     = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z));      // yaw   (z-axis rotation)
 7400              		.loc 1 3675 13 is_stmt 0 view .LVU2243
 7401 0156 DDE90001 		ldrd	r0, [sp]
 7402 015a FFF7FEFF 		bl	__aeabi_d2f
 7403              	.LVL566:
 7404              		.loc 1 3680 39 view .LVU2244
 7405 015e FFF7FEFF 		bl	__aeabi_f2d
 7406              	.LVL567:
 7407 0162 11A3     		adr	r3, .L596
 7408 0164 D3E90023 		ldrd	r2, [r3]
 7409 0168 FFF7FEFF 		bl	__aeabi_dmul
 7410              	.LVL568:
 7411              		.loc 1 3680 49 view .LVU2245
 7412 016c 0022     		movs	r2, #0
 7413 016e 114B     		ldr	r3, .L596+12
 7414 0170 FFF7FEFF 		bl	__aeabi_dmul
 7415              	.LVL569:
 7416              		.loc 1 3680 23 view .LVU2246
 7417 0174 FFF7FEFF 		bl	__aeabi_d2iz
 7418              	.LVL570:
3676:Src/mpu6050.c **** 
 7419              		.loc 1 3676 13 view .LVU2247
 7420 0178 3946     		mov	r1, r7
 7421              		.loc 1 3680 23 view .LVU2248
 7422 017a E083     		strh	r0, [r4, #30]	@ movhi
3681:Src/mpu6050.c ****     mpu.euler.yaw   = (int16_t)(yaw   * RAD2DEG * 100);
 7423              		.loc 1 3681 5 is_stmt 1 view .LVU2249
3676:Src/mpu6050.c **** 
 7424              		.loc 1 3676 13 is_stmt 0 view .LVU2250
 7425 017c 3046     		mov	r0, r6
 7426 017e FFF7FEFF 		bl	__aeabi_d2f
 7427              	.LVL571:
 7428              		.loc 1 3681 39 view .LVU2251
 7429 0182 FFF7FEFF 		bl	__aeabi_f2d
 7430              	.LVL572:
 7431 0186 08A3     		adr	r3, .L596
 7432 0188 D3E90023 		ldrd	r2, [r3]
 7433 018c FFF7FEFF 		bl	__aeabi_dmul
 7434              	.LVL573:
 7435              		.loc 1 3681 49 view .LVU2252
 7436 0190 0022     		movs	r2, #0
 7437 0192 084B     		ldr	r3, .L596+12
 7438 0194 FFF7FEFF 		bl	__aeabi_dmul
 7439              	.LVL574:
 7440              		.loc 1 3681 23 view .LVU2253
 7441 0198 FFF7FEFF 		bl	__aeabi_d2iz
 7442              	.LVL575:
ARM GAS  /tmp/ccNfEN49.s 			page 229


 7443 019c 2084     		strh	r0, [r4, #32]	@ movhi
3682:Src/mpu6050.c ****     
3683:Src/mpu6050.c **** }
 7444              		.loc 1 3683 1 view .LVU2254
 7445 019e 05B0     		add	sp, sp, #20
 7446              	.LCFI113:
 7447              		.cfi_def_cfa_offset 36
 7448              	.LVL576:
 7449              		.loc 1 3683 1 view .LVU2255
 7450              		@ sp needed
 7451 01a0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 7452              	.LVL577:
 7453              	.L597:
 7454              		.loc 1 3683 1 view .LVU2256
 7455 01a4 AFF30080 		.align	3
 7456              	.L596:
 7457 01a8 F8C1631A 		.word	442745336
 7458 01ac DCA54C40 		.word	1078765020
 7459 01b0 00000000 		.word	.LANCHOR3
 7460 01b4 00005940 		.word	1079574528
 7461              		.cfi_endproc
 7462              	.LFE117:
 7464              		.global	__aeabi_ui2d
 7465              		.global	__aeabi_dsub
 7466              		.global	__aeabi_ddiv
 7467              		.global	__aeabi_i2d
 7468              		.section	.text.mpu_get_data,"ax",%progbits
 7469              		.align	1
 7470              		.global	mpu_get_data
 7471              		.syntax unified
 7472              		.thumb
 7473              		.thumb_func
 7474              		.fpu softvfp
 7476              	mpu_get_data:
 7477              	.LFB114:
3482:Src/mpu6050.c ****     
 7478              		.loc 1 3482 1 is_stmt 1 view -0
 7479              		.cfi_startproc
 7480              		@ args = 0, pretend = 0, frame = 32
 7481              		@ frame_needed = 0, uses_anonymous_args = 0
3484:Src/mpu6050.c ****     unsigned long timestamp;
 7482              		.loc 1 3484 5 view .LVU2258
3485:Src/mpu6050.c ****     unsigned char new_data = 0, new_temp = 0;
 7483              		.loc 1 3485 5 view .LVU2259
3486:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7484              		.loc 1 3486 5 view .LVU2260
 7485              	.LVL578:
3487:Src/mpu6050.c **** 
 7486              		.loc 1 3487 5 view .LVU2261
3490:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7487              		.loc 1 3490 5 view .LVU2262
3482:Src/mpu6050.c ****     
 7488              		.loc 1 3482 1 is_stmt 0 view .LVU2263
 7489 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 7490              	.LCFI114:
 7491              		.cfi_def_cfa_offset 28
 7492              		.cfi_offset 4, -28
ARM GAS  /tmp/ccNfEN49.s 			page 230


 7493              		.cfi_offset 5, -24
 7494              		.cfi_offset 6, -20
 7495              		.cfi_offset 7, -16
 7496              		.cfi_offset 8, -12
 7497              		.cfi_offset 9, -8
 7498              		.cfi_offset 14, -4
3490:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7499              		.loc 1 3490 33 view .LVU2264
 7500 0004 A24B     		ldr	r3, .L642+16
3482:Src/mpu6050.c ****     
 7501              		.loc 1 3482 1 view .LVU2265
 7502 0006 95B0     		sub	sp, sp, #84
 7503              	.LCFI115:
 7504              		.cfi_def_cfa_offset 112
3490:Src/mpu6050.c ****     if (mpu_int_status & MPU_INT_STATUS_DMP || mpu_int_status & MPU_INT_STATUS_DATA_READY) {
 7505              		.loc 1 3490 5 view .LVU2266
 7506 0008 D3E90013 		ldrd	r1, r3, [r3]
 7507 000c 0DF13102 		add	r2, sp, #49
 7508 0010 C97C     		ldrb	r1, [r1, #19]	@ zero_extendqisi2
 7509 0012 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 7510 0014 FFF7FEFF 		bl	i2c_readByte
 7511              	.LVL579:
3491:Src/mpu6050.c ****             hal.new_gyro = 1;
 7512              		.loc 1 3491 5 is_stmt 1 view .LVU2267
3491:Src/mpu6050.c ****             hal.new_gyro = 1;
 7513              		.loc 1 3491 8 is_stmt 0 view .LVU2268
 7514 0018 9DF83130 		ldrb	r3, [sp, #49]	@ zero_extendqisi2
 7515 001c 9D4C     		ldr	r4, .L642+20
3492:Src/mpu6050.c ****     }
 7516              		.loc 1 3492 13 is_stmt 1 view .LVU2269
3491:Src/mpu6050.c ****             hal.new_gyro = 1;
 7517              		.loc 1 3491 8 is_stmt 0 view .LVU2270
 7518 001e 13F0030F 		tst	r3, #3
3492:Src/mpu6050.c ****     }
 7519              		.loc 1 3492 26 view .LVU2271
 7520 0022 18BF     		it	ne
 7521 0024 0123     		movne	r3, #1
3495:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
 7522              		.loc 1 3495 5 view .LVU2272
 7523 0026 0EA8     		add	r0, sp, #56
3492:Src/mpu6050.c ****     }
 7524              		.loc 1 3492 26 view .LVU2273
 7525 0028 18BF     		it	ne
 7526 002a 2371     		strbne	r3, [r4, #4]
3495:Src/mpu6050.c ****     /* Temperature data doesn't need to be read with every gyro sample.
 7527              		.loc 1 3495 5 is_stmt 1 view .LVU2274
 7528 002c FFF7FEFF 		bl	get_tick_count_ms
 7529              	.LVL580:
3499:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7530              		.loc 1 3499 5 view .LVU2275
3499:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7531              		.loc 1 3499 19 is_stmt 0 view .LVU2276
 7532 0030 0E9B     		ldr	r3, [sp, #56]
3499:Src/mpu6050.c ****         hal.next_temp_ms = timestamp + TEMP_READ_MS;
 7533              		.loc 1 3499 8 view .LVU2277
 7534 0032 2269     		ldr	r2, [r4, #16]
 7535 0034 9A42     		cmp	r2, r3
ARM GAS  /tmp/ccNfEN49.s 			page 231


3500:Src/mpu6050.c ****         new_temp = 1;
 7536              		.loc 1 3500 9 is_stmt 1 view .LVU2278
3500:Src/mpu6050.c ****         new_temp = 1;
 7537              		.loc 1 3500 38 is_stmt 0 view .LVU2279
 7538 0036 3CBF     		itt	cc
 7539 0038 03F5FA73 		addcc	r3, r3, #500
3500:Src/mpu6050.c ****         new_temp = 1;
 7540              		.loc 1 3500 26 view .LVU2280
 7541 003c 2361     		strcc	r3, [r4, #16]
3501:Src/mpu6050.c ****     }
 7542              		.loc 1 3501 9 is_stmt 1 view .LVU2281
 7543              	.LVL581:
3505:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7544              		.loc 1 3505 12 is_stmt 0 view .LVU2282
 7545 003e 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
3501:Src/mpu6050.c ****     }
 7546              		.loc 1 3501 18 view .LVU2283
 7547 0040 34BF     		ite	cc
 7548 0042 0125     		movcc	r5, #1
3486:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7549              		.loc 1 3486 33 view .LVU2284
 7550 0044 0025     		movcs	r5, #0
 7551              	.LVL582:
3505:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7552              		.loc 1 3505 5 is_stmt 1 view .LVU2285
3505:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7553              		.loc 1 3505 8 is_stmt 0 view .LVU2286
 7554 0046 002B     		cmp	r3, #0
 7555 0048 00F0D880 		beq	.L601
3505:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7556              		.loc 1 3505 22 discriminator 1 view .LVU2287
 7557 004c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 7558 004e 002B     		cmp	r3, #0
 7559 0050 00F0D480 		beq	.L601
 7560              	.LBB52:
3506:Src/mpu6050.c ****         static long quat[4], temperature;
 7561              		.loc 1 3506 9 is_stmt 1 view .LVU2288
3507:Src/mpu6050.c ****         unsigned char more;
 7562              		.loc 1 3507 9 view .LVU2289
3508:Src/mpu6050.c ****         /* This function gets new data from the FIFO when the DMP is in
 7563              		.loc 1 3508 9 view .LVU2290
3521:Src/mpu6050.c ****         if (!more)
 7564              		.loc 1 3521 9 view .LVU2291
 7565 0054 0DF13303 		add	r3, sp, #51
 7566 0058 0193     		str	r3, [sp, #4]
 7567 005a 0FAB     		add	r3, sp, #60
 7568 005c 0093     		str	r3, [sp]
 7569 005e 8E4A     		ldr	r2, .L642+24
 7570 0060 0DAB     		add	r3, sp, #52
 7571 0062 12A9     		add	r1, sp, #72
 7572 0064 10A8     		add	r0, sp, #64
 7573 0066 FFF7FEFF 		bl	dmp_read_fifo
 7574              	.LVL583:
3522:Src/mpu6050.c ****             hal.new_gyro = 0;
 7575              		.loc 1 3522 9 view .LVU2292
3522:Src/mpu6050.c ****             hal.new_gyro = 0;
 7576              		.loc 1 3522 12 is_stmt 0 view .LVU2293
ARM GAS  /tmp/ccNfEN49.s 			page 232


 7577 006a 9DF83330 		ldrb	r3, [sp, #51]	@ zero_extendqisi2
 7578 006e 03B9     		cbnz	r3, .L602
3523:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7579              		.loc 1 3523 13 is_stmt 1 view .LVU2294
3523:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7580              		.loc 1 3523 26 is_stmt 0 view .LVU2295
 7581 0070 2371     		strb	r3, [r4, #4]
 7582              	.L602:
3524:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7583              		.loc 1 3524 9 is_stmt 1 view .LVU2296
3524:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7584              		.loc 1 3524 12 is_stmt 0 view .LVU2297
 7585 0072 BDF83C30 		ldrh	r3, [sp, #60]
 7586 0076 13F07003 		ands	r3, r3, #112
 7587 007a 00F0B480 		beq	.L615
3525:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7588              		.loc 1 3525 13 is_stmt 1 view .LVU2298
3525:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7589              		.loc 1 3525 24 is_stmt 0 view .LVU2299
 7590 007e 874C     		ldr	r4, .L642+28
 7591 0080 BDF84030 		ldrh	r3, [sp, #64]
 7592 0084 2380     		strh	r3, [r4]	@ movhi
3526:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7593              		.loc 1 3526 13 is_stmt 1 view .LVU2300
3526:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7594              		.loc 1 3526 24 is_stmt 0 view .LVU2301
 7595 0086 BDF84230 		ldrh	r3, [sp, #66]
 7596 008a 6380     		strh	r3, [r4, #2]	@ movhi
3527:Src/mpu6050.c ****             new_data = 1;
 7597              		.loc 1 3527 13 is_stmt 1 view .LVU2302
3527:Src/mpu6050.c ****             new_data = 1;
 7598              		.loc 1 3527 24 is_stmt 0 view .LVU2303
 7599 008c BDF84430 		ldrh	r3, [sp, #68]
 7600 0090 A380     		strh	r3, [r4, #4]	@ movhi
3528:Src/mpu6050.c ****             if (new_temp) {
 7601              		.loc 1 3528 13 is_stmt 1 view .LVU2304
 7602              	.LVL584:
3529:Src/mpu6050.c ****                 new_temp = 0;
 7603              		.loc 1 3529 13 view .LVU2305
3529:Src/mpu6050.c ****                 new_temp = 0;
 7604              		.loc 1 3529 16 is_stmt 0 view .LVU2306
 7605 0092 002D     		cmp	r5, #0
 7606 0094 00F0A980 		beq	.L616
3530:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
 7607              		.loc 1 3530 17 is_stmt 1 view .LVU2307
 7608              	.LVL585:
3531:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
 7609              		.loc 1 3531 17 view .LVU2308
 7610 0098 814E     		ldr	r6, .L642+32
 7611 009a 0DA9     		add	r1, sp, #52
 7612 009c 3046     		mov	r0, r6
 7613 009e FFF7FEFF 		bl	mpu_get_temperature
 7614              	.LVL586:
3532:Src/mpu6050.c ****             }
 7615              		.loc 1 3532 17 view .LVU2309
3532:Src/mpu6050.c ****             }
 7616              		.loc 1 3532 50 is_stmt 0 view .LVU2310
ARM GAS  /tmp/ccNfEN49.s 			page 233


 7617 00a2 6422     		movs	r2, #100
 7618 00a4 3368     		ldr	r3, [r6]
 7619 00a6 5343     		muls	r3, r2, r3
3532:Src/mpu6050.c ****             }
 7620              		.loc 1 3532 56 view .LVU2311
 7621 00a8 1B14     		asrs	r3, r3, #16
3532:Src/mpu6050.c ****             }
 7622              		.loc 1 3532 28 view .LVU2312
 7623 00aa 6384     		strh	r3, [r4, #34]	@ movhi
 7624              	.LVL587:
 7625              	.L603:
3535:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7626              		.loc 1 3535 9 is_stmt 1 view .LVU2313
3535:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7627              		.loc 1 3535 21 is_stmt 0 view .LVU2314
 7628 00ac BDF83C20 		ldrh	r2, [sp, #60]
3535:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7629              		.loc 1 3535 12 view .LVU2315
 7630 00b0 1007     		lsls	r0, r2, #28
 7631 00b2 0AD5     		bpl	.L604
3536:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7632              		.loc 1 3536 13 is_stmt 1 view .LVU2316
3539:Src/mpu6050.c ****         }
 7633              		.loc 1 3539 22 is_stmt 0 view .LVU2317
 7634 00b4 0125     		movs	r5, #1
 7635              	.LVL588:
3536:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7636              		.loc 1 3536 25 view .LVU2318
 7637 00b6 794B     		ldr	r3, .L642+28
 7638 00b8 BDF84810 		ldrh	r1, [sp, #72]
 7639 00bc D980     		strh	r1, [r3, #6]	@ movhi
3537:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7640              		.loc 1 3537 13 is_stmt 1 view .LVU2319
3537:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7641              		.loc 1 3537 25 is_stmt 0 view .LVU2320
 7642 00be BDF84A10 		ldrh	r1, [sp, #74]
 7643 00c2 1981     		strh	r1, [r3, #8]	@ movhi
3538:Src/mpu6050.c ****             new_data = 1;
 7644              		.loc 1 3538 13 is_stmt 1 view .LVU2321
3538:Src/mpu6050.c ****             new_data = 1;
 7645              		.loc 1 3538 25 is_stmt 0 view .LVU2322
 7646 00c4 BDF84C10 		ldrh	r1, [sp, #76]
 7647 00c8 5981     		strh	r1, [r3, #10]	@ movhi
3539:Src/mpu6050.c ****         }
 7648              		.loc 1 3539 13 is_stmt 1 view .LVU2323
 7649              	.LVL589:
 7650              	.L604:
3541:Src/mpu6050.c ****             mpu.quat.w = quat[0];
 7651              		.loc 1 3541 9 view .LVU2324
3541:Src/mpu6050.c ****             mpu.quat.w = quat[0];
 7652              		.loc 1 3541 12 is_stmt 0 view .LVU2325
 7653 00ca D105     		lsls	r1, r2, #23
 7654 00cc 40F18F80 		bpl	.L605
3542:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7655              		.loc 1 3542 13 is_stmt 1 view .LVU2326
3542:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7656              		.loc 1 3542 30 is_stmt 0 view .LVU2327
ARM GAS  /tmp/ccNfEN49.s 			page 234


 7657 00d0 714A     		ldr	r2, .L642+24
3542:Src/mpu6050.c ****             mpu.quat.x = quat[1];
 7658              		.loc 1 3542 24 view .LVU2328
 7659 00d2 724B     		ldr	r3, .L642+28
 7660 00d4 1168     		ldr	r1, [r2]
 7661 00d6 D960     		str	r1, [r3, #12]
3543:Src/mpu6050.c ****             mpu.quat.y = quat[2];
 7662              		.loc 1 3543 13 is_stmt 1 view .LVU2329
3543:Src/mpu6050.c ****             mpu.quat.y = quat[2];
 7663              		.loc 1 3543 24 is_stmt 0 view .LVU2330
 7664 00d8 5168     		ldr	r1, [r2, #4]
 7665 00da 1961     		str	r1, [r3, #16]
3544:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7666              		.loc 1 3544 13 is_stmt 1 view .LVU2331
3544:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7667              		.loc 1 3544 24 is_stmt 0 view .LVU2332
 7668 00dc 9168     		ldr	r1, [r2, #8]
3545:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7669              		.loc 1 3545 24 view .LVU2333
 7670 00de D268     		ldr	r2, [r2, #12]
3544:Src/mpu6050.c ****             mpu.quat.z = quat[3];
 7671              		.loc 1 3544 24 view .LVU2334
 7672 00e0 5961     		str	r1, [r3, #20]
3545:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7673              		.loc 1 3545 13 is_stmt 1 view .LVU2335
3545:Src/mpu6050.c ****             mpu_calc_euler_angles();        // Calculate Euler angles
 7674              		.loc 1 3545 24 is_stmt 0 view .LVU2336
 7675 00e2 9A61     		str	r2, [r3, #24]
3546:Src/mpu6050.c ****             new_data = 1;
 7676              		.loc 1 3546 13 is_stmt 1 view .LVU2337
 7677 00e4 FFF7FEFF 		bl	mpu_calc_euler_angles
 7678              	.LVL590:
3547:Src/mpu6050.c ****         }
 7679              		.loc 1 3547 13 view .LVU2338
3547:Src/mpu6050.c ****         }
 7680              		.loc 1 3547 13 is_stmt 0 view .LVU2339
 7681              	.LBE52:
3585:Src/mpu6050.c ****         // do something if needed
 7682              		.loc 1 3585 5 is_stmt 1 view .LVU2340
 7683              	.L606:
 7684              	.LBB53:
3588:Src/mpu6050.c ****         last_quat_timestamp = sensor_timestamp;
 7685              		.loc 1 3588 9 view .LVU2341
3588:Src/mpu6050.c ****         last_quat_timestamp = sensor_timestamp;
 7686              		.loc 1 3588 39 is_stmt 0 view .LVU2342
 7687 00e8 0D98     		ldr	r0, [sp, #52]
 7688 00ea FFF7FEFF 		bl	__aeabi_ui2d
 7689              	.LVL591:
 7690 00ee 6D4E     		ldr	r6, .L642+36
 7691 00f0 0446     		mov	r4, r0
 7692 00f2 D6E90023 		ldrd	r2, [r6]
 7693 00f6 0D46     		mov	r5, r1
 7694 00f8 FFF7FEFF 		bl	__aeabi_dsub
 7695              	.LVL592:
3588:Src/mpu6050.c ****         last_quat_timestamp = sensor_timestamp;
 7696              		.loc 1 3588 16 view .LVU2343
 7697 00fc 0022     		movs	r2, #0
ARM GAS  /tmp/ccNfEN49.s 			page 235


 7698 00fe 6A4B     		ldr	r3, .L642+40
 7699 0100 FFF7FEFF 		bl	__aeabi_ddiv
 7700              	.LVL593:
3589:Src/mpu6050.c **** 
 7701              		.loc 1 3589 29 view .LVU2344
 7702 0104 C6E90045 		strd	r4, [r6]
3592:Src/mpu6050.c ****                         (double)mpu.accel.y / ACCEL_TO_G, 
 7703              		.loc 1 3592 42 view .LVU2345
 7704 0108 644C     		ldr	r4, .L642+28
3588:Src/mpu6050.c ****         last_quat_timestamp = sensor_timestamp;
 7705              		.loc 1 3588 16 view .LVU2346
 7706 010a 8046     		mov	r8, r0
 7707 010c 8946     		mov	r9, r1
 7708              	.LVL594:
3589:Src/mpu6050.c **** 
 7709              		.loc 1 3589 9 is_stmt 1 view .LVU2347
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7710              		.loc 1 3591 9 view .LVU2348
3592:Src/mpu6050.c ****                         (double)mpu.accel.y / ACCEL_TO_G, 
 7711              		.loc 1 3592 25 is_stmt 0 view .LVU2349
 7712 010e B4F90600 		ldrsh	r0, [r4, #6]
 7713 0112 FFF7FEFF 		bl	__aeabi_i2d
 7714              	.LVL595:
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7715              		.loc 1 3591 9 view .LVU2350
 7716 0116 0022     		movs	r2, #0
 7717 0118 644B     		ldr	r3, .L642+44
 7718 011a FFF7FEFF 		bl	__aeabi_dmul
 7719              	.LVL596:
 7720 011e CDE90A89 		strd	r8, [sp, #40]
 7721 0122 0646     		mov	r6, r0
3597:Src/mpu6050.c ****                         dt
 7722              		.loc 1 3597 27 view .LVU2351
 7723 0124 B4F90400 		ldrsh	r0, [r4, #4]
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7724              		.loc 1 3591 9 view .LVU2352
 7725 0128 0F46     		mov	r7, r1
3597:Src/mpu6050.c ****                         dt
 7726              		.loc 1 3597 27 view .LVU2353
 7727 012a FFF7FEFF 		bl	__aeabi_i2d
 7728              	.LVL597:
3597:Src/mpu6050.c ****                         dt
 7729              		.loc 1 3597 46 view .LVU2354
 7730 012e 54A3     		adr	r3, .L642
 7731 0130 D3E90023 		ldrd	r2, [r3]
 7732 0134 FFF7FEFF 		bl	__aeabi_ddiv
 7733              	.LVL598:
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7734              		.loc 1 3591 9 view .LVU2355
 7735 0138 53A3     		adr	r3, .L642+8
 7736 013a D3E90023 		ldrd	r2, [r3]
 7737 013e FFF7FEFF 		bl	__aeabi_dmul
 7738              	.LVL599:
 7739 0142 CDE90801 		strd	r0, [sp, #32]
3596:Src/mpu6050.c ****                         ( (double)mpu.gyro.z / GYRO_TO_DEG_S )*( M_PI/ 180.00),
 7740              		.loc 1 3596 27 view .LVU2356
 7741 0146 B4F90200 		ldrsh	r0, [r4, #2]
ARM GAS  /tmp/ccNfEN49.s 			page 236


 7742 014a FFF7FEFF 		bl	__aeabi_i2d
 7743              	.LVL600:
3596:Src/mpu6050.c ****                         ( (double)mpu.gyro.z / GYRO_TO_DEG_S )*( M_PI/ 180.00),
 7744              		.loc 1 3596 46 view .LVU2357
 7745 014e 4CA3     		adr	r3, .L642
 7746 0150 D3E90023 		ldrd	r2, [r3]
 7747 0154 FFF7FEFF 		bl	__aeabi_ddiv
 7748              	.LVL601:
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7749              		.loc 1 3591 9 view .LVU2358
 7750 0158 4BA3     		adr	r3, .L642+8
 7751 015a D3E90023 		ldrd	r2, [r3]
 7752 015e FFF7FEFF 		bl	__aeabi_dmul
 7753              	.LVL602:
 7754 0162 CDE90601 		strd	r0, [sp, #24]
3595:Src/mpu6050.c ****                         ( (double)mpu.gyro.y / GYRO_TO_DEG_S )*( M_PI/ 180.00),  
 7755              		.loc 1 3595 27 view .LVU2359
 7756 0166 B4F90000 		ldrsh	r0, [r4]
 7757 016a FFF7FEFF 		bl	__aeabi_i2d
 7758              	.LVL603:
3595:Src/mpu6050.c ****                         ( (double)mpu.gyro.y / GYRO_TO_DEG_S )*( M_PI/ 180.00),  
 7759              		.loc 1 3595 46 view .LVU2360
 7760 016e 44A3     		adr	r3, .L642
 7761 0170 D3E90023 		ldrd	r2, [r3]
 7762 0174 FFF7FEFF 		bl	__aeabi_ddiv
 7763              	.LVL604:
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7764              		.loc 1 3591 9 view .LVU2361
 7765 0178 43A3     		adr	r3, .L642+8
 7766 017a D3E90023 		ldrd	r2, [r3]
 7767 017e FFF7FEFF 		bl	__aeabi_dmul
 7768              	.LVL605:
 7769 0182 CDE90401 		strd	r0, [sp, #16]
3594:Src/mpu6050.c ****                         ( (double)mpu.gyro.x / GYRO_TO_DEG_S )*( M_PI/ 180.00), 
 7770              		.loc 1 3594 25 view .LVU2362
 7771 0186 B4F90A00 		ldrsh	r0, [r4, #10]
 7772 018a FFF7FEFF 		bl	__aeabi_i2d
 7773              	.LVL606:
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7774              		.loc 1 3591 9 view .LVU2363
 7775 018e 0022     		movs	r2, #0
 7776 0190 464B     		ldr	r3, .L642+44
 7777 0192 FFF7FEFF 		bl	__aeabi_dmul
 7778              	.LVL607:
 7779 0196 CDE90201 		strd	r0, [sp, #8]
3593:Src/mpu6050.c ****                         (double)mpu.accel.z / ACCEL_TO_G,
 7780              		.loc 1 3593 25 view .LVU2364
 7781 019a B4F90800 		ldrsh	r0, [r4, #8]
 7782 019e FFF7FEFF 		bl	__aeabi_i2d
 7783              	.LVL608:
3591:Src/mpu6050.c ****                         (double)mpu.accel.x / ACCEL_TO_G, 
 7784              		.loc 1 3591 9 view .LVU2365
 7785 01a2 0022     		movs	r2, #0
 7786 01a4 414B     		ldr	r3, .L642+44
 7787 01a6 FFF7FEFF 		bl	__aeabi_dmul
 7788              	.LVL609:
 7789 01aa 414D     		ldr	r5, .L642+48
ARM GAS  /tmp/ccNfEN49.s 			page 237


 7790 01ac CDE90001 		strd	r0, [sp]
 7791 01b0 3246     		mov	r2, r6
 7792 01b2 3B46     		mov	r3, r7
 7793 01b4 2846     		mov	r0, r5
 7794 01b6 FFF7FEFF 		bl	madgwick_update
 7795              	.LVL610:
3600:Src/mpu6050.c **** 
 7796              		.loc 1 3600 9 is_stmt 1 view .LVU2366
 7797 01ba 04F12003 		add	r3, r4, #32
 7798 01be 0293     		str	r3, [sp, #8]
 7799 01c0 04F11E03 		add	r3, r4, #30
 7800 01c4 0193     		str	r3, [sp, #4]
 7801 01c6 04F11C03 		add	r3, r4, #28
 7802 01ca 0093     		str	r3, [sp]
 7803 01cc 95E80F00 		ldm	r5, {r0, r1, r2, r3}
 7804 01d0 FFF7FEFF 		bl	quat_to_euler
 7805              	.LVL611:
3603:Src/mpu6050.c ****         mpu.quat.x = imu_quaternion.x;
 7806              		.loc 1 3603 9 view .LVU2367
3603:Src/mpu6050.c ****         mpu.quat.x = imu_quaternion.x;
 7807              		.loc 1 3603 20 is_stmt 0 view .LVU2368
 7808 01d4 2B68     		ldr	r3, [r5]
 7809 01d6 E360     		str	r3, [r4, #12]
3604:Src/mpu6050.c ****         mpu.quat.y = imu_quaternion.y;
 7810              		.loc 1 3604 9 is_stmt 1 view .LVU2369
3604:Src/mpu6050.c ****         mpu.quat.y = imu_quaternion.y;
 7811              		.loc 1 3604 20 is_stmt 0 view .LVU2370
 7812 01d8 6B68     		ldr	r3, [r5, #4]
 7813 01da 2361     		str	r3, [r4, #16]
3605:Src/mpu6050.c ****         mpu.quat.z = imu_quaternion.z;
 7814              		.loc 1 3605 9 is_stmt 1 view .LVU2371
3605:Src/mpu6050.c ****         mpu.quat.z = imu_quaternion.z;
 7815              		.loc 1 3605 20 is_stmt 0 view .LVU2372
 7816 01dc AB68     		ldr	r3, [r5, #8]
 7817 01de 6361     		str	r3, [r4, #20]
3606:Src/mpu6050.c ****     }   
 7818              		.loc 1 3606 9 is_stmt 1 view .LVU2373
3606:Src/mpu6050.c ****     }   
 7819              		.loc 1 3606 20 is_stmt 0 view .LVU2374
 7820 01e0 EB68     		ldr	r3, [r5, #12]
 7821 01e2 A361     		str	r3, [r4, #24]
 7822              	.LBE53:
3608:Src/mpu6050.c **** 
 7823              		.loc 1 3608 1 view .LVU2375
 7824 01e4 07E0     		b	.L598
 7825              	.LVL612:
 7826              	.L615:
3486:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7827              		.loc 1 3486 19 view .LVU2376
 7828 01e6 1D46     		mov	r5, r3
 7829              	.LVL613:
3486:Src/mpu6050.c ****     uint8_t mpu_int_status;   // holds actual interrupt status byte from MPU
 7830              		.loc 1 3486 19 view .LVU2377
 7831 01e8 60E7     		b	.L603
 7832              	.LVL614:
 7833              	.L616:
 7834              	.LBB54:
ARM GAS  /tmp/ccNfEN49.s 			page 238


3528:Src/mpu6050.c ****             if (new_temp) {
 7835              		.loc 1 3528 22 view .LVU2378
 7836 01ea 0125     		movs	r5, #1
 7837              	.LVL615:
3528:Src/mpu6050.c ****             if (new_temp) {
 7838              		.loc 1 3528 22 view .LVU2379
 7839 01ec 5EE7     		b	.L603
 7840              	.LVL616:
 7841              	.L605:
3528:Src/mpu6050.c ****             if (new_temp) {
 7842              		.loc 1 3528 22 view .LVU2380
 7843              	.LBE54:
3505:Src/mpu6050.c ****         short gyro[3], accel[3], sensors;
 7844              		.loc 1 3505 37 view .LVU2381
 7845 01ee 2B46     		mov	r3, r5
 7846              	.LVL617:
 7847              	.L607:
3585:Src/mpu6050.c ****         // do something if needed
 7848              		.loc 1 3585 5 is_stmt 1 view .LVU2382
3585:Src/mpu6050.c ****         // do something if needed
 7849              		.loc 1 3585 8 is_stmt 0 view .LVU2383
 7850 01f0 002B     		cmp	r3, #0
 7851 01f2 7FF479AF 		bne	.L606
 7852              	.LVL618:
 7853              	.L598:
3608:Src/mpu6050.c **** 
 7854              		.loc 1 3608 1 view .LVU2384
 7855 01f6 15B0     		add	sp, sp, #84
 7856              	.LCFI116:
 7857              		.cfi_remember_state
 7858              		.cfi_def_cfa_offset 28
 7859              		@ sp needed
 7860 01f8 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 7861              	.LVL619:
 7862              	.L601:
 7863              	.LCFI117:
 7864              		.cfi_restore_state
3549:Src/mpu6050.c ****         short gyro[3], accel[3];
 7865              		.loc 1 3549 12 is_stmt 1 view .LVU2385
3549:Src/mpu6050.c ****         short gyro[3], accel[3];
 7866              		.loc 1 3549 19 is_stmt 0 view .LVU2386
 7867 01fc 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
3549:Src/mpu6050.c ****         short gyro[3], accel[3];
 7868              		.loc 1 3549 15 view .LVU2387
 7869 01fe 002B     		cmp	r3, #0
 7870 0200 F9D0     		beq	.L598
 7871              	.LBB55:
3550:Src/mpu6050.c ****         long temperature;
 7872              		.loc 1 3550 9 is_stmt 1 view .LVU2388
3551:Src/mpu6050.c ****         unsigned char sensors, more;
 7873              		.loc 1 3551 9 view .LVU2389
3552:Src/mpu6050.c ****         /* This function gets new data from the FIFO. The FIFO can contain
 7874              		.loc 1 3552 9 view .LVU2390
3562:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
 7875              		.loc 1 3562 9 view .LVU2391
3562:Src/mpu6050.c ****         mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
 7876              		.loc 1 3562 22 is_stmt 0 view .LVU2392
ARM GAS  /tmp/ccNfEN49.s 			page 239


 7877 0202 0023     		movs	r3, #0
 7878 0204 2371     		strb	r3, [r4, #4]
3563:Src/mpu6050.c ****         if (more)
 7879              		.loc 1 3563 9 is_stmt 1 view .LVU2393
 7880 0206 0DF13303 		add	r3, sp, #51
 7881 020a 0093     		str	r3, [sp]
 7882 020c 0DAA     		add	r2, sp, #52
 7883 020e 0DF13203 		add	r3, sp, #50
 7884 0212 12A9     		add	r1, sp, #72
 7885 0214 10A8     		add	r0, sp, #64
 7886 0216 FFF7FEFF 		bl	mpu_read_fifo
 7887              	.LVL620:
3564:Src/mpu6050.c ****             hal.new_gyro = 1;
 7888              		.loc 1 3564 9 view .LVU2394
3564:Src/mpu6050.c ****             hal.new_gyro = 1;
 7889              		.loc 1 3564 12 is_stmt 0 view .LVU2395
 7890 021a 9DF83330 		ldrb	r3, [sp, #51]	@ zero_extendqisi2
 7891 021e 0BB1     		cbz	r3, .L610
3565:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7892              		.loc 1 3565 13 is_stmt 1 view .LVU2396
3565:Src/mpu6050.c ****         if (sensors & INV_XYZ_GYRO) {
 7893              		.loc 1 3565 26 is_stmt 0 view .LVU2397
 7894 0220 0123     		movs	r3, #1
 7895 0222 2371     		strb	r3, [r4, #4]
 7896              	.L610:
3566:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7897              		.loc 1 3566 9 is_stmt 1 view .LVU2398
 7898 0224 9DF83230 		ldrb	r3, [sp, #50]	@ zero_extendqisi2
3566:Src/mpu6050.c ****             mpu.gyro.x = gyro[0];
 7899              		.loc 1 3566 12 is_stmt 0 view .LVU2399
 7900 0228 13F07003 		ands	r3, r3, #112
 7901 022c 14D0     		beq	.L611
3567:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7902              		.loc 1 3567 13 is_stmt 1 view .LVU2400
3567:Src/mpu6050.c ****             mpu.gyro.y = gyro[1];
 7903              		.loc 1 3567 24 is_stmt 0 view .LVU2401
 7904 022e 1B4C     		ldr	r4, .L642+28
 7905 0230 BDF84030 		ldrh	r3, [sp, #64]
 7906 0234 2380     		strh	r3, [r4]	@ movhi
3568:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7907              		.loc 1 3568 13 is_stmt 1 view .LVU2402
3568:Src/mpu6050.c ****             mpu.gyro.z = gyro[2];
 7908              		.loc 1 3568 24 is_stmt 0 view .LVU2403
 7909 0236 BDF84230 		ldrh	r3, [sp, #66]
 7910 023a 6380     		strh	r3, [r4, #2]	@ movhi
3569:Src/mpu6050.c ****             new_data = 1;
 7911              		.loc 1 3569 13 is_stmt 1 view .LVU2404
3569:Src/mpu6050.c ****             new_data = 1;
 7912              		.loc 1 3569 24 is_stmt 0 view .LVU2405
 7913 023c BDF84430 		ldrh	r3, [sp, #68]
 7914 0240 A380     		strh	r3, [r4, #4]	@ movhi
3570:Src/mpu6050.c ****             if (new_temp) {
 7915              		.loc 1 3570 13 is_stmt 1 view .LVU2406
 7916              	.LVL621:
3571:Src/mpu6050.c ****                 new_temp = 0;
 7917              		.loc 1 3571 13 view .LVU2407
3571:Src/mpu6050.c ****                 new_temp = 0;
ARM GAS  /tmp/ccNfEN49.s 			page 240


 7918              		.loc 1 3571 16 is_stmt 0 view .LVU2408
 7919 0242 C5B1     		cbz	r5, .L617
3572:Src/mpu6050.c ****                 mpu_get_temperature(&temperature, &sensor_timestamp);
 7920              		.loc 1 3572 17 is_stmt 1 view .LVU2409
 7921              	.LVL622:
3573:Src/mpu6050.c ****                 mpu.temp = (int16_t)((temperature*100) >> 16);  // Convert temperature[q16] to temp
 7922              		.loc 1 3573 17 view .LVU2410
 7923 0244 0DA9     		add	r1, sp, #52
 7924 0246 0FA8     		add	r0, sp, #60
 7925 0248 FFF7FEFF 		bl	mpu_get_temperature
 7926              	.LVL623:
3574:Src/mpu6050.c ****             }
 7927              		.loc 1 3574 17 view .LVU2411
3574:Src/mpu6050.c ****             }
 7928              		.loc 1 3574 50 is_stmt 0 view .LVU2412
 7929 024c 6422     		movs	r2, #100
 7930 024e 0F9B     		ldr	r3, [sp, #60]
 7931 0250 5343     		muls	r3, r2, r3
3574:Src/mpu6050.c ****             }
 7932              		.loc 1 3574 56 view .LVU2413
 7933 0252 1B14     		asrs	r3, r3, #16
3574:Src/mpu6050.c ****             }
 7934              		.loc 1 3574 28 view .LVU2414
 7935 0254 6384     		strh	r3, [r4, #34]	@ movhi
3570:Src/mpu6050.c ****             if (new_temp) {
 7936              		.loc 1 3570 22 view .LVU2415
 7937 0256 2B46     		mov	r3, r5
 7938              	.LVL624:
 7939              	.L611:
3577:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7940              		.loc 1 3577 9 is_stmt 1 view .LVU2416
3577:Src/mpu6050.c ****             mpu.accel.x = accel[0];
 7941              		.loc 1 3577 12 is_stmt 0 view .LVU2417
 7942 0258 9DF83220 		ldrb	r2, [sp, #50]	@ zero_extendqisi2
 7943 025c 1207     		lsls	r2, r2, #28
 7944 025e C7D5     		bpl	.L607
3578:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7945              		.loc 1 3578 13 is_stmt 1 view .LVU2418
3578:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7946              		.loc 1 3578 25 is_stmt 0 view .LVU2419
 7947 0260 0E4B     		ldr	r3, .L642+28
 7948              	.LVL625:
3578:Src/mpu6050.c ****             mpu.accel.y = accel[1];
 7949              		.loc 1 3578 25 view .LVU2420
 7950 0262 BDF84820 		ldrh	r2, [sp, #72]
 7951 0266 DA80     		strh	r2, [r3, #6]	@ movhi
3579:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7952              		.loc 1 3579 13 is_stmt 1 view .LVU2421
3579:Src/mpu6050.c ****             mpu.accel.z = accel[2];
 7953              		.loc 1 3579 25 is_stmt 0 view .LVU2422
 7954 0268 BDF84A20 		ldrh	r2, [sp, #74]
 7955 026c 1A81     		strh	r2, [r3, #8]	@ movhi
3580:Src/mpu6050.c ****             new_data = 1;
 7956              		.loc 1 3580 13 is_stmt 1 view .LVU2423
3580:Src/mpu6050.c ****             new_data = 1;
 7957              		.loc 1 3580 25 is_stmt 0 view .LVU2424
 7958 026e BDF84C20 		ldrh	r2, [sp, #76]
ARM GAS  /tmp/ccNfEN49.s 			page 241


 7959 0272 5A81     		strh	r2, [r3, #10]	@ movhi
3581:Src/mpu6050.c ****         }
 7960              		.loc 1 3581 13 is_stmt 1 view .LVU2425
 7961              	.LVL626:
3581:Src/mpu6050.c ****         }
 7962              		.loc 1 3581 13 is_stmt 0 view .LVU2426
 7963              	.LBE55:
3585:Src/mpu6050.c ****         // do something if needed
 7964              		.loc 1 3585 5 is_stmt 1 view .LVU2427
 7965 0274 38E7     		b	.L606
 7966              	.LVL627:
 7967              	.L617:
 7968              	.LBB56:
3570:Src/mpu6050.c ****             if (new_temp) {
 7969              		.loc 1 3570 22 is_stmt 0 view .LVU2428
 7970 0276 0123     		movs	r3, #1
 7971 0278 EEE7     		b	.L611
 7972              	.L643:
 7973 027a 00BFAFF3 		.align	3
 7973      0080
 7974              	.L642:
 7975 0280 66666666 		.word	1717986918
 7976 0284 66663040 		.word	1076913766
 7977 0288 399D52A2 		.word	-1571644103
 7978 028c 46DF913F 		.word	1066524486
 7979 0290 00000000 		.word	.LANCHOR0
 7980 0294 00000000 		.word	.LANCHOR2
 7981 0298 00000000 		.word	.LANCHOR4
 7982 029c 00000000 		.word	.LANCHOR3
 7983 02a0 00000000 		.word	.LANCHOR5
 7984 02a4 00000000 		.word	.LANCHOR6
 7985 02a8 00408F40 		.word	1083129856
 7986 02ac 0000103F 		.word	1058013184
 7987 02b0 00000000 		.word	.LANCHOR7
 7988              	.LBE56:
 7989              		.cfi_endproc
 7990              	.LFE114:
 7992              		.section	.rodata.mpu_tap_func.str1.1,"aMS",%progbits,1
 7993              	.LC12:
 7994 0000 54617020 		.ascii	"Tap X+ \000"
 7994      582B2000 
 7995              	.LC13:
 7996 0008 54617020 		.ascii	"Tap X- \000"
 7996      582D2000 
 7997              	.LC14:
 7998 0010 54617020 		.ascii	"Tap Y+ \000"
 7998      592B2000 
 7999              	.LC15:
 8000 0018 54617020 		.ascii	"Tap Y- \000"
 8000      592D2000 
 8001              	.LC16:
 8002 0020 54617020 		.ascii	"Tap Z+ \000"
 8002      5A2B2000 
 8003              	.LC17:
 8004 0028 54617020 		.ascii	"Tap Z- \000"
 8004      5A2D2000 
 8005              		.section	.text.mpu_tap_func,"ax",%progbits
ARM GAS  /tmp/ccNfEN49.s 			page 242


 8006              		.align	1
 8007              		.global	mpu_tap_func
 8008              		.syntax unified
 8009              		.thumb
 8010              		.thumb_func
 8011              		.fpu softvfp
 8013              	mpu_tap_func:
 8014              	.LVL628:
 8015              	.LFB118:
3684:Src/mpu6050.c **** 
3685:Src/mpu6050.c **** 
3686:Src/mpu6050.c **** void mpu_tap_func(unsigned char direction, unsigned char count)
3687:Src/mpu6050.c **** {
 8016              		.loc 1 3687 1 is_stmt 1 view -0
 8017              		.cfi_startproc
 8018              		@ args = 0, pretend = 0, frame = 0
 8019              		@ frame_needed = 0, uses_anonymous_args = 0
 8020              		@ link register save eliminated.
3688:Src/mpu6050.c ****     switch (direction) {
 8021              		.loc 1 3688 5 view .LVU2430
 8022 0000 0138     		subs	r0, r0, #1
 8023              	.LVL629:
 8024              		.loc 1 3688 5 is_stmt 0 view .LVU2431
 8025 0002 0528     		cmp	r0, #5
 8026 0004 11D8     		bhi	.L644
 8027 0006 DFE800F0 		tbb	[pc, r0]
 8028              	.L647:
 8029 000a 03       		.byte	(.L652-.L647)/2
 8030 000b 06       		.byte	(.L651-.L647)/2
 8031 000c 08       		.byte	(.L650-.L647)/2
 8032 000d 0A       		.byte	(.L649-.L647)/2
 8033 000e 0C       		.byte	(.L648-.L647)/2
 8034 000f 0E       		.byte	(.L646-.L647)/2
 8035              		.p2align 1
 8036              	.L652:
3689:Src/mpu6050.c ****     case TAP_X_UP:
3690:Src/mpu6050.c ****         consoleLog("Tap X+ ");
 8037              		.loc 1 3690 9 is_stmt 1 view .LVU2432
 8038 0010 0648     		ldr	r0, .L654
 8039              	.L653:
3691:Src/mpu6050.c ****         break;
3692:Src/mpu6050.c ****     case TAP_X_DOWN:
3693:Src/mpu6050.c ****         consoleLog("Tap X- ");
3694:Src/mpu6050.c ****         break;
3695:Src/mpu6050.c ****     case TAP_Y_UP:
3696:Src/mpu6050.c ****         consoleLog("Tap Y+ ");
3697:Src/mpu6050.c ****         break;
3698:Src/mpu6050.c ****     case TAP_Y_DOWN:
3699:Src/mpu6050.c ****         consoleLog("Tap Y- ");
3700:Src/mpu6050.c ****         break;
3701:Src/mpu6050.c ****     case TAP_Z_UP:
3702:Src/mpu6050.c ****         consoleLog("Tap Z+ ");
3703:Src/mpu6050.c ****         break;
3704:Src/mpu6050.c ****     case TAP_Z_DOWN:
3705:Src/mpu6050.c ****         consoleLog("Tap Z- ");
 8040              		.loc 1 3705 9 is_stmt 0 view .LVU2433
 8041 0012 FFF7FEBF 		b	consoleLog
ARM GAS  /tmp/ccNfEN49.s 			page 243


 8042              	.LVL630:
 8043              	.L651:
3693:Src/mpu6050.c ****         break;
 8044              		.loc 1 3693 9 is_stmt 1 view .LVU2434
 8045 0016 0648     		ldr	r0, .L654+4
 8046 0018 FBE7     		b	.L653
 8047              	.L650:
3696:Src/mpu6050.c ****         break;
 8048              		.loc 1 3696 9 view .LVU2435
 8049 001a 0648     		ldr	r0, .L654+8
 8050 001c F9E7     		b	.L653
 8051              	.L649:
3699:Src/mpu6050.c ****         break;
 8052              		.loc 1 3699 9 view .LVU2436
 8053 001e 0648     		ldr	r0, .L654+12
 8054 0020 F7E7     		b	.L653
 8055              	.L648:
3702:Src/mpu6050.c ****         break;
 8056              		.loc 1 3702 9 view .LVU2437
 8057 0022 0648     		ldr	r0, .L654+16
 8058 0024 F5E7     		b	.L653
 8059              	.L646:
 8060              		.loc 1 3705 9 view .LVU2438
 8061 0026 0648     		ldr	r0, .L654+20
 8062 0028 F3E7     		b	.L653
 8063              	.L644:
3706:Src/mpu6050.c ****         break;
3707:Src/mpu6050.c ****     default:
3708:Src/mpu6050.c ****         return;
3709:Src/mpu6050.c ****     }
3710:Src/mpu6050.c ****     #ifdef SERIAL_DEBUG
3711:Src/mpu6050.c ****         log_i("x %d\r\n", count);
3712:Src/mpu6050.c ****     #endif
3713:Src/mpu6050.c ****     return;
3714:Src/mpu6050.c **** }
 8064              		.loc 1 3714 1 is_stmt 0 view .LVU2439
 8065 002a 7047     		bx	lr
 8066              	.L655:
 8067              		.align	2
 8068              	.L654:
 8069 002c 00000000 		.word	.LC12
 8070 0030 08000000 		.word	.LC13
 8071 0034 10000000 		.word	.LC14
 8072 0038 18000000 		.word	.LC15
 8073 003c 20000000 		.word	.LC16
 8074 0040 28000000 		.word	.LC17
 8075              		.cfi_endproc
 8076              	.LFE118:
 8078              		.section	.rodata.mpu_android_orient_func.str1.1,"aMS",%progbits,1
 8079              	.LC18:
 8080 0000 506F7274 		.ascii	"Portrait\015\012\000"
 8080      72616974 
 8080      0D0A00
 8081              	.LC19:
 8082 000b 4C616E64 		.ascii	"Landscape\015\012\000"
 8082      73636170 
 8082      650D0A00 
ARM GAS  /tmp/ccNfEN49.s 			page 244


 8083              	.LC20:
 8084 0017 5265762E 		.ascii	"Rev. Portrait\015\012\000"
 8084      20506F72 
 8084      74726169 
 8084      740D0A00 
 8085              	.LC21:
 8086 0027 5265762E 		.ascii	"Rev. Landscape\015\012\000"
 8086      204C616E 
 8086      64736361 
 8086      70650D0A 
 8086      00
 8087              		.section	.text.mpu_android_orient_func,"ax",%progbits
 8088              		.align	1
 8089              		.global	mpu_android_orient_func
 8090              		.syntax unified
 8091              		.thumb
 8092              		.thumb_func
 8093              		.fpu softvfp
 8095              	mpu_android_orient_func:
 8096              	.LVL631:
 8097              	.LFB119:
3715:Src/mpu6050.c **** 
3716:Src/mpu6050.c **** 
3717:Src/mpu6050.c **** void mpu_android_orient_func(unsigned char orientation)
3718:Src/mpu6050.c **** {
 8098              		.loc 1 3718 1 is_stmt 1 view -0
 8099              		.cfi_startproc
 8100              		@ args = 0, pretend = 0, frame = 0
 8101              		@ frame_needed = 0, uses_anonymous_args = 0
 8102              		@ link register save eliminated.
3719:Src/mpu6050.c ****     switch (orientation) {
 8103              		.loc 1 3719 5 view .LVU2441
 8104 0000 0328     		cmp	r0, #3
 8105 0002 0CD8     		bhi	.L656
 8106 0004 DFE800F0 		tbb	[pc, r0]
 8107              	.L659:
 8108 0008 02       		.byte	(.L662-.L659)/2
 8109 0009 05       		.byte	(.L661-.L659)/2
 8110 000a 07       		.byte	(.L660-.L659)/2
 8111 000b 09       		.byte	(.L658-.L659)/2
 8112              		.p2align 1
 8113              	.L662:
3720:Src/mpu6050.c ****     case ANDROID_ORIENT_PORTRAIT:
3721:Src/mpu6050.c ****         consoleLog("Portrait\r\n");
 8114              		.loc 1 3721 9 view .LVU2442
 8115 000c 0448     		ldr	r0, .L664
 8116              	.LVL632:
 8117              	.L663:
3722:Src/mpu6050.c ****         break;
3723:Src/mpu6050.c ****     case ANDROID_ORIENT_LANDSCAPE:
3724:Src/mpu6050.c ****         consoleLog("Landscape\r\n");
3725:Src/mpu6050.c ****         break;
3726:Src/mpu6050.c ****     case ANDROID_ORIENT_REVERSE_PORTRAIT:
3727:Src/mpu6050.c ****         consoleLog("Rev. Portrait\r\n");
3728:Src/mpu6050.c ****         break;
3729:Src/mpu6050.c ****     case ANDROID_ORIENT_REVERSE_LANDSCAPE:
3730:Src/mpu6050.c ****         consoleLog("Rev. Landscape\r\n");
ARM GAS  /tmp/ccNfEN49.s 			page 245


 8118              		.loc 1 3730 9 is_stmt 0 view .LVU2443
 8119 000e FFF7FEBF 		b	consoleLog
 8120              	.LVL633:
 8121              	.L661:
3724:Src/mpu6050.c ****         break;
 8122              		.loc 1 3724 9 is_stmt 1 view .LVU2444
 8123 0012 0448     		ldr	r0, .L664+4
 8124              	.LVL634:
3724:Src/mpu6050.c ****         break;
 8125              		.loc 1 3724 9 is_stmt 0 view .LVU2445
 8126 0014 FBE7     		b	.L663
 8127              	.LVL635:
 8128              	.L660:
3727:Src/mpu6050.c ****         break;
 8129              		.loc 1 3727 9 is_stmt 1 view .LVU2446
 8130 0016 0448     		ldr	r0, .L664+8
 8131              	.LVL636:
3727:Src/mpu6050.c ****         break;
 8132              		.loc 1 3727 9 is_stmt 0 view .LVU2447
 8133 0018 F9E7     		b	.L663
 8134              	.LVL637:
 8135              	.L658:
 8136              		.loc 1 3730 9 is_stmt 1 view .LVU2448
 8137 001a 0448     		ldr	r0, .L664+12
 8138              	.LVL638:
 8139              		.loc 1 3730 9 is_stmt 0 view .LVU2449
 8140 001c F7E7     		b	.L663
 8141              	.LVL639:
 8142              	.L656:
3731:Src/mpu6050.c ****         break;
3732:Src/mpu6050.c ****     default:
3733:Src/mpu6050.c ****         return;
3734:Src/mpu6050.c ****     }
3735:Src/mpu6050.c **** }
 8143              		.loc 1 3735 1 view .LVU2450
 8144 001e 7047     		bx	lr
 8145              	.L665:
 8146              		.align	2
 8147              	.L664:
 8148 0020 00000000 		.word	.LC18
 8149 0024 0B000000 		.word	.LC19
 8150 0028 17000000 		.word	.LC20
 8151 002c 27000000 		.word	.LC21
 8152              		.cfi_endproc
 8153              	.LFE119:
 8155              		.section	.text.mpu_print_to_console,"ax",%progbits
 8156              		.align	1
 8157              		.global	mpu_print_to_console
 8158              		.syntax unified
 8159              		.thumb
 8160              		.thumb_func
 8161              		.fpu softvfp
 8163              	mpu_print_to_console:
 8164              	.LFB120:
3736:Src/mpu6050.c **** 
3737:Src/mpu6050.c **** 
3738:Src/mpu6050.c **** /* =========================== MPU Print data =========================== */
ARM GAS  /tmp/ccNfEN49.s 			page 246


3739:Src/mpu6050.c **** 
3740:Src/mpu6050.c **** void mpu_print_to_console(void)
3741:Src/mpu6050.c **** {
 8165              		.loc 1 3741 1 is_stmt 1 view -0
 8166              		.cfi_startproc
 8167              		@ args = 0, pretend = 0, frame = 0
 8168              		@ frame_needed = 0, uses_anonymous_args = 0
 8169              		@ link register save eliminated.
3742:Src/mpu6050.c **** #ifdef SERIAL_DEBUG
3743:Src/mpu6050.c ****     if (hal.report & PRINT_ACCEL) {
3744:Src/mpu6050.c ****         log_i( "accX:%d accY:%d accZ:%d\r\n", mpu.accel.x, mpu.accel.y, mpu.accel.z);
3745:Src/mpu6050.c ****     }
3746:Src/mpu6050.c ****     if (hal.report & PRINT_GYRO) {
3747:Src/mpu6050.c ****         log_i( "gyrX:%d gyrY:%d gyrZ:%d\r\n", mpu.gyro.x, mpu.gyro.y, mpu.gyro.z);
3748:Src/mpu6050.c ****     }
3749:Src/mpu6050.c ****     if (hal.report & PRINT_QUAT) {
3750:Src/mpu6050.c ****         log_i( "qW:%ld qX:%ld qY:%ld qZ:%ld\r\n", (long)mpu.quat.w, (long)mpu.quat.x, (long)mpu.qua
3751:Src/mpu6050.c ****     }
3752:Src/mpu6050.c ****     if (hal.report & PRINT_EULER) {
3753:Src/mpu6050.c ****         log_i( "Roll:%d Pitch:%d Yaw:%d\r\n", mpu.euler.roll, mpu.euler.pitch, mpu.euler.yaw);
3754:Src/mpu6050.c ****     }
3755:Src/mpu6050.c ****     if (hal.report & PRINT_TEMP) {
3756:Src/mpu6050.c ****         log_i( "Temp:%d\r\n", mpu.temp);
3757:Src/mpu6050.c ****     }
3758:Src/mpu6050.c ****     if (hal.report & PRINT_PEDO) {
3759:Src/mpu6050.c ****         unsigned long timestamp;
3760:Src/mpu6050.c ****         get_tick_count_ms(&timestamp);
3761:Src/mpu6050.c ****         if (timestamp > hal.next_pedo_ms) {
3762:Src/mpu6050.c ****             hal.next_pedo_ms = timestamp + PEDO_READ_MS;
3763:Src/mpu6050.c ****             unsigned long step_count, walk_time;
3764:Src/mpu6050.c ****             dmp_get_pedometer_step_count(&step_count);
3765:Src/mpu6050.c ****             dmp_get_pedometer_walk_time(&walk_time);
3766:Src/mpu6050.c ****             log_i( "Walked %ld steps in %ld sec\r\n", step_count, walk_time/1000);
3767:Src/mpu6050.c ****         }
3768:Src/mpu6050.c ****     }
3769:Src/mpu6050.c **** #endif
3770:Src/mpu6050.c **** }
 8170              		.loc 1 3770 1 view .LVU2452
 8171 0000 7047     		bx	lr
 8172              		.cfi_endproc
 8173              	.LFE120:
 8175              		.section	.text.mpu_handle_input,"ax",%progbits
 8176              		.align	1
 8177              		.global	mpu_handle_input
 8178              		.syntax unified
 8179              		.thumb
 8180              		.thumb_func
 8181              		.fpu softvfp
 8183              	mpu_handle_input:
 8184              	.LVL640:
 8185              	.LFB121:
3771:Src/mpu6050.c **** 
3772:Src/mpu6050.c **** #endif // MPU_SENSOR_ENABLE
3773:Src/mpu6050.c **** 
3774:Src/mpu6050.c **** 
3775:Src/mpu6050.c **** /* =========================== User Input Handling =========================== */
3776:Src/mpu6050.c **** 
ARM GAS  /tmp/ccNfEN49.s 			page 247


3777:Src/mpu6050.c **** void mpu_handle_input(char c)
3778:Src/mpu6050.c **** {
 8186              		.loc 1 3778 1 view -0
 8187              		.cfi_startproc
 8188              		@ args = 0, pretend = 0, frame = 0
 8189              		@ frame_needed = 0, uses_anonymous_args = 0
 8190              		@ link register save eliminated.
3779:Src/mpu6050.c **** #ifdef SERIAL_DEBUG
3780:Src/mpu6050.c ****     switch (c) {
3781:Src/mpu6050.c ****         /* This command prints the Help text. */
3782:Src/mpu6050.c ****         case 'h':
3783:Src/mpu6050.c ****             consoleLog("=== HELP ===\r\n");
3784:Src/mpu6050.c ****             consoleLog("h: Print Help\r\n");
3785:Src/mpu6050.c ****             consoleLog("x: Print Serial AUX\r\n");
3786:Src/mpu6050.c ****             #ifdef MPU_SENSOR_ENABLE
3787:Src/mpu6050.c ****             consoleLog("8: Set Accelerometer on/off\r\n");
3788:Src/mpu6050.c ****             consoleLog("9: Set Gyroscope on/off\r\n");
3789:Src/mpu6050.c ****             consoleLog("r: Print Registers\r\n");
3790:Src/mpu6050.c ****             consoleLog("a: Print Accelerometer\r\n");
3791:Src/mpu6050.c ****             consoleLog("g: Print Gyroscope\r\n");
3792:Src/mpu6050.c ****             consoleLog("q: Print Quaternion\r\n");
3793:Src/mpu6050.c ****             consoleLog("e: Print Euler angles in deg*100\r\n");
3794:Src/mpu6050.c ****             consoleLog("t: Print Temperature in degC*100\r\n");
3795:Src/mpu6050.c ****             consoleLog("p: Print Pedometer\r\n");
3796:Src/mpu6050.c ****             consoleLog("0: Reset Pedometer\r\n");
3797:Src/mpu6050.c ****             consoleLog("1: Set DMP/MPU freq 10 Hz\r\n");
3798:Src/mpu6050.c ****             consoleLog("2: Set DMP/MPU freq 50 Hz\r\n");
3799:Src/mpu6050.c ****             consoleLog("3: Set DMP/MPU freq 100 Hz\r\n");
3800:Src/mpu6050.c ****             consoleLog(",: Set DMP interrupt to gesture\r\n");
3801:Src/mpu6050.c ****             consoleLog(".: Set DMP interrupt to continuous\r\n");
3802:Src/mpu6050.c ****             consoleLog("f: Set DMP on/off\r\n");
3803:Src/mpu6050.c ****             consoleLog("v: Set Quaternion on/off\r\n");
3804:Src/mpu6050.c ****             consoleLog("w: Test low-power accel mode\r\n");
3805:Src/mpu6050.c ****             consoleLog("s: Run self-test (device must be facing up or down)\r\n");
3806:Src/mpu6050.c ****             #endif // MPU_SENSOR_ENABLE
3807:Src/mpu6050.c ****             consoleLog("============\r\n");
3808:Src/mpu6050.c ****             break;
3809:Src/mpu6050.c **** 
3810:Src/mpu6050.c ****         /* These commands print individual sensor data. */
3811:Src/mpu6050.c ****         case 'x':
3812:Src/mpu6050.c ****             #ifdef SERIAL_AUX_RX
3813:Src/mpu6050.c ****             print_aux ^= PRINT_AUX;
3814:Src/mpu6050.c ****             #else
3815:Src/mpu6050.c ****             consoleLog("AUX serial NOT enabled\r\n");
3816:Src/mpu6050.c ****             #endif
3817:Src/mpu6050.c ****             break;
3818:Src/mpu6050.c **** 
3819:Src/mpu6050.c ****         #ifdef MPU_SENSOR_ENABLE
3820:Src/mpu6050.c ****         /* These commands turn off individual sensors. */
3821:Src/mpu6050.c ****         case '8':
3822:Src/mpu6050.c ****             hal.sensors ^= ACCEL_ON;
3823:Src/mpu6050.c ****             mpu_setup_gyro();
3824:Src/mpu6050.c ****             break;
3825:Src/mpu6050.c ****         case '9':
3826:Src/mpu6050.c ****             hal.sensors ^= GYRO_ON;
3827:Src/mpu6050.c ****             mpu_setup_gyro();
3828:Src/mpu6050.c ****             break;
ARM GAS  /tmp/ccNfEN49.s 			page 248


3829:Src/mpu6050.c **** 
3830:Src/mpu6050.c ****         /* This command prints out the value of each gyro register for debugging.
3831:Src/mpu6050.c ****         * If logging is disabled, this function has no effect.
3832:Src/mpu6050.c ****         */
3833:Src/mpu6050.c ****         case 'r':
3834:Src/mpu6050.c ****             mpu_reg_dump();
3835:Src/mpu6050.c ****             break;
3836:Src/mpu6050.c **** 
3837:Src/mpu6050.c ****         /* These commands print individual sensor data. */
3838:Src/mpu6050.c ****         case 'a':
3839:Src/mpu6050.c ****             hal.report ^= PRINT_ACCEL;
3840:Src/mpu6050.c ****             break;
3841:Src/mpu6050.c ****         case 'g':
3842:Src/mpu6050.c ****             hal.report ^= PRINT_GYRO;
3843:Src/mpu6050.c ****             break;
3844:Src/mpu6050.c ****         case 'q':
3845:Src/mpu6050.c ****             hal.report ^= PRINT_QUAT;
3846:Src/mpu6050.c ****             break;
3847:Src/mpu6050.c ****         case 'e':
3848:Src/mpu6050.c ****             hal.report ^= PRINT_EULER;
3849:Src/mpu6050.c ****             break;
3850:Src/mpu6050.c ****         case 't':
3851:Src/mpu6050.c ****             hal.report ^= PRINT_TEMP;
3852:Src/mpu6050.c ****             break;
3853:Src/mpu6050.c ****         case 'p':
3854:Src/mpu6050.c ****             /* Toggle pedometer display. */
3855:Src/mpu6050.c ****             hal.report ^= PRINT_PEDO;
3856:Src/mpu6050.c ****             break;
3857:Src/mpu6050.c ****         case '0':
3858:Src/mpu6050.c ****             /* Reset pedometer. */
3859:Src/mpu6050.c ****             dmp_set_pedometer_step_count(0);
3860:Src/mpu6050.c ****             dmp_set_pedometer_walk_time(0);
3861:Src/mpu6050.c ****             consoleLog("Pedometer reset OK\r\n");
3862:Src/mpu6050.c ****             break;
3863:Src/mpu6050.c **** 
3864:Src/mpu6050.c ****         /* Depending on your application, sensor data may be needed at a faster or
3865:Src/mpu6050.c ****         * slower rate. These commands can speed up or slow down the rate at which
3866:Src/mpu6050.c ****         * the sensor data is received.
3867:Src/mpu6050.c ****         */
3868:Src/mpu6050.c ****         case '1':
3869:Src/mpu6050.c ****             if (hal.dmp_on) {
3870:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(10))      {consoleLog("DMP 10 Hz\r\n");}
3871:Src/mpu6050.c ****             } else
3872:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(10))    {consoleLog("MPU 10 Hz\r\n");}
3873:Src/mpu6050.c ****             break;
3874:Src/mpu6050.c ****         case '2':
3875:Src/mpu6050.c ****             if (hal.dmp_on) {
3876:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(50))      {consoleLog("DMP 50 Hz\r\n");}
3877:Src/mpu6050.c ****             } else
3878:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(50))    {consoleLog("MPU 50 Hz\r\n");}
3879:Src/mpu6050.c ****             break;
3880:Src/mpu6050.c ****         case '3':
3881:Src/mpu6050.c ****             if (hal.dmp_on) {
3882:Src/mpu6050.c ****                 if (0 == dmp_set_fifo_rate(100))     {consoleLog("DMP 100 Hz\r\n");}
3883:Src/mpu6050.c ****             } else
3884:Src/mpu6050.c ****                 if (0 == mpu_set_sample_rate(100))   {consoleLog("MPU 100 Hz\r\n");}
3885:Src/mpu6050.c ****             break;
ARM GAS  /tmp/ccNfEN49.s 			page 249


3886:Src/mpu6050.c **** 
3887:Src/mpu6050.c ****             /* Set hardware to interrupt on gesture event only. This feature is
3888:Src/mpu6050.c ****             * useful for keeping the MCU asleep until the DMP detects as a tap or
3889:Src/mpu6050.c ****             * orientation event.
3890:Src/mpu6050.c ****             */
3891:Src/mpu6050.c ****             case ',':
3892:Src/mpu6050.c ****             dmp_set_interrupt_mode(DMP_INT_GESTURE);
3893:Src/mpu6050.c ****             break;
3894:Src/mpu6050.c ****         case '.':
3895:Src/mpu6050.c ****             /* Set hardware to interrupt periodically. */
3896:Src/mpu6050.c ****             dmp_set_interrupt_mode(DMP_INT_CONTINUOUS);
3897:Src/mpu6050.c ****             break;
3898:Src/mpu6050.c **** 
3899:Src/mpu6050.c ****             /* Toggle DMP. */
3900:Src/mpu6050.c ****         case 'f':
3901:Src/mpu6050.c ****             if (hal.lp_accel_mode)  /* LP accel is not compatible with the DMP. */
3902:Src/mpu6050.c ****                 return;
3903:Src/mpu6050.c ****             if (hal.dmp_on) {
3904:Src/mpu6050.c ****                 unsigned short dmp_rate;
3905:Src/mpu6050.c ****                 unsigned char mask = 0;
3906:Src/mpu6050.c ****                 hal.dmp_on = 0;
3907:Src/mpu6050.c ****                 mpu_set_dmp_state(0);
3908:Src/mpu6050.c ****                 /* Restore FIFO settings. */
3909:Src/mpu6050.c ****                 if (hal.sensors & ACCEL_ON)
3910:Src/mpu6050.c ****                     mask |= INV_XYZ_ACCEL;
3911:Src/mpu6050.c ****                 if (hal.sensors & GYRO_ON)
3912:Src/mpu6050.c ****                     mask |= INV_XYZ_GYRO;
3913:Src/mpu6050.c ****                 if (hal.sensors & COMPASS_ON)
3914:Src/mpu6050.c ****                     mask |= INV_XYZ_COMPASS;
3915:Src/mpu6050.c ****                 mpu_configure_fifo(mask);
3916:Src/mpu6050.c ****                 /* When the DMP is used, the hardware sampling rate is fixed at
3917:Src/mpu6050.c ****                 * 200Hz, and the DMP is configured to downsample the FIFO output
3918:Src/mpu6050.c ****                 * using the function dmp_set_fifo_rate. However, when the DMP is
3919:Src/mpu6050.c ****                 * turned off, the sampling rate remains at 200Hz. This could be
3920:Src/mpu6050.c ****                 * handled in mpu6050.c, but it would need to know that
3921:Src/mpu6050.c ****                 * mpu6050_dmp.c exists. To avoid this, we'll just
3922:Src/mpu6050.c ****                 * put the extra logic in the application layer.
3923:Src/mpu6050.c ****                 */
3924:Src/mpu6050.c ****                 dmp_get_fifo_rate(&dmp_rate);
3925:Src/mpu6050.c ****                 mpu_set_sample_rate(dmp_rate);
3926:Src/mpu6050.c ****                 consoleLog("DMP OFF\r\n");
3927:Src/mpu6050.c ****             } else {
3928:Src/mpu6050.c ****                 unsigned short sample_rate;
3929:Src/mpu6050.c ****                 hal.dmp_on = 1;
3930:Src/mpu6050.c ****                 /* Preserve current FIFO rate. */
3931:Src/mpu6050.c ****                 mpu_get_sample_rate(&sample_rate);
3932:Src/mpu6050.c ****                 dmp_set_fifo_rate(sample_rate);
3933:Src/mpu6050.c ****                 mpu_set_dmp_state(1);
3934:Src/mpu6050.c ****                 consoleLog("DMP ON\r\n");
3935:Src/mpu6050.c ****             }
3936:Src/mpu6050.c ****             break;
3937:Src/mpu6050.c **** 
3938:Src/mpu6050.c ****         case 'v':
3939:Src/mpu6050.c ****             /* Toggle LP quaternion.
3940:Src/mpu6050.c ****             * The DMP features can be enabled/disabled at runtime. Use this same
3941:Src/mpu6050.c ****             * approach for other features.
3942:Src/mpu6050.c ****             */
ARM GAS  /tmp/ccNfEN49.s 			page 250


3943:Src/mpu6050.c ****             hal.dmp_features ^= DMP_FEATURE_6X_LP_QUAT;
3944:Src/mpu6050.c ****             dmp_enable_feature(hal.dmp_features);
3945:Src/mpu6050.c ****             if (!(hal.dmp_features & DMP_FEATURE_6X_LP_QUAT)) {
3946:Src/mpu6050.c ****                 consoleLog("Quat OFF\n");
3947:Src/mpu6050.c ****             } else
3948:Src/mpu6050.c ****                 consoleLog("Quat ON\n");
3949:Src/mpu6050.c ****             break;
3950:Src/mpu6050.c **** 
3951:Src/mpu6050.c ****             /* Test out low-power accel mode. */
3952:Src/mpu6050.c ****         case 'w':
3953:Src/mpu6050.c ****             if (hal.dmp_on) {
3954:Src/mpu6050.c ****                 consoleLog("Low-power mode needs DMP to be off!\r\n");
3955:Src/mpu6050.c ****                 break;  /* LP accel is not compatible with the DMP. */
3956:Src/mpu6050.c ****             }
3957:Src/mpu6050.c ****             mpu_lp_accel_mode(20);
3958:Src/mpu6050.c ****             /* When LP accel mode is enabled, the driver automatically configures
3959:Src/mpu6050.c ****             * the hardware for latched interrupts. However, the MCU sometimes
3960:Src/mpu6050.c ****             * misses the rising/falling edge, and the hal.new_gyro flag is never
3961:Src/mpu6050.c ****             * set. To avoid getting locked in this state, we're overriding the
3962:Src/mpu6050.c ****             * driver's configuration and sticking to unlatched interrupt mode.
3963:Src/mpu6050.c ****             *
3964:Src/mpu6050.c ****             * TODO: The MCU supports level-triggered interrupts.
3965:Src/mpu6050.c ****             */
3966:Src/mpu6050.c ****             mpu_set_int_latched(0);
3967:Src/mpu6050.c ****             hal.sensors &= ~(GYRO_ON|COMPASS_ON);
3968:Src/mpu6050.c ****             hal.sensors |= ACCEL_ON;
3969:Src/mpu6050.c ****             hal.lp_accel_mode = 1;
3970:Src/mpu6050.c ****             break;
3971:Src/mpu6050.c **** 
3972:Src/mpu6050.c ****         /* The hardware self test is completely localized in the gyro driver.
3973:Src/mpu6050.c ****         * Logging is assumed to be enabled; otherwise, a couple LEDs could
3974:Src/mpu6050.c ****         * probably be used here to display the test results.
3975:Src/mpu6050.c ****         */
3976:Src/mpu6050.c ****         case 's':
3977:Src/mpu6050.c ****             mpu_start_self_test();
3978:Src/mpu6050.c ****             break;
3979:Src/mpu6050.c ****         #endif // MPU_SENSOR_ENABLE
3980:Src/mpu6050.c **** 
3981:Src/mpu6050.c ****         default:
3982:Src/mpu6050.c ****             break;
3983:Src/mpu6050.c ****     }
3984:Src/mpu6050.c **** #endif // SERIAL_DEBUG
3985:Src/mpu6050.c **** }
 8191              		.loc 1 3985 1 view .LVU2454
 8192 0000 7047     		bx	lr
 8193              		.cfi_endproc
 8194              	.LFE121:
 8196              		.global	test
 8197              		.global	hw
 8198              		.global	reg
 8199              		.global	last_quat_timestamp
 8200              		.global	imu_quaternion
 8201              		.global	mpu
 8202              		.section	.rodata
 8203              		.set	.LANCHOR1,. + 0
 8204              	.LC0:
 8205 0000 00000000 		.ascii	"\000\000\000\000\000\000"
ARM GAS  /tmp/ccNfEN49.s 			page 251


 8205      0000
 8206              		.section	.bss.hal,"aw",%nobits
 8207              		.align	2
 8208              		.set	.LANCHOR2,. + 0
 8211              	hal:
 8212 0000 00000000 		.space	28
 8212      00000000 
 8212      00000000 
 8212      00000000 
 8212      00000000 
 8213              		.section	.bss.imu_quaternion,"aw",%nobits
 8214              		.align	2
 8215              		.set	.LANCHOR7,. + 0
 8218              	imu_quaternion:
 8219 0000 00000000 		.space	16
 8219      00000000 
 8219      00000000 
 8219      00000000 
 8220              		.section	.bss.last_quat_timestamp,"aw",%nobits
 8221              		.align	3
 8222              		.set	.LANCHOR6,. + 0
 8225              	last_quat_timestamp:
 8226 0000 00000000 		.space	8
 8226      00000000 
 8227              		.section	.bss.mpu,"aw",%nobits
 8228              		.align	2
 8229              		.set	.LANCHOR3,. + 0
 8232              	mpu:
 8233 0000 00000000 		.space	36
 8233      00000000 
 8233      00000000 
 8233      00000000 
 8233      00000000 
 8234              		.section	.bss.quat.1,"aw",%nobits
 8235              		.align	2
 8236              		.set	.LANCHOR4,. + 0
 8239              	quat.1:
 8240 0000 00000000 		.space	16
 8240      00000000 
 8240      00000000 
 8240      00000000 
 8241              		.section	.bss.temperature.0,"aw",%nobits
 8242              		.align	2
 8243              		.set	.LANCHOR5,. + 0
 8246              	temperature.0:
 8247 0000 00000000 		.space	4
 8248              		.section	.data.st,"aw"
 8249              		.align	2
 8250              		.set	.LANCHOR0,. + 0
 8253              	st:
 8254 0000 00000000 		.word	reg
 8255 0004 00000000 		.word	hw
 8256 0008 00000000 		.space	32
 8256      00000000 
 8256      00000000 
 8256      00000000 
 8256      00000000 
ARM GAS  /tmp/ccNfEN49.s 			page 252


 8257 0028 00000000 		.word	test
 8258              		.section	.rodata.hw,"a"
 8259              		.align	1
 8262              	hw:
 8263 0000 68       		.byte	104
 8264 0001 00       		.space	1
 8265 0002 0004     		.short	1024
 8266 0004 76       		.byte	118
 8267 0005 00       		.space	1
 8268 0006 5401     		.short	340
 8269 0008 F7FD     		.short	-521
 8270 000a 0001     		.short	256
 8271              		.section	.rodata.reg,"a"
 8274              	reg:
 8275 0000 75       		.byte	117
 8276 0001 19       		.byte	25
 8277 0002 1A       		.byte	26
 8278 0003 0C       		.byte	12
 8279 0004 6A       		.byte	106
 8280 0005 23       		.byte	35
 8281 0006 1B       		.byte	27
 8282 0007 1C       		.byte	28
 8283 0008 0000     		.space	2
 8284 000a 1F       		.byte	31
 8285 000b 20       		.byte	32
 8286 000c 72       		.byte	114
 8287 000d 74       		.byte	116
 8288 000e 43       		.byte	67
 8289 000f 3B       		.byte	59
 8290 0010 41       		.byte	65
 8291 0011 38       		.byte	56
 8292 0012 39       		.byte	57
 8293 0013 3A       		.byte	58
 8294 0014 00       		.space	1
 8295 0015 6B       		.byte	107
 8296 0016 6C       		.byte	108
 8297 0017 37       		.byte	55
 8298 0018 6F       		.byte	111
 8299 0019 06       		.byte	6
 8300 001a 24       		.byte	36
 8301 001b 6D       		.byte	109
 8302 001c 6E       		.byte	110
 8303 001d 70       		.byte	112
 8304              		.section	.rodata.test,"a"
 8305              		.align	2
 8308              	test:
 8309 0000 83000000 		.word	131
 8310 0004 00080000 		.word	2048
 8311 0008 00       		.byte	0
 8312 0009 01       		.byte	1
 8313 000a 00       		.byte	0
 8314 000b 18       		.byte	24
 8315 000c 3200     		.short	50
 8316 000e 05       		.byte	5
 8317 000f 00       		.space	1
 8318 0010 00002041 		.word	1092616192
 8319 0014 0000D242 		.word	1121058816
ARM GAS  /tmp/ccNfEN49.s 			page 253


 8320 0018 295C0F3E 		.word	1041194025
 8321 001c 9A99993E 		.word	1050253722
 8322 0020 3333733F 		.word	1064514355
 8323 0024 295C0F3E 		.word	1041194025
 8324              		.text
 8325              	.Letext0:
 8326              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 8327              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 8328              		.file 4 "Inc/defines.h"
 8329              		.file 5 "Inc/madgwick_filter.h"
 8330              		.file 6 "Inc/util.h"
 8331              		.file 7 "/usr/include/newlib/math.h"
 8332              		.file 8 "Inc/mpu6050_dmp.h"
 8333              		.file 9 "Inc/systick.h"
 8334              		.file 10 "/usr/include/newlib/string.h"
ARM GAS  /tmp/ccNfEN49.s 			page 254


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mpu6050.c
     /tmp/ccNfEN49.s:17     .text.get_st_biases:0000000000000000 $t
     /tmp/ccNfEN49.s:24     .text.get_st_biases:0000000000000000 get_st_biases
     /tmp/ccNfEN49.s:556    .text.get_st_biases:00000000000002e4 $d
     /tmp/ccNfEN49.s:563    .text.get_st_biases:00000000000002e8 $t
     /tmp/ccNfEN49.s:641    .text.set_int_enable.isra.0:0000000000000000 $t
     /tmp/ccNfEN49.s:647    .text.set_int_enable.isra.0:0000000000000000 set_int_enable.isra.0
     /tmp/ccNfEN49.s:724    .text.set_int_enable.isra.0:0000000000000048 $d
     /tmp/ccNfEN49.s:729    .text.mpu_reg_dump:0000000000000000 $t
     /tmp/ccNfEN49.s:736    .text.mpu_reg_dump:0000000000000000 mpu_reg_dump
     /tmp/ccNfEN49.s:820    .text.mpu_reg_dump:0000000000000040 $d
     /tmp/ccNfEN49.s:825    .text.mpu_read_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:832    .text.mpu_read_reg:0000000000000000 mpu_read_reg
     /tmp/ccNfEN49.s:890    .text.mpu_read_reg:0000000000000030 $d
     /tmp/ccNfEN49.s:895    .text.mpu_get_gyro_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:902    .text.mpu_get_gyro_reg:0000000000000000 mpu_get_gyro_reg
     /tmp/ccNfEN49.s:993    .text.mpu_get_gyro_reg:0000000000000054 $d
     /tmp/ccNfEN49.s:998    .text.mpu_get_accel_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:1005   .text.mpu_get_accel_reg:0000000000000000 mpu_get_accel_reg
     /tmp/ccNfEN49.s:1096   .text.mpu_get_accel_reg:0000000000000054 $d
     /tmp/ccNfEN49.s:1107   .text.mpu_get_temperature:0000000000000000 $t
     /tmp/ccNfEN49.s:1114   .text.mpu_get_temperature:0000000000000000 mpu_get_temperature
     /tmp/ccNfEN49.s:1233   .text.mpu_get_temperature:0000000000000078 $d
     /tmp/ccNfEN49.s:1239   .text.mpu_read_6500_accel_bias:0000000000000000 $t
     /tmp/ccNfEN49.s:1246   .text.mpu_read_6500_accel_bias:0000000000000000 mpu_read_6500_accel_bias
     /tmp/ccNfEN49.s:1341   .text.mpu_read_6500_accel_bias:0000000000000064 $d
     /tmp/ccNfEN49.s:1346   .text.mpu_read_6050_accel_bias:0000000000000000 $t
     /tmp/ccNfEN49.s:1353   .text.mpu_read_6050_accel_bias:0000000000000000 mpu_read_6050_accel_bias
     /tmp/ccNfEN49.s:1448   .text.mpu_read_6050_accel_bias:0000000000000064 $d
     /tmp/ccNfEN49.s:1453   .text.mpu_read_6500_gyro_bias:0000000000000000 $t
     /tmp/ccNfEN49.s:1460   .text.mpu_read_6500_gyro_bias:0000000000000000 mpu_read_6500_gyro_bias
     /tmp/ccNfEN49.s:1555   .text.mpu_read_6500_gyro_bias:0000000000000064 $d
     /tmp/ccNfEN49.s:1560   .text.mpu_set_gyro_bias_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:1567   .text.mpu_set_gyro_bias_reg:0000000000000000 mpu_set_gyro_bias_reg
     /tmp/ccNfEN49.s:1692   .text.mpu_set_gyro_bias_reg:0000000000000078 $d
     /tmp/ccNfEN49.s:1697   .text.mpu_set_accel_bias_6050_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:1704   .text.mpu_set_accel_bias_6050_reg:0000000000000000 mpu_set_accel_bias_6050_reg
     /tmp/ccNfEN49.s:1868   .text.mpu_set_accel_bias_6050_reg:00000000000000ac $d
     /tmp/ccNfEN49.s:1874   .text.mpu_set_accel_bias_6500_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:1881   .text.mpu_set_accel_bias_6500_reg:0000000000000000 mpu_set_accel_bias_6500_reg
     /tmp/ccNfEN49.s:2045   .text.mpu_set_accel_bias_6500_reg:00000000000000ac $d
     /tmp/ccNfEN49.s:2051   .text.mpu_reset_fifo:0000000000000000 $t
     /tmp/ccNfEN49.s:2058   .text.mpu_reset_fifo:0000000000000000 mpu_reset_fifo
     /tmp/ccNfEN49.s:2309   .text.mpu_reset_fifo:0000000000000164 $d
     /tmp/ccNfEN49.s:2315   .text.mpu_get_gyro_fsr:0000000000000000 $t
     /tmp/ccNfEN49.s:2322   .text.mpu_get_gyro_fsr:0000000000000000 mpu_get_gyro_fsr
     /tmp/ccNfEN49.s:2339   .text.mpu_get_gyro_fsr:000000000000000c $d
     /tmp/ccNfEN49.s:2343   .text.mpu_get_gyro_fsr:0000000000000010 $t
     /tmp/ccNfEN49.s:2382   .text.mpu_get_gyro_fsr:0000000000000030 $d
     /tmp/ccNfEN49.s:2387   .text.mpu_set_gyro_fsr:0000000000000000 $t
     /tmp/ccNfEN49.s:2394   .text.mpu_set_gyro_fsr:0000000000000000 mpu_set_gyro_fsr
     /tmp/ccNfEN49.s:2502   .text.mpu_set_gyro_fsr:000000000000006c $d
     /tmp/ccNfEN49.s:2507   .text.mpu_get_accel_fsr:0000000000000000 $t
     /tmp/ccNfEN49.s:2514   .text.mpu_get_accel_fsr:0000000000000000 mpu_get_accel_fsr
     /tmp/ccNfEN49.s:2531   .text.mpu_get_accel_fsr:000000000000000c $d
     /tmp/ccNfEN49.s:2535   .text.mpu_get_accel_fsr:0000000000000010 $t
ARM GAS  /tmp/ccNfEN49.s 			page 255


     /tmp/ccNfEN49.s:2584   .text.mpu_get_accel_fsr:0000000000000034 $d
     /tmp/ccNfEN49.s:2589   .text.mpu_set_accel_fsr:0000000000000000 $t
     /tmp/ccNfEN49.s:2596   .text.mpu_set_accel_fsr:0000000000000000 mpu_set_accel_fsr
     /tmp/ccNfEN49.s:2704   .text.mpu_set_accel_fsr:0000000000000064 $d
     /tmp/ccNfEN49.s:2709   .text.mpu_get_lpf:0000000000000000 $t
     /tmp/ccNfEN49.s:2716   .text.mpu_get_lpf:0000000000000000 mpu_get_lpf
     /tmp/ccNfEN49.s:2734   .text.mpu_get_lpf:000000000000000e $d
     /tmp/ccNfEN49.s:2740   .text.mpu_get_lpf:0000000000000014 $t
     /tmp/ccNfEN49.s:2789   .text.mpu_get_lpf:0000000000000034 $d
     /tmp/ccNfEN49.s:2794   .text.mpu_set_lpf:0000000000000000 $t
     /tmp/ccNfEN49.s:2801   .text.mpu_set_lpf:0000000000000000 mpu_set_lpf
     /tmp/ccNfEN49.s:2923   .text.mpu_set_lpf:0000000000000068 $d
     /tmp/ccNfEN49.s:2928   .text.mpu_get_sample_rate:0000000000000000 $t
     /tmp/ccNfEN49.s:2935   .text.mpu_get_sample_rate:0000000000000000 mpu_get_sample_rate
     /tmp/ccNfEN49.s:2969   .text.mpu_get_sample_rate:0000000000000018 $d
     /tmp/ccNfEN49.s:2974   .text.mpu_get_compass_sample_rate:0000000000000000 $t
     /tmp/ccNfEN49.s:2981   .text.mpu_get_compass_sample_rate:0000000000000000 mpu_get_compass_sample_rate
     /tmp/ccNfEN49.s:3003   .text.mpu_set_compass_sample_rate:0000000000000000 $t
     /tmp/ccNfEN49.s:3010   .text.mpu_set_compass_sample_rate:0000000000000000 mpu_set_compass_sample_rate
     /tmp/ccNfEN49.s:3028   .text.mpu_get_gyro_sens:0000000000000000 $t
     /tmp/ccNfEN49.s:3035   .text.mpu_get_gyro_sens:0000000000000000 mpu_get_gyro_sens
     /tmp/ccNfEN49.s:3052   .text.mpu_get_gyro_sens:000000000000000c $d
     /tmp/ccNfEN49.s:3056   .text.mpu_get_gyro_sens:0000000000000010 $t
     /tmp/ccNfEN49.s:3095   .text.mpu_get_gyro_sens:000000000000002c $d
     /tmp/ccNfEN49.s:3104   .text.mpu_get_accel_sens:0000000000000000 $t
     /tmp/ccNfEN49.s:3111   .text.mpu_get_accel_sens:0000000000000000 mpu_get_accel_sens
     /tmp/ccNfEN49.s:3128   .text.mpu_get_accel_sens:000000000000000c $d
     /tmp/ccNfEN49.s:3132   .text.mpu_get_accel_sens:0000000000000010 $t
     /tmp/ccNfEN49.s:3181   .text.mpu_get_accel_sens:000000000000003c $d
     /tmp/ccNfEN49.s:3186   .text.mpu_get_fifo_config:0000000000000000 $t
     /tmp/ccNfEN49.s:3193   .text.mpu_get_fifo_config:0000000000000000 mpu_get_fifo_config
     /tmp/ccNfEN49.s:3216   .text.mpu_get_fifo_config:000000000000000c $d
     /tmp/ccNfEN49.s:3221   .text.mpu_configure_fifo:0000000000000000 $t
     /tmp/ccNfEN49.s:3228   .text.mpu_configure_fifo:0000000000000000 mpu_configure_fifo
     /tmp/ccNfEN49.s:3323   .text.mpu_configure_fifo:0000000000000048 $d
     /tmp/ccNfEN49.s:3328   .text.mpu_get_power_state:0000000000000000 $t
     /tmp/ccNfEN49.s:3335   .text.mpu_get_power_state:0000000000000000 mpu_get_power_state
     /tmp/ccNfEN49.s:3361   .text.mpu_get_power_state:0000000000000010 $d
     /tmp/ccNfEN49.s:3366   .text.mpu_get_int_status:0000000000000000 $t
     /tmp/ccNfEN49.s:3373   .text.mpu_get_int_status:0000000000000000 mpu_get_int_status
     /tmp/ccNfEN49.s:3436   .text.mpu_get_int_status:0000000000000030 $d
     /tmp/ccNfEN49.s:3441   .text.mpu_read_fifo:0000000000000000 $t
     /tmp/ccNfEN49.s:3448   .text.mpu_read_fifo:0000000000000000 mpu_read_fifo
     /tmp/ccNfEN49.s:3803   .text.mpu_read_fifo:000000000000019c $d
     /tmp/ccNfEN49.s:3808   .text.mpu_read_fifo_stream:0000000000000000 $t
     /tmp/ccNfEN49.s:3815   .text.mpu_read_fifo_stream:0000000000000000 mpu_read_fifo_stream
     /tmp/ccNfEN49.s:3959   .text.mpu_read_fifo_stream:0000000000000094 $d
     /tmp/ccNfEN49.s:3964   .text.mpu_set_bypass:0000000000000000 $t
     /tmp/ccNfEN49.s:3971   .text.mpu_set_bypass:0000000000000000 mpu_set_bypass
     /tmp/ccNfEN49.s:4154   .text.mpu_set_bypass:00000000000000e4 $d
     /tmp/ccNfEN49.s:4159   .text.mpu_set_int_level:0000000000000000 $t
     /tmp/ccNfEN49.s:4166   .text.mpu_set_int_level:0000000000000000 mpu_set_int_level
     /tmp/ccNfEN49.s:4187   .text.mpu_set_int_level:000000000000000c $d
     /tmp/ccNfEN49.s:4192   .text.mpu_set_int_latched:0000000000000000 $t
     /tmp/ccNfEN49.s:4199   .text.mpu_set_int_latched:0000000000000000 mpu_set_int_latched
     /tmp/ccNfEN49.s:4291   .text.mpu_set_int_latched:0000000000000060 $d
     /tmp/ccNfEN49.s:4296   .text.mpu_lp_accel_mode:0000000000000000 $t
ARM GAS  /tmp/ccNfEN49.s 			page 256


     /tmp/ccNfEN49.s:4303   .text.mpu_lp_accel_mode:0000000000000000 mpu_lp_accel_mode
     /tmp/ccNfEN49.s:4484   .text.mpu_lp_accel_mode:00000000000000ac $d
     /tmp/ccNfEN49.s:4489   .text.mpu_set_sample_rate:0000000000000000 $t
     /tmp/ccNfEN49.s:4496   .text.mpu_set_sample_rate:0000000000000000 mpu_set_sample_rate
     /tmp/ccNfEN49.s:4616   .text.mpu_set_sample_rate:000000000000007c $d
     /tmp/ccNfEN49.s:4621   .text.mpu_set_sensors:0000000000000000 $t
     /tmp/ccNfEN49.s:4628   .text.mpu_set_sensors:0000000000000000 mpu_set_sensors
     /tmp/ccNfEN49.s:4796   .text.mpu_set_sensors:00000000000000bc $d
     /tmp/ccNfEN49.s:4801   .text.mpu_init:0000000000000000 $t
     /tmp/ccNfEN49.s:4808   .text.mpu_init:0000000000000000 mpu_init
     /tmp/ccNfEN49.s:4977   .text.mpu_init:00000000000000b0 $d
     /tmp/ccNfEN49.s:4982   .text.mpu_write_mem:0000000000000000 $t
     /tmp/ccNfEN49.s:4989   .text.mpu_write_mem:0000000000000000 mpu_write_mem
     /tmp/ccNfEN49.s:5089   .text.mpu_write_mem:000000000000005c $d
     /tmp/ccNfEN49.s:5094   .text.mpu_read_mem:0000000000000000 $t
     /tmp/ccNfEN49.s:5101   .text.mpu_read_mem:0000000000000000 mpu_read_mem
     /tmp/ccNfEN49.s:5201   .text.mpu_read_mem:000000000000005c $d
     /tmp/ccNfEN49.s:5206   .text.mpu_load_firmware:0000000000000000 $t
     /tmp/ccNfEN49.s:5213   .text.mpu_load_firmware:0000000000000000 mpu_load_firmware
     /tmp/ccNfEN49.s:5365   .text.mpu_load_firmware:000000000000009c $d
     /tmp/ccNfEN49.s:5370   .text.mpu_set_dmp_state:0000000000000000 $t
     /tmp/ccNfEN49.s:5377   .text.mpu_set_dmp_state:0000000000000000 mpu_set_dmp_state
     /tmp/ccNfEN49.s:5503   .text.mpu_set_dmp_state:0000000000000078 $d
     /tmp/ccNfEN49.s:5511   .text.mpu_run_self_test:0000000000000000 $t
     /tmp/ccNfEN49.s:5518   .text.mpu_run_self_test:0000000000000000 mpu_run_self_test
     /tmp/ccNfEN49.s:6222   .text.mpu_run_self_test:00000000000002ec $d
     /tmp/ccNfEN49.s:6238   .text.mpu_get_dmp_state:0000000000000000 $t
     /tmp/ccNfEN49.s:6245   .text.mpu_get_dmp_state:0000000000000000 mpu_get_dmp_state
     /tmp/ccNfEN49.s:6268   .text.mpu_get_dmp_state:000000000000000c $d
     /tmp/ccNfEN49.s:6273   .text.mpu_get_compass_reg:0000000000000000 $t
     /tmp/ccNfEN49.s:6280   .text.mpu_get_compass_reg:0000000000000000 mpu_get_compass_reg
     /tmp/ccNfEN49.s:6298   .text.mpu_get_compass_fsr:0000000000000000 $t
     /tmp/ccNfEN49.s:6305   .text.mpu_get_compass_fsr:0000000000000000 mpu_get_compass_fsr
     /tmp/ccNfEN49.s:6323   .text.mpu_lp_motion_interrupt:0000000000000000 $t
     /tmp/ccNfEN49.s:6330   .text.mpu_lp_motion_interrupt:0000000000000000 mpu_lp_motion_interrupt
     /tmp/ccNfEN49.s:6505   .text.mpu_lp_motion_interrupt:000000000000009c $d
     /tmp/ccNfEN49.s:6523   .text.mpu_start_self_test:0000000000000000 $t
     /tmp/ccNfEN49.s:6530   .text.mpu_start_self_test:0000000000000000 mpu_start_self_test
     /tmp/ccNfEN49.s:6610   .text.mpu_start_self_test:0000000000000038 $d
     /tmp/ccNfEN49.s:6627   .text.mpu_setup_gyro:0000000000000000 $t
     /tmp/ccNfEN49.s:6634   .text.mpu_setup_gyro:0000000000000000 mpu_setup_gyro
     /tmp/ccNfEN49.s:6732   .text.mpu_setup_gyro:0000000000000050 $d
     /tmp/ccNfEN49.s:6741   .text.inv_row_2_scale:0000000000000000 $t
     /tmp/ccNfEN49.s:6748   .text.inv_row_2_scale:0000000000000000 inv_row_2_scale
     /tmp/ccNfEN49.s:6849   .text.inv_orientation_matrix_to_scalar:0000000000000000 $t
     /tmp/ccNfEN49.s:6856   .text.inv_orientation_matrix_to_scalar:0000000000000000 inv_orientation_matrix_to_scalar
     /tmp/ccNfEN49.s:6913   .text.mpu_config:0000000000000000 $t
     /tmp/ccNfEN49.s:6920   .text.mpu_config:0000000000000000 mpu_config
     /tmp/ccNfEN49.s:6994   .text.mpu_config:0000000000000048 $d
     /tmp/ccNfEN49.s:7002   .text.mpu_read_gyro_raw:0000000000000000 $t
     /tmp/ccNfEN49.s:7009   .text.mpu_read_gyro_raw:0000000000000000 mpu_read_gyro_raw
     /tmp/ccNfEN49.s:7057   .text.mpu_read_gyro_raw:0000000000000034 $d
     /tmp/ccNfEN49.s:7063   .text.mpu_read_accel_raw:0000000000000000 $t
     /tmp/ccNfEN49.s:7070   .text.mpu_read_accel_raw:0000000000000000 mpu_read_accel_raw
     /tmp/ccNfEN49.s:7118   .text.mpu_read_accel_raw:0000000000000034 $d
     /tmp/ccNfEN49.s:7128   .text.mpu_calc_euler_angles:0000000000000000 $t
     /tmp/ccNfEN49.s:7135   .text.mpu_calc_euler_angles:0000000000000000 mpu_calc_euler_angles
ARM GAS  /tmp/ccNfEN49.s 			page 257


     /tmp/ccNfEN49.s:7457   .text.mpu_calc_euler_angles:00000000000001a8 $d
     /tmp/ccNfEN49.s:7469   .text.mpu_get_data:0000000000000000 $t
     /tmp/ccNfEN49.s:7476   .text.mpu_get_data:0000000000000000 mpu_get_data
     /tmp/ccNfEN49.s:7975   .text.mpu_get_data:0000000000000280 $d
     /tmp/ccNfEN49.s:8006   .text.mpu_tap_func:0000000000000000 $t
     /tmp/ccNfEN49.s:8013   .text.mpu_tap_func:0000000000000000 mpu_tap_func
     /tmp/ccNfEN49.s:8029   .text.mpu_tap_func:000000000000000a $d
     /tmp/ccNfEN49.s:8035   .text.mpu_tap_func:0000000000000010 $t
     /tmp/ccNfEN49.s:8069   .text.mpu_tap_func:000000000000002c $d
     /tmp/ccNfEN49.s:8088   .text.mpu_android_orient_func:0000000000000000 $t
     /tmp/ccNfEN49.s:8095   .text.mpu_android_orient_func:0000000000000000 mpu_android_orient_func
     /tmp/ccNfEN49.s:8108   .text.mpu_android_orient_func:0000000000000008 $d
     /tmp/ccNfEN49.s:8112   .text.mpu_android_orient_func:000000000000000c $t
     /tmp/ccNfEN49.s:8148   .text.mpu_android_orient_func:0000000000000020 $d
     /tmp/ccNfEN49.s:8156   .text.mpu_print_to_console:0000000000000000 $t
     /tmp/ccNfEN49.s:8163   .text.mpu_print_to_console:0000000000000000 mpu_print_to_console
     /tmp/ccNfEN49.s:8176   .text.mpu_handle_input:0000000000000000 $t
     /tmp/ccNfEN49.s:8183   .text.mpu_handle_input:0000000000000000 mpu_handle_input
     /tmp/ccNfEN49.s:8308   .rodata.test:0000000000000000 test
     /tmp/ccNfEN49.s:8262   .rodata.hw:0000000000000000 hw
     /tmp/ccNfEN49.s:8274   .rodata.reg:0000000000000000 reg
     /tmp/ccNfEN49.s:8225   .bss.last_quat_timestamp:0000000000000000 last_quat_timestamp
     /tmp/ccNfEN49.s:8218   .bss.imu_quaternion:0000000000000000 imu_quaternion
     /tmp/ccNfEN49.s:8232   .bss.mpu:0000000000000000 mpu
     /tmp/ccNfEN49.s:8207   .bss.hal:0000000000000000 $d
     /tmp/ccNfEN49.s:8211   .bss.hal:0000000000000000 hal
     /tmp/ccNfEN49.s:8214   .bss.imu_quaternion:0000000000000000 $d
     /tmp/ccNfEN49.s:8221   .bss.last_quat_timestamp:0000000000000000 $d
     /tmp/ccNfEN49.s:8228   .bss.mpu:0000000000000000 $d
     /tmp/ccNfEN49.s:8235   .bss.quat.1:0000000000000000 $d
     /tmp/ccNfEN49.s:8239   .bss.quat.1:0000000000000000 quat.1
     /tmp/ccNfEN49.s:8242   .bss.temperature.0:0000000000000000 $d
     /tmp/ccNfEN49.s:8246   .bss.temperature.0:0000000000000000 temperature.0
     /tmp/ccNfEN49.s:8249   .data.st:0000000000000000 $d
     /tmp/ccNfEN49.s:8253   .data.st:0000000000000000 st
     /tmp/ccNfEN49.s:8259   .rodata.hw:0000000000000000 $d
     /tmp/ccNfEN49.s:8283   .rodata.reg:0000000000000008 $d
     /tmp/ccNfEN49.s:8305   .rodata.test:0000000000000000 $d

UNDEFINED SYMBOLS
__aeabi_ldivmod
i2c_writeBytes
delay_1ms
i2c_readBytes
get_tick_count_ms
__aeabi_i2f
__aeabi_fsub
__aeabi_fdiv
__aeabi_fadd
__aeabi_fmul
__aeabi_f2iz
memcmp
__aeabi_fcmpeq
__aeabi_fcmpgt
__aeabi_fcmplt
consoleLog
__aeabi_f2d
ARM GAS  /tmp/ccNfEN49.s 			page 258


__aeabi_d2f
__aeabi_dmul
__aeabi_d2iz
atan2
asin
__aeabi_ui2d
__aeabi_dsub
__aeabi_ddiv
__aeabi_i2d
i2c_readByte
dmp_read_fifo
madgwick_update
quat_to_euler
