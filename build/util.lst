ARM GAS  /tmp/ccpMgpO6.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.consoleLog,"ax",%progbits
  16              		.align	1
  17              		.global	consoleLog
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	consoleLog:
  25              	.LVL0:
  26              	.LFB59:
  27              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-sideboard-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <string.h>
  23:Src/util.c    **** #include "systick.h"
  24:Src/util.c    **** #include "gd32f1x0.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "config.h"
  27:Src/util.c    **** #include "setup.h"
  28:Src/util.c    **** #include "util.h"
  29:Src/util.c    **** #include "mpu6050.h"
  30:Src/util.c    **** 
  31:Src/util.c    **** // USART1 variables
ARM GAS  /tmp/ccpMgpO6.s 			page 2


  32:Src/util.c    **** #ifdef SERIAL_CONTROL
  33:Src/util.c    **** static SerialSideboard Sideboard;
  34:Src/util.c    **** static SideboardImuRaw sideboard_imu;
  35:Src/util.c    **** #endif
  36:Src/util.c    **** 
  37:Src/util.c    **** #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
  38:Src/util.c    **** static uint8_t  rx1_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  39:Src/util.c    **** static uint32_t rx1_buffer_len = ARRAY_LEN(rx1_buffer);
  40:Src/util.c    **** #endif
  41:Src/util.c    **** 
  42:Src/util.c    **** #ifdef SERIAL_FEEDBACK
  43:Src/util.c    **** static SerialFeedback Feedback;
  44:Src/util.c    **** static SerialFeedback FeedbackRaw;
  45:Src/util.c    **** static uint16_t timeoutCntSerial1  = 0;         // Timeout counter for UART1 Rx Serial
  46:Src/util.c    **** static uint8_t  timeoutFlagSerial1 = 0;         // Timeout Flag for UART1 Rx Serial: 0 = OK, 1 = Pr
  47:Src/util.c    **** static uint32_t Feedback_len  = sizeof(Feedback);
  48:Src/util.c    **** #endif
  49:Src/util.c    **** 
  50:Src/util.c    **** // USART0 variables
  51:Src/util.c    **** #ifdef SERIAL_AUX_TX
  52:Src/util.c    **** static SerialAuxTx AuxTx;
  53:Src/util.c    **** #endif
  54:Src/util.c    **** 
  55:Src/util.c    **** #ifdef SERIAL_AUX_RX
  56:Src/util.c    **** static uint8_t  rx0_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  57:Src/util.c    **** static uint32_t rx0_buffer_len = ARRAY_LEN(rx0_buffer);
  58:Src/util.c    **** #endif
  59:Src/util.c    **** 
  60:Src/util.c    **** #ifdef SERIAL_AUX_RX
  61:Src/util.c    **** static SerialCommand command;
  62:Src/util.c    **** static SerialCommand command_raw;
  63:Src/util.c    **** static uint16_t timeoutCntSerial0  = 0;         // Timeout counter for UART0 Rx Serial
  64:Src/util.c    **** static uint8_t  timeoutFlagSerial0 = 0;         // Timeout Flag for UART0 Rx Serial: 0 = OK, 1 = Pr
  65:Src/util.c    **** static uint32_t command_len = sizeof(command);
  66:Src/util.c    **** extern uint8_t  print_aux;
  67:Src/util.c    ****   #ifdef CONTROL_IBUS
  68:Src/util.c    ****   static uint16_t ibus_chksum;
  69:Src/util.c    ****   static uint16_t ibus_captured_value[IBUS_NUM_CHANNELS];
  70:Src/util.c    ****   #endif
  71:Src/util.c    **** #endif
  72:Src/util.c    **** 
  73:Src/util.c    **** #if (defined(SERIAL_AUX_RX) && defined(CONTROL_IBUS)) || defined(SERIAL_CONTROL)
  74:Src/util.c    **** static int16_t  cmd1, cmd2;
  75:Src/util.c    **** static uint16_t cmdSwitch;
  76:Src/util.c    **** #endif
  77:Src/util.c    **** 
  78:Src/util.c    **** // Optical sensors variables
  79:Src/util.c    **** static FlagStatus   sensor1, sensor2;           // holds the sensor1 and sensor 2 values
  80:Src/util.c    **** static FlagStatus   sensor1_read, sensor2_read; // holds the instantaneous Read for sensor1 and sen
  81:Src/util.c    **** 
  82:Src/util.c    **** // MPU variables
  83:Src/util.c    **** extern MPU_Data     mpu;                        // holds the MPU-6050 data
  84:Src/util.c    **** #if defined(MPU_SENSOR_ENABLE) || defined(SERIAL_CONTROL)
  85:Src/util.c    **** static ErrStatus    mpuStatus;                  // holds the MPU-6050 status: SUCCESS or ERROR
  86:Src/util.c    **** #endif
  87:Src/util.c    **** 
  88:Src/util.c    **** extern uint32_t     main_loop_counter;          // main loop counter to perform task scheduling ins
ARM GAS  /tmp/ccpMgpO6.s 			page 3


  89:Src/util.c    **** 
  90:Src/util.c    **** // MAIN I2C variables
  91:Src/util.c    **** volatile int8_t     i2c_status;
  92:Src/util.c    **** volatile i2c_cmd    i2c_ReadWriteCmd;
  93:Src/util.c    **** volatile uint8_t    i2c_regAddress;
  94:Src/util.c    **** volatile uint8_t    i2c_slaveAddress;
  95:Src/util.c    **** volatile uint8_t*   i2c_txbuffer;
  96:Src/util.c    **** volatile uint8_t*   i2c_rxbuffer;
  97:Src/util.c    **** volatile uint8_t    i2c_nDABytes;
  98:Src/util.c    **** volatile  int8_t    i2c_nRABytes;
  99:Src/util.c    **** volatile uint8_t    buffer[14];
 100:Src/util.c    **** 
 101:Src/util.c    **** #ifdef AUX45_USE_I2C
 102:Src/util.c    **** // AUX I2C variables
 103:Src/util.c    **** volatile int8_t     i2c_aux_status;
 104:Src/util.c    **** volatile i2c_cmd    i2c_aux_ReadWriteCmd;
 105:Src/util.c    **** volatile uint8_t    i2c_aux_regAddress;
 106:Src/util.c    **** volatile uint8_t    i2c_aux_slaveAddress;
 107:Src/util.c    **** volatile uint8_t*   i2c_aux_txbuffer;
 108:Src/util.c    **** volatile uint8_t*   i2c_aux_rxbuffer;
 109:Src/util.c    **** volatile uint8_t    i2c_aux_nDABytes;
 110:Src/util.c    **** volatile  int8_t    i2c_aux_nRABytes;
 111:Src/util.c    **** #endif
 112:Src/util.c    **** 
 113:Src/util.c    **** 
 114:Src/util.c    **** 
 115:Src/util.c    **** /* =========================== General Functions =========================== */
 116:Src/util.c    **** 
 117:Src/util.c    **** void consoleLog(char *message)
 118:Src/util.c    **** {
  28              		.loc 1 118 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
 119:Src/util.c    ****   #ifdef SERIAL_DEBUG
 120:Src/util.c    ****     log_i("%s", message);
 121:Src/util.c    ****   #endif
 122:Src/util.c    **** }
  33              		.loc 1 122 1 view .LVU1
  34 0000 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE59:
  38              		.section	.text.toggle_led,"ax",%progbits
  39              		.align	1
  40              		.global	toggle_led
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	toggle_led:
  47              	.LVL1:
  48              	.LFB60:
 123:Src/util.c    **** 
 124:Src/util.c    **** 
 125:Src/util.c    **** /* retarget the C library printf function to the USART */
 126:Src/util.c    **** #ifdef SERIAL_DEBUG	
ARM GAS  /tmp/ccpMgpO6.s 			page 4


 127:Src/util.c    ****     #ifdef __GNUC__
 128:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 129:Src/util.c    ****     #else
 130:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 131:Src/util.c    ****     #endif
 132:Src/util.c    ****     PUTCHAR_PROTOTYPE {
 133:Src/util.c    ****         usart_data_transmit(USART_MAIN, (uint8_t)ch);
 134:Src/util.c    ****         while(RESET == usart_flag_get(USART_MAIN, USART_FLAG_TBE));
 135:Src/util.c    ****         return ch;
 136:Src/util.c    ****     }
 137:Src/util.c    ****     
 138:Src/util.c    ****     #ifdef __GNUC__
 139:Src/util.c    ****         int _write(int file, char *data, int len) {
 140:Src/util.c    ****             int i;
 141:Src/util.c    ****             for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 142:Src/util.c    ****             return len; 
 143:Src/util.c    ****         }
 144:Src/util.c    ****     #endif
 145:Src/util.c    **** #endif
 146:Src/util.c    **** 
 147:Src/util.c    **** 
 148:Src/util.c    **** void toggle_led(uint32_t gpio_periph, uint32_t pin)
 149:Src/util.c    **** {
  49              		.loc 1 149 1 view -0
  50              		.cfi_startproc
  51              		@ args = 0, pretend = 0, frame = 0
  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
 150:Src/util.c    ****     GPIO_OCTL(gpio_periph) ^= pin;
  54              		.loc 1 150 5 view .LVU3
  55              		.loc 1 150 28 is_stmt 0 view .LVU4
  56 0000 4369     		ldr	r3, [r0, #20]
  57 0002 4B40     		eors	r3, r3, r1
  58 0004 4361     		str	r3, [r0, #20]
 151:Src/util.c    **** }
  59              		.loc 1 151 1 view .LVU5
  60 0006 7047     		bx	lr
  61              		.cfi_endproc
  62              	.LFE60:
  64              		.section	.text.intro_demo_led,"ax",%progbits
  65              		.align	1
  66              		.global	intro_demo_led
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu softvfp
  72              	intro_demo_led:
  73              	.LVL2:
  74              	.LFB61:
 152:Src/util.c    **** 
 153:Src/util.c    **** 
 154:Src/util.c    **** void intro_demo_led(uint32_t tDelay)
 155:Src/util.c    **** {
  75              		.loc 1 155 1 is_stmt 1 view -0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccpMgpO6.s 			page 5


 156:Src/util.c    ****     int i;
  79              		.loc 1 156 5 view .LVU7
 157:Src/util.c    **** 
 158:Src/util.c    ****     for (i = 0; i < 3; i++) {
  80              		.loc 1 158 5 view .LVU8
  81              		.loc 1 158 17 view .LVU9
 155:Src/util.c    ****     int i;
  82              		.loc 1 155 1 is_stmt 0 view .LVU10
  83 0000 70B5     		push	{r4, r5, r6, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 16
  86              		.cfi_offset 4, -16
  87              		.cfi_offset 5, -12
  88              		.cfi_offset 6, -8
  89              		.cfi_offset 14, -4
 155:Src/util.c    ****     int i;
  90              		.loc 1 155 1 view .LVU11
  91 0002 0546     		mov	r5, r0
  92 0004 0326     		movs	r6, #3
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 160:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
  93              		.loc 1 160 9 view .LVU12
  94 0006 314C     		ldr	r4, .L8
  95              	.LVL3:
  96              	.L4:
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
  97              		.loc 1 159 9 is_stmt 1 discriminator 3 view .LVU13
  98 0008 0121     		movs	r1, #1
  99 000a 4FF09040 		mov	r0, #1207959552
 100 000e FFF7FEFF 		bl	gpio_bit_set
 101              	.LVL4:
 102              		.loc 1 160 9 discriminator 3 view .LVU14
 103 0012 4FF48071 		mov	r1, #256
 104 0016 2046     		mov	r0, r4
 105 0018 FFF7FEFF 		bl	gpio_bit_reset
 106              	.LVL5:
 161:Src/util.c    ****         delay_1ms(tDelay);
 107              		.loc 1 161 9 discriminator 3 view .LVU15
 108 001c 2846     		mov	r0, r5
 109 001e FFF7FEFF 		bl	delay_1ms
 110              	.LVL6:
 162:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 111              		.loc 1 162 9 discriminator 3 view .LVU16
 112 0022 4FF40071 		mov	r1, #512
 113 0026 2046     		mov	r0, r4
 114 0028 FFF7FEFF 		bl	gpio_bit_set
 115              	.LVL7:
 163:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 116              		.loc 1 163 9 discriminator 3 view .LVU17
 117 002c 0121     		movs	r1, #1
 118 002e 4FF09040 		mov	r0, #1207959552
 119 0032 FFF7FEFF 		bl	gpio_bit_reset
 120              	.LVL8:
 164:Src/util.c    ****         delay_1ms(tDelay);
 121              		.loc 1 164 9 discriminator 3 view .LVU18
 122 0036 2846     		mov	r0, r5
 123 0038 FFF7FEFF 		bl	delay_1ms
ARM GAS  /tmp/ccpMgpO6.s 			page 6


 124              	.LVL9:
 165:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 125              		.loc 1 165 9 discriminator 3 view .LVU19
 126 003c 4FF48071 		mov	r1, #256
 127 0040 2046     		mov	r0, r4
 128 0042 FFF7FEFF 		bl	gpio_bit_set
 129              	.LVL10:
 166:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 130              		.loc 1 166 9 discriminator 3 view .LVU20
 131 0046 4FF40071 		mov	r1, #512
 132 004a 2046     		mov	r0, r4
 133 004c FFF7FEFF 		bl	gpio_bit_reset
 134              	.LVL11:
 167:Src/util.c    ****         delay_1ms(tDelay);
 135              		.loc 1 167 9 discriminator 3 view .LVU21
 136 0050 2846     		mov	r0, r5
 137 0052 FFF7FEFF 		bl	delay_1ms
 138              	.LVL12:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 139              		.loc 1 158 24 discriminator 3 view .LVU22
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 140              		.loc 1 158 17 discriminator 3 view .LVU23
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 141              		.loc 1 158 5 is_stmt 0 discriminator 3 view .LVU24
 142 0056 013E     		subs	r6, r6, #1
 143              	.LVL13:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 144              		.loc 1 158 5 discriminator 3 view .LVU25
 145 0058 D6D1     		bne	.L4
 146 005a 0226     		movs	r6, #2
 147              	.LVL14:
 168:Src/util.c    ****     }
 169:Src/util.c    **** 
 170:Src/util.c    ****     for (i = 0; i < 2; i++) {
 171:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 172:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 148              		.loc 1 172 9 view .LVU26
 149 005c 1B4C     		ldr	r4, .L8
 150              	.L5:
 151              	.LVL15:
 171:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 152              		.loc 1 171 9 is_stmt 1 discriminator 3 view .LVU27
 153 005e 0121     		movs	r1, #1
 154 0060 4FF09040 		mov	r0, #1207959552
 155 0064 FFF7FEFF 		bl	gpio_bit_set
 156              	.LVL16:
 157              		.loc 1 172 9 discriminator 3 view .LVU28
 158 0068 4FF40071 		mov	r1, #512
 159 006c 2046     		mov	r0, r4
 160 006e FFF7FEFF 		bl	gpio_bit_set
 161              	.LVL17:
 173:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 162              		.loc 1 173 9 discriminator 3 view .LVU29
 163 0072 4FF48071 		mov	r1, #256
 164 0076 2046     		mov	r0, r4
 165 0078 FFF7FEFF 		bl	gpio_bit_set
 166              	.LVL18:
ARM GAS  /tmp/ccpMgpO6.s 			page 7


 174:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 167              		.loc 1 174 9 discriminator 3 view .LVU30
 168 007c 2021     		movs	r1, #32
 169 007e 2046     		mov	r0, r4
 170 0080 FFF7FEFF 		bl	gpio_bit_set
 171              	.LVL19:
 175:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 172              		.loc 1 175 9 discriminator 3 view .LVU31
 173 0084 1021     		movs	r1, #16
 174 0086 2046     		mov	r0, r4
 175 0088 FFF7FEFF 		bl	gpio_bit_set
 176              	.LVL20:
 176:Src/util.c    ****         delay_1ms(tDelay);
 177              		.loc 1 176 9 discriminator 3 view .LVU32
 178 008c 2846     		mov	r0, r5
 179 008e FFF7FEFF 		bl	delay_1ms
 180              	.LVL21:
 177:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 181              		.loc 1 177 9 discriminator 3 view .LVU33
 182 0092 0121     		movs	r1, #1
 183 0094 4FF09040 		mov	r0, #1207959552
 184 0098 FFF7FEFF 		bl	gpio_bit_reset
 185              	.LVL22:
 178:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 186              		.loc 1 178 9 discriminator 3 view .LVU34
 187 009c 4FF40071 		mov	r1, #512
 188 00a0 2046     		mov	r0, r4
 189 00a2 FFF7FEFF 		bl	gpio_bit_reset
 190              	.LVL23:
 179:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
 191              		.loc 1 179 9 discriminator 3 view .LVU35
 192 00a6 4FF48071 		mov	r1, #256
 193 00aa 2046     		mov	r0, r4
 194 00ac FFF7FEFF 		bl	gpio_bit_reset
 195              	.LVL24:
 180:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 196              		.loc 1 180 9 discriminator 3 view .LVU36
 197 00b0 2021     		movs	r1, #32
 198 00b2 2046     		mov	r0, r4
 199 00b4 FFF7FEFF 		bl	gpio_bit_reset
 200              	.LVL25:
 181:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 201              		.loc 1 181 9 discriminator 3 view .LVU37
 202 00b8 1021     		movs	r1, #16
 203 00ba 2046     		mov	r0, r4
 204 00bc FFF7FEFF 		bl	gpio_bit_reset
 205              	.LVL26:
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 206              		.loc 1 170 24 discriminator 3 view .LVU38
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 207              		.loc 1 170 17 discriminator 3 view .LVU39
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 208              		.loc 1 170 5 is_stmt 0 discriminator 3 view .LVU40
 209 00c0 012E     		cmp	r6, #1
 210 00c2 00D1     		bne	.L6
 182:Src/util.c    ****     }
 183:Src/util.c    **** }
ARM GAS  /tmp/ccpMgpO6.s 			page 8


 211              		.loc 1 183 1 view .LVU41
 212 00c4 70BD     		pop	{r4, r5, r6, pc}
 213              	.LVL27:
 214              	.L6:
 215              		.loc 1 183 1 view .LVU42
 216 00c6 0126     		movs	r6, #1
 217              	.LVL28:
 218              		.loc 1 183 1 view .LVU43
 219 00c8 C9E7     		b	.L5
 220              	.L9:
 221 00ca 00BF     		.align	2
 222              	.L8:
 223 00cc 00040048 		.word	1207960576
 224              		.cfi_endproc
 225              	.LFE61:
 227              		.section	.text.switch_check,"ax",%progbits
 228              		.align	1
 229              		.global	switch_check
 230              		.syntax unified
 231              		.thumb
 232              		.thumb_func
 233              		.fpu softvfp
 235              	switch_check:
 236              	.LVL29:
 237              	.LFB62:
 184:Src/util.c    **** 
 185:Src/util.c    **** 
 186:Src/util.c    **** uint8_t switch_check(uint16_t ch, uint8_t type) {
 238              		.loc 1 186 49 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 187:Src/util.c    ****     if (type) { // 3 positions switch
 243              		.loc 1 187 5 view .LVU45
 244              		.loc 1 187 8 is_stmt 0 view .LVU46
 245 0000 41B1     		cbz	r1, .L11
 188:Src/util.c    ****         if      (ch < 250) return 0;    // switch in position 0
 246              		.loc 1 188 9 is_stmt 1 view .LVU47
 247              		.loc 1 188 17 is_stmt 0 view .LVU48
 248 0002 F928     		cmp	r0, #249
 249 0004 0DD9     		bls	.L13
 189:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 250              		.loc 1 189 14 is_stmt 1 view .LVU49
 190:Src/util.c    ****         else               return 2;    // switch in position 2
 251              		.loc 1 190 35 is_stmt 0 view .LVU50
 252 0006 40F25133 		movw	r3, #849
 253 000a 9842     		cmp	r0, r3
 254 000c 94BF     		ite	ls
 255 000e 0120     		movls	r0, #1
 256 0010 0220     		movhi	r0, #2
 257              	.LVL30:
 258              		.loc 1 190 35 view .LVU51
 259 0012 7047     		bx	lr
 260              	.LVL31:
 261              	.L11:
 191:Src/util.c    ****     } else {    // 2 positions switch
ARM GAS  /tmp/ccpMgpO6.s 			page 9


 192:Src/util.c    ****         return  (ch > 850);
 262              		.loc 1 192 9 is_stmt 1 view .LVU52
 263              		.loc 1 192 21 is_stmt 0 view .LVU53
 264 0014 40F25233 		movw	r3, #850
 265 0018 9842     		cmp	r0, r3
 266 001a 94BF     		ite	ls
 267 001c 0020     		movls	r0, #0
 268              	.LVL32:
 269              		.loc 1 192 21 view .LVU54
 270 001e 0120     		movhi	r0, #1
 271 0020 7047     		bx	lr
 272              	.LVL33:
 273              	.L13:
 188:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 274              		.loc 1 188 35 view .LVU55
 275 0022 0020     		movs	r0, #0
 276              	.LVL34:
 193:Src/util.c    ****     }
 194:Src/util.c    **** }
 277              		.loc 1 194 1 view .LVU56
 278 0024 7047     		bx	lr
 279              		.cfi_endproc
 280              	.LFE62:
 282              		.section	.text.input_init,"ax",%progbits
 283              		.align	1
 284              		.global	input_init
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 288              		.fpu softvfp
 290              	input_init:
 291              	.LFB63:
 195:Src/util.c    **** 
 196:Src/util.c    **** 
 197:Src/util.c    **** /* =========================== Input Initialization Function =========================== */
 198:Src/util.c    **** 
 199:Src/util.c    **** void input_init(void) {
 292              		.loc 1 199 23 is_stmt 1 view -0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 200:Src/util.c    ****     #ifdef SERIAL_CONTROL
 201:Src/util.c    ****         usart_Tx_DMA_config(USART_MAIN, (uint8_t *)&Sideboard, sizeof(Sideboard));
 296              		.loc 1 201 9 view .LVU58
 199:Src/util.c    ****     #ifdef SERIAL_CONTROL
 297              		.loc 1 199 23 is_stmt 0 view .LVU59
 298 0000 08B5     		push	{r3, lr}
 299              	.LCFI1:
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 3, -8
 302              		.cfi_offset 14, -4
 303              		.loc 1 201 9 view .LVU60
 304 0002 0E22     		movs	r2, #14
 305 0004 0F49     		ldr	r1, .L18
 306 0006 1048     		ldr	r0, .L18+4
 307 0008 FFF7FEFF 		bl	usart_Tx_DMA_config
 308              	.LVL35:
ARM GAS  /tmp/ccpMgpO6.s 			page 10


 202:Src/util.c    ****     #endif
 203:Src/util.c    ****     #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
 204:Src/util.c    ****         usart_Rx_DMA_config(USART_MAIN, (uint8_t *)rx1_buffer, sizeof(rx1_buffer));
 309              		.loc 1 204 9 is_stmt 1 view .LVU61
 310 000c 4022     		movs	r2, #64
 311 000e 0F49     		ldr	r1, .L18+8
 312 0010 0D48     		ldr	r0, .L18+4
 313 0012 FFF7FEFF 		bl	usart_Rx_DMA_config
 314              	.LVL36:
 205:Src/util.c    ****     #endif
 206:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 207:Src/util.c    ****         usart_Tx_DMA_config(USART_AUX, (uint8_t *)&AuxTx, sizeof(AuxTx));
 208:Src/util.c    ****     #endif
 209:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 210:Src/util.c    ****         usart_Rx_DMA_config(USART_AUX, (uint8_t *)rx0_buffer, sizeof(rx0_buffer));
 211:Src/util.c    ****     #endif
 212:Src/util.c    **** 
 213:Src/util.c    ****     intro_demo_led(100);                                // Short LEDs intro demo with 100 ms delay.
 315              		.loc 1 213 5 view .LVU62
 316 0016 6420     		movs	r0, #100
 317 0018 FFF7FEFF 		bl	intro_demo_led
 318              	.LVL37:
 214:Src/util.c    **** 
 215:Src/util.c    ****     #ifdef MPU_SENSOR_ENABLE
 216:Src/util.c    ****         if(mpu_config()) {                              // IMU MPU-6050 config
 319              		.loc 1 216 9 view .LVU63
 320              		.loc 1 216 12 is_stmt 0 view .LVU64
 321 001c FFF7FEFF 		bl	mpu_config
 322              	.LVL38:
 323 0020 0B4B     		ldr	r3, .L18+12
 324              		.loc 1 216 11 view .LVU65
 325 0022 40B1     		cbz	r0, .L16
 217:Src/util.c    ****             mpuStatus = ERROR;
 326              		.loc 1 217 13 is_stmt 1 view .LVU66
 327              		.loc 1 217 23 is_stmt 0 view .LVU67
 328 0024 0022     		movs	r2, #0
 218:Src/util.c    ****             gpio_bit_set(LED1_GPIO_Port, LED1_Pin);     // Turn on RED LED - sensor enabled and NOT
 329              		.loc 1 218 13 view .LVU68
 330 0026 0121     		movs	r1, #1
 331 0028 4FF09040 		mov	r0, #1207959552
 217:Src/util.c    ****             mpuStatus = ERROR;
 332              		.loc 1 217 23 view .LVU69
 333 002c 1A70     		strb	r2, [r3]
 334              		.loc 1 218 13 is_stmt 1 view .LVU70
 335              	.L17:
 219:Src/util.c    ****         }
 220:Src/util.c    ****         else {
 221:Src/util.c    ****             mpuStatus = SUCCESS;
 222:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 223:Src/util.c    ****         }
 224:Src/util.c    ****     #else
 225:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);         // Turn on GREEN LED - sensor disabled
 226:Src/util.c    ****     #endif
 227:Src/util.c    **** 
 228:Src/util.c    ****     #ifdef SERIAL_DEBUG
 229:Src/util.c    ****         mpu_handle_input('h');                          // Print the User Help commands to serial
 230:Src/util.c    ****     #endif
ARM GAS  /tmp/ccpMgpO6.s 			page 11


 231:Src/util.c    **** }
 336              		.loc 1 231 1 is_stmt 0 view .LVU71
 337 002e BDE80840 		pop	{r3, lr}
 338              	.LCFI2:
 339              		.cfi_remember_state
 340              		.cfi_restore 14
 341              		.cfi_restore 3
 342              		.cfi_def_cfa_offset 0
 222:Src/util.c    ****         }
 343              		.loc 1 222 13 view .LVU72
 344 0032 FFF7FEBF 		b	gpio_bit_set
 345              	.LVL39:
 346              	.L16:
 347              	.LCFI3:
 348              		.cfi_restore_state
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 349              		.loc 1 221 13 is_stmt 1 view .LVU73
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 350              		.loc 1 221 23 is_stmt 0 view .LVU74
 351 0036 0122     		movs	r2, #1
 222:Src/util.c    ****         }
 352              		.loc 1 222 13 view .LVU75
 353 0038 4FF40071 		mov	r1, #512
 354 003c 0548     		ldr	r0, .L18+16
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 355              		.loc 1 221 23 view .LVU76
 356 003e 1A70     		strb	r2, [r3]
 222:Src/util.c    ****         }
 357              		.loc 1 222 13 is_stmt 1 view .LVU77
 358 0040 F5E7     		b	.L17
 359              	.L19:
 360 0042 00BF     		.align	2
 361              	.L18:
 362 0044 00000000 		.word	.LANCHOR0
 363 0048 00440040 		.word	1073759232
 364 004c 00000000 		.word	.LANCHOR1
 365 0050 00000000 		.word	.LANCHOR2
 366 0054 00040048 		.word	1207960576
 367              		.cfi_endproc
 368              	.LFE63:
 370              		.section	.text.handle_mpu6050,"ax",%progbits
 371              		.align	1
 372              		.global	handle_mpu6050
 373              		.syntax unified
 374              		.thumb
 375              		.thumb_func
 376              		.fpu softvfp
 378              	handle_mpu6050:
 379              	.LFB64:
 232:Src/util.c    **** 
 233:Src/util.c    **** 
 234:Src/util.c    **** /* =========================== Handle Functions =========================== */
 235:Src/util.c    **** 
 236:Src/util.c    **** /*
 237:Src/util.c    ****  * Handle of the MPU-6050 IMU sensor
 238:Src/util.c    ****  */
 239:Src/util.c    **** void handle_mpu6050(void) {
ARM GAS  /tmp/ccpMgpO6.s 			page 12


 380              		.loc 1 239 27 view -0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              		@ link register save eliminated.
 240:Src/util.c    **** #ifdef MPU_SENSOR_ENABLE
 241:Src/util.c    ****     // Get MPU data. Because the MPU-6050 interrupt pin is not wired we have to check DMP data by p
 242:Src/util.c    ****     if (SUCCESS == mpuStatus) {
 385              		.loc 1 242 5 view .LVU79
 386              		.loc 1 242 17 is_stmt 0 view .LVU80
 387 0000 0A4B     		ldr	r3, .L23
 388 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 389              		.loc 1 242 8 view .LVU81
 390 0004 012B     		cmp	r3, #1
 391 0006 01D1     		bne	.L21
 243:Src/util.c    ****         mpu_get_data();
 392              		.loc 1 243 9 is_stmt 1 view .LVU82
 393 0008 FFF7FEBF 		b	mpu_get_data
 394              	.LVL40:
 395              	.L21:
 244:Src/util.c    ****     } else if (ERROR == mpuStatus && main_loop_counter % 100 == 0) {
 396              		.loc 1 244 12 view .LVU83
 397              		.loc 1 244 15 is_stmt 0 view .LVU84
 398 000c 6BB9     		cbnz	r3, .L20
 399 000e 6422     		movs	r2, #100
 400              		.loc 1 244 56 discriminator 1 view .LVU85
 401 0010 074B     		ldr	r3, .L23+4
 402 0012 1B68     		ldr	r3, [r3]
 403 0014 B3FBF2F1 		udiv	r1, r3, r2
 404 0018 02FB1133 		mls	r3, r2, r1, r3
 405              		.loc 1 244 35 discriminator 1 view .LVU86
 406 001c 2BB9     		cbnz	r3, .L20
 245:Src/util.c    ****         toggle_led(LED1_GPIO_Port, LED1_Pin);                    // Toggle the Red LED every 100 ms
 407              		.loc 1 245 9 is_stmt 1 view .LVU87
 408              	.LVL41:
 409              	.LBB14:
 410              	.LBI14:
 148:Src/util.c    **** {
 411              		.loc 1 148 6 view .LVU88
 412              	.LBB15:
 150:Src/util.c    **** }
 413              		.loc 1 150 5 view .LVU89
 150:Src/util.c    **** }
 414              		.loc 1 150 28 is_stmt 0 view .LVU90
 415 001e 4FF09042 		mov	r2, #1207959552
 416 0022 5369     		ldr	r3, [r2, #20]
 417 0024 83F00103 		eor	r3, r3, #1
 418 0028 5361     		str	r3, [r2, #20]
 419              	.LVL42:
 420              	.L20:
 150:Src/util.c    **** }
 421              		.loc 1 150 28 view .LVU91
 422              	.LBE15:
 423              	.LBE14:
 246:Src/util.c    ****     }
 247:Src/util.c    ****     // Print MPU data to Console
 248:Src/util.c    ****     #ifdef SERIAL_DEBUG
ARM GAS  /tmp/ccpMgpO6.s 			page 13


 249:Src/util.c    ****     if (main_loop_counter % 50 == 0) {
 250:Src/util.c    ****         mpu_print_to_console();
 251:Src/util.c    ****     }
 252:Src/util.c    ****     #endif
 253:Src/util.c    **** #endif
 254:Src/util.c    **** }
 424              		.loc 1 254 1 view .LVU92
 425 002a 7047     		bx	lr
 426              	.L24:
 427              		.align	2
 428              	.L23:
 429 002c 00000000 		.word	.LANCHOR2
 430 0030 00000000 		.word	main_loop_counter
 431              		.cfi_endproc
 432              	.LFE64:
 434              		.section	.text.handle_sensors,"ax",%progbits
 435              		.align	1
 436              		.global	handle_sensors
 437              		.syntax unified
 438              		.thumb
 439              		.thumb_func
 440              		.fpu softvfp
 442              	handle_sensors:
 443              	.LFB65:
 255:Src/util.c    **** 
 256:Src/util.c    **** /*
 257:Src/util.c    ****  * Handle of the optical sensors
 258:Src/util.c    ****  */
 259:Src/util.c    **** void handle_sensors(void) {
 444              		.loc 1 259 27 is_stmt 1 view -0
 445              		.cfi_startproc
 446              		@ args = 0, pretend = 0, frame = 0
 447              		@ frame_needed = 0, uses_anonymous_args = 0
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 448              		.loc 1 260 5 view .LVU94
 259:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 449              		.loc 1 259 27 is_stmt 0 view .LVU95
 450 0000 38B5     		push	{r3, r4, r5, lr}
 451              	.LCFI4:
 452              		.cfi_def_cfa_offset 16
 453              		.cfi_offset 3, -16
 454              		.cfi_offset 4, -12
 455              		.cfi_offset 5, -8
 456              		.cfi_offset 14, -4
 457              		.loc 1 260 20 view .LVU96
 458 0002 1021     		movs	r1, #16
 459 0004 4FF09040 		mov	r0, #1207959552
 460 0008 FFF7FEFF 		bl	gpio_input_bit_get
 461              	.LVL43:
 462              		.loc 1 260 18 view .LVU97
 463 000c 1B4D     		ldr	r5, .L30
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 464              		.loc 1 261 20 view .LVU98
 465 000e 4FF48041 		mov	r1, #16384
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 466              		.loc 1 260 18 view .LVU99
 467 0012 2870     		strb	r0, [r5]
ARM GAS  /tmp/ccpMgpO6.s 			page 14


 468              		.loc 1 261 5 is_stmt 1 view .LVU100
 469              		.loc 1 261 20 is_stmt 0 view .LVU101
 470 0014 1A48     		ldr	r0, .L30+4
 471 0016 FFF7FEFF 		bl	gpio_input_bit_get
 472              	.LVL44:
 262:Src/util.c    **** 
 263:Src/util.c    ****     // SENSOR1
 264:Src/util.c    ****     if (sensor1 == RESET && sensor1_read == SET) {
 473              		.loc 1 264 17 view .LVU102
 474 001a 1A4B     		ldr	r3, .L30+8
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 475              		.loc 1 261 18 view .LVU103
 476 001c 1A4C     		ldr	r4, .L30+12
 477              		.loc 1 264 17 view .LVU104
 478 001e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 479              		.loc 1 261 18 view .LVU105
 480 0020 2070     		strb	r0, [r4]
 481              		.loc 1 264 5 is_stmt 1 view .LVU106
 482              		.loc 1 264 8 is_stmt 0 view .LVU107
 483 0022 A2B9     		cbnz	r2, .L26
 484              		.loc 1 264 26 discriminator 1 view .LVU108
 485 0024 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 486 0026 012A     		cmp	r2, #1
 487 0028 04D1     		bne	.L27
 265:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 266:Src/util.c    ****         sensor1 = SET;
 488              		.loc 1 266 9 is_stmt 1 view .LVU109
 267:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 489              		.loc 1 267 9 is_stmt 0 view .LVU110
 490 002a 2021     		movs	r1, #32
 491 002c 1748     		ldr	r0, .L30+16
 266:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 492              		.loc 1 266 17 view .LVU111
 493 002e 1A70     		strb	r2, [r3]
 494              		.loc 1 267 9 is_stmt 1 view .LVU112
 495 0030 FFF7FEFF 		bl	gpio_bit_set
 496              	.LVL45:
 268:Src/util.c    ****         consoleLog("SENSOR 1 ON\r\n");
 497              		.loc 1 268 9 view .LVU113
 498              	.LBB16:
 499              	.LBI16:
 117:Src/util.c    **** {
 500              		.loc 1 117 6 view .LVU114
 501              	.LBB17:
 122:Src/util.c    **** 
 502              		.loc 1 122 1 view .LVU115
 503              	.L27:
 122:Src/util.c    **** 
 504              		.loc 1 122 1 is_stmt 0 view .LVU116
 505              	.LBE17:
 506              	.LBE16:
 269:Src/util.c    ****     } else if(sensor1 == SET && sensor1_read == RESET) {
 270:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 271:Src/util.c    ****         sensor1 = RESET;
 272:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 273:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
ARM GAS  /tmp/ccpMgpO6.s 			page 15


 274:Src/util.c    ****     }
 275:Src/util.c    **** 
 276:Src/util.c    ****     // SENSOR2
 277:Src/util.c    ****     if (sensor2 == RESET && sensor2_read == SET) {
 507              		.loc 1 277 5 is_stmt 1 view .LVU117
 508              		.loc 1 277 17 is_stmt 0 view .LVU118
 509 0034 164B     		ldr	r3, .L30+20
 510 0036 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 511              		.loc 1 277 8 view .LVU119
 512 0038 A2B9     		cbnz	r2, .L28
 513              		.loc 1 277 26 discriminator 1 view .LVU120
 514 003a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 515 003c 012A     		cmp	r2, #1
 516 003e 1CD1     		bne	.L25
 278:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 279:Src/util.c    ****         sensor2 = SET;
 517              		.loc 1 279 9 is_stmt 1 view .LVU121
 518              		.loc 1 279 17 is_stmt 0 view .LVU122
 519 0040 1A70     		strb	r2, [r3]
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 520              		.loc 1 280 9 is_stmt 1 view .LVU123
 521 0042 1021     		movs	r1, #16
 281:Src/util.c    ****         consoleLog("SENSOR 2 ON\r\n");
 282:Src/util.c    ****     } else if (sensor2 == SET && sensor2_read == RESET) {
 283:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 284:Src/util.c    ****         sensor2 = RESET;
 285:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 286:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 287:Src/util.c    ****     }
 288:Src/util.c    **** 
 289:Src/util.c    ****     if (sensor1 == SET) {
 290:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 291:Src/util.c    ****     }
 292:Src/util.c    ****     if (sensor2 == SET) {
 293:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 294:Src/util.c    ****     }
 295:Src/util.c    **** }
 522              		.loc 1 295 1 is_stmt 0 view .LVU124
 523 0044 BDE83840 		pop	{r3, r4, r5, lr}
 524              	.LCFI5:
 525              		.cfi_remember_state
 526              		.cfi_restore 14
 527              		.cfi_restore 5
 528              		.cfi_restore 4
 529              		.cfi_restore 3
 530              		.cfi_def_cfa_offset 0
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 531              		.loc 1 280 9 view .LVU125
 532 0048 1048     		ldr	r0, .L30+16
 533 004a FFF7FEBF 		b	gpio_bit_set
 534              	.LVL46:
 535              	.L26:
 536              	.LCFI6:
 537              		.cfi_restore_state
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 538              		.loc 1 269 12 is_stmt 1 view .LVU126
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
ARM GAS  /tmp/ccpMgpO6.s 			page 16


 539              		.loc 1 269 14 is_stmt 0 view .LVU127
 540 004e 012A     		cmp	r2, #1
 541 0050 F0D1     		bne	.L27
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 542              		.loc 1 269 30 discriminator 1 view .LVU128
 543 0052 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 544 0054 002A     		cmp	r2, #0
 545 0056 EDD1     		bne	.L27
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 546              		.loc 1 271 9 is_stmt 1 view .LVU129
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 547              		.loc 1 272 9 is_stmt 0 view .LVU130
 548 0058 2021     		movs	r1, #32
 549 005a 0C48     		ldr	r0, .L30+16
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 550              		.loc 1 271 17 view .LVU131
 551 005c 1A70     		strb	r2, [r3]
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 552              		.loc 1 272 9 is_stmt 1 view .LVU132
 553 005e FFF7FEFF 		bl	gpio_bit_reset
 554              	.LVL47:
 273:Src/util.c    ****     }
 555              		.loc 1 273 9 view .LVU133
 556              	.LBB18:
 557              	.LBI18:
 117:Src/util.c    **** {
 558              		.loc 1 117 6 view .LVU134
 559              	.LBB19:
 122:Src/util.c    **** 
 560              		.loc 1 122 1 view .LVU135
 561 0062 E7E7     		b	.L27
 562              	.LVL48:
 563              	.L28:
 122:Src/util.c    **** 
 564              		.loc 1 122 1 is_stmt 0 view .LVU136
 565              	.LBE19:
 566              	.LBE18:
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 567              		.loc 1 282 12 is_stmt 1 view .LVU137
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 568              		.loc 1 282 15 is_stmt 0 view .LVU138
 569 0064 012A     		cmp	r2, #1
 570 0066 08D1     		bne	.L25
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 571              		.loc 1 282 31 discriminator 1 view .LVU139
 572 0068 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 573 006a 32B9     		cbnz	r2, .L25
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 574              		.loc 1 284 9 is_stmt 1 view .LVU140
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 575              		.loc 1 284 17 is_stmt 0 view .LVU141
 576 006c 1A70     		strb	r2, [r3]
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 577              		.loc 1 285 9 is_stmt 1 view .LVU142
 578 006e 1021     		movs	r1, #16
 579              		.loc 1 295 1 is_stmt 0 view .LVU143
 580 0070 BDE83840 		pop	{r3, r4, r5, lr}
ARM GAS  /tmp/ccpMgpO6.s 			page 17


 581              	.LCFI7:
 582              		.cfi_remember_state
 583              		.cfi_restore 14
 584              		.cfi_restore 5
 585              		.cfi_restore 4
 586              		.cfi_restore 3
 587              		.cfi_def_cfa_offset 0
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 588              		.loc 1 285 9 view .LVU144
 589 0074 0548     		ldr	r0, .L30+16
 590 0076 FFF7FEBF 		b	gpio_bit_reset
 591              	.LVL49:
 592              	.L25:
 593              	.LCFI8:
 594              		.cfi_restore_state
 595              		.loc 1 295 1 view .LVU145
 596 007a 38BD     		pop	{r3, r4, r5, pc}
 597              	.L31:
 598              		.align	2
 599              	.L30:
 600 007c 00000000 		.word	.LANCHOR3
 601 0080 00080048 		.word	1207961600
 602 0084 00000000 		.word	.LANCHOR5
 603 0088 00000000 		.word	.LANCHOR4
 604 008c 00040048 		.word	1207960576
 605 0090 00000000 		.word	.LANCHOR6
 606              		.cfi_endproc
 607              	.LFE65:
 609              		.section	.text.handle_usart,"ax",%progbits
 610              		.align	1
 611              		.global	handle_usart
 612              		.syntax unified
 613              		.thumb
 614              		.thumb_func
 615              		.fpu softvfp
 617              	handle_usart:
 618              	.LFB66:
 296:Src/util.c    **** 
 297:Src/util.c    **** 
 298:Src/util.c    **** 
 299:Src/util.c    **** 
 300:Src/util.c    **** /*
 301:Src/util.c    ****  * Handle of the USART data
 302:Src/util.c    ****  */
 303:Src/util.c    **** void handle_usart(void) {
 619              		.loc 1 303 25 is_stmt 1 view -0
 620              		.cfi_startproc
 621              		@ args = 0, pretend = 0, frame = 16
 622              		@ frame_needed = 0, uses_anonymous_args = 0
 304:Src/util.c    ****     // Tx USART MAIN
 305:Src/util.c    ****     #ifdef SERIAL_CONTROL
 306:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART1_TX_DMA_CH) == 0) {     // 
 623              		.loc 1 306 9 view .LVU147
 624              		.loc 1 306 31 is_stmt 0 view .LVU148
 625 0000 504B     		ldr	r3, .L40
 303:Src/util.c    ****     // Tx USART MAIN
 626              		.loc 1 303 25 view .LVU149
ARM GAS  /tmp/ccpMgpO6.s 			page 18


 627 0002 514A     		ldr	r2, .L40+4
 628 0004 1B68     		ldr	r3, [r3]
 629 0006 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 630              	.LCFI9:
 631              		.cfi_def_cfa_offset 36
 632              		.cfi_offset 4, -36
 633              		.cfi_offset 5, -32
 634              		.cfi_offset 6, -28
 635              		.cfi_offset 7, -24
 636              		.cfi_offset 8, -20
 637              		.cfi_offset 9, -16
 638              		.cfi_offset 10, -12
 639              		.cfi_offset 11, -8
 640              		.cfi_offset 14, -4
 641 000a 5343     		muls	r3, r2, r3
 642              		.loc 1 306 12 view .LVU150
 643 000c B3F1333F 		cmp	r3, #858993459
 303:Src/util.c    ****     // Tx USART MAIN
 644              		.loc 1 303 25 view .LVU151
 645 0010 85B0     		sub	sp, sp, #20
 646              	.LCFI10:
 647              		.cfi_def_cfa_offset 56
 648              		.loc 1 306 12 view .LVU152
 649 0012 72D8     		bhi	.L34
 650              		.loc 1 306 43 discriminator 1 view .LVU153
 651 0014 0320     		movs	r0, #3
 652 0016 FFF7FEFF 		bl	dma_transfer_number_get
 653              	.LVL50:
 654              		.loc 1 306 40 discriminator 1 view .LVU154
 655 001a 0028     		cmp	r0, #0
 656 001c 6DD1     		bne	.L34
 307:Src/util.c    ****             sideboard_imu.start = (uint16_t)SERIAL_START_FRAME;
 657              		.loc 1 307 13 is_stmt 1 view .LVU155
 658              		.loc 1 307 33 is_stmt 0 view .LVU156
 659 001e 4AF6CD33 		movw	r3, 43981	@ movhi
 660 0022 4A4C     		ldr	r4, .L40+8
 661 0024 2380     		strh	r3, [r4]	@ movhi
 308:Src/util.c    ****             sideboard_imu.cmd1 = (int16_t)cmd1;
 662              		.loc 1 308 13 is_stmt 1 view .LVU157
 309:Src/util.c    ****             sideboard_imu.cmd2 = (int16_t)cmd2;
 310:Src/util.c    ****             sideboard_imu.pitch = (int16_t)mpu.euler.pitch;
 663              		.loc 1 310 53 is_stmt 0 view .LVU158
 664 0026 4A4B     		ldr	r3, .L40+12
 308:Src/util.c    ****             sideboard_imu.cmd1 = (int16_t)cmd1;
 665              		.loc 1 308 32 view .LVU159
 666 0028 6080     		strh	r0, [r4, #2]	@ movhi
 309:Src/util.c    ****             sideboard_imu.cmd2 = (int16_t)cmd2;
 667              		.loc 1 309 13 is_stmt 1 view .LVU160
 311:Src/util.c    ****             sideboard_imu.dPitch = (int16_t)mpu.gyro.y;
 312:Src/util.c    ****   
 313:Src/util.c    ****             sideboard_imu.gyro_x = (int16_t)mpu.gyro.x;
 314:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 315:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 316:Src/util.c    ****             
 317:Src/util.c    ****             sideboard_imu.accel_x = (int16_t)mpu.accel.x;
 318:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 319:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
ARM GAS  /tmp/ccpMgpO6.s 			page 19


 320:Src/util.c    ****         
 321:Src/util.c    ****             sideboard_imu.quat_w = (int16_t)mpu.quat.w;
 322:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 668              		.loc 1 322 36 is_stmt 0 view .LVU161
 669 002a B3F91010 		ldrsh	r1, [r3, #16]
 310:Src/util.c    ****             sideboard_imu.dPitch = (int16_t)mpu.gyro.y;
 670              		.loc 1 310 53 view .LVU162
 671 002e B3F91E20 		ldrsh	r2, [r3, #30]
 672              		.loc 1 322 36 view .LVU163
 673 0032 0191     		str	r1, [sp, #4]
 674              		.loc 1 322 34 view .LVU164
 675 0034 2183     		strh	r1, [r4, #24]	@ movhi
 323:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 676              		.loc 1 323 36 view .LVU165
 677 0036 B3F91410 		ldrsh	r1, [r3, #20]
 311:Src/util.c    ****             sideboard_imu.dPitch = (int16_t)mpu.gyro.y;
 678              		.loc 1 311 53 view .LVU166
 679 003a B3F902B0 		ldrsh	fp, [r3, #2]
 680              		.loc 1 323 36 view .LVU167
 681 003e 0291     		str	r1, [sp, #8]
 682              		.loc 1 323 34 view .LVU168
 683 0040 6183     		strh	r1, [r4, #26]	@ movhi
 324:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 684              		.loc 1 324 36 view .LVU169
 685 0042 B3F91810 		ldrsh	r1, [r3, #24]
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 686              		.loc 1 318 55 view .LVU170
 687 0046 B3F908E0 		ldrsh	lr, [r3, #8]
 319:Src/util.c    ****         
 688              		.loc 1 319 55 view .LVU171
 689 004a B3F90AC0 		ldrsh	ip, [r3, #10]
 313:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 690              		.loc 1 313 53 view .LVU172
 691 004e B3F900A0 		ldrsh	r10, [r3]
 315:Src/util.c    ****             
 692              		.loc 1 315 53 view .LVU173
 693 0052 B3F90490 		ldrsh	r9, [r3, #4]
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 694              		.loc 1 317 55 view .LVU174
 695 0056 B3F90680 		ldrsh	r8, [r3, #6]
 325:Src/util.c    ****  
 326:Src/util.c    ****             sideboard_imu.euler_pitch = (int16_t)mpu.euler.pitch;
 327:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 696              		.loc 1 327 58 view .LVU175
 697 005a B3F91C70 		ldrsh	r7, [r3, #28]
 309:Src/util.c    ****             sideboard_imu.pitch = (int16_t)mpu.euler.pitch;
 698              		.loc 1 309 32 view .LVU176
 699 005e A080     		strh	r0, [r4, #4]	@ movhi
 310:Src/util.c    ****             sideboard_imu.dPitch = (int16_t)mpu.gyro.y;
 700              		.loc 1 310 13 is_stmt 1 view .LVU177
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 701              		.loc 1 321 36 is_stmt 0 view .LVU178
 702 0060 B3F90C00 		ldrsh	r0, [r3, #12]
 324:Src/util.c    ****  
 703              		.loc 1 324 36 view .LVU179
 704 0064 0391     		str	r1, [sp, #12]
 324:Src/util.c    ****  
ARM GAS  /tmp/ccpMgpO6.s 			page 20


 705              		.loc 1 324 34 view .LVU180
 706 0066 A183     		strh	r1, [r4, #28]	@ movhi
 328:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 329:Src/util.c    ****             
 330:Src/util.c    ****             sideboard_imu.temperature = (int16_t)mpu.temp;
 331:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 707              		.loc 1 331 106 view .LVU181
 708 0068 3A49     		ldr	r1, .L40+16
 310:Src/util.c    ****             sideboard_imu.dPitch = (int16_t)mpu.gyro.y;
 709              		.loc 1 310 33 view .LVU182
 710 006a E280     		strh	r2, [r4, #6]	@ movhi
 311:Src/util.c    ****   
 711              		.loc 1 311 13 is_stmt 1 view .LVU183
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 712              		.loc 1 318 35 is_stmt 0 view .LVU184
 713 006c A4F812E0 		strh	lr, [r4, #18]	@ movhi
 319:Src/util.c    ****         
 714              		.loc 1 319 35 view .LVU185
 715 0070 A4F814C0 		strh	ip, [r4, #20]	@ movhi
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 716              		.loc 1 321 34 view .LVU186
 717 0074 E082     		strh	r0, [r4, #22]	@ movhi
 326:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 718              		.loc 1 326 39 view .LVU187
 719 0076 E283     		strh	r2, [r4, #30]	@ movhi
 311:Src/util.c    ****   
 720              		.loc 1 311 34 view .LVU188
 721 0078 A4F808B0 		strh	fp, [r4, #8]	@ movhi
 313:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 722              		.loc 1 313 13 is_stmt 1 view .LVU189
 313:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 723              		.loc 1 313 34 is_stmt 0 view .LVU190
 724 007c A4F80AA0 		strh	r10, [r4, #10]	@ movhi
 314:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 725              		.loc 1 314 13 is_stmt 1 view .LVU191
 314:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 726              		.loc 1 314 34 is_stmt 0 view .LVU192
 727 0080 A4F80CB0 		strh	fp, [r4, #12]	@ movhi
 315:Src/util.c    ****             
 728              		.loc 1 315 13 is_stmt 1 view .LVU193
 315:Src/util.c    ****             
 729              		.loc 1 315 34 is_stmt 0 view .LVU194
 730 0084 A4F80E90 		strh	r9, [r4, #14]	@ movhi
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 731              		.loc 1 317 13 is_stmt 1 view .LVU195
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 732              		.loc 1 317 35 is_stmt 0 view .LVU196
 733 0088 A4F81080 		strh	r8, [r4, #16]	@ movhi
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 734              		.loc 1 318 13 is_stmt 1 view .LVU197
 319:Src/util.c    ****         
 735              		.loc 1 319 13 view .LVU198
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 736              		.loc 1 321 13 view .LVU199
 322:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 737              		.loc 1 322 13 view .LVU200
 323:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
ARM GAS  /tmp/ccpMgpO6.s 			page 21


 738              		.loc 1 323 13 view .LVU201
 324:Src/util.c    ****  
 739              		.loc 1 324 13 view .LVU202
 326:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 740              		.loc 1 326 13 view .LVU203
 327:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 741              		.loc 1 327 13 view .LVU204
 327:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 742              		.loc 1 327 38 is_stmt 0 view .LVU205
 743 008c 2784     		strh	r7, [r4, #32]	@ movhi
 328:Src/util.c    ****             
 744              		.loc 1 328 13 is_stmt 1 view .LVU206
 328:Src/util.c    ****             
 745              		.loc 1 328 57 is_stmt 0 view .LVU207
 746 008e B3F92060 		ldrsh	r6, [r3, #32]
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 747              		.loc 1 330 53 view .LVU208
 748 0092 B3F92250 		ldrsh	r5, [r3, #34]
 749              		.loc 1 331 87 view .LVU209
 750 0096 304B     		ldr	r3, .L40+20
 751              		.loc 1 331 106 view .LVU210
 752 0098 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 753              		.loc 1 331 87 view .LVU211
 754 009a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 755              		.loc 1 331 106 view .LVU212
 756 009c 8900     		lsls	r1, r1, #2
 757              		.loc 1 331 93 view .LVU213
 758 009e 41EA4301 		orr	r1, r1, r3, lsl #1
 759              		.loc 1 331 76 view .LVU214
 760 00a2 2E4B     		ldr	r3, .L40+24
 332:Src/util.c    **** 
 333:Src/util.c    ****             sideboard_imu.checksum = (uint16_t)(
 334:Src/util.c    ****                 sideboard_imu.start ^ 
 335:Src/util.c    ****                 sideboard_imu.gyro_x ^ sideboard_imu.gyro_y ^ sideboard_imu.gyro_z ^
 336:Src/util.c    ****                 sideboard_imu.accel_x ^ sideboard_imu.accel_y ^ sideboard_imu.accel_z ^
 337:Src/util.c    ****                 sideboard_imu.quat_w ^ sideboard_imu.quat_x ^ sideboard_imu.quat_y ^ sideboard_imu.
 338:Src/util.c    ****                 sideboard_imu.euler_pitch ^ sideboard_imu.euler_roll ^ sideboard_imu.euler_yaw ^
 339:Src/util.c    ****                 sideboard_imu.temperature ^ sideboard_imu.sensors
 761              		.loc 1 339 43 view .LVU215
 762 00a4 82EA0B02 		eor	r2, r2, fp
 331:Src/util.c    **** 
 763              		.loc 1 331 76 view .LVU216
 764 00a8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 328:Src/util.c    ****             
 765              		.loc 1 328 37 view .LVU217
 766 00aa 6684     		strh	r6, [r4, #34]	@ movhi
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 767              		.loc 1 330 13 is_stmt 1 view .LVU218
 331:Src/util.c    **** 
 768              		.loc 1 331 93 is_stmt 0 view .LVU219
 769 00ac 0B43     		orrs	r3, r3, r1
 331:Src/util.c    **** 
 770              		.loc 1 331 35 view .LVU220
 771 00ae E384     		strh	r3, [r4, #38]	@ movhi
 772              		.loc 1 339 43 view .LVU221
 773 00b0 5340     		eors	r3, r3, r2
 774 00b2 8AEA0303 		eor	r3, r10, r3
ARM GAS  /tmp/ccpMgpO6.s 			page 22


 775 00b6 89EA0303 		eor	r3, r9, r3
 776 00ba 88EA0303 		eor	r3, r8, r3
 777 00be 8EEA0303 		eor	r3, lr, r3
 778 00c2 8CEA0303 		eor	r3, ip, r3
 779 00c6 7B40     		eors	r3, r3, r7
 780 00c8 7340     		eors	r3, r3, r6
 781 00ca 019A     		ldr	r2, [sp, #4]
 782 00cc 6B40     		eors	r3, r3, r5
 783 00ce 4340     		eors	r3, r3, r0
 784 00d0 5340     		eors	r3, r3, r2
 785 00d2 029A     		ldr	r2, [sp, #8]
 340:Src/util.c    ****             );
 341:Src/util.c    ****         
 342:Src/util.c    ****             dma_channel_disable(USART1_TX_DMA_CH);
 786              		.loc 1 342 13 view .LVU222
 787 00d4 0320     		movs	r0, #3
 339:Src/util.c    ****             );
 788              		.loc 1 339 43 view .LVU223
 789 00d6 5340     		eors	r3, r3, r2
 790 00d8 039A     		ldr	r2, [sp, #12]
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 791              		.loc 1 330 39 view .LVU224
 792 00da A584     		strh	r5, [r4, #36]	@ movhi
 331:Src/util.c    **** 
 793              		.loc 1 331 13 is_stmt 1 view .LVU225
 333:Src/util.c    ****                 sideboard_imu.start ^ 
 794              		.loc 1 333 13 view .LVU226
 339:Src/util.c    ****             );
 795              		.loc 1 339 43 is_stmt 0 view .LVU227
 796 00dc 5340     		eors	r3, r3, r2
 797 00de 83F42B43 		eor	r3, r3, #43776
 798 00e2 83F0CD03 		eor	r3, r3, #205
 333:Src/util.c    ****                 sideboard_imu.start ^ 
 799              		.loc 1 333 36 view .LVU228
 800 00e6 2385     		strh	r3, [r4, #40]	@ movhi
 801              		.loc 1 342 13 is_stmt 1 view .LVU229
 802 00e8 FFF7FEFF 		bl	dma_channel_disable
 803              	.LVL51:
 343:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 804              		.loc 1 343 13 view .LVU230
 805              		.loc 1 343 45 is_stmt 0 view .LVU231
 806 00ec 2A22     		movs	r2, #42
 807 00ee 1C4B     		ldr	r3, .L40+28
 344:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 345:Src/util.c    ****             dma_channel_enable(USART1_TX_DMA_CH);
 808              		.loc 1 345 13 view .LVU232
 809 00f0 0320     		movs	r0, #3
 343:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 810              		.loc 1 343 45 view .LVU233
 811 00f2 9A64     		str	r2, [r3, #72]
 344:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 812              		.loc 1 344 13 is_stmt 1 view .LVU234
 344:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 813              		.loc 1 344 45 is_stmt 0 view .LVU235
 814 00f4 1C65     		str	r4, [r3, #80]
 815              		.loc 1 345 13 is_stmt 1 view .LVU236
 816 00f6 FFF7FEFF 		bl	dma_channel_enable
ARM GAS  /tmp/ccpMgpO6.s 			page 23


 817              	.LVL52:
 818              	.L34:
 346:Src/util.c    ****         }
 347:Src/util.c    ****     #endif
 348:Src/util.c    ****     // Rx USART MAIN
 349:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 350:Src/util.c    ****         if (timeoutCntSerial1++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 819              		.loc 1 350 9 view .LVU237
 820              		.loc 1 350 30 is_stmt 0 view .LVU238
 821 00fa 1A4B     		ldr	r3, .L40+32
 822 00fc 1A88     		ldrh	r2, [r3]
 823 00fe 511C     		adds	r1, r2, #1
 824              		.loc 1 350 12 view .LVU239
 825 0100 B2F5167F 		cmp	r2, #600
 826              		.loc 1 350 30 view .LVU240
 827 0104 1980     		strh	r1, [r3]	@ movhi
 828 0106 184A     		ldr	r2, .L40+36
 829              		.loc 1 350 12 view .LVU241
 830 0108 15D3     		bcc	.L36
 351:Src/util.c    ****             timeoutFlagSerial1 = 1;                                 // Timeout detected
 831              		.loc 1 351 13 is_stmt 1 view .LVU242
 832              		.loc 1 351 32 is_stmt 0 view .LVU243
 833 010a 0121     		movs	r1, #1
 834 010c 1170     		strb	r1, [r2]
 352:Src/util.c    ****             timeoutCntSerial1  = SERIAL_TIMEOUT;                    // Limit timout counter value
 835              		.loc 1 352 13 is_stmt 1 view .LVU244
 836              		.loc 1 352 32 is_stmt 0 view .LVU245
 837 010e 4FF41672 		mov	r2, #600
 838 0112 1A80     		strh	r2, [r3]	@ movhi
 353:Src/util.c    ****         }
 354:Src/util.c    ****         if (timeoutFlagSerial1 && main_loop_counter % 100 == 0) {   // In case of timeout bring the
 839              		.loc 1 354 9 is_stmt 1 view .LVU246
 840              	.L37:
 841 0114 6422     		movs	r2, #100
 842              		.loc 1 354 53 is_stmt 0 discriminator 1 view .LVU247
 843 0116 0B4B     		ldr	r3, .L40
 844 0118 1B68     		ldr	r3, [r3]
 845 011a B3FBF2F1 		udiv	r1, r3, r2
 846 011e 02FB1133 		mls	r3, r2, r1, r3
 847              		.loc 1 354 32 discriminator 1 view .LVU248
 848 0122 5BB9     		cbnz	r3, .L32
 355:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 849              		.loc 1 355 13 is_stmt 1 view .LVU249
 850              	.LVL53:
 851              	.LBB20:
 852              	.LBI20:
 148:Src/util.c    **** {
 853              		.loc 1 148 6 view .LVU250
 854              	.LBB21:
 150:Src/util.c    **** }
 855              		.loc 1 150 5 view .LVU251
 150:Src/util.c    **** }
 856              		.loc 1 150 28 is_stmt 0 view .LVU252
 857 0124 4FF09042 		mov	r2, #1207959552
 858 0128 D2F81434 		ldr	r3, [r2, #1044]
 859 012c 83F48073 		eor	r3, r3, #256
 860 0130 C2F81434 		str	r3, [r2, #1044]
ARM GAS  /tmp/ccpMgpO6.s 			page 24


 861              	.LVL54:
 150:Src/util.c    **** }
 862              		.loc 1 150 28 view .LVU253
 863              	.LBE21:
 864              	.LBE20:
 356:Src/util.c    ****         }
 357:Src/util.c    ****     #endif
 358:Src/util.c    **** 
 359:Src/util.c    ****     // Tx USART AUX
 360:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 361:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART0_TX_DMA_CH) == 0) {     // 
 362:Src/util.c    ****             AuxTx.start     = (uint16_t)SERIAL_START_FRAME;
 363:Src/util.c    ****             AuxTx.signal1   = (int16_t)sensor1;
 364:Src/util.c    ****             AuxTx.signal2   = (int16_t)sensor2;
 365:Src/util.c    ****             AuxTx.checksum  = (uint16_t)(AuxTx.start ^ AuxTx.signal1 ^ AuxTx.signal2);
 366:Src/util.c    ****         
 367:Src/util.c    ****             dma_channel_disable(USART0_TX_DMA_CH);
 368:Src/util.c    ****             DMA_CHCNT(USART0_TX_DMA_CH)     = sizeof(AuxTx);
 369:Src/util.c    ****             DMA_CHMADDR(USART0_TX_DMA_CH)   = (uint32_t)&AuxTx;
 370:Src/util.c    ****             dma_channel_enable(USART0_TX_DMA_CH);
 371:Src/util.c    ****         }
 372:Src/util.c    ****     #endif
 373:Src/util.c    ****     // Rx USART AUX
 374:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 375:Src/util.c    ****         #ifdef CONTROL_IBUS
 376:Src/util.c    ****         if (!timeoutFlagSerial0) {
 377:Src/util.c    ****             for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 378:Src/util.c    ****                 ibus_captured_value[(i/2)] = CLAMP(command.channels[i] + (command.channels[i+1] << 
 379:Src/util.c    ****             }
 380:Src/util.c    ****             cmd1        = (ibus_captured_value[0] - 500) * 2;                           // Channel 
 381:Src/util.c    ****             cmd2        = (ibus_captured_value[1] - 500) * 2;                           // Channel 
 382:Src/util.c    ****             cmdSwitch   = (uint16_t)(switch_check(ibus_captured_value[6],0)      |      // Channel 
 383:Src/util.c    ****                                      switch_check(ibus_captured_value[7],1) << 1 |      // Channel 
 384:Src/util.c    ****                                      switch_check(ibus_captured_value[8],1) << 3 |      // Channel 
 385:Src/util.c    ****                                      switch_check(ibus_captured_value[9],0) << 5);      // Channel 
 386:Src/util.c    ****         }
 387:Src/util.c    ****         #endif
 388:Src/util.c    **** 
 389:Src/util.c    ****         if (timeoutCntSerial0++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 390:Src/util.c    ****             timeoutFlagSerial0 = 1;                                 // Timeout detected
 391:Src/util.c    ****             timeoutCntSerial0  = SERIAL_TIMEOUT;                    // Limit timout counter value
 392:Src/util.c    ****             cmd1 = cmd2 = 0;                                        // Set commands to 0
 393:Src/util.c    ****             cmdSwitch &= ~(1U << 0);                                // Clear Bit 0, to switch to de
 394:Src/util.c    ****         }
 395:Src/util.c    ****         // if (timeoutFlagSerial0 && main_loop_counter % 100 == 0) {   // In case of timeout bring 
 396:Src/util.c    ****         //     toggle_led(LED2_GPIO_Port, LED2_Pin);                   // Toggle the Green LED ever
 397:Src/util.c    ****         // }
 398:Src/util.c    **** 
 399:Src/util.c    ****         #ifdef SERIAL_DEBUG
 400:Src/util.c    ****             // Print MPU data to Console
 401:Src/util.c    ****             if (main_loop_counter % 50 == 0) {
 402:Src/util.c    ****                 aux_print_to_console();
 403:Src/util.c    ****             }
 404:Src/util.c    ****         #endif
 405:Src/util.c    ****     #endif
 406:Src/util.c    **** }
 865              		.loc 1 406 1 view .LVU254
ARM GAS  /tmp/ccpMgpO6.s 			page 25


 866 0134 02E0     		b	.L32
 867              	.L36:
 354:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 868              		.loc 1 354 9 is_stmt 1 view .LVU255
 354:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 869              		.loc 1 354 12 is_stmt 0 view .LVU256
 870 0136 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 871 0138 002B     		cmp	r3, #0
 872 013a EBD1     		bne	.L37
 873              	.L32:
 874              		.loc 1 406 1 view .LVU257
 875 013c 05B0     		add	sp, sp, #20
 876              	.LCFI11:
 877              		.cfi_def_cfa_offset 36
 878              		@ sp needed
 879 013e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 880              	.L41:
 881 0142 00BF     		.align	2
 882              	.L40:
 883 0144 00000000 		.word	main_loop_counter
 884 0148 CDCCCCCC 		.word	-858993459
 885 014c 00000000 		.word	.LANCHOR7
 886 0150 00000000 		.word	mpu
 887 0154 00000000 		.word	.LANCHOR2
 888 0158 00000000 		.word	.LANCHOR6
 889 015c 00000000 		.word	.LANCHOR5
 890 0160 00000240 		.word	1073872896
 891 0164 00000000 		.word	.LANCHOR8
 892 0168 00000000 		.word	.LANCHOR9
 893              		.cfi_endproc
 894              	.LFE66:
 896              		.section	.text.handle_leds,"ax",%progbits
 897              		.align	1
 898              		.global	handle_leds
 899              		.syntax unified
 900              		.thumb
 901              		.thumb_func
 902              		.fpu softvfp
 904              	handle_leds:
 905              	.LFB67:
 407:Src/util.c    **** 
 408:Src/util.c    **** /*
 409:Src/util.c    ****  * Handle of the sideboard LEDs
 410:Src/util.c    ****  */
 411:Src/util.c    **** void handle_leds(void) {
 906              		.loc 1 411 24 is_stmt 1 view -0
 907              		.cfi_startproc
 908              		@ args = 0, pretend = 0, frame = 0
 909              		@ frame_needed = 0, uses_anonymous_args = 0
 412:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 413:Src/util.c    ****         if (!timeoutFlagSerial1) {
 910              		.loc 1 413 9 view .LVU259
 411:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 911              		.loc 1 411 24 is_stmt 0 view .LVU260
 912 0000 10B5     		push	{r4, lr}
 913              	.LCFI12:
 914              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccpMgpO6.s 			page 26


 915              		.cfi_offset 4, -8
 916              		.cfi_offset 14, -4
 917              		.loc 1 413 13 view .LVU261
 918 0002 244B     		ldr	r3, .L55
 919              		.loc 1 413 12 view .LVU262
 920 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 921 0006 002B     		cmp	r3, #0
 922 0008 43D1     		bne	.L42
 414:Src/util.c    ****             if (Feedback.cmdLed & LED1_SET) { gpio_bit_set(LED1_GPIO_Port, LED1_Pin); } else { gpio
 923              		.loc 1 414 13 is_stmt 1 view .LVU263
 924              		.loc 1 414 25 is_stmt 0 view .LVU264
 925 000a 234C     		ldr	r4, .L55+4
 926              		.loc 1 414 47 view .LVU265
 927 000c 0121     		movs	r1, #1
 928              		.loc 1 414 16 view .LVU266
 929 000e E389     		ldrh	r3, [r4, #14]
 930              		.loc 1 414 47 view .LVU267
 931 0010 4FF09040 		mov	r0, #1207959552
 932              		.loc 1 414 16 view .LVU268
 933 0014 DA07     		lsls	r2, r3, #31
 934 0016 29D5     		bpl	.L44
 935              		.loc 1 414 47 is_stmt 1 discriminator 1 view .LVU269
 936 0018 FFF7FEFF 		bl	gpio_bit_set
 937              	.LVL55:
 938              	.L45:
 415:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 939              		.loc 1 415 13 view .LVU270
 940              		.loc 1 415 16 is_stmt 0 view .LVU271
 941 001c E389     		ldrh	r3, [r4, #14]
 942              		.loc 1 415 47 view .LVU272
 943 001e 4FF40071 		mov	r1, #512
 944              		.loc 1 415 16 view .LVU273
 945 0022 9B07     		lsls	r3, r3, #30
 946              		.loc 1 415 47 view .LVU274
 947 0024 1D48     		ldr	r0, .L55+8
 948              		.loc 1 415 16 view .LVU275
 949 0026 24D5     		bpl	.L46
 950              		.loc 1 415 47 is_stmt 1 discriminator 1 view .LVU276
 951 0028 FFF7FEFF 		bl	gpio_bit_set
 952              	.LVL56:
 953              	.L47:
 416:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 954              		.loc 1 416 13 view .LVU277
 955              		.loc 1 416 16 is_stmt 0 view .LVU278
 956 002c E389     		ldrh	r3, [r4, #14]
 957              		.loc 1 416 47 view .LVU279
 958 002e 4FF48071 		mov	r1, #256
 959              		.loc 1 416 16 view .LVU280
 960 0032 5A07     		lsls	r2, r3, #29
 961              		.loc 1 416 47 view .LVU281
 962 0034 1948     		ldr	r0, .L55+8
 963              		.loc 1 416 16 view .LVU282
 964 0036 1FD5     		bpl	.L48
 965              		.loc 1 416 47 is_stmt 1 discriminator 1 view .LVU283
 966 0038 FFF7FEFF 		bl	gpio_bit_set
 967              	.LVL57:
 968              	.L49:
ARM GAS  /tmp/ccpMgpO6.s 			page 27


 417:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 969              		.loc 1 417 13 view .LVU284
 970              		.loc 1 417 16 is_stmt 0 view .LVU285
 971 003c E389     		ldrh	r3, [r4, #14]
 972              		.loc 1 417 47 view .LVU286
 973 003e 2021     		movs	r1, #32
 974              		.loc 1 417 16 view .LVU287
 975 0040 1B07     		lsls	r3, r3, #28
 976              		.loc 1 417 47 view .LVU288
 977 0042 1648     		ldr	r0, .L55+8
 978              		.loc 1 417 16 view .LVU289
 979 0044 1BD5     		bpl	.L50
 980              		.loc 1 417 47 is_stmt 1 discriminator 1 view .LVU290
 981 0046 FFF7FEFF 		bl	gpio_bit_set
 982              	.LVL58:
 983              	.L51:
 418:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 984              		.loc 1 418 13 view .LVU291
 985              		.loc 1 418 16 is_stmt 0 view .LVU292
 986 004a E389     		ldrh	r3, [r4, #14]
 987              		.loc 1 418 47 view .LVU293
 988 004c 1021     		movs	r1, #16
 989              		.loc 1 418 16 view .LVU294
 990 004e DA06     		lsls	r2, r3, #27
 991              		.loc 1 418 47 view .LVU295
 992 0050 1248     		ldr	r0, .L55+8
 993              		.loc 1 418 16 view .LVU296
 994 0052 17D5     		bpl	.L52
 995              		.loc 1 418 47 is_stmt 1 discriminator 1 view .LVU297
 996 0054 FFF7FEFF 		bl	gpio_bit_set
 997              	.LVL59:
 998              	.L53:
 419:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 999              		.loc 1 419 13 view .LVU298
 1000              		.loc 1 419 16 is_stmt 0 view .LVU299
 1001 0058 E389     		ldrh	r3, [r4, #14]
 1002              		.loc 1 419 47 view .LVU300
 1003 005a 4FF48061 		mov	r1, #1024
 1004              		.loc 1 419 16 view .LVU301
 1005 005e 1B07     		lsls	r3, r3, #28
 1006              		.loc 1 419 47 view .LVU302
 1007 0060 0E48     		ldr	r0, .L55+8
 1008              		.loc 1 419 16 view .LVU303
 1009 0062 12D5     		bpl	.L54
 1010              		.loc 1 419 47 is_stmt 1 discriminator 1 view .LVU304
 420:Src/util.c    ****         }
 421:Src/util.c    ****     #endif
 422:Src/util.c    **** }
 1011              		.loc 1 422 1 is_stmt 0 discriminator 1 view .LVU305
 1012 0064 BDE81040 		pop	{r4, lr}
 1013              	.LCFI13:
 1014              		.cfi_remember_state
 1015              		.cfi_restore 14
 1016              		.cfi_restore 4
 1017              		.cfi_def_cfa_offset 0
 419:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 1018              		.loc 1 419 47 discriminator 1 view .LVU306
ARM GAS  /tmp/ccpMgpO6.s 			page 28


 1019 0068 FFF7FEBF 		b	gpio_bit_set
 1020              	.LVL60:
 1021              	.L44:
 1022              	.LCFI14:
 1023              		.cfi_restore_state
 414:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 1024              		.loc 1 414 96 is_stmt 1 discriminator 2 view .LVU307
 1025 006c FFF7FEFF 		bl	gpio_bit_reset
 1026              	.LVL61:
 1027 0070 D4E7     		b	.L45
 1028              	.L46:
 415:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 1029              		.loc 1 415 96 discriminator 2 view .LVU308
 1030 0072 FFF7FEFF 		bl	gpio_bit_reset
 1031              	.LVL62:
 1032 0076 D9E7     		b	.L47
 1033              	.L48:
 416:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 1034              		.loc 1 416 96 discriminator 2 view .LVU309
 1035 0078 FFF7FEFF 		bl	gpio_bit_reset
 1036              	.LVL63:
 1037 007c DEE7     		b	.L49
 1038              	.L50:
 417:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 1039              		.loc 1 417 96 discriminator 2 view .LVU310
 1040 007e FFF7FEFF 		bl	gpio_bit_reset
 1041              	.LVL64:
 1042 0082 E2E7     		b	.L51
 1043              	.L52:
 418:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 1044              		.loc 1 418 96 discriminator 2 view .LVU311
 1045 0084 FFF7FEFF 		bl	gpio_bit_reset
 1046              	.LVL65:
 1047 0088 E6E7     		b	.L53
 1048              	.L54:
 419:Src/util.c    ****         }
 1049              		.loc 1 419 96 discriminator 2 view .LVU312
 1050              		.loc 1 422 1 is_stmt 0 discriminator 2 view .LVU313
 1051 008a BDE81040 		pop	{r4, lr}
 1052              	.LCFI15:
 1053              		.cfi_remember_state
 1054              		.cfi_restore 14
 1055              		.cfi_restore 4
 1056              		.cfi_def_cfa_offset 0
 419:Src/util.c    ****         }
 1057              		.loc 1 419 96 discriminator 2 view .LVU314
 1058 008e FFF7FEBF 		b	gpio_bit_reset
 1059              	.LVL66:
 1060              	.L42:
 1061              	.LCFI16:
 1062              		.cfi_restore_state
 1063              		.loc 1 422 1 view .LVU315
 1064 0092 10BD     		pop	{r4, pc}
 1065              	.L56:
 1066              		.align	2
 1067              	.L55:
 1068 0094 00000000 		.word	.LANCHOR9
ARM GAS  /tmp/ccpMgpO6.s 			page 29


 1069 0098 00000000 		.word	.LANCHOR10
 1070 009c 00040048 		.word	1207960576
 1071              		.cfi_endproc
 1072              	.LFE67:
 1074              		.section	.text.usart_process_data,"ax",%progbits
 1075              		.align	1
 1076              		.global	usart_process_data
 1077              		.syntax unified
 1078              		.thumb
 1079              		.thumb_func
 1080              		.fpu softvfp
 1082              	usart_process_data:
 1083              	.LVL67:
 1084              	.LFB69:
 423:Src/util.c    **** 
 424:Src/util.c    **** 
 425:Src/util.c    **** /* =========================== USART1 READ Functions =========================== */
 426:Src/util.c    **** 
 427:Src/util.c    **** void usart1_rx_check(void)
 428:Src/util.c    **** {
 429:Src/util.c    ****     #ifdef SERIAL_DEBUG
 430:Src/util.c    ****     static uint32_t old_pos;
 431:Src/util.c    ****     uint32_t pos;
 432:Src/util.c    **** 
 433:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 434:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 435:Src/util.c    ****         if (pos > old_pos) {                                                    // "Linear" buffer 
 436:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], pos - old_pos);           // Process data
 437:Src/util.c    ****         } else {                                                                // "Overflow" buffe
 438:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], rx1_buffer_len - old_pos);// First Process da
 439:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 440:Src/util.c    ****                 usart_process_debug(&rx1_buffer[0], pos);                       // Process remainin
 441:Src/util.c    ****             }
 442:Src/util.c    ****         }
 443:Src/util.c    ****     }
 444:Src/util.c    ****     old_pos = pos;                                                              // Update old posit
 445:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 446:Src/util.c    ****         old_pos = 0;
 447:Src/util.c    ****     }
 448:Src/util.c    ****     #endif // SERIAL_DEBUG
 449:Src/util.c    **** 
 450:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 451:Src/util.c    ****     static uint32_t old_pos;
 452:Src/util.c    ****     uint32_t pos;
 453:Src/util.c    ****     uint8_t *ptr;
 454:Src/util.c    **** 
 455:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 456:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 457:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 458:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 459:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 460:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 461:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 462:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 463:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 464:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 465:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
ARM GAS  /tmp/ccpMgpO6.s 			page 30


 466:Src/util.c    ****             }
 467:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 468:Src/util.c    ****         }
 469:Src/util.c    ****     }
 470:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 471:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 472:Src/util.c    ****         old_pos = 0;
 473:Src/util.c    ****     }
 474:Src/util.c    ****     #endif // SERIAL_FEEDBACK
 475:Src/util.c    **** }
 476:Src/util.c    **** 
 477:Src/util.c    **** /*
 478:Src/util.c    ****  * Process Rx debug user command input
 479:Src/util.c    ****  */
 480:Src/util.c    **** #ifdef SERIAL_DEBUG
 481:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
 482:Src/util.c    **** {
 483:Src/util.c    ****     for (; len > 0; len--, userCommand++) {
 484:Src/util.c    ****         if (*userCommand != '\n' && *userCommand != '\r') {     // Do not accept 'new line' and 'ca
 485:Src/util.c    ****             log_i("Command = %c\r\n", *userCommand);
 486:Src/util.c    ****             mpu_handle_input(*userCommand);
 487:Src/util.c    ****         }
 488:Src/util.c    ****     }
 489:Src/util.c    **** }
 490:Src/util.c    **** #endif // SERIAL_DEBUG
 491:Src/util.c    **** 
 492:Src/util.c    **** /*
 493:Src/util.c    ****  * Process Rx data
 494:Src/util.c    ****  * - if the Feedback_in data is valid (correct START_FRAME and checksum) copy the Feedback_in to Fe
 495:Src/util.c    ****  */
 496:Src/util.c    **** #ifdef SERIAL_FEEDBACK
 497:Src/util.c    **** void usart_process_data(SerialFeedback *Feedback_in, SerialFeedback *Feedback_out)
 498:Src/util.c    **** {
 1085              		.loc 1 498 1 is_stmt 1 view -0
 1086              		.cfi_startproc
 1087              		@ args = 0, pretend = 0, frame = 0
 1088              		@ frame_needed = 0, uses_anonymous_args = 0
 499:Src/util.c    ****     uint16_t checksum;
 1089              		.loc 1 499 5 view .LVU317
 500:Src/util.c    ****     if (Feedback_in->start == SERIAL_START_FRAME) {
 1090              		.loc 1 500 5 view .LVU318
 1091              		.loc 1 500 8 is_stmt 0 view .LVU319
 1092 0000 4AF6CD33 		movw	r3, #43981
 1093 0004 0288     		ldrh	r2, [r0]
 498:Src/util.c    ****     uint16_t checksum;
 1094              		.loc 1 498 1 view .LVU320
 1095 0006 10B5     		push	{r4, lr}
 1096              	.LCFI17:
 1097              		.cfi_def_cfa_offset 8
 1098              		.cfi_offset 4, -8
 1099              		.cfi_offset 14, -4
 1100              		.loc 1 500 8 view .LVU321
 1101 0008 9A42     		cmp	r2, r3
 1102 000a 20D1     		bne	.L57
 1103              	.LVL68:
 1104              	.LBB24:
 1105              	.LBI24:
ARM GAS  /tmp/ccpMgpO6.s 			page 31


 497:Src/util.c    **** {
 1106              		.loc 1 497 6 is_stmt 1 view .LVU322
 1107              	.LBB25:
 501:Src/util.c    ****         checksum = (uint16_t)(Feedback_in->start ^ Feedback_in->cmd1 ^ Feedback_in->cmd2 ^ Feedback
 1108              		.loc 1 501 9 view .LVU323
 502:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 503:Src/util.c    ****         if (Feedback_in->checksum == checksum) {
 1109              		.loc 1 503 9 view .LVU324
 502:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 1110              		.loc 1 502 80 is_stmt 0 view .LVU325
 1111 000c 8488     		ldrh	r4, [r0, #4]
 1112 000e 4388     		ldrh	r3, [r0, #2]
 1113 0010 6340     		eors	r3, r3, r4
 1114 0012 C489     		ldrh	r4, [r0, #14]
 1115 0014 6340     		eors	r3, r3, r4
 1116 0016 C488     		ldrh	r4, [r0, #6]
 1117 0018 6340     		eors	r3, r3, r4
 1118 001a 0489     		ldrh	r4, [r0, #8]
 1119 001c 6340     		eors	r3, r3, r4
 1120 001e 4489     		ldrh	r4, [r0, #10]
 1121 0020 6340     		eors	r3, r3, r4
 1122 0022 8489     		ldrh	r4, [r0, #12]
 1123 0024 6340     		eors	r3, r3, r4
 1124 0026 5A40     		eors	r2, r2, r3
 1125              		.loc 1 503 12 view .LVU326
 1126 0028 038A     		ldrh	r3, [r0, #16]
 1127 002a 92B2     		uxth	r2, r2
 1128 002c 9342     		cmp	r3, r2
 1129 002e 0ED1     		bne	.L57
 504:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1130              		.loc 1 504 13 is_stmt 1 view .LVU327
 1131              		.loc 1 504 27 is_stmt 0 view .LVU328
 1132 0030 00F11003 		add	r3, r0, #16
 1133              	.LVL69:
 1134              	.L59:
 1135              		.loc 1 504 27 view .LVU329
 1136 0034 50F8042B 		ldr	r2, [r0], #4	@ unaligned
 1137 0038 9842     		cmp	r0, r3
 1138 003a 41F8042B 		str	r2, [r1], #4	@ unaligned
 1139 003e F9D1     		bne	.L59
 1140 0040 0388     		ldrh	r3, [r0]	@ unaligned
 1141              	.LVL70:
 505:Src/util.c    ****             timeoutCntSerial1  = 0;     // Reset timeout counter
 1142              		.loc 1 505 32 view .LVU330
 1143 0042 034A     		ldr	r2, .L61
 504:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1144              		.loc 1 504 27 view .LVU331
 1145 0044 0B80     		strh	r3, [r1]	@ unaligned
 1146              		.loc 1 505 13 is_stmt 1 view .LVU332
 1147              		.loc 1 505 32 is_stmt 0 view .LVU333
 1148 0046 0023     		movs	r3, #0
 1149 0048 1380     		strh	r3, [r2]	@ movhi
 506:Src/util.c    ****             timeoutFlagSerial1 = 0;     // Clear timeout flag
 1150              		.loc 1 506 13 is_stmt 1 view .LVU334
 1151              		.loc 1 506 32 is_stmt 0 view .LVU335
 1152 004a 024A     		ldr	r2, .L61+4
 1153 004c 1370     		strb	r3, [r2]
ARM GAS  /tmp/ccpMgpO6.s 			page 32


 1154              	.LVL71:
 1155              	.L57:
 1156              		.loc 1 506 32 view .LVU336
 1157              	.LBE25:
 1158              	.LBE24:
 507:Src/util.c    ****         }
 508:Src/util.c    ****     }
 509:Src/util.c    **** }
 1159              		.loc 1 509 1 view .LVU337
 1160 004e 10BD     		pop	{r4, pc}
 1161              	.L62:
 1162              		.align	2
 1163              	.L61:
 1164 0050 00000000 		.word	.LANCHOR8
 1165 0054 00000000 		.word	.LANCHOR9
 1166              		.cfi_endproc
 1167              	.LFE69:
 1169              		.section	.text.usart1_rx_check,"ax",%progbits
 1170              		.align	1
 1171              		.global	usart1_rx_check
 1172              		.syntax unified
 1173              		.thumb
 1174              		.thumb_func
 1175              		.fpu softvfp
 1177              	usart1_rx_check:
 1178              	.LFB68:
 428:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1179              		.loc 1 428 1 is_stmt 1 view -0
 1180              		.cfi_startproc
 1181              		@ args = 0, pretend = 0, frame = 0
 1182              		@ frame_needed = 0, uses_anonymous_args = 0
 451:Src/util.c    ****     uint32_t pos;
 1183              		.loc 1 451 5 view .LVU339
 452:Src/util.c    ****     uint8_t *ptr;
 1184              		.loc 1 452 5 view .LVU340
 453:Src/util.c    **** 
 1185              		.loc 1 453 5 view .LVU341
 455:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1186              		.loc 1 455 5 view .LVU342
 428:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1187              		.loc 1 428 1 is_stmt 0 view .LVU343
 1188 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1189              	.LCFI18:
 1190              		.cfi_def_cfa_offset 24
 1191              		.cfi_offset 3, -24
 1192              		.cfi_offset 4, -20
 1193              		.cfi_offset 5, -16
 1194              		.cfi_offset 6, -12
 1195              		.cfi_offset 7, -8
 1196              		.cfi_offset 14, -4
 455:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1197              		.loc 1 455 28 view .LVU344
 1198 0002 0420     		movs	r0, #4
 1199 0004 FFF7FEFF 		bl	dma_transfer_number_get
 1200              	.LVL72:
 456:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1201              		.loc 1 456 13 view .LVU345
ARM GAS  /tmp/ccpMgpO6.s 			page 33


 1202 0008 1A4D     		ldr	r5, .L74
 455:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1203              		.loc 1 455 9 view .LVU346
 1204 000a C0F14004 		rsb	r4, r0, #64
 1205              	.LVL73:
 456:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1206              		.loc 1 456 5 is_stmt 1 view .LVU347
 456:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1207              		.loc 1 456 13 is_stmt 0 view .LVU348
 1208 000e 2968     		ldr	r1, [r5]
 456:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1209              		.loc 1 456 8 view .LVU349
 1210 0010 A142     		cmp	r1, r4
 1211 0012 14D0     		beq	.L64
 457:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 1212              		.loc 1 457 9 is_stmt 1 view .LVU350
 1213              	.LVL74:
 458:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1214              		.loc 1 458 9 view .LVU351
 458:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1215              		.loc 1 458 12 is_stmt 0 view .LVU352
 1216 0014 19D2     		bcs	.L65
 458:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1217              		.loc 1 458 35 discriminator 1 view .LVU353
 1218 0016 631A     		subs	r3, r4, r1
 458:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1219              		.loc 1 458 27 discriminator 1 view .LVU354
 1220 0018 122B     		cmp	r3, #18
 1221 001a 16D1     		bne	.L65
 459:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1222              		.loc 1 459 13 is_stmt 1 view .LVU355
 459:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1223              		.loc 1 459 25 is_stmt 0 view .LVU356
 1224 001c 164B     		ldr	r3, .L74+4
 1225 001e 1944     		add	r1, r1, r3
 459:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1226              		.loc 1 459 13 view .LVU357
 1227 0020 164B     		ldr	r3, .L74+8
 1228 0022 01F11002 		add	r2, r1, #16
 1229              	.L66:
 1230 0026 51F8040B 		ldr	r0, [r1], #4	@ unaligned
 1231 002a 9142     		cmp	r1, r2
 1232 002c 43F8040B 		str	r0, [r3], #4	@ unaligned
 1233 0030 F9D1     		bne	.L66
 1234 0032 0A88     		ldrh	r2, [r1]	@ unaligned
 1235 0034 1A80     		strh	r2, [r3]	@ unaligned
 460:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 1236              		.loc 1 460 13 is_stmt 1 view .LVU358
 1237              	.LVL75:
 1238              	.L67:
 467:Src/util.c    ****         }
 1239              		.loc 1 467 13 view .LVU359
 1240 0036 1249     		ldr	r1, .L74+12
 1241 0038 1048     		ldr	r0, .L74+8
 1242 003a FFF7FEFF 		bl	usart_process_data
 1243              	.LVL76:
 1244              	.L64:
ARM GAS  /tmp/ccpMgpO6.s 			page 34


 470:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1245              		.loc 1 470 5 view .LVU360
 471:Src/util.c    ****         old_pos = 0;
 1246              		.loc 1 471 5 view .LVU361
 471:Src/util.c    ****         old_pos = 0;
 1247              		.loc 1 471 8 is_stmt 0 view .LVU362
 1248 003e 402C     		cmp	r4, #64
 472:Src/util.c    ****     }
 1249              		.loc 1 472 17 view .LVU363
 1250 0040 0ABF     		itet	eq
 1251 0042 0023     		moveq	r3, #0
 470:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1252              		.loc 1 470 13 view .LVU364
 1253 0044 2C60     		strne	r4, [r5]
 472:Src/util.c    ****     }
 1254              		.loc 1 472 9 is_stmt 1 view .LVU365
 472:Src/util.c    ****     }
 1255              		.loc 1 472 17 is_stmt 0 view .LVU366
 1256 0046 2B60     		streq	r3, [r5]
 475:Src/util.c    **** 
 1257              		.loc 1 475 1 view .LVU367
 1258 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1259              	.LVL77:
 1260              	.L65:
 461:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1261              		.loc 1 461 16 is_stmt 1 view .LVU368
 461:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1262              		.loc 1 461 36 is_stmt 0 view .LVU369
 1263 004a C1F14006 		rsb	r6, r1, #64
 461:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1264              		.loc 1 461 46 view .LVU370
 1265 004e 3319     		adds	r3, r6, r4
 461:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1266              		.loc 1 461 19 view .LVU371
 1267 0050 122B     		cmp	r3, #18
 1268 0052 F4D1     		bne	.L64
 462:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1269              		.loc 1 462 13 is_stmt 1 view .LVU372
 1270 0054 094B     		ldr	r3, .L74+8
 462:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1271              		.loc 1 462 25 is_stmt 0 view .LVU373
 1272 0056 084F     		ldr	r7, .L74+4
 462:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1273              		.loc 1 462 13 view .LVU374
 1274 0058 3246     		mov	r2, r6
 1275 005a 1846     		mov	r0, r3
 1276 005c 3944     		add	r1, r1, r7
 1277 005e FFF7FEFF 		bl	memcpy
 1278              	.LVL78:
 463:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1279              		.loc 1 463 13 is_stmt 1 view .LVU375
 463:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1280              		.loc 1 463 16 is_stmt 0 view .LVU376
 1281 0062 002C     		cmp	r4, #0
 1282 0064 E7D0     		beq	.L67
 464:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 1283              		.loc 1 464 17 is_stmt 1 view .LVU377
ARM GAS  /tmp/ccpMgpO6.s 			page 35


 1284              	.LVL79:
 465:Src/util.c    ****             }
 1285              		.loc 1 465 17 view .LVU378
 1286 0066 2246     		mov	r2, r4
 1287 0068 3946     		mov	r1, r7
 1288 006a 3044     		add	r0, r0, r6
 1289 006c FFF7FEFF 		bl	memcpy
 1290              	.LVL80:
 1291 0070 E1E7     		b	.L67
 1292              	.L75:
 1293 0072 00BF     		.align	2
 1294              	.L74:
 1295 0074 00000000 		.word	.LANCHOR11
 1296 0078 00000000 		.word	.LANCHOR1
 1297 007c 00000000 		.word	.LANCHOR12
 1298 0080 00000000 		.word	.LANCHOR10
 1299              		.cfi_endproc
 1300              	.LFE68:
 1302              		.section	.text.usart0_rx_check,"ax",%progbits
 1303              		.align	1
 1304              		.global	usart0_rx_check
 1305              		.syntax unified
 1306              		.thumb
 1307              		.thumb_func
 1308              		.fpu softvfp
 1310              	usart0_rx_check:
 1311              	.LFB70:
 510:Src/util.c    **** #endif // SERIAL_FEEDBACK
 511:Src/util.c    **** 
 512:Src/util.c    **** 
 513:Src/util.c    **** /* =========================== USART0 READ Functions =========================== */
 514:Src/util.c    **** 
 515:Src/util.c    **** /*
 516:Src/util.c    ****  * Check for new data received on USART with DMA: refactored function from https://github.com/MaJer
 517:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 518:Src/util.c    ****  */
 519:Src/util.c    **** void usart0_rx_check(void)
 520:Src/util.c    **** {
 1312              		.loc 1 520 1 view -0
 1313              		.cfi_startproc
 1314              		@ args = 0, pretend = 0, frame = 0
 1315              		@ frame_needed = 0, uses_anonymous_args = 0
 1316              		@ link register save eliminated.
 521:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 522:Src/util.c    ****     static uint32_t old_pos;
 523:Src/util.c    ****     uint32_t pos;
 524:Src/util.c    ****     uint8_t *ptr;
 525:Src/util.c    **** 
 526:Src/util.c    ****     pos = rx0_buffer_len - dma_transfer_number_get(USART0_RX_DMA_CH);           // Calculate curren
 527:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 528:Src/util.c    ****         ptr = (uint8_t *)&command_raw;                                          // Initialize the p
 529:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == command_len) {                  // "Linear" buffer 
 530:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], command_len);                     // Copy data. This 
 531:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 532:Src/util.c    ****         } else if ((rx0_buffer_len - old_pos + pos) == command_len) {           // "Overflow" buffe
 533:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], rx0_buffer_len - old_pos);        // First copy data 
 534:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
ARM GAS  /tmp/ccpMgpO6.s 			page 36


 535:Src/util.c    ****                 ptr += rx0_buffer_len - old_pos;                                // Update position
 536:Src/util.c    ****                 memcpy(ptr, &rx0_buffer[0], pos);                               // Copy remaining d
 537:Src/util.c    ****             }
 538:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 539:Src/util.c    ****         }
 540:Src/util.c    ****     }
 541:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 542:Src/util.c    ****     if (old_pos == rx0_buffer_len) {                                            // Check and manual
 543:Src/util.c    ****         old_pos = 0;
 544:Src/util.c    ****     }
 545:Src/util.c    ****     #endif  // SERIAL_AUX_RX
 546:Src/util.c    **** }
 1317              		.loc 1 546 1 view .LVU380
 1318 0000 7047     		bx	lr
 1319              		.cfi_endproc
 1320              	.LFE70:
 1322              		.section	.text.aux_print_to_console,"ax",%progbits
 1323              		.align	1
 1324              		.global	aux_print_to_console
 1325              		.syntax unified
 1326              		.thumb
 1327              		.thumb_func
 1328              		.fpu softvfp
 1330              	aux_print_to_console:
 1331              	.LFB80:
 1332              		.cfi_startproc
 1333              		@ args = 0, pretend = 0, frame = 0
 1334              		@ frame_needed = 0, uses_anonymous_args = 0
 1335              		@ link register save eliminated.
 1336 0000 7047     		bx	lr
 1337              		.cfi_endproc
 1338              	.LFE80:
 1340              		.section	.text.i2c_writeBytes,"ax",%progbits
 1341              		.align	1
 1342              		.global	i2c_writeBytes
 1343              		.syntax unified
 1344              		.thumb
 1345              		.thumb_func
 1346              		.fpu softvfp
 1348              	i2c_writeBytes:
 1349              	.LVL81:
 1350              	.LFB72:
 547:Src/util.c    **** 
 548:Src/util.c    **** /*
 549:Src/util.c    ****  * Process command UART0 Rx data
 550:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
 551:Src/util.c    ****  */
 552:Src/util.c    **** #ifdef SERIAL_AUX_RX
 553:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out)
 554:Src/util.c    **** {
 555:Src/util.c    ****   #ifdef CONTROL_IBUS
 556:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
 557:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
 558:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
 559:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
 560:Src/util.c    ****       }
 561:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
ARM GAS  /tmp/ccpMgpO6.s 			page 37


 562:Src/util.c    ****         *command_out = *command_in;
 563:Src/util.c    ****         timeoutCntSerial0  = 0;        // Reset timeout counter
 564:Src/util.c    ****         timeoutFlagSerial0 = 0;        // Clear timeout flag
 565:Src/util.c    ****       }
 566:Src/util.c    ****     }
 567:Src/util.c    ****   #endif
 568:Src/util.c    **** }
 569:Src/util.c    **** #endif
 570:Src/util.c    **** 
 571:Src/util.c    **** 
 572:Src/util.c    **** /* =========================== AUX Serial Print data =========================== */
 573:Src/util.c    **** 
 574:Src/util.c    **** void aux_print_to_console(void)
 575:Src/util.c    **** {
 576:Src/util.c    **** #if defined(SERIAL_DEBUG) && defined(SERIAL_AUX_RX)
 577:Src/util.c    ****     #ifdef CONTROL_IBUS
 578:Src/util.c    ****     if (print_aux & PRINT_AUX) {
 579:Src/util.c    ****         log_i( "Ch1: %d Ch2: %d Sw: %u\r\n", cmd1, cmd2, cmdSwitch);
 580:Src/util.c    ****     }
 581:Src/util.c    ****     #endif
 582:Src/util.c    **** #endif
 583:Src/util.c    **** }
 584:Src/util.c    **** 
 585:Src/util.c    **** 
 586:Src/util.c    **** /* =========================== I2C WRITE Functions =========================== */
 587:Src/util.c    **** 
 588:Src/util.c    **** /*
 589:Src/util.c    ****  * write bytes to chip register
 590:Src/util.c    ****  */
 591:Src/util.c    **** int8_t i2c_writeBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data)
 592:Src/util.c    **** {
 1351              		.loc 1 592 1 view -0
 1352              		.cfi_startproc
 1353              		@ args = 0, pretend = 0, frame = 0
 1354              		@ frame_needed = 0, uses_anonymous_args = 0
 593:Src/util.c    **** 
 594:Src/util.c    ****     // assign WRITE command
 595:Src/util.c    ****     i2c_ReadWriteCmd    = WRITE;
 1355              		.loc 1 595 5 view .LVU382
 592:Src/util.c    **** 
 1356              		.loc 1 592 1 is_stmt 0 view .LVU383
 1357 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1358              	.LCFI19:
 1359              		.cfi_def_cfa_offset 24
 1360              		.cfi_offset 4, -24
 1361              		.cfi_offset 5, -20
 1362              		.cfi_offset 6, -16
 1363              		.cfi_offset 7, -12
 1364              		.cfi_offset 8, -8
 1365              		.cfi_offset 14, -4
 1366              		.loc 1 595 25 view .LVU384
 1367 0004 0124     		movs	r4, #1
 596:Src/util.c    **** 
 597:Src/util.c    ****     // assign inputs
 598:Src/util.c    ****     i2c_status          = -1;
 1368              		.loc 1 598 25 view .LVU385
 1369 0006 FF26     		movs	r6, #255
ARM GAS  /tmp/ccpMgpO6.s 			page 38


 595:Src/util.c    **** 
 1370              		.loc 1 595 25 view .LVU386
 1371 0008 184D     		ldr	r5, .L91
 599:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1372              		.loc 1 599 37 view .LVU387
 1373 000a A040     		lsls	r0, r0, r4
 1374              	.LVL82:
 595:Src/util.c    **** 
 1375              		.loc 1 595 25 view .LVU388
 1376 000c 2C70     		strb	r4, [r5]
 598:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1377              		.loc 1 598 5 is_stmt 1 view .LVU389
 598:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1378              		.loc 1 598 25 is_stmt 0 view .LVU390
 1379 000e 184D     		ldr	r5, .L91+4
 1380              		.loc 1 599 37 view .LVU391
 1381 0010 C0B2     		uxtb	r0, r0
 598:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1382              		.loc 1 598 25 view .LVU392
 1383 0012 2E70     		strb	r6, [r5]
 1384              		.loc 1 599 5 is_stmt 1 view .LVU393
 1385              		.loc 1 599 25 is_stmt 0 view .LVU394
 1386 0014 174E     		ldr	r6, .L91+8
 600:Src/util.c    ****     i2c_regAddress      = regAddr;
 601:Src/util.c    ****     i2c_txbuffer        = data;
 602:Src/util.c    ****     i2c_nDABytes        = length;
 603:Src/util.c    ****     i2c_nRABytes        = 1;
 604:Src/util.c    **** 
 605:Src/util.c    ****     uint16_t i2c_timeout = 0;
 606:Src/util.c    **** 
 607:Src/util.c    ****     // enable the I2C0 interrupt
 608:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 609:Src/util.c    **** 
 610:Src/util.c    ****     // the master waits until the I2C bus is idle
 611:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1387              		.loc 1 611 11 view .LVU395
 1388 0016 184F     		ldr	r7, .L91+12
 599:Src/util.c    ****     i2c_regAddress      = regAddr;
 1389              		.loc 1 599 25 view .LVU396
 1390 0018 3070     		strb	r0, [r6]
 600:Src/util.c    ****     i2c_regAddress      = regAddr;
 1391              		.loc 1 600 5 is_stmt 1 view .LVU397
 600:Src/util.c    ****     i2c_regAddress      = regAddr;
 1392              		.loc 1 600 25 is_stmt 0 view .LVU398
 1393 001a 1848     		ldr	r0, .L91+16
 602:Src/util.c    ****     i2c_nRABytes        = 1;
 1394              		.loc 1 602 25 view .LVU399
 1395 001c 184E     		ldr	r6, .L91+20
 600:Src/util.c    ****     i2c_regAddress      = regAddr;
 1396              		.loc 1 600 25 view .LVU400
 1397 001e 0170     		strb	r1, [r0]
 601:Src/util.c    ****     i2c_nDABytes        = length;
 1398              		.loc 1 601 5 is_stmt 1 view .LVU401
 601:Src/util.c    ****     i2c_nDABytes        = length;
 1399              		.loc 1 601 25 is_stmt 0 view .LVU402
 1400 0020 1849     		ldr	r1, .L91+24
 1401              	.LVL83:
ARM GAS  /tmp/ccpMgpO6.s 			page 39


 608:Src/util.c    **** 
 1402              		.loc 1 608 5 view .LVU403
 1403 0022 1948     		ldr	r0, .L91+28
 601:Src/util.c    ****     i2c_nDABytes        = length;
 1404              		.loc 1 601 25 view .LVU404
 1405 0024 0B60     		str	r3, [r1]
 602:Src/util.c    ****     i2c_nRABytes        = 1;
 1406              		.loc 1 602 5 is_stmt 1 view .LVU405
 603:Src/util.c    **** 
 1407              		.loc 1 603 25 is_stmt 0 view .LVU406
 1408 0026 194B     		ldr	r3, .L91+32
 1409              	.LVL84:
 608:Src/util.c    **** 
 1410              		.loc 1 608 5 view .LVU407
 1411 0028 4FF4E061 		mov	r1, #1792
 602:Src/util.c    ****     i2c_nRABytes        = 1;
 1412              		.loc 1 602 25 view .LVU408
 1413 002c 3270     		strb	r2, [r6]
 1414              	.LVL85:
 603:Src/util.c    **** 
 1415              		.loc 1 603 5 is_stmt 1 view .LVU409
 603:Src/util.c    **** 
 1416              		.loc 1 603 25 is_stmt 0 view .LVU410
 1417 002e 1C70     		strb	r4, [r3]
 605:Src/util.c    **** 
 1418              		.loc 1 605 5 is_stmt 1 view .LVU411
 1419              	.LVL86:
 608:Src/util.c    **** 
 1420              		.loc 1 608 5 view .LVU412
 1421 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1422              	.LVL87:
 1423              		.loc 1 611 5 view .LVU413
 1424              		.loc 1 611 10 is_stmt 0 view .LVU414
 1425 0034 44F62164 		movw	r4, #20001
 1426              		.loc 1 611 11 view .LVU415
 1427 0038 DFF84C80 		ldr	r8, .L91+28
 1428              	.LVL88:
 1429              	.L80:
 1430              		.loc 1 611 75 is_stmt 1 discriminator 2 view .LVU416
 1431              		.loc 1 611 10 discriminator 2 view .LVU417
 1432              		.loc 1 611 11 is_stmt 0 discriminator 2 view .LVU418
 1433 003c 3946     		mov	r1, r7
 1434 003e 4046     		mov	r0, r8
 1435 0040 FFF7FEFF 		bl	i2c_flag_get
 1436              	.LVL89:
 1437              		.loc 1 611 10 discriminator 2 view .LVU419
 1438 0044 18B1     		cbz	r0, .L79
 1439              	.LVL90:
 1440              		.loc 1 611 50 discriminator 1 view .LVU420
 1441 0046 013C     		subs	r4, r4, #1
 1442              	.LVL91:
 1443              		.loc 1 611 50 discriminator 1 view .LVU421
 1444 0048 A4B2     		uxth	r4, r4
 1445 004a 002C     		cmp	r4, #0
 1446 004c F6D1     		bne	.L80
 1447              	.L79:
 612:Src/util.c    **** 
ARM GAS  /tmp/ccpMgpO6.s 			page 40


 613:Src/util.c    ****     // the master sends a start condition to I2C bus
 614:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1448              		.loc 1 614 5 is_stmt 1 view .LVU422
 1449 004e 0E48     		ldr	r0, .L91+28
 1450 0050 FFF7FEFF 		bl	i2c_start_on_bus
 1451              	.LVL92:
 615:Src/util.c    ****     
 616:Src/util.c    ****     // Wait until all data bytes are sent/received
 617:Src/util.c    ****     i2c_timeout = 0;
 1452              		.loc 1 617 5 view .LVU423
 618:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1453              		.loc 1 618 5 view .LVU424
 1454              		.loc 1 618 10 is_stmt 0 view .LVU425
 1455 0054 44F62163 		movw	r3, #20001
 1456              	.LVL93:
 1457              	.L82:
 1458              		.loc 1 618 53 is_stmt 1 discriminator 2 view .LVU426
 1459              		.loc 1 618 10 discriminator 2 view .LVU427
 1460              		.loc 1 618 24 is_stmt 0 discriminator 2 view .LVU428
 1461 0058 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1462              		.loc 1 618 10 discriminator 2 view .LVU429
 1463 005a 1AB1     		cbz	r2, .L81
 1464              	.LVL94:
 1465              		.loc 1 618 28 discriminator 1 view .LVU430
 1466 005c 013B     		subs	r3, r3, #1
 1467              	.LVL95:
 1468              		.loc 1 618 28 discriminator 1 view .LVU431
 1469 005e 9BB2     		uxth	r3, r3
 1470 0060 002B     		cmp	r3, #0
 1471 0062 F9D1     		bne	.L82
 1472              	.L81:
 619:Src/util.c    **** 
 620:Src/util.c    ****     return i2c_status;
 1473              		.loc 1 620 5 is_stmt 1 view .LVU432
 1474              		.loc 1 620 12 is_stmt 0 view .LVU433
 1475 0064 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 621:Src/util.c    **** 
 622:Src/util.c    **** }
 1476              		.loc 1 622 1 view .LVU434
 1477 0066 40B2     		sxtb	r0, r0
 1478 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1479              	.L92:
 1480              		.align	2
 1481              	.L91:
 1482 006c 00000000 		.word	.LANCHOR13
 1483 0070 00000000 		.word	.LANCHOR14
 1484 0074 00000000 		.word	.LANCHOR15
 1485 0078 02000080 		.word	-2147483646
 1486 007c 00000000 		.word	.LANCHOR16
 1487 0080 00000000 		.word	.LANCHOR18
 1488 0084 00000000 		.word	.LANCHOR17
 1489 0088 00540040 		.word	1073763328
 1490 008c 00000000 		.word	.LANCHOR19
 1491              		.cfi_endproc
 1492              	.LFE72:
 1494              		.section	.text.i2c_writeByte,"ax",%progbits
 1495              		.align	1
ARM GAS  /tmp/ccpMgpO6.s 			page 41


 1496              		.global	i2c_writeByte
 1497              		.syntax unified
 1498              		.thumb
 1499              		.thumb_func
 1500              		.fpu softvfp
 1502              	i2c_writeByte:
 1503              	.LVL96:
 1504              	.LFB73:
 623:Src/util.c    **** 
 624:Src/util.c    **** 
 625:Src/util.c    **** /*
 626:Src/util.c    ****  * write 1 byte to chip register
 627:Src/util.c    ****  */
 628:Src/util.c    **** int8_t i2c_writeByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t data)
 629:Src/util.c    **** {
 1505              		.loc 1 629 1 is_stmt 1 view -0
 1506              		.cfi_startproc
 1507              		@ args = 0, pretend = 0, frame = 8
 1508              		@ frame_needed = 0, uses_anonymous_args = 0
 630:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1509              		.loc 1 630 5 view .LVU436
 629:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1510              		.loc 1 629 1 is_stmt 0 view .LVU437
 1511 0000 07B5     		push	{r0, r1, r2, lr}
 1512              	.LCFI20:
 1513              		.cfi_def_cfa_offset 16
 1514              		.cfi_offset 14, -4
 629:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1515              		.loc 1 629 1 view .LVU438
 1516 0002 8DF80720 		strb	r2, [sp, #7]
 1517              		.loc 1 630 12 view .LVU439
 1518 0006 0DF10703 		add	r3, sp, #7
 1519 000a 0122     		movs	r2, #1
 1520              	.LVL97:
 1521              		.loc 1 630 12 view .LVU440
 1522 000c FFF7FEFF 		bl	i2c_writeBytes
 1523              	.LVL98:
 631:Src/util.c    **** }
 1524              		.loc 1 631 1 view .LVU441
 1525 0010 03B0     		add	sp, sp, #12
 1526              	.LCFI21:
 1527              		.cfi_def_cfa_offset 4
 1528              		@ sp needed
 1529 0012 5DF804FB 		ldr	pc, [sp], #4
 1530              		.cfi_endproc
 1531              	.LFE73:
 1533              		.section	.text.i2c_readBytes,"ax",%progbits
 1534              		.align	1
 1535              		.global	i2c_readBytes
 1536              		.syntax unified
 1537              		.thumb
 1538              		.thumb_func
 1539              		.fpu softvfp
 1541              	i2c_readBytes:
 1542              	.LVL99:
 1543              	.LFB75:
 632:Src/util.c    **** 
ARM GAS  /tmp/ccpMgpO6.s 			page 42


 633:Src/util.c    **** 
 634:Src/util.c    **** /*
 635:Src/util.c    ****  * write one bit to chip register
 636:Src/util.c    ****  */
 637:Src/util.c    **** int8_t i2c_writeBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 638:Src/util.c    ****     uint8_t b;
 639:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 640:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 641:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 642:Src/util.c    **** }
 643:Src/util.c    **** 
 644:Src/util.c    **** 
 645:Src/util.c    **** 
 646:Src/util.c    **** /* =========================== I2C READ Functions =========================== */
 647:Src/util.c    **** 
 648:Src/util.c    **** /*
 649:Src/util.c    ****  * read bytes from chip register
 650:Src/util.c    ****  */
 651:Src/util.c    **** int8_t i2c_readBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data) 
 652:Src/util.c    **** {
 1544              		.loc 1 652 1 is_stmt 1 view -0
 1545              		.cfi_startproc
 1546              		@ args = 0, pretend = 0, frame = 0
 1547              		@ frame_needed = 0, uses_anonymous_args = 0
 653:Src/util.c    **** 
 654:Src/util.c    ****     // assign READ command
 655:Src/util.c    ****     i2c_ReadWriteCmd    = READ;
 1548              		.loc 1 655 5 view .LVU443
 652:Src/util.c    **** 
 1549              		.loc 1 652 1 is_stmt 0 view .LVU444
 1550 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1551              	.LCFI22:
 1552              		.cfi_def_cfa_offset 24
 1553              		.cfi_offset 4, -24
 1554              		.cfi_offset 5, -20
 1555              		.cfi_offset 6, -16
 1556              		.cfi_offset 7, -12
 1557              		.cfi_offset 8, -8
 1558              		.cfi_offset 14, -4
 1559              		.loc 1 655 25 view .LVU445
 1560 0004 0024     		movs	r4, #0
 656:Src/util.c    ****     
 657:Src/util.c    ****     // assign inputs
 658:Src/util.c    ****     i2c_status          = -1;
 1561              		.loc 1 658 25 view .LVU446
 1562 0006 FF26     		movs	r6, #255
 655:Src/util.c    ****     
 1563              		.loc 1 655 25 view .LVU447
 1564 0008 1C4D     		ldr	r5, .L108
 659:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1565              		.loc 1 659 37 view .LVU448
 1566 000a 4000     		lsls	r0, r0, #1
 1567              	.LVL100:
 655:Src/util.c    ****     
 1568              		.loc 1 655 25 view .LVU449
 1569 000c 2C70     		strb	r4, [r5]
 658:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
ARM GAS  /tmp/ccpMgpO6.s 			page 43


 1570              		.loc 1 658 5 is_stmt 1 view .LVU450
 658:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1571              		.loc 1 658 25 is_stmt 0 view .LVU451
 1572 000e 1C4D     		ldr	r5, .L108+4
 1573              		.loc 1 659 37 view .LVU452
 1574 0010 C0B2     		uxtb	r0, r0
 658:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1575              		.loc 1 658 25 view .LVU453
 1576 0012 2E70     		strb	r6, [r5]
 1577              		.loc 1 659 5 is_stmt 1 view .LVU454
 1578              		.loc 1 659 25 is_stmt 0 view .LVU455
 1579 0014 1B4E     		ldr	r6, .L108+8
 1580 0016 3070     		strb	r0, [r6]
 660:Src/util.c    ****     i2c_regAddress      = regAddr;
 1581              		.loc 1 660 5 is_stmt 1 view .LVU456
 1582              		.loc 1 660 25 is_stmt 0 view .LVU457
 1583 0018 1B48     		ldr	r0, .L108+12
 661:Src/util.c    ****     i2c_rxbuffer        = data;
 662:Src/util.c    ****     i2c_nDABytes        = length;
 1584              		.loc 1 662 25 view .LVU458
 1585 001a 1C4E     		ldr	r6, .L108+16
 660:Src/util.c    ****     i2c_regAddress      = regAddr;
 1586              		.loc 1 660 25 view .LVU459
 1587 001c 0170     		strb	r1, [r0]
 661:Src/util.c    ****     i2c_rxbuffer        = data;
 1588              		.loc 1 661 5 is_stmt 1 view .LVU460
 1589              		.loc 1 662 25 is_stmt 0 view .LVU461
 1590 001e 3270     		strb	r2, [r6]
 663:Src/util.c    ****     i2c_nRABytes        = 1;
 1591              		.loc 1 663 25 view .LVU462
 1592 0020 0122     		movs	r2, #1
 1593              	.LVL101:
 661:Src/util.c    ****     i2c_rxbuffer        = data;
 1594              		.loc 1 661 25 view .LVU463
 1595 0022 1B49     		ldr	r1, .L108+20
 1596              	.LVL102:
 664:Src/util.c    **** 
 665:Src/util.c    ****     uint16_t i2c_timeout = 0;
 666:Src/util.c    **** 
 667:Src/util.c    ****     // enable the I2C0 interrupt
 668:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 1597              		.loc 1 668 5 view .LVU464
 1598 0024 1B48     		ldr	r0, .L108+24
 661:Src/util.c    ****     i2c_nDABytes        = length;
 1599              		.loc 1 661 25 view .LVU465
 1600 0026 0B60     		str	r3, [r1]
 662:Src/util.c    ****     i2c_nRABytes        = 1;
 1601              		.loc 1 662 5 is_stmt 1 view .LVU466
 663:Src/util.c    **** 
 1602              		.loc 1 663 5 view .LVU467
 663:Src/util.c    **** 
 1603              		.loc 1 663 25 is_stmt 0 view .LVU468
 1604 0028 1B4B     		ldr	r3, .L108+28
 1605              	.LVL103:
 1606              		.loc 1 668 5 view .LVU469
 1607 002a 4FF4E061 		mov	r1, #1792
 663:Src/util.c    **** 
ARM GAS  /tmp/ccpMgpO6.s 			page 44


 1608              		.loc 1 663 25 view .LVU470
 1609 002e 1A70     		strb	r2, [r3]
 1610              	.LVL104:
 665:Src/util.c    **** 
 1611              		.loc 1 665 5 is_stmt 1 view .LVU471
 1612              		.loc 1 668 5 view .LVU472
 1613 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1614              	.LVL105:
 669:Src/util.c    **** 
 670:Src/util.c    ****     if(2 == i2c_nDABytes){
 1615              		.loc 1 670 5 view .LVU473
 1616              		.loc 1 670 10 is_stmt 0 view .LVU474
 1617 0034 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1618              		.loc 1 670 7 view .LVU475
 1619 0036 022B     		cmp	r3, #2
 1620 0038 03D1     		bne	.L95
 671:Src/util.c    ****         i2c_ackpos_config(MPU_I2C, I2C_ACKPOS_NEXT);    // send ACK for the next byte
 1621              		.loc 1 671 9 is_stmt 1 view .LVU476
 1622 003a 2146     		mov	r1, r4
 1623 003c 1548     		ldr	r0, .L108+24
 1624 003e FFF7FEFF 		bl	i2c_ackpos_config
 1625              	.LVL106:
 1626              	.L95:
 652:Src/util.c    **** 
 1627              		.loc 1 652 1 is_stmt 0 discriminator 2 view .LVU477
 1628 0042 44F62164 		movw	r4, #20001
 672:Src/util.c    ****     }
 673:Src/util.c    **** 
 674:Src/util.c    ****     // the master waits until the I2C bus is idle
 675:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1629              		.loc 1 675 11 discriminator 2 view .LVU478
 1630 0046 154F     		ldr	r7, .L108+32
 1631 0048 DFF84880 		ldr	r8, .L108+24
 1632              	.LVL107:
 1633              	.L97:
 1634              		.loc 1 675 75 is_stmt 1 discriminator 2 view .LVU479
 1635              		.loc 1 675 10 discriminator 2 view .LVU480
 1636              		.loc 1 675 11 is_stmt 0 discriminator 2 view .LVU481
 1637 004c 3946     		mov	r1, r7
 1638 004e 4046     		mov	r0, r8
 1639 0050 FFF7FEFF 		bl	i2c_flag_get
 1640              	.LVL108:
 1641              		.loc 1 675 10 discriminator 2 view .LVU482
 1642 0054 18B1     		cbz	r0, .L96
 1643              	.LVL109:
 1644              		.loc 1 675 50 discriminator 1 view .LVU483
 1645 0056 013C     		subs	r4, r4, #1
 1646              	.LVL110:
 1647              		.loc 1 675 50 discriminator 1 view .LVU484
 1648 0058 A4B2     		uxth	r4, r4
 1649 005a 002C     		cmp	r4, #0
 1650 005c F6D1     		bne	.L97
 1651              	.L96:
 676:Src/util.c    **** 
 677:Src/util.c    ****     // the master sends a start condition to I2C bus
 678:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1652              		.loc 1 678 5 is_stmt 1 view .LVU485
ARM GAS  /tmp/ccpMgpO6.s 			page 45


 1653 005e 0D48     		ldr	r0, .L108+24
 1654 0060 FFF7FEFF 		bl	i2c_start_on_bus
 1655              	.LVL111:
 679:Src/util.c    **** 
 680:Src/util.c    ****     // Wait until all data bytes are sent/received
 681:Src/util.c    ****     i2c_timeout = 0;
 1656              		.loc 1 681 5 view .LVU486
 682:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1657              		.loc 1 682 5 view .LVU487
 1658              		.loc 1 682 10 is_stmt 0 view .LVU488
 1659 0064 44F62163 		movw	r3, #20001
 1660              	.LVL112:
 1661              	.L99:
 1662              		.loc 1 682 53 is_stmt 1 discriminator 2 view .LVU489
 1663              		.loc 1 682 10 discriminator 2 view .LVU490
 1664              		.loc 1 682 24 is_stmt 0 discriminator 2 view .LVU491
 1665 0068 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1666              		.loc 1 682 10 discriminator 2 view .LVU492
 1667 006a 1AB1     		cbz	r2, .L98
 1668              	.LVL113:
 1669              		.loc 1 682 28 discriminator 1 view .LVU493
 1670 006c 013B     		subs	r3, r3, #1
 1671              	.LVL114:
 1672              		.loc 1 682 28 discriminator 1 view .LVU494
 1673 006e 9BB2     		uxth	r3, r3
 1674 0070 002B     		cmp	r3, #0
 1675 0072 F9D1     		bne	.L99
 1676              	.L98:
 683:Src/util.c    **** 
 684:Src/util.c    ****     // Return status
 685:Src/util.c    ****     return i2c_status;
 1677              		.loc 1 685 5 is_stmt 1 view .LVU495
 1678              		.loc 1 685 12 is_stmt 0 view .LVU496
 1679 0074 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 686:Src/util.c    **** 
 687:Src/util.c    **** }
 1680              		.loc 1 687 1 view .LVU497
 1681 0076 40B2     		sxtb	r0, r0
 1682 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1683              	.L109:
 1684              		.align	2
 1685              	.L108:
 1686 007c 00000000 		.word	.LANCHOR13
 1687 0080 00000000 		.word	.LANCHOR14
 1688 0084 00000000 		.word	.LANCHOR15
 1689 0088 00000000 		.word	.LANCHOR16
 1690 008c 00000000 		.word	.LANCHOR18
 1691 0090 00000000 		.word	.LANCHOR20
 1692 0094 00540040 		.word	1073763328
 1693 0098 00000000 		.word	.LANCHOR19
 1694 009c 02000080 		.word	-2147483646
 1695              		.cfi_endproc
 1696              	.LFE75:
 1698              		.section	.text.i2c_readByte,"ax",%progbits
 1699              		.align	1
 1700              		.global	i2c_readByte
 1701              		.syntax unified
ARM GAS  /tmp/ccpMgpO6.s 			page 46


 1702              		.thumb
 1703              		.thumb_func
 1704              		.fpu softvfp
 1706              	i2c_readByte:
 1707              	.LVL115:
 1708              	.LFB76:
 688:Src/util.c    **** 
 689:Src/util.c    **** 
 690:Src/util.c    **** /*
 691:Src/util.c    ****  * read 1 byte from chip register
 692:Src/util.c    ****  */
 693:Src/util.c    **** int8_t i2c_readByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t *data)
 694:Src/util.c    **** {
 1709              		.loc 1 694 1 is_stmt 1 view -0
 1710              		.cfi_startproc
 1711              		@ args = 0, pretend = 0, frame = 0
 1712              		@ frame_needed = 0, uses_anonymous_args = 0
 1713              		@ link register save eliminated.
 695:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1714              		.loc 1 695 5 view .LVU499
 694:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1715              		.loc 1 694 1 is_stmt 0 view .LVU500
 1716 0000 1346     		mov	r3, r2
 1717              		.loc 1 695 12 view .LVU501
 1718 0002 0122     		movs	r2, #1
 1719              	.LVL116:
 1720              		.loc 1 695 12 view .LVU502
 1721 0004 FFF7FEBF 		b	i2c_readBytes
 1722              	.LVL117:
 1723              		.loc 1 695 12 view .LVU503
 1724              		.cfi_endproc
 1725              	.LFE76:
 1727              		.section	.text.i2c_writeBit,"ax",%progbits
 1728              		.align	1
 1729              		.global	i2c_writeBit
 1730              		.syntax unified
 1731              		.thumb
 1732              		.thumb_func
 1733              		.fpu softvfp
 1735              	i2c_writeBit:
 1736              	.LVL118:
 1737              	.LFB74:
 637:Src/util.c    ****     uint8_t b;
 1738              		.loc 1 637 87 is_stmt 1 view -0
 1739              		.cfi_startproc
 1740              		@ args = 0, pretend = 0, frame = 8
 1741              		@ frame_needed = 0, uses_anonymous_args = 0
 638:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 1742              		.loc 1 638 5 view .LVU505
 639:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1743              		.loc 1 639 5 view .LVU506
 637:Src/util.c    ****     uint8_t b;
 1744              		.loc 1 637 87 is_stmt 0 view .LVU507
 1745 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 1746              	.LCFI23:
 1747              		.cfi_def_cfa_offset 32
 1748              		.cfi_offset 4, -24
ARM GAS  /tmp/ccpMgpO6.s 			page 47


 1749              		.cfi_offset 5, -20
 1750              		.cfi_offset 6, -16
 1751              		.cfi_offset 7, -12
 1752              		.cfi_offset 8, -8
 1753              		.cfi_offset 14, -4
 637:Src/util.c    ****     uint8_t b;
 1754              		.loc 1 637 87 view .LVU508
 1755 0004 9046     		mov	r8, r2
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1756              		.loc 1 640 31 view .LVU509
 1757 0006 0124     		movs	r4, #1
 637:Src/util.c    ****     uint8_t b;
 1758              		.loc 1 637 87 view .LVU510
 1759 0008 1F46     		mov	r7, r3
 639:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1760              		.loc 1 639 5 view .LVU511
 1761 000a 0DF10702 		add	r2, sp, #7
 1762              	.LVL119:
 637:Src/util.c    ****     uint8_t b;
 1763              		.loc 1 637 87 view .LVU512
 1764 000e 0546     		mov	r5, r0
 1765 0010 0E46     		mov	r6, r1
 639:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1766              		.loc 1 639 5 view .LVU513
 1767 0012 FFF7FEFF 		bl	i2c_readByte
 1768              	.LVL120:
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1769              		.loc 1 640 5 is_stmt 1 view .LVU514
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1770              		.loc 1 640 31 is_stmt 0 view .LVU515
 1771 0016 04FA08F2 		lsl	r2, r4, r8
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1772              		.loc 1 640 26 view .LVU516
 1773 001a 52B2     		sxtb	r2, r2
 1774 001c 9DF80740 		ldrb	r4, [sp, #7]	@ zero_extendqisi2
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1775              		.loc 1 640 7 view .LVU517
 1776 0020 57B1     		cbz	r7, .L112
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1777              		.loc 1 640 26 discriminator 1 view .LVU518
 1778 0022 2243     		orrs	r2, r2, r4
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1779              		.loc 1 640 7 discriminator 1 view .LVU519
 1780 0024 D2B2     		uxtb	r2, r2
 1781              	.L113:
 641:Src/util.c    **** }
 1782              		.loc 1 641 12 discriminator 4 view .LVU520
 1783 0026 3146     		mov	r1, r6
 1784 0028 2846     		mov	r0, r5
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1785              		.loc 1 640 7 discriminator 4 view .LVU521
 1786 002a 8DF80720 		strb	r2, [sp, #7]
 641:Src/util.c    **** }
 1787              		.loc 1 641 5 is_stmt 1 discriminator 4 view .LVU522
 641:Src/util.c    **** }
 1788              		.loc 1 641 12 is_stmt 0 discriminator 4 view .LVU523
 1789 002e FFF7FEFF 		bl	i2c_writeByte
ARM GAS  /tmp/ccpMgpO6.s 			page 48


 1790              	.LVL121:
 642:Src/util.c    **** 
 1791              		.loc 1 642 1 discriminator 4 view .LVU524
 1792 0032 02B0     		add	sp, sp, #8
 1793              	.LCFI24:
 1794              		.cfi_remember_state
 1795              		.cfi_def_cfa_offset 24
 1796              		@ sp needed
 1797 0034 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1798              	.L112:
 1799              	.LCFI25:
 1800              		.cfi_restore_state
 640:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1801              		.loc 1 640 7 discriminator 2 view .LVU525
 1802 0038 24EA0202 		bic	r2, r4, r2
 1803 003c F3E7     		b	.L113
 1804              		.cfi_endproc
 1805              	.LFE74:
 1807              		.section	.text.i2c_readBit,"ax",%progbits
 1808              		.align	1
 1809              		.global	i2c_readBit
 1810              		.syntax unified
 1811              		.thumb
 1812              		.thumb_func
 1813              		.fpu softvfp
 1815              	i2c_readBit:
 1816              	.LVL122:
 1817              	.LFB77:
 696:Src/util.c    **** }
 697:Src/util.c    **** 
 698:Src/util.c    **** 
 699:Src/util.c    **** /*
 700:Src/util.c    ****  * read 1 bit from chip register
 701:Src/util.c    ****  */
 702:Src/util.c    **** int8_t i2c_readBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data)
 703:Src/util.c    **** {
 1818              		.loc 1 703 1 is_stmt 1 view -0
 1819              		.cfi_startproc
 1820              		@ args = 0, pretend = 0, frame = 8
 1821              		@ frame_needed = 0, uses_anonymous_args = 0
 704:Src/util.c    ****     uint8_t b;
 1822              		.loc 1 704 5 view .LVU527
 705:Src/util.c    ****     int8_t status = i2c_readByte(slaveAddr, regAddr, &b);
 1823              		.loc 1 705 5 view .LVU528
 703:Src/util.c    ****     uint8_t b;
 1824              		.loc 1 703 1 is_stmt 0 view .LVU529
 1825 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1826              	.LCFI26:
 1827              		.cfi_def_cfa_offset 24
 1828              		.cfi_offset 4, -12
 1829              		.cfi_offset 5, -8
 1830              		.cfi_offset 14, -4
 703:Src/util.c    ****     uint8_t b;
 1831              		.loc 1 703 1 view .LVU530
 1832 0002 1546     		mov	r5, r2
 1833              		.loc 1 705 21 view .LVU531
 1834 0004 0DF10702 		add	r2, sp, #7
ARM GAS  /tmp/ccpMgpO6.s 			page 49


 1835              	.LVL123:
 703:Src/util.c    ****     uint8_t b;
 1836              		.loc 1 703 1 view .LVU532
 1837 0008 1C46     		mov	r4, r3
 1838              		.loc 1 705 21 view .LVU533
 1839 000a FFF7FEFF 		bl	i2c_readByte
 1840              	.LVL124:
 706:Src/util.c    ****     *data = b & (1 << bitNum);
 1841              		.loc 1 706 5 is_stmt 1 view .LVU534
 1842              		.loc 1 706 20 is_stmt 0 view .LVU535
 1843 000e 0121     		movs	r1, #1
 1844              		.loc 1 706 15 view .LVU536
 1845 0010 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1846              		.loc 1 706 20 view .LVU537
 1847 0014 01FA05F2 		lsl	r2, r1, r5
 1848              		.loc 1 706 15 view .LVU538
 1849 0018 1A40     		ands	r2, r2, r3
 1850              		.loc 1 706 11 view .LVU539
 1851 001a 2270     		strb	r2, [r4]
 707:Src/util.c    ****     return status;
 1852              		.loc 1 707 5 is_stmt 1 view .LVU540
 708:Src/util.c    **** }
 1853              		.loc 1 708 1 is_stmt 0 view .LVU541
 1854 001c 03B0     		add	sp, sp, #12
 1855              	.LCFI27:
 1856              		.cfi_def_cfa_offset 12
 1857              		@ sp needed
 1858 001e 30BD     		pop	{r4, r5, pc}
 1859              		.loc 1 708 1 view .LVU542
 1860              		.cfi_endproc
 1861              	.LFE77:
 1863              		.global	buffer
 1864              		.global	i2c_nRABytes
 1865              		.global	i2c_nDABytes
 1866              		.global	i2c_rxbuffer
 1867              		.global	i2c_txbuffer
 1868              		.global	i2c_slaveAddress
 1869              		.global	i2c_regAddress
 1870              		.global	i2c_ReadWriteCmd
 1871              		.global	i2c_status
 1872              		.section	.bss.Feedback,"aw",%nobits
 1873              		.align	1
 1874              		.set	.LANCHOR10,. + 0
 1877              	Feedback:
 1878 0000 00000000 		.space	18
 1878      00000000 
 1878      00000000 
 1878      00000000 
 1878      0000
 1879              		.section	.bss.FeedbackRaw,"aw",%nobits
 1880              		.align	1
 1881              		.set	.LANCHOR12,. + 0
 1884              	FeedbackRaw:
 1885 0000 00000000 		.space	18
 1885      00000000 
 1885      00000000 
 1885      00000000 
ARM GAS  /tmp/ccpMgpO6.s 			page 50


 1885      0000
 1886              		.section	.bss.Sideboard,"aw",%nobits
 1887              		.align	1
 1888              		.set	.LANCHOR0,. + 0
 1891              	Sideboard:
 1892 0000 00000000 		.space	14
 1892      00000000 
 1892      00000000 
 1892      0000
 1893              		.section	.bss.buffer,"aw",%nobits
 1896              	buffer:
 1897 0000 00000000 		.space	14
 1897      00000000 
 1897      00000000 
 1897      0000
 1898              		.section	.bss.i2c_ReadWriteCmd,"aw",%nobits
 1899              		.set	.LANCHOR13,. + 0
 1902              	i2c_ReadWriteCmd:
 1903 0000 00       		.space	1
 1904              		.section	.bss.i2c_nDABytes,"aw",%nobits
 1905              		.set	.LANCHOR18,. + 0
 1908              	i2c_nDABytes:
 1909 0000 00       		.space	1
 1910              		.section	.bss.i2c_nRABytes,"aw",%nobits
 1911              		.set	.LANCHOR19,. + 0
 1914              	i2c_nRABytes:
 1915 0000 00       		.space	1
 1916              		.section	.bss.i2c_regAddress,"aw",%nobits
 1917              		.set	.LANCHOR16,. + 0
 1920              	i2c_regAddress:
 1921 0000 00       		.space	1
 1922              		.section	.bss.i2c_rxbuffer,"aw",%nobits
 1923              		.align	2
 1924              		.set	.LANCHOR20,. + 0
 1927              	i2c_rxbuffer:
 1928 0000 00000000 		.space	4
 1929              		.section	.bss.i2c_slaveAddress,"aw",%nobits
 1930              		.set	.LANCHOR15,. + 0
 1933              	i2c_slaveAddress:
 1934 0000 00       		.space	1
 1935              		.section	.bss.i2c_status,"aw",%nobits
 1936              		.set	.LANCHOR14,. + 0
 1939              	i2c_status:
 1940 0000 00       		.space	1
 1941              		.section	.bss.i2c_txbuffer,"aw",%nobits
 1942              		.align	2
 1943              		.set	.LANCHOR17,. + 0
 1946              	i2c_txbuffer:
 1947 0000 00000000 		.space	4
 1948              		.section	.bss.mpuStatus,"aw",%nobits
 1949              		.set	.LANCHOR2,. + 0
 1952              	mpuStatus:
 1953 0000 00       		.space	1
 1954              		.section	.bss.old_pos.0,"aw",%nobits
 1955              		.align	2
 1956              		.set	.LANCHOR11,. + 0
 1959              	old_pos.0:
ARM GAS  /tmp/ccpMgpO6.s 			page 51


 1960 0000 00000000 		.space	4
 1961              		.section	.bss.rx1_buffer,"aw",%nobits
 1962              		.set	.LANCHOR1,. + 0
 1965              	rx1_buffer:
 1966 0000 00000000 		.space	64
 1966      00000000 
 1966      00000000 
 1966      00000000 
 1966      00000000 
 1967              		.section	.bss.sensor1,"aw",%nobits
 1968              		.set	.LANCHOR5,. + 0
 1971              	sensor1:
 1972 0000 00       		.space	1
 1973              		.section	.bss.sensor1_read,"aw",%nobits
 1974              		.set	.LANCHOR3,. + 0
 1977              	sensor1_read:
 1978 0000 00       		.space	1
 1979              		.section	.bss.sensor2,"aw",%nobits
 1980              		.set	.LANCHOR6,. + 0
 1983              	sensor2:
 1984 0000 00       		.space	1
 1985              		.section	.bss.sensor2_read,"aw",%nobits
 1986              		.set	.LANCHOR4,. + 0
 1989              	sensor2_read:
 1990 0000 00       		.space	1
 1991              		.section	.bss.sideboard_imu,"aw",%nobits
 1992              		.align	1
 1993              		.set	.LANCHOR7,. + 0
 1996              	sideboard_imu:
 1997 0000 00000000 		.space	42
 1997      00000000 
 1997      00000000 
 1997      00000000 
 1997      00000000 
 1998              		.section	.bss.timeoutCntSerial1,"aw",%nobits
 1999              		.align	1
 2000              		.set	.LANCHOR8,. + 0
 2003              	timeoutCntSerial1:
 2004 0000 0000     		.space	2
 2005              		.section	.bss.timeoutFlagSerial1,"aw",%nobits
 2006              		.set	.LANCHOR9,. + 0
 2009              	timeoutFlagSerial1:
 2010 0000 00       		.space	1
 2011              		.text
 2012              	.Letext0:
 2013              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 2014              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 2015              		.file 4 "Drivers/CMSIS/Include/gd32f1x0.h"
 2016              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dma.h"
 2017              		.file 6 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 2018              		.file 7 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 2019              		.file 8 "Inc/util.h"
 2020              		.file 9 "Inc/defines.h"
 2021              		.file 10 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_i2c.h"
 2022              		.file 11 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_gpio.h"
 2023              		.file 12 "Inc/mpu6050.h"
 2024              		.file 13 "Inc/setup.h"
ARM GAS  /tmp/ccpMgpO6.s 			page 52


 2025              		.file 14 "Inc/systick.h"
 2026              		.file 15 "<built-in>"
ARM GAS  /tmp/ccpMgpO6.s 			page 53


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccpMgpO6.s:16     .text.consoleLog:0000000000000000 $t
     /tmp/ccpMgpO6.s:24     .text.consoleLog:0000000000000000 consoleLog
     /tmp/ccpMgpO6.s:39     .text.toggle_led:0000000000000000 $t
     /tmp/ccpMgpO6.s:46     .text.toggle_led:0000000000000000 toggle_led
     /tmp/ccpMgpO6.s:65     .text.intro_demo_led:0000000000000000 $t
     /tmp/ccpMgpO6.s:72     .text.intro_demo_led:0000000000000000 intro_demo_led
     /tmp/ccpMgpO6.s:223    .text.intro_demo_led:00000000000000cc $d
     /tmp/ccpMgpO6.s:228    .text.switch_check:0000000000000000 $t
     /tmp/ccpMgpO6.s:235    .text.switch_check:0000000000000000 switch_check
     /tmp/ccpMgpO6.s:283    .text.input_init:0000000000000000 $t
     /tmp/ccpMgpO6.s:290    .text.input_init:0000000000000000 input_init
     /tmp/ccpMgpO6.s:362    .text.input_init:0000000000000044 $d
     /tmp/ccpMgpO6.s:371    .text.handle_mpu6050:0000000000000000 $t
     /tmp/ccpMgpO6.s:378    .text.handle_mpu6050:0000000000000000 handle_mpu6050
     /tmp/ccpMgpO6.s:429    .text.handle_mpu6050:000000000000002c $d
     /tmp/ccpMgpO6.s:435    .text.handle_sensors:0000000000000000 $t
     /tmp/ccpMgpO6.s:442    .text.handle_sensors:0000000000000000 handle_sensors
     /tmp/ccpMgpO6.s:600    .text.handle_sensors:000000000000007c $d
     /tmp/ccpMgpO6.s:610    .text.handle_usart:0000000000000000 $t
     /tmp/ccpMgpO6.s:617    .text.handle_usart:0000000000000000 handle_usart
     /tmp/ccpMgpO6.s:883    .text.handle_usart:0000000000000144 $d
     /tmp/ccpMgpO6.s:897    .text.handle_leds:0000000000000000 $t
     /tmp/ccpMgpO6.s:904    .text.handle_leds:0000000000000000 handle_leds
     /tmp/ccpMgpO6.s:1068   .text.handle_leds:0000000000000094 $d
     /tmp/ccpMgpO6.s:1075   .text.usart_process_data:0000000000000000 $t
     /tmp/ccpMgpO6.s:1082   .text.usart_process_data:0000000000000000 usart_process_data
     /tmp/ccpMgpO6.s:1164   .text.usart_process_data:0000000000000050 $d
     /tmp/ccpMgpO6.s:1170   .text.usart1_rx_check:0000000000000000 $t
     /tmp/ccpMgpO6.s:1177   .text.usart1_rx_check:0000000000000000 usart1_rx_check
     /tmp/ccpMgpO6.s:1295   .text.usart1_rx_check:0000000000000074 $d
     /tmp/ccpMgpO6.s:1303   .text.usart0_rx_check:0000000000000000 $t
     /tmp/ccpMgpO6.s:1310   .text.usart0_rx_check:0000000000000000 usart0_rx_check
     /tmp/ccpMgpO6.s:1323   .text.aux_print_to_console:0000000000000000 $t
     /tmp/ccpMgpO6.s:1330   .text.aux_print_to_console:0000000000000000 aux_print_to_console
     /tmp/ccpMgpO6.s:1341   .text.i2c_writeBytes:0000000000000000 $t
     /tmp/ccpMgpO6.s:1348   .text.i2c_writeBytes:0000000000000000 i2c_writeBytes
     /tmp/ccpMgpO6.s:1482   .text.i2c_writeBytes:000000000000006c $d
     /tmp/ccpMgpO6.s:1495   .text.i2c_writeByte:0000000000000000 $t
     /tmp/ccpMgpO6.s:1502   .text.i2c_writeByte:0000000000000000 i2c_writeByte
     /tmp/ccpMgpO6.s:1534   .text.i2c_readBytes:0000000000000000 $t
     /tmp/ccpMgpO6.s:1541   .text.i2c_readBytes:0000000000000000 i2c_readBytes
     /tmp/ccpMgpO6.s:1686   .text.i2c_readBytes:000000000000007c $d
     /tmp/ccpMgpO6.s:1699   .text.i2c_readByte:0000000000000000 $t
     /tmp/ccpMgpO6.s:1706   .text.i2c_readByte:0000000000000000 i2c_readByte
     /tmp/ccpMgpO6.s:1728   .text.i2c_writeBit:0000000000000000 $t
     /tmp/ccpMgpO6.s:1735   .text.i2c_writeBit:0000000000000000 i2c_writeBit
     /tmp/ccpMgpO6.s:1808   .text.i2c_readBit:0000000000000000 $t
     /tmp/ccpMgpO6.s:1815   .text.i2c_readBit:0000000000000000 i2c_readBit
     /tmp/ccpMgpO6.s:1896   .bss.buffer:0000000000000000 buffer
     /tmp/ccpMgpO6.s:1914   .bss.i2c_nRABytes:0000000000000000 i2c_nRABytes
     /tmp/ccpMgpO6.s:1908   .bss.i2c_nDABytes:0000000000000000 i2c_nDABytes
     /tmp/ccpMgpO6.s:1927   .bss.i2c_rxbuffer:0000000000000000 i2c_rxbuffer
     /tmp/ccpMgpO6.s:1946   .bss.i2c_txbuffer:0000000000000000 i2c_txbuffer
     /tmp/ccpMgpO6.s:1933   .bss.i2c_slaveAddress:0000000000000000 i2c_slaveAddress
     /tmp/ccpMgpO6.s:1920   .bss.i2c_regAddress:0000000000000000 i2c_regAddress
ARM GAS  /tmp/ccpMgpO6.s 			page 54


     /tmp/ccpMgpO6.s:1902   .bss.i2c_ReadWriteCmd:0000000000000000 i2c_ReadWriteCmd
     /tmp/ccpMgpO6.s:1939   .bss.i2c_status:0000000000000000 i2c_status
     /tmp/ccpMgpO6.s:1873   .bss.Feedback:0000000000000000 $d
     /tmp/ccpMgpO6.s:1877   .bss.Feedback:0000000000000000 Feedback
     /tmp/ccpMgpO6.s:1880   .bss.FeedbackRaw:0000000000000000 $d
     /tmp/ccpMgpO6.s:1884   .bss.FeedbackRaw:0000000000000000 FeedbackRaw
     /tmp/ccpMgpO6.s:1887   .bss.Sideboard:0000000000000000 $d
     /tmp/ccpMgpO6.s:1891   .bss.Sideboard:0000000000000000 Sideboard
     /tmp/ccpMgpO6.s:1897   .bss.buffer:0000000000000000 $d
     /tmp/ccpMgpO6.s:1903   .bss.i2c_ReadWriteCmd:0000000000000000 $d
     /tmp/ccpMgpO6.s:1909   .bss.i2c_nDABytes:0000000000000000 $d
     /tmp/ccpMgpO6.s:1915   .bss.i2c_nRABytes:0000000000000000 $d
     /tmp/ccpMgpO6.s:1921   .bss.i2c_regAddress:0000000000000000 $d
     /tmp/ccpMgpO6.s:1923   .bss.i2c_rxbuffer:0000000000000000 $d
     /tmp/ccpMgpO6.s:1934   .bss.i2c_slaveAddress:0000000000000000 $d
     /tmp/ccpMgpO6.s:1940   .bss.i2c_status:0000000000000000 $d
     /tmp/ccpMgpO6.s:1942   .bss.i2c_txbuffer:0000000000000000 $d
     /tmp/ccpMgpO6.s:1952   .bss.mpuStatus:0000000000000000 mpuStatus
     /tmp/ccpMgpO6.s:1953   .bss.mpuStatus:0000000000000000 $d
     /tmp/ccpMgpO6.s:1955   .bss.old_pos.0:0000000000000000 $d
     /tmp/ccpMgpO6.s:1959   .bss.old_pos.0:0000000000000000 old_pos.0
     /tmp/ccpMgpO6.s:1965   .bss.rx1_buffer:0000000000000000 rx1_buffer
     /tmp/ccpMgpO6.s:1966   .bss.rx1_buffer:0000000000000000 $d
     /tmp/ccpMgpO6.s:1971   .bss.sensor1:0000000000000000 sensor1
     /tmp/ccpMgpO6.s:1972   .bss.sensor1:0000000000000000 $d
     /tmp/ccpMgpO6.s:1977   .bss.sensor1_read:0000000000000000 sensor1_read
     /tmp/ccpMgpO6.s:1978   .bss.sensor1_read:0000000000000000 $d
     /tmp/ccpMgpO6.s:1983   .bss.sensor2:0000000000000000 sensor2
     /tmp/ccpMgpO6.s:1984   .bss.sensor2:0000000000000000 $d
     /tmp/ccpMgpO6.s:1989   .bss.sensor2_read:0000000000000000 sensor2_read
     /tmp/ccpMgpO6.s:1990   .bss.sensor2_read:0000000000000000 $d
     /tmp/ccpMgpO6.s:1992   .bss.sideboard_imu:0000000000000000 $d
     /tmp/ccpMgpO6.s:1996   .bss.sideboard_imu:0000000000000000 sideboard_imu
     /tmp/ccpMgpO6.s:1999   .bss.timeoutCntSerial1:0000000000000000 $d
     /tmp/ccpMgpO6.s:2003   .bss.timeoutCntSerial1:0000000000000000 timeoutCntSerial1
     /tmp/ccpMgpO6.s:2009   .bss.timeoutFlagSerial1:0000000000000000 timeoutFlagSerial1
     /tmp/ccpMgpO6.s:2010   .bss.timeoutFlagSerial1:0000000000000000 $d

UNDEFINED SYMBOLS
gpio_bit_set
gpio_bit_reset
delay_1ms
usart_Tx_DMA_config
usart_Rx_DMA_config
mpu_config
mpu_get_data
main_loop_counter
gpio_input_bit_get
dma_transfer_number_get
dma_channel_disable
dma_channel_enable
mpu
memcpy
i2c_interrupt_enable
i2c_flag_get
i2c_start_on_bus
i2c_ackpos_config
ARM GAS  /tmp/ccpMgpO6.s 			page 55


