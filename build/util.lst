ARM GAS  /tmp/cc9tOEVd.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.consoleLog,"ax",%progbits
  16              		.align	1
  17              		.global	consoleLog
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	consoleLog:
  25              	.LVL0:
  26              	.LFB59:
  27              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-sideboard-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <string.h>
  23:Src/util.c    **** #include "systick.h"
  24:Src/util.c    **** #include "gd32f1x0.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "config.h"
  27:Src/util.c    **** #include "setup.h"
  28:Src/util.c    **** #include "util.h"
  29:Src/util.c    **** #include "mpu6050.h"
  30:Src/util.c    **** 
  31:Src/util.c    **** // USART1 variables
ARM GAS  /tmp/cc9tOEVd.s 			page 2


  32:Src/util.c    **** #ifdef SERIAL_CONTROL
  33:Src/util.c    **** //static SerialSideboard Sideboard;
  34:Src/util.c    **** static SideboardImuRaw sideboard_imu;
  35:Src/util.c    **** #endif
  36:Src/util.c    **** 
  37:Src/util.c    **** #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
  38:Src/util.c    **** static uint8_t  rx1_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  39:Src/util.c    **** static uint32_t rx1_buffer_len = ARRAY_LEN(rx1_buffer);
  40:Src/util.c    **** #endif
  41:Src/util.c    **** 
  42:Src/util.c    **** #ifdef SERIAL_FEEDBACK
  43:Src/util.c    **** static SerialFeedback Feedback;
  44:Src/util.c    **** static SerialFeedback FeedbackRaw;
  45:Src/util.c    **** static uint16_t timeoutCntSerial1  = 0;         // Timeout counter for UART1 Rx Serial
  46:Src/util.c    **** static uint8_t  timeoutFlagSerial1 = 0;         // Timeout Flag for UART1 Rx Serial: 0 = OK, 1 = Pr
  47:Src/util.c    **** static uint32_t Feedback_len  = sizeof(Feedback);
  48:Src/util.c    **** #endif
  49:Src/util.c    **** 
  50:Src/util.c    **** // USART0 variables
  51:Src/util.c    **** #ifdef SERIAL_AUX_TX
  52:Src/util.c    **** static SerialAuxTx AuxTx;
  53:Src/util.c    **** #endif
  54:Src/util.c    **** 
  55:Src/util.c    **** #ifdef SERIAL_AUX_RX
  56:Src/util.c    **** static uint8_t  rx0_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  57:Src/util.c    **** static uint32_t rx0_buffer_len = ARRAY_LEN(rx0_buffer);
  58:Src/util.c    **** #endif
  59:Src/util.c    **** 
  60:Src/util.c    **** #ifdef SERIAL_AUX_RX
  61:Src/util.c    **** static SerialCommand command;
  62:Src/util.c    **** static SerialCommand command_raw;
  63:Src/util.c    **** static uint16_t timeoutCntSerial0  = 0;         // Timeout counter for UART0 Rx Serial
  64:Src/util.c    **** static uint8_t  timeoutFlagSerial0 = 0;         // Timeout Flag for UART0 Rx Serial: 0 = OK, 1 = Pr
  65:Src/util.c    **** static uint32_t command_len = sizeof(command);
  66:Src/util.c    **** extern uint8_t  print_aux;
  67:Src/util.c    ****   #ifdef CONTROL_IBUS
  68:Src/util.c    ****   static uint16_t ibus_chksum;
  69:Src/util.c    ****   static uint16_t ibus_captured_value[IBUS_NUM_CHANNELS];
  70:Src/util.c    ****   #endif
  71:Src/util.c    **** #endif
  72:Src/util.c    **** 
  73:Src/util.c    **** #if (defined(SERIAL_AUX_RX) && defined(CONTROL_IBUS)) || defined(SERIAL_CONTROL)
  74:Src/util.c    **** static int16_t  cmd1, cmd2;
  75:Src/util.c    **** static uint16_t cmdSwitch;
  76:Src/util.c    **** #endif
  77:Src/util.c    **** 
  78:Src/util.c    **** // Optical sensors variables
  79:Src/util.c    **** static FlagStatus   sensor1, sensor2;           // holds the sensor1 and sensor 2 values
  80:Src/util.c    **** static FlagStatus   sensor1_read, sensor2_read; // holds the instantaneous Read for sensor1 and sen
  81:Src/util.c    **** 
  82:Src/util.c    **** // MPU variables
  83:Src/util.c    **** extern MPU_Data     mpu;                        // holds the MPU-6050 data
  84:Src/util.c    **** #if defined(MPU_SENSOR_ENABLE) || defined(SERIAL_CONTROL)
  85:Src/util.c    **** static ErrStatus    mpuStatus;                  // holds the MPU-6050 status: SUCCESS or ERROR
  86:Src/util.c    **** #endif
  87:Src/util.c    **** 
  88:Src/util.c    **** extern uint32_t     main_loop_counter;          // main loop counter to perform task scheduling ins
ARM GAS  /tmp/cc9tOEVd.s 			page 3


  89:Src/util.c    **** 
  90:Src/util.c    **** // MAIN I2C variables
  91:Src/util.c    **** volatile int8_t     i2c_status;
  92:Src/util.c    **** volatile i2c_cmd    i2c_ReadWriteCmd;
  93:Src/util.c    **** volatile uint8_t    i2c_regAddress;
  94:Src/util.c    **** volatile uint8_t    i2c_slaveAddress;
  95:Src/util.c    **** volatile uint8_t*   i2c_txbuffer;
  96:Src/util.c    **** volatile uint8_t*   i2c_rxbuffer;
  97:Src/util.c    **** volatile uint8_t    i2c_nDABytes;
  98:Src/util.c    **** volatile  int8_t    i2c_nRABytes;
  99:Src/util.c    **** volatile uint8_t    buffer[14];
 100:Src/util.c    **** 
 101:Src/util.c    **** #ifdef AUX45_USE_I2C
 102:Src/util.c    **** // AUX I2C variables
 103:Src/util.c    **** volatile int8_t     i2c_aux_status;
 104:Src/util.c    **** volatile i2c_cmd    i2c_aux_ReadWriteCmd;
 105:Src/util.c    **** volatile uint8_t    i2c_aux_regAddress;
 106:Src/util.c    **** volatile uint8_t    i2c_aux_slaveAddress;
 107:Src/util.c    **** volatile uint8_t*   i2c_aux_txbuffer;
 108:Src/util.c    **** volatile uint8_t*   i2c_aux_rxbuffer;
 109:Src/util.c    **** volatile uint8_t    i2c_aux_nDABytes;
 110:Src/util.c    **** volatile  int8_t    i2c_aux_nRABytes;
 111:Src/util.c    **** #endif
 112:Src/util.c    **** 
 113:Src/util.c    **** 
 114:Src/util.c    **** 
 115:Src/util.c    **** /* =========================== General Functions =========================== */
 116:Src/util.c    **** 
 117:Src/util.c    **** void consoleLog(char *message)
 118:Src/util.c    **** {
  28              		.loc 1 118 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
 119:Src/util.c    ****   #ifdef SERIAL_DEBUG
 120:Src/util.c    ****     log_i("%s", message);
 121:Src/util.c    ****   #endif
 122:Src/util.c    **** }
  33              		.loc 1 122 1 view .LVU1
  34 0000 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE59:
  38              		.section	.text.toggle_led,"ax",%progbits
  39              		.align	1
  40              		.global	toggle_led
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	toggle_led:
  47              	.LVL1:
  48              	.LFB60:
 123:Src/util.c    **** 
 124:Src/util.c    **** 
 125:Src/util.c    **** /* retarget the C library printf function to the USART */
 126:Src/util.c    **** #ifdef SERIAL_DEBUG	
ARM GAS  /tmp/cc9tOEVd.s 			page 4


 127:Src/util.c    ****     #ifdef __GNUC__
 128:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 129:Src/util.c    ****     #else
 130:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 131:Src/util.c    ****     #endif
 132:Src/util.c    ****     PUTCHAR_PROTOTYPE {
 133:Src/util.c    ****         usart_data_transmit(USART_MAIN, (uint8_t)ch);
 134:Src/util.c    ****         while(RESET == usart_flag_get(USART_MAIN, USART_FLAG_TBE));
 135:Src/util.c    ****         return ch;
 136:Src/util.c    ****     }
 137:Src/util.c    ****     
 138:Src/util.c    ****     #ifdef __GNUC__
 139:Src/util.c    ****         int _write(int file, char *data, int len) {
 140:Src/util.c    ****             int i;
 141:Src/util.c    ****             for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 142:Src/util.c    ****             return len; 
 143:Src/util.c    ****         }
 144:Src/util.c    ****     #endif
 145:Src/util.c    **** #endif
 146:Src/util.c    **** 
 147:Src/util.c    **** 
 148:Src/util.c    **** void toggle_led(uint32_t gpio_periph, uint32_t pin)
 149:Src/util.c    **** {
  49              		.loc 1 149 1 view -0
  50              		.cfi_startproc
  51              		@ args = 0, pretend = 0, frame = 0
  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
 150:Src/util.c    ****     GPIO_OCTL(gpio_periph) ^= pin;
  54              		.loc 1 150 5 view .LVU3
  55              		.loc 1 150 28 is_stmt 0 view .LVU4
  56 0000 4369     		ldr	r3, [r0, #20]
  57 0002 4B40     		eors	r3, r3, r1
  58 0004 4361     		str	r3, [r0, #20]
 151:Src/util.c    **** }
  59              		.loc 1 151 1 view .LVU5
  60 0006 7047     		bx	lr
  61              		.cfi_endproc
  62              	.LFE60:
  64              		.section	.text.intro_demo_led,"ax",%progbits
  65              		.align	1
  66              		.global	intro_demo_led
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu softvfp
  72              	intro_demo_led:
  73              	.LVL2:
  74              	.LFB61:
 152:Src/util.c    **** 
 153:Src/util.c    **** 
 154:Src/util.c    **** void intro_demo_led(uint32_t tDelay)
 155:Src/util.c    **** {
  75              		.loc 1 155 1 is_stmt 1 view -0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc9tOEVd.s 			page 5


 156:Src/util.c    ****     int i;
  79              		.loc 1 156 5 view .LVU7
 157:Src/util.c    **** 
 158:Src/util.c    ****     for (i = 0; i < 3; i++) {
  80              		.loc 1 158 5 view .LVU8
  81              		.loc 1 158 17 view .LVU9
 155:Src/util.c    ****     int i;
  82              		.loc 1 155 1 is_stmt 0 view .LVU10
  83 0000 70B5     		push	{r4, r5, r6, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 16
  86              		.cfi_offset 4, -16
  87              		.cfi_offset 5, -12
  88              		.cfi_offset 6, -8
  89              		.cfi_offset 14, -4
 155:Src/util.c    ****     int i;
  90              		.loc 1 155 1 view .LVU11
  91 0002 0546     		mov	r5, r0
  92 0004 0326     		movs	r6, #3
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 160:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
  93              		.loc 1 160 9 view .LVU12
  94 0006 314C     		ldr	r4, .L8
  95              	.LVL3:
  96              	.L4:
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
  97              		.loc 1 159 9 is_stmt 1 discriminator 3 view .LVU13
  98 0008 0121     		movs	r1, #1
  99 000a 4FF09040 		mov	r0, #1207959552
 100 000e FFF7FEFF 		bl	gpio_bit_set
 101              	.LVL4:
 102              		.loc 1 160 9 discriminator 3 view .LVU14
 103 0012 4FF48071 		mov	r1, #256
 104 0016 2046     		mov	r0, r4
 105 0018 FFF7FEFF 		bl	gpio_bit_reset
 106              	.LVL5:
 161:Src/util.c    ****         delay_1ms(tDelay);
 107              		.loc 1 161 9 discriminator 3 view .LVU15
 108 001c 2846     		mov	r0, r5
 109 001e FFF7FEFF 		bl	delay_1ms
 110              	.LVL6:
 162:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 111              		.loc 1 162 9 discriminator 3 view .LVU16
 112 0022 4FF40071 		mov	r1, #512
 113 0026 2046     		mov	r0, r4
 114 0028 FFF7FEFF 		bl	gpio_bit_set
 115              	.LVL7:
 163:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 116              		.loc 1 163 9 discriminator 3 view .LVU17
 117 002c 0121     		movs	r1, #1
 118 002e 4FF09040 		mov	r0, #1207959552
 119 0032 FFF7FEFF 		bl	gpio_bit_reset
 120              	.LVL8:
 164:Src/util.c    ****         delay_1ms(tDelay);
 121              		.loc 1 164 9 discriminator 3 view .LVU18
 122 0036 2846     		mov	r0, r5
 123 0038 FFF7FEFF 		bl	delay_1ms
ARM GAS  /tmp/cc9tOEVd.s 			page 6


 124              	.LVL9:
 165:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 125              		.loc 1 165 9 discriminator 3 view .LVU19
 126 003c 4FF48071 		mov	r1, #256
 127 0040 2046     		mov	r0, r4
 128 0042 FFF7FEFF 		bl	gpio_bit_set
 129              	.LVL10:
 166:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 130              		.loc 1 166 9 discriminator 3 view .LVU20
 131 0046 4FF40071 		mov	r1, #512
 132 004a 2046     		mov	r0, r4
 133 004c FFF7FEFF 		bl	gpio_bit_reset
 134              	.LVL11:
 167:Src/util.c    ****         delay_1ms(tDelay);
 135              		.loc 1 167 9 discriminator 3 view .LVU21
 136 0050 2846     		mov	r0, r5
 137 0052 FFF7FEFF 		bl	delay_1ms
 138              	.LVL12:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 139              		.loc 1 158 24 discriminator 3 view .LVU22
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 140              		.loc 1 158 17 discriminator 3 view .LVU23
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 141              		.loc 1 158 5 is_stmt 0 discriminator 3 view .LVU24
 142 0056 013E     		subs	r6, r6, #1
 143              	.LVL13:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 144              		.loc 1 158 5 discriminator 3 view .LVU25
 145 0058 D6D1     		bne	.L4
 146 005a 0226     		movs	r6, #2
 147              	.LVL14:
 168:Src/util.c    ****     }
 169:Src/util.c    **** 
 170:Src/util.c    ****     for (i = 0; i < 2; i++) {
 171:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 172:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 148              		.loc 1 172 9 view .LVU26
 149 005c 1B4C     		ldr	r4, .L8
 150              	.L5:
 151              	.LVL15:
 171:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 152              		.loc 1 171 9 is_stmt 1 discriminator 3 view .LVU27
 153 005e 0121     		movs	r1, #1
 154 0060 4FF09040 		mov	r0, #1207959552
 155 0064 FFF7FEFF 		bl	gpio_bit_set
 156              	.LVL16:
 157              		.loc 1 172 9 discriminator 3 view .LVU28
 158 0068 4FF40071 		mov	r1, #512
 159 006c 2046     		mov	r0, r4
 160 006e FFF7FEFF 		bl	gpio_bit_set
 161              	.LVL17:
 173:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 162              		.loc 1 173 9 discriminator 3 view .LVU29
 163 0072 4FF48071 		mov	r1, #256
 164 0076 2046     		mov	r0, r4
 165 0078 FFF7FEFF 		bl	gpio_bit_set
 166              	.LVL18:
ARM GAS  /tmp/cc9tOEVd.s 			page 7


 174:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 167              		.loc 1 174 9 discriminator 3 view .LVU30
 168 007c 2021     		movs	r1, #32
 169 007e 2046     		mov	r0, r4
 170 0080 FFF7FEFF 		bl	gpio_bit_set
 171              	.LVL19:
 175:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 172              		.loc 1 175 9 discriminator 3 view .LVU31
 173 0084 1021     		movs	r1, #16
 174 0086 2046     		mov	r0, r4
 175 0088 FFF7FEFF 		bl	gpio_bit_set
 176              	.LVL20:
 176:Src/util.c    ****         delay_1ms(tDelay);
 177              		.loc 1 176 9 discriminator 3 view .LVU32
 178 008c 2846     		mov	r0, r5
 179 008e FFF7FEFF 		bl	delay_1ms
 180              	.LVL21:
 177:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 181              		.loc 1 177 9 discriminator 3 view .LVU33
 182 0092 0121     		movs	r1, #1
 183 0094 4FF09040 		mov	r0, #1207959552
 184 0098 FFF7FEFF 		bl	gpio_bit_reset
 185              	.LVL22:
 178:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 186              		.loc 1 178 9 discriminator 3 view .LVU34
 187 009c 4FF40071 		mov	r1, #512
 188 00a0 2046     		mov	r0, r4
 189 00a2 FFF7FEFF 		bl	gpio_bit_reset
 190              	.LVL23:
 179:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
 191              		.loc 1 179 9 discriminator 3 view .LVU35
 192 00a6 4FF48071 		mov	r1, #256
 193 00aa 2046     		mov	r0, r4
 194 00ac FFF7FEFF 		bl	gpio_bit_reset
 195              	.LVL24:
 180:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 196              		.loc 1 180 9 discriminator 3 view .LVU36
 197 00b0 2021     		movs	r1, #32
 198 00b2 2046     		mov	r0, r4
 199 00b4 FFF7FEFF 		bl	gpio_bit_reset
 200              	.LVL25:
 181:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 201              		.loc 1 181 9 discriminator 3 view .LVU37
 202 00b8 1021     		movs	r1, #16
 203 00ba 2046     		mov	r0, r4
 204 00bc FFF7FEFF 		bl	gpio_bit_reset
 205              	.LVL26:
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 206              		.loc 1 170 24 discriminator 3 view .LVU38
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 207              		.loc 1 170 17 discriminator 3 view .LVU39
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 208              		.loc 1 170 5 is_stmt 0 discriminator 3 view .LVU40
 209 00c0 012E     		cmp	r6, #1
 210 00c2 00D1     		bne	.L6
 182:Src/util.c    ****     }
 183:Src/util.c    **** }
ARM GAS  /tmp/cc9tOEVd.s 			page 8


 211              		.loc 1 183 1 view .LVU41
 212 00c4 70BD     		pop	{r4, r5, r6, pc}
 213              	.LVL27:
 214              	.L6:
 215              		.loc 1 183 1 view .LVU42
 216 00c6 0126     		movs	r6, #1
 217              	.LVL28:
 218              		.loc 1 183 1 view .LVU43
 219 00c8 C9E7     		b	.L5
 220              	.L9:
 221 00ca 00BF     		.align	2
 222              	.L8:
 223 00cc 00040048 		.word	1207960576
 224              		.cfi_endproc
 225              	.LFE61:
 227              		.section	.text.switch_check,"ax",%progbits
 228              		.align	1
 229              		.global	switch_check
 230              		.syntax unified
 231              		.thumb
 232              		.thumb_func
 233              		.fpu softvfp
 235              	switch_check:
 236              	.LVL29:
 237              	.LFB62:
 184:Src/util.c    **** 
 185:Src/util.c    **** 
 186:Src/util.c    **** uint8_t switch_check(uint16_t ch, uint8_t type) {
 238              		.loc 1 186 49 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 187:Src/util.c    ****     if (type) { // 3 positions switch
 243              		.loc 1 187 5 view .LVU45
 244              		.loc 1 187 8 is_stmt 0 view .LVU46
 245 0000 41B1     		cbz	r1, .L11
 188:Src/util.c    ****         if      (ch < 250) return 0;    // switch in position 0
 246              		.loc 1 188 9 is_stmt 1 view .LVU47
 247              		.loc 1 188 17 is_stmt 0 view .LVU48
 248 0002 F928     		cmp	r0, #249
 249 0004 0DD9     		bls	.L13
 189:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 250              		.loc 1 189 14 is_stmt 1 view .LVU49
 190:Src/util.c    ****         else               return 2;    // switch in position 2
 251              		.loc 1 190 35 is_stmt 0 view .LVU50
 252 0006 40F25133 		movw	r3, #849
 253 000a 9842     		cmp	r0, r3
 254 000c 94BF     		ite	ls
 255 000e 0120     		movls	r0, #1
 256 0010 0220     		movhi	r0, #2
 257              	.LVL30:
 258              		.loc 1 190 35 view .LVU51
 259 0012 7047     		bx	lr
 260              	.LVL31:
 261              	.L11:
 191:Src/util.c    ****     } else {    // 2 positions switch
ARM GAS  /tmp/cc9tOEVd.s 			page 9


 192:Src/util.c    ****         return  (ch > 850);
 262              		.loc 1 192 9 is_stmt 1 view .LVU52
 263              		.loc 1 192 21 is_stmt 0 view .LVU53
 264 0014 40F25233 		movw	r3, #850
 265 0018 9842     		cmp	r0, r3
 266 001a 94BF     		ite	ls
 267 001c 0020     		movls	r0, #0
 268              	.LVL32:
 269              		.loc 1 192 21 view .LVU54
 270 001e 0120     		movhi	r0, #1
 271 0020 7047     		bx	lr
 272              	.LVL33:
 273              	.L13:
 188:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 274              		.loc 1 188 35 view .LVU55
 275 0022 0020     		movs	r0, #0
 276              	.LVL34:
 193:Src/util.c    ****     }
 194:Src/util.c    **** }
 277              		.loc 1 194 1 view .LVU56
 278 0024 7047     		bx	lr
 279              		.cfi_endproc
 280              	.LFE62:
 282              		.section	.text.input_init,"ax",%progbits
 283              		.align	1
 284              		.global	input_init
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 288              		.fpu softvfp
 290              	input_init:
 291              	.LFB63:
 195:Src/util.c    **** 
 196:Src/util.c    **** 
 197:Src/util.c    **** /* =========================== Input Initialization Function =========================== */
 198:Src/util.c    **** 
 199:Src/util.c    **** void input_init(void) {
 292              		.loc 1 199 23 is_stmt 1 view -0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 200:Src/util.c    ****     #ifdef SERIAL_CONTROL
 201:Src/util.c    ****         usart_Tx_DMA_config(USART_MAIN, (uint8_t *)&sideboard_imu, sizeof(sideboard_imu));
 296              		.loc 1 201 9 view .LVU58
 199:Src/util.c    ****     #ifdef SERIAL_CONTROL
 297              		.loc 1 199 23 is_stmt 0 view .LVU59
 298 0000 08B5     		push	{r3, lr}
 299              	.LCFI1:
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 3, -8
 302              		.cfi_offset 14, -4
 303              		.loc 1 201 9 view .LVU60
 304 0002 2A22     		movs	r2, #42
 305 0004 0E49     		ldr	r1, .L18
 306 0006 0F48     		ldr	r0, .L18+4
 307 0008 FFF7FEFF 		bl	usart_Tx_DMA_config
 308              	.LVL35:
ARM GAS  /tmp/cc9tOEVd.s 			page 10


 202:Src/util.c    ****     #endif
 203:Src/util.c    ****     #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
 204:Src/util.c    ****         usart_Rx_DMA_config(USART_MAIN, (uint8_t *)rx1_buffer, sizeof(rx1_buffer));
 309              		.loc 1 204 9 is_stmt 1 view .LVU61
 310 000c 4FF48072 		mov	r2, #256
 311 0010 0D49     		ldr	r1, .L18+8
 312 0012 0C48     		ldr	r0, .L18+4
 313 0014 FFF7FEFF 		bl	usart_Rx_DMA_config
 314              	.LVL36:
 205:Src/util.c    ****     #endif
 206:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 207:Src/util.c    ****         usart_Tx_DMA_config(USART_AUX, (uint8_t *)&AuxTx, sizeof(AuxTx));
 208:Src/util.c    ****     #endif
 209:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 210:Src/util.c    ****         usart_Rx_DMA_config(USART_AUX, (uint8_t *)rx0_buffer, sizeof(rx0_buffer));
 211:Src/util.c    ****     #endif
 212:Src/util.c    **** 
 213:Src/util.c    ****     //intro_demo_led(100);                                // Short LEDs intro demo with 100 ms dela
 214:Src/util.c    **** 
 215:Src/util.c    ****     #ifdef MPU_SENSOR_ENABLE
 216:Src/util.c    ****         if(mpu_config()) {                              // IMU MPU-6050 config
 315              		.loc 1 216 9 view .LVU62
 316              		.loc 1 216 12 is_stmt 0 view .LVU63
 317 0018 FFF7FEFF 		bl	mpu_config
 318              	.LVL37:
 319 001c 0B4B     		ldr	r3, .L18+12
 320              		.loc 1 216 11 view .LVU64
 321 001e 40B1     		cbz	r0, .L16
 217:Src/util.c    ****             mpuStatus = ERROR;
 322              		.loc 1 217 13 is_stmt 1 view .LVU65
 323              		.loc 1 217 23 is_stmt 0 view .LVU66
 324 0020 0022     		movs	r2, #0
 218:Src/util.c    ****             gpio_bit_set(LED1_GPIO_Port, LED1_Pin);     // Turn on RED LED - sensor enabled and NOT
 325              		.loc 1 218 13 view .LVU67
 326 0022 0121     		movs	r1, #1
 327 0024 4FF09040 		mov	r0, #1207959552
 217:Src/util.c    ****             mpuStatus = ERROR;
 328              		.loc 1 217 23 view .LVU68
 329 0028 1A70     		strb	r2, [r3]
 330              		.loc 1 218 13 is_stmt 1 view .LVU69
 331              	.L17:
 219:Src/util.c    ****         }
 220:Src/util.c    ****         else {
 221:Src/util.c    ****             mpuStatus = SUCCESS;
 222:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 223:Src/util.c    ****         }
 224:Src/util.c    ****     #else
 225:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);         // Turn on GREEN LED - sensor disabled
 226:Src/util.c    ****     #endif
 227:Src/util.c    **** 
 228:Src/util.c    ****     #ifdef SERIAL_DEBUG
 229:Src/util.c    ****         mpu_handle_input('h');                          // Print the User Help commands to serial
 230:Src/util.c    ****     #endif
 231:Src/util.c    **** }
 332              		.loc 1 231 1 is_stmt 0 view .LVU70
 333 002a BDE80840 		pop	{r3, lr}
 334              	.LCFI2:
ARM GAS  /tmp/cc9tOEVd.s 			page 11


 335              		.cfi_remember_state
 336              		.cfi_restore 14
 337              		.cfi_restore 3
 338              		.cfi_def_cfa_offset 0
 222:Src/util.c    ****         }
 339              		.loc 1 222 13 view .LVU71
 340 002e FFF7FEBF 		b	gpio_bit_set
 341              	.LVL38:
 342              	.L16:
 343              	.LCFI3:
 344              		.cfi_restore_state
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 345              		.loc 1 221 13 is_stmt 1 view .LVU72
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 346              		.loc 1 221 23 is_stmt 0 view .LVU73
 347 0032 0122     		movs	r2, #1
 222:Src/util.c    ****         }
 348              		.loc 1 222 13 view .LVU74
 349 0034 4FF40071 		mov	r1, #512
 350 0038 0548     		ldr	r0, .L18+16
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 351              		.loc 1 221 23 view .LVU75
 352 003a 1A70     		strb	r2, [r3]
 222:Src/util.c    ****         }
 353              		.loc 1 222 13 is_stmt 1 view .LVU76
 354 003c F5E7     		b	.L17
 355              	.L19:
 356 003e 00BF     		.align	2
 357              	.L18:
 358 0040 00000000 		.word	.LANCHOR0
 359 0044 00440040 		.word	1073759232
 360 0048 00000000 		.word	.LANCHOR1
 361 004c 00000000 		.word	.LANCHOR2
 362 0050 00040048 		.word	1207960576
 363              		.cfi_endproc
 364              	.LFE63:
 366              		.section	.text.handle_mpu6050,"ax",%progbits
 367              		.align	1
 368              		.global	handle_mpu6050
 369              		.syntax unified
 370              		.thumb
 371              		.thumb_func
 372              		.fpu softvfp
 374              	handle_mpu6050:
 375              	.LFB64:
 232:Src/util.c    **** 
 233:Src/util.c    **** 
 234:Src/util.c    **** /* =========================== Handle Functions =========================== */
 235:Src/util.c    **** 
 236:Src/util.c    **** /*
 237:Src/util.c    ****  * Handle of the MPU-6050 IMU sensor
 238:Src/util.c    ****  */
 239:Src/util.c    **** void handle_mpu6050(void) {
 376              		.loc 1 239 27 view -0
 377              		.cfi_startproc
 378              		@ args = 0, pretend = 0, frame = 0
 379              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc9tOEVd.s 			page 12


 380              		@ link register save eliminated.
 240:Src/util.c    **** #ifdef MPU_SENSOR_ENABLE
 241:Src/util.c    ****     // Get MPU data. Because the MPU-6050 interrupt pin is not wired we have to check DMP data by p
 242:Src/util.c    ****     if (SUCCESS == mpuStatus) {
 381              		.loc 1 242 5 view .LVU78
 382              		.loc 1 242 17 is_stmt 0 view .LVU79
 383 0000 0A4B     		ldr	r3, .L23
 384 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 385              		.loc 1 242 8 view .LVU80
 386 0004 012B     		cmp	r3, #1
 387 0006 01D1     		bne	.L21
 243:Src/util.c    ****         mpu_get_data();
 388              		.loc 1 243 9 is_stmt 1 view .LVU81
 389 0008 FFF7FEBF 		b	mpu_get_data
 390              	.LVL39:
 391              	.L21:
 244:Src/util.c    ****     } else if (ERROR == mpuStatus && main_loop_counter % 100 == 0) {
 392              		.loc 1 244 12 view .LVU82
 393              		.loc 1 244 15 is_stmt 0 view .LVU83
 394 000c 6BB9     		cbnz	r3, .L20
 395 000e 6422     		movs	r2, #100
 396              		.loc 1 244 56 discriminator 1 view .LVU84
 397 0010 074B     		ldr	r3, .L23+4
 398 0012 1B68     		ldr	r3, [r3]
 399 0014 B3FBF2F1 		udiv	r1, r3, r2
 400 0018 02FB1133 		mls	r3, r2, r1, r3
 401              		.loc 1 244 35 discriminator 1 view .LVU85
 402 001c 2BB9     		cbnz	r3, .L20
 245:Src/util.c    ****         toggle_led(LED1_GPIO_Port, LED1_Pin);                    // Toggle the Red LED every 100 ms
 403              		.loc 1 245 9 is_stmt 1 view .LVU86
 404              	.LVL40:
 405              	.LBB14:
 406              	.LBI14:
 148:Src/util.c    **** {
 407              		.loc 1 148 6 view .LVU87
 408              	.LBB15:
 150:Src/util.c    **** }
 409              		.loc 1 150 5 view .LVU88
 150:Src/util.c    **** }
 410              		.loc 1 150 28 is_stmt 0 view .LVU89
 411 001e 4FF09042 		mov	r2, #1207959552
 412 0022 5369     		ldr	r3, [r2, #20]
 413 0024 83F00103 		eor	r3, r3, #1
 414 0028 5361     		str	r3, [r2, #20]
 415              	.LVL41:
 416              	.L20:
 150:Src/util.c    **** }
 417              		.loc 1 150 28 view .LVU90
 418              	.LBE15:
 419              	.LBE14:
 246:Src/util.c    ****     }
 247:Src/util.c    ****     // Print MPU data to Console
 248:Src/util.c    ****     #ifdef SERIAL_DEBUG
 249:Src/util.c    ****     if (main_loop_counter % 50 == 0) {
 250:Src/util.c    ****         mpu_print_to_console();
 251:Src/util.c    ****     }
 252:Src/util.c    ****     #endif
ARM GAS  /tmp/cc9tOEVd.s 			page 13


 253:Src/util.c    **** #endif
 254:Src/util.c    **** }
 420              		.loc 1 254 1 view .LVU91
 421 002a 7047     		bx	lr
 422              	.L24:
 423              		.align	2
 424              	.L23:
 425 002c 00000000 		.word	.LANCHOR2
 426 0030 00000000 		.word	main_loop_counter
 427              		.cfi_endproc
 428              	.LFE64:
 430              		.section	.text.handle_sensors,"ax",%progbits
 431              		.align	1
 432              		.global	handle_sensors
 433              		.syntax unified
 434              		.thumb
 435              		.thumb_func
 436              		.fpu softvfp
 438              	handle_sensors:
 439              	.LFB65:
 255:Src/util.c    **** 
 256:Src/util.c    **** /*
 257:Src/util.c    ****  * Handle of the optical sensors
 258:Src/util.c    ****  */
 259:Src/util.c    **** void handle_sensors(void) {
 440              		.loc 1 259 27 is_stmt 1 view -0
 441              		.cfi_startproc
 442              		@ args = 0, pretend = 0, frame = 0
 443              		@ frame_needed = 0, uses_anonymous_args = 0
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 444              		.loc 1 260 5 view .LVU93
 259:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 445              		.loc 1 259 27 is_stmt 0 view .LVU94
 446 0000 38B5     		push	{r3, r4, r5, lr}
 447              	.LCFI4:
 448              		.cfi_def_cfa_offset 16
 449              		.cfi_offset 3, -16
 450              		.cfi_offset 4, -12
 451              		.cfi_offset 5, -8
 452              		.cfi_offset 14, -4
 453              		.loc 1 260 20 view .LVU95
 454 0002 1021     		movs	r1, #16
 455 0004 4FF09040 		mov	r0, #1207959552
 456 0008 FFF7FEFF 		bl	gpio_input_bit_get
 457              	.LVL42:
 458              		.loc 1 260 18 view .LVU96
 459 000c 1B4D     		ldr	r5, .L30
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 460              		.loc 1 261 20 view .LVU97
 461 000e 4FF48041 		mov	r1, #16384
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 462              		.loc 1 260 18 view .LVU98
 463 0012 2870     		strb	r0, [r5]
 464              		.loc 1 261 5 is_stmt 1 view .LVU99
 465              		.loc 1 261 20 is_stmt 0 view .LVU100
 466 0014 1A48     		ldr	r0, .L30+4
 467 0016 FFF7FEFF 		bl	gpio_input_bit_get
ARM GAS  /tmp/cc9tOEVd.s 			page 14


 468              	.LVL43:
 262:Src/util.c    **** 
 263:Src/util.c    ****     // SENSOR1
 264:Src/util.c    ****     if (sensor1 == RESET && sensor1_read == SET) {
 469              		.loc 1 264 17 view .LVU101
 470 001a 1A4B     		ldr	r3, .L30+8
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 471              		.loc 1 261 18 view .LVU102
 472 001c 1A4C     		ldr	r4, .L30+12
 473              		.loc 1 264 17 view .LVU103
 474 001e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 475              		.loc 1 261 18 view .LVU104
 476 0020 2070     		strb	r0, [r4]
 477              		.loc 1 264 5 is_stmt 1 view .LVU105
 478              		.loc 1 264 8 is_stmt 0 view .LVU106
 479 0022 A2B9     		cbnz	r2, .L26
 480              		.loc 1 264 26 discriminator 1 view .LVU107
 481 0024 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 482 0026 012A     		cmp	r2, #1
 483 0028 04D1     		bne	.L27
 265:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 266:Src/util.c    ****         sensor1 = SET;
 484              		.loc 1 266 9 is_stmt 1 view .LVU108
 267:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 485              		.loc 1 267 9 is_stmt 0 view .LVU109
 486 002a 2021     		movs	r1, #32
 487 002c 1748     		ldr	r0, .L30+16
 266:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 488              		.loc 1 266 17 view .LVU110
 489 002e 1A70     		strb	r2, [r3]
 490              		.loc 1 267 9 is_stmt 1 view .LVU111
 491 0030 FFF7FEFF 		bl	gpio_bit_set
 492              	.LVL44:
 268:Src/util.c    ****         consoleLog("SENSOR 1 ON\r\n");
 493              		.loc 1 268 9 view .LVU112
 494              	.LBB16:
 495              	.LBI16:
 117:Src/util.c    **** {
 496              		.loc 1 117 6 view .LVU113
 497              	.LBB17:
 122:Src/util.c    **** 
 498              		.loc 1 122 1 view .LVU114
 499              	.L27:
 122:Src/util.c    **** 
 500              		.loc 1 122 1 is_stmt 0 view .LVU115
 501              	.LBE17:
 502              	.LBE16:
 269:Src/util.c    ****     } else if(sensor1 == SET && sensor1_read == RESET) {
 270:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 271:Src/util.c    ****         sensor1 = RESET;
 272:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 273:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 274:Src/util.c    ****     }
 275:Src/util.c    **** 
 276:Src/util.c    ****     // SENSOR2
 277:Src/util.c    ****     if (sensor2 == RESET && sensor2_read == SET) {
ARM GAS  /tmp/cc9tOEVd.s 			page 15


 503              		.loc 1 277 5 is_stmt 1 view .LVU116
 504              		.loc 1 277 17 is_stmt 0 view .LVU117
 505 0034 164B     		ldr	r3, .L30+20
 506 0036 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 507              		.loc 1 277 8 view .LVU118
 508 0038 A2B9     		cbnz	r2, .L28
 509              		.loc 1 277 26 discriminator 1 view .LVU119
 510 003a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 511 003c 012A     		cmp	r2, #1
 512 003e 1CD1     		bne	.L25
 278:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 279:Src/util.c    ****         sensor2 = SET;
 513              		.loc 1 279 9 is_stmt 1 view .LVU120
 514              		.loc 1 279 17 is_stmt 0 view .LVU121
 515 0040 1A70     		strb	r2, [r3]
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 516              		.loc 1 280 9 is_stmt 1 view .LVU122
 517 0042 1021     		movs	r1, #16
 281:Src/util.c    ****         consoleLog("SENSOR 2 ON\r\n");
 282:Src/util.c    ****     } else if (sensor2 == SET && sensor2_read == RESET) {
 283:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 284:Src/util.c    ****         sensor2 = RESET;
 285:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 286:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 287:Src/util.c    ****     }
 288:Src/util.c    **** 
 289:Src/util.c    ****     if (sensor1 == SET) {
 290:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 291:Src/util.c    ****     }
 292:Src/util.c    ****     if (sensor2 == SET) {
 293:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 294:Src/util.c    ****     }
 295:Src/util.c    **** }
 518              		.loc 1 295 1 is_stmt 0 view .LVU123
 519 0044 BDE83840 		pop	{r3, r4, r5, lr}
 520              	.LCFI5:
 521              		.cfi_remember_state
 522              		.cfi_restore 14
 523              		.cfi_restore 5
 524              		.cfi_restore 4
 525              		.cfi_restore 3
 526              		.cfi_def_cfa_offset 0
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 527              		.loc 1 280 9 view .LVU124
 528 0048 1048     		ldr	r0, .L30+16
 529 004a FFF7FEBF 		b	gpio_bit_set
 530              	.LVL45:
 531              	.L26:
 532              	.LCFI6:
 533              		.cfi_restore_state
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 534              		.loc 1 269 12 is_stmt 1 view .LVU125
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 535              		.loc 1 269 14 is_stmt 0 view .LVU126
 536 004e 012A     		cmp	r2, #1
 537 0050 F0D1     		bne	.L27
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
ARM GAS  /tmp/cc9tOEVd.s 			page 16


 538              		.loc 1 269 30 discriminator 1 view .LVU127
 539 0052 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 540 0054 002A     		cmp	r2, #0
 541 0056 EDD1     		bne	.L27
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 542              		.loc 1 271 9 is_stmt 1 view .LVU128
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 543              		.loc 1 272 9 is_stmt 0 view .LVU129
 544 0058 2021     		movs	r1, #32
 545 005a 0C48     		ldr	r0, .L30+16
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 546              		.loc 1 271 17 view .LVU130
 547 005c 1A70     		strb	r2, [r3]
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 548              		.loc 1 272 9 is_stmt 1 view .LVU131
 549 005e FFF7FEFF 		bl	gpio_bit_reset
 550              	.LVL46:
 273:Src/util.c    ****     }
 551              		.loc 1 273 9 view .LVU132
 552              	.LBB18:
 553              	.LBI18:
 117:Src/util.c    **** {
 554              		.loc 1 117 6 view .LVU133
 555              	.LBB19:
 122:Src/util.c    **** 
 556              		.loc 1 122 1 view .LVU134
 557 0062 E7E7     		b	.L27
 558              	.LVL47:
 559              	.L28:
 122:Src/util.c    **** 
 560              		.loc 1 122 1 is_stmt 0 view .LVU135
 561              	.LBE19:
 562              	.LBE18:
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 563              		.loc 1 282 12 is_stmt 1 view .LVU136
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 564              		.loc 1 282 15 is_stmt 0 view .LVU137
 565 0064 012A     		cmp	r2, #1
 566 0066 08D1     		bne	.L25
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 567              		.loc 1 282 31 discriminator 1 view .LVU138
 568 0068 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 569 006a 32B9     		cbnz	r2, .L25
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 570              		.loc 1 284 9 is_stmt 1 view .LVU139
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 571              		.loc 1 284 17 is_stmt 0 view .LVU140
 572 006c 1A70     		strb	r2, [r3]
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 573              		.loc 1 285 9 is_stmt 1 view .LVU141
 574 006e 1021     		movs	r1, #16
 575              		.loc 1 295 1 is_stmt 0 view .LVU142
 576 0070 BDE83840 		pop	{r3, r4, r5, lr}
 577              	.LCFI7:
 578              		.cfi_remember_state
 579              		.cfi_restore 14
 580              		.cfi_restore 5
ARM GAS  /tmp/cc9tOEVd.s 			page 17


 581              		.cfi_restore 4
 582              		.cfi_restore 3
 583              		.cfi_def_cfa_offset 0
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 584              		.loc 1 285 9 view .LVU143
 585 0074 0548     		ldr	r0, .L30+16
 586 0076 FFF7FEBF 		b	gpio_bit_reset
 587              	.LVL48:
 588              	.L25:
 589              	.LCFI8:
 590              		.cfi_restore_state
 591              		.loc 1 295 1 view .LVU144
 592 007a 38BD     		pop	{r3, r4, r5, pc}
 593              	.L31:
 594              		.align	2
 595              	.L30:
 596 007c 00000000 		.word	.LANCHOR3
 597 0080 00080048 		.word	1207961600
 598 0084 00000000 		.word	.LANCHOR5
 599 0088 00000000 		.word	.LANCHOR4
 600 008c 00040048 		.word	1207960576
 601 0090 00000000 		.word	.LANCHOR6
 602              		.cfi_endproc
 603              	.LFE65:
 605              		.section	.text.handle_usart,"ax",%progbits
 606              		.align	1
 607              		.global	handle_usart
 608              		.syntax unified
 609              		.thumb
 610              		.thumb_func
 611              		.fpu softvfp
 613              	handle_usart:
 614              	.LFB66:
 296:Src/util.c    **** 
 297:Src/util.c    **** 
 298:Src/util.c    **** 
 299:Src/util.c    **** 
 300:Src/util.c    **** /*
 301:Src/util.c    ****  * Handle of the USART data
 302:Src/util.c    ****  */
 303:Src/util.c    **** void handle_usart(void) {
 615              		.loc 1 303 25 is_stmt 1 view -0
 616              		.cfi_startproc
 617              		@ args = 0, pretend = 0, frame = 8
 618              		@ frame_needed = 0, uses_anonymous_args = 0
 304:Src/util.c    ****     // Tx USART MAIN
 305:Src/util.c    ****     #ifdef SERIAL_CONTROL
 306:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART1_TX_DMA_CH) == 0) {     // 
 619              		.loc 1 306 9 view .LVU146
 620              		.loc 1 306 31 is_stmt 0 view .LVU147
 621 0000 484B     		ldr	r3, .L37
 303:Src/util.c    ****     // Tx USART MAIN
 622              		.loc 1 303 25 view .LVU148
 623 0002 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 624              	.LCFI9:
 625              		.cfi_def_cfa_offset 48
 626              		.cfi_offset 4, -36
ARM GAS  /tmp/cc9tOEVd.s 			page 18


 627              		.cfi_offset 5, -32
 628              		.cfi_offset 6, -28
 629              		.cfi_offset 7, -24
 630              		.cfi_offset 8, -20
 631              		.cfi_offset 9, -16
 632              		.cfi_offset 10, -12
 633              		.cfi_offset 11, -8
 634              		.cfi_offset 14, -4
 303:Src/util.c    ****     // Tx USART MAIN
 635              		.loc 1 303 25 view .LVU149
 636 0006 1B68     		ldr	r3, [r3]
 637 0008 474A     		ldr	r2, .L37+4
 638 000a 5343     		muls	r3, r2, r3
 639              		.loc 1 306 12 view .LVU150
 640 000c B3F1333F 		cmp	r3, #858993459
 641 0010 79D8     		bhi	.L34
 642              		.loc 1 306 43 discriminator 1 view .LVU151
 643 0012 0320     		movs	r0, #3
 644 0014 FFF7FEFF 		bl	dma_transfer_number_get
 645              	.LVL49:
 646              		.loc 1 306 40 discriminator 1 view .LVU152
 647 0018 0028     		cmp	r0, #0
 648 001a 74D1     		bne	.L34
 307:Src/util.c    ****             sideboard_imu.start =   (uint16_t)SERIAL_START_FRAME;
 649              		.loc 1 307 13 is_stmt 1 view .LVU153
 650              		.loc 1 307 33 is_stmt 0 view .LVU154
 651 001c 6FF03203 		mvn	r3, #50
 652 0020 424C     		ldr	r4, .L37+8
 653 0022 2370     		strb	r3, [r4]
 654 0024 6FF05403 		mvn	r3, #84
 655 0028 6370     		strb	r3, [r4, #1]
 308:Src/util.c    ****             sideboard_imu.cmd1 =    (int16_t)0;
 656              		.loc 1 308 13 is_stmt 1 view .LVU155
 309:Src/util.c    ****             sideboard_imu.cmd2 =    (int16_t)0;
 310:Src/util.c    ****             sideboard_imu.pitch =   (int16_t)mpu.euler.pitch;
 657              		.loc 1 310 55 is_stmt 0 view .LVU156
 658 002a 414B     		ldr	r3, .L37+12
 308:Src/util.c    ****             sideboard_imu.cmd1 =    (int16_t)0;
 659              		.loc 1 308 32 view .LVU157
 660 002c A070     		strb	r0, [r4, #2]
 311:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 661              		.loc 1 311 54 view .LVU158
 662 002e B3F90210 		ldrsh	r1, [r3, #2]
 310:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 663              		.loc 1 310 55 view .LVU159
 664 0032 B3F91E20 		ldrsh	r2, [r3, #30]
 312:Src/util.c    ****   
 313:Src/util.c    ****             sideboard_imu.gyro_x =  (int16_t)mpu.gyro.x;
 314:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 315:Src/util.c    ****             sideboard_imu.gyro_z =  (int16_t)mpu.gyro.z;
 316:Src/util.c    ****             
 317:Src/util.c    ****             sideboard_imu.accel_x = (int16_t)mpu.accel.x;
 318:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 319:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 320:Src/util.c    ****         
 321:Src/util.c    ****             sideboard_imu.quat_w = (int16_t)mpu.quat.w;
 322:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
ARM GAS  /tmp/cc9tOEVd.s 			page 19


 323:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 324:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 665              		.loc 1 324 36 view .LVU160
 666 0036 B3F91860 		ldrsh	r6, [r3, #24]
 313:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 667              		.loc 1 313 54 view .LVU161
 668 003a B3F900A0 		ldrsh	r10, [r3]
 315:Src/util.c    ****             
 669              		.loc 1 315 54 view .LVU162
 670 003e B3F904B0 		ldrsh	fp, [r3, #4]
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 671              		.loc 1 317 55 view .LVU163
 672 0042 B3F90690 		ldrsh	r9, [r3, #6]
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 673              		.loc 1 318 55 view .LVU164
 674 0046 B3F90880 		ldrsh	r8, [r3, #8]
 319:Src/util.c    ****         
 675              		.loc 1 319 55 view .LVU165
 676 004a B3F90AE0 		ldrsh	lr, [r3, #10]
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 677              		.loc 1 321 36 view .LVU166
 678 004e B3F90C50 		ldrsh	r5, [r3, #12]
 325:Src/util.c    ****  
 326:Src/util.c    ****             sideboard_imu.euler_pitch = (int16_t)mpu.euler.pitch;
 327:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 679              		.loc 1 327 58 view .LVU167
 680 0052 B3F91CC0 		ldrsh	ip, [r3, #28]
 308:Src/util.c    ****             sideboard_imu.cmd2 =    (int16_t)0;
 681              		.loc 1 308 32 view .LVU168
 682 0056 E070     		strb	r0, [r4, #3]
 309:Src/util.c    ****             sideboard_imu.pitch =   (int16_t)mpu.euler.pitch;
 683              		.loc 1 309 13 is_stmt 1 view .LVU169
 309:Src/util.c    ****             sideboard_imu.pitch =   (int16_t)mpu.euler.pitch;
 684              		.loc 1 309 32 is_stmt 0 view .LVU170
 685 0058 2071     		strb	r0, [r4, #4]
 686 005a 6071     		strb	r0, [r4, #5]
 310:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 687              		.loc 1 310 13 is_stmt 1 view .LVU171
 311:Src/util.c    ****   
 688              		.loc 1 311 34 is_stmt 0 view .LVU172
 689 005c 2181     		strh	r1, [r4, #8]	@ unaligned
 322:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 690              		.loc 1 322 36 view .LVU173
 691 005e B3F91000 		ldrsh	r0, [r3, #16]
 314:Src/util.c    ****             sideboard_imu.gyro_z =  (int16_t)mpu.gyro.z;
 692              		.loc 1 314 34 view .LVU174
 693 0062 A181     		strh	r1, [r4, #12]	@ unaligned
 323:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 694              		.loc 1 323 36 view .LVU175
 695 0064 B3F91410 		ldrsh	r1, [r3, #20]
 310:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 696              		.loc 1 310 33 view .LVU176
 697 0068 E280     		strh	r2, [r4, #6]	@ unaligned
 311:Src/util.c    ****   
 698              		.loc 1 311 13 is_stmt 1 view .LVU177
 313:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 699              		.loc 1 313 13 view .LVU178
ARM GAS  /tmp/cc9tOEVd.s 			page 20


 326:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 700              		.loc 1 326 39 is_stmt 0 view .LVU179
 701 006a E283     		strh	r2, [r4, #30]	@ unaligned
 328:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 329:Src/util.c    ****             
 330:Src/util.c    ****             sideboard_imu.temperature = (int16_t)mpu.temp;
 331:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 702              		.loc 1 331 106 view .LVU180
 703 006c 314A     		ldr	r2, .L37+16
 313:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 704              		.loc 1 313 34 view .LVU181
 705 006e A4F80AA0 		strh	r10, [r4, #10]	@ unaligned
 314:Src/util.c    ****             sideboard_imu.gyro_z =  (int16_t)mpu.gyro.z;
 706              		.loc 1 314 13 is_stmt 1 view .LVU182
 315:Src/util.c    ****             
 707              		.loc 1 315 13 view .LVU183
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 708              		.loc 1 317 35 is_stmt 0 view .LVU184
 709 0072 A4F81090 		strh	r9, [r4, #16]	@ unaligned
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 710              		.loc 1 318 35 view .LVU185
 711 0076 A4F81280 		strh	r8, [r4, #18]	@ unaligned
 319:Src/util.c    ****         
 712              		.loc 1 319 35 view .LVU186
 713 007a A4F814E0 		strh	lr, [r4, #20]	@ unaligned
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 714              		.loc 1 321 34 view .LVU187
 715 007e E582     		strh	r5, [r4, #22]	@ unaligned
 322:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 716              		.loc 1 322 34 view .LVU188
 717 0080 2083     		strh	r0, [r4, #24]	@ unaligned
 323:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 718              		.loc 1 323 34 view .LVU189
 719 0082 6183     		strh	r1, [r4, #26]	@ unaligned
 324:Src/util.c    ****  
 720              		.loc 1 324 36 view .LVU190
 721 0084 0196     		str	r6, [sp, #4]
 324:Src/util.c    ****  
 722              		.loc 1 324 34 view .LVU191
 723 0086 A683     		strh	r6, [r4, #28]	@ unaligned
 315:Src/util.c    ****             
 724              		.loc 1 315 34 view .LVU192
 725 0088 A4F80EB0 		strh	fp, [r4, #14]	@ unaligned
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 726              		.loc 1 317 13 is_stmt 1 view .LVU193
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 727              		.loc 1 318 13 view .LVU194
 319:Src/util.c    ****         
 728              		.loc 1 319 13 view .LVU195
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 729              		.loc 1 321 13 view .LVU196
 322:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 730              		.loc 1 322 13 view .LVU197
 323:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 731              		.loc 1 323 13 view .LVU198
 324:Src/util.c    ****  
 732              		.loc 1 324 13 view .LVU199
ARM GAS  /tmp/cc9tOEVd.s 			page 21


 326:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 733              		.loc 1 326 13 view .LVU200
 327:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 734              		.loc 1 327 13 view .LVU201
 327:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 735              		.loc 1 327 38 is_stmt 0 view .LVU202
 736 008c A4F820C0 		strh	ip, [r4, #32]	@ unaligned
 328:Src/util.c    ****             
 737              		.loc 1 328 13 is_stmt 1 view .LVU203
 328:Src/util.c    ****             
 738              		.loc 1 328 57 is_stmt 0 view .LVU204
 739 0090 B3F92070 		ldrsh	r7, [r3, #32]
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 740              		.loc 1 330 53 view .LVU205
 741 0094 B3F92260 		ldrsh	r6, [r3, #34]
 742              		.loc 1 331 87 view .LVU206
 743 0098 274B     		ldr	r3, .L37+20
 744              		.loc 1 331 106 view .LVU207
 745 009a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 746              		.loc 1 331 87 view .LVU208
 747 009c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 748              		.loc 1 331 106 view .LVU209
 749 009e 9200     		lsls	r2, r2, #2
 750              		.loc 1 331 93 view .LVU210
 751 00a0 42EA4302 		orr	r2, r2, r3, lsl #1
 752              		.loc 1 331 76 view .LVU211
 753 00a4 254B     		ldr	r3, .L37+24
 332:Src/util.c    **** 
 333:Src/util.c    ****             sideboard_imu.checksum = (uint16_t)(
 334:Src/util.c    ****                 sideboard_imu.start ^
 335:Src/util.c    ****                 sideboard_imu.cmd1 ^ sideboard_imu.cmd2 ^
 336:Src/util.c    ****                 sideboard_imu.pitch ^ sideboard_imu.dPitch ^
 337:Src/util.c    ****                 sideboard_imu.gyro_x ^ sideboard_imu.gyro_y ^ sideboard_imu.gyro_z ^
 338:Src/util.c    ****                 sideboard_imu.accel_x ^ sideboard_imu.accel_y ^ sideboard_imu.accel_z ^
 339:Src/util.c    ****                 sideboard_imu.quat_w ^ sideboard_imu.quat_x ^ sideboard_imu.quat_y ^ sideboard_imu.
 340:Src/util.c    ****                 sideboard_imu.euler_pitch ^ sideboard_imu.euler_roll ^ sideboard_imu.euler_yaw ^
 341:Src/util.c    ****                 sideboard_imu.temperature ^ sideboard_imu.sensors
 754              		.loc 1 341 43 view .LVU212
 755 00a6 8AEA0B0A 		eor	r10, r10, fp
 331:Src/util.c    **** 
 756              		.loc 1 331 76 view .LVU213
 757 00aa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 328:Src/util.c    ****             
 758              		.loc 1 328 37 view .LVU214
 759 00ac 6784     		strh	r7, [r4, #34]	@ unaligned
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 760              		.loc 1 330 13 is_stmt 1 view .LVU215
 331:Src/util.c    **** 
 761              		.loc 1 331 93 is_stmt 0 view .LVU216
 762 00ae 1343     		orrs	r3, r3, r2
 331:Src/util.c    **** 
 763              		.loc 1 331 35 view .LVU217
 764 00b0 E384     		strh	r3, [r4, #38]	@ unaligned
 765              		.loc 1 341 43 view .LVU218
 766 00b2 83EA0A03 		eor	r3, r3, r10
 767 00b6 89EA0309 		eor	r9, r9, r3
 768 00ba 88EA0908 		eor	r8, r8, r9
ARM GAS  /tmp/cc9tOEVd.s 			page 22


 769 00be 8EEA080E 		eor	lr, lr, r8
 770 00c2 8CEA0E0C 		eor	ip, ip, lr
 771 00c6 87EA0C07 		eor	r7, r7, ip
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 772              		.loc 1 330 39 view .LVU219
 773 00ca A684     		strh	r6, [r4, #36]	@ unaligned
 331:Src/util.c    **** 
 774              		.loc 1 331 13 is_stmt 1 view .LVU220
 333:Src/util.c    ****                 sideboard_imu.start ^
 775              		.loc 1 333 13 view .LVU221
 776              		.loc 1 341 43 is_stmt 0 view .LVU222
 777 00cc 7E40     		eors	r6, r6, r7
 778 00ce 7540     		eors	r5, r5, r6
 779 00d0 019B     		ldr	r3, [sp, #4]
 780 00d2 6840     		eors	r0, r0, r5
 781 00d4 4140     		eors	r1, r1, r0
 782 00d6 5940     		eors	r1, r1, r3
 783 00d8 81F42B41 		eor	r1, r1, #43776
 784 00dc 81F0CD01 		eor	r1, r1, #205
 342:Src/util.c    ****             );
 343:Src/util.c    ****         
 344:Src/util.c    ****             dma_channel_disable(USART1_TX_DMA_CH);
 785              		.loc 1 344 13 view .LVU223
 786 00e0 0320     		movs	r0, #3
 333:Src/util.c    ****                 sideboard_imu.start ^
 787              		.loc 1 333 36 view .LVU224
 788 00e2 2185     		strh	r1, [r4, #40]	@ unaligned
 789              		.loc 1 344 13 is_stmt 1 view .LVU225
 790 00e4 FFF7FEFF 		bl	dma_channel_disable
 791              	.LVL50:
 345:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 792              		.loc 1 345 13 view .LVU226
 793              		.loc 1 345 45 is_stmt 0 view .LVU227
 794 00e8 2A22     		movs	r2, #42
 795 00ea 154B     		ldr	r3, .L37+28
 346:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 347:Src/util.c    ****             dma_channel_enable(USART1_TX_DMA_CH);
 796              		.loc 1 347 13 view .LVU228
 797 00ec 0320     		movs	r0, #3
 345:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 798              		.loc 1 345 45 view .LVU229
 799 00ee 9A64     		str	r2, [r3, #72]
 346:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 800              		.loc 1 346 13 is_stmt 1 view .LVU230
 346:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 801              		.loc 1 346 45 is_stmt 0 view .LVU231
 802 00f0 1C65     		str	r4, [r3, #80]
 803              		.loc 1 347 13 is_stmt 1 view .LVU232
 804 00f2 FFF7FEFF 		bl	dma_channel_enable
 805              	.LVL51:
 348:Src/util.c    **** 
 349:Src/util.c    **** 
 350:Src/util.c    ****             toggle_led(LED2_GPIO_Port, LED2_Pin); //toggle green
 806              		.loc 1 350 13 view .LVU233
 807              	.LBB20:
 808              	.LBI20:
 148:Src/util.c    **** {
ARM GAS  /tmp/cc9tOEVd.s 			page 23


 809              		.loc 1 148 6 view .LVU234
 810              	.LBB21:
 150:Src/util.c    **** }
 811              		.loc 1 150 5 view .LVU235
 150:Src/util.c    **** }
 812              		.loc 1 150 28 is_stmt 0 view .LVU236
 813 00f6 4FF09042 		mov	r2, #1207959552
 814 00fa D2F81434 		ldr	r3, [r2, #1044]
 815 00fe 83F40073 		eor	r3, r3, #512
 816 0102 C2F81434 		str	r3, [r2, #1044]
 817              	.LVL52:
 818              	.L34:
 150:Src/util.c    **** }
 819              		.loc 1 150 28 view .LVU237
 820              	.LBE21:
 821              	.LBE20:
 351:Src/util.c    **** 
 352:Src/util.c    ****         }
 353:Src/util.c    ****     #endif
 354:Src/util.c    ****     // Rx USART MAIN
 355:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 356:Src/util.c    ****         if (timeoutCntSerial1++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 822              		.loc 1 356 9 is_stmt 1 view .LVU238
 823              		.loc 1 356 30 is_stmt 0 view .LVU239
 824 0106 0F4B     		ldr	r3, .L37+32
 825 0108 1A88     		ldrh	r2, [r3]
 826 010a 511C     		adds	r1, r2, #1
 827              		.loc 1 356 12 view .LVU240
 828 010c 9F2A     		cmp	r2, #159
 829              		.loc 1 356 30 view .LVU241
 830 010e 1980     		strh	r1, [r3]	@ movhi
 831              		.loc 1 356 12 view .LVU242
 832 0110 04D9     		bls	.L32
 357:Src/util.c    ****             timeoutFlagSerial1 = 1;                                 // Timeout detected
 833              		.loc 1 357 13 is_stmt 1 view .LVU243
 834              		.loc 1 357 32 is_stmt 0 view .LVU244
 835 0112 0121     		movs	r1, #1
 836 0114 0C4A     		ldr	r2, .L37+36
 837 0116 1170     		strb	r1, [r2]
 358:Src/util.c    ****             timeoutCntSerial1  = SERIAL_TIMEOUT;                    // Limit timout counter value
 838              		.loc 1 358 13 is_stmt 1 view .LVU245
 839              		.loc 1 358 32 is_stmt 0 view .LVU246
 840 0118 A022     		movs	r2, #160
 841 011a 1A80     		strh	r2, [r3]	@ movhi
 359:Src/util.c    ****         }
 360:Src/util.c    ****         if (timeoutFlagSerial1 && main_loop_counter % 100 == 0) {   // In case of timeout bring the
 842              		.loc 1 360 9 is_stmt 1 view .LVU247
 361:Src/util.c    ****             //toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED ever
 362:Src/util.c    ****         }
 843              		.loc 1 362 9 view .LVU248
 844              	.L32:
 363:Src/util.c    ****     #endif
 364:Src/util.c    **** 
 365:Src/util.c    ****     // Tx USART AUX
 366:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 367:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART0_TX_DMA_CH) == 0) {     // 
 368:Src/util.c    ****             AuxTx.start     = (uint16_t)SERIAL_START_FRAME;
ARM GAS  /tmp/cc9tOEVd.s 			page 24


 369:Src/util.c    ****             AuxTx.signal1   = (int16_t)sensor1;
 370:Src/util.c    ****             AuxTx.signal2   = (int16_t)sensor2;
 371:Src/util.c    ****             AuxTx.checksum  = (uint16_t)(AuxTx.start ^ AuxTx.signal1 ^ AuxTx.signal2);
 372:Src/util.c    ****         
 373:Src/util.c    ****             dma_channel_disable(USART0_TX_DMA_CH);
 374:Src/util.c    ****             DMA_CHCNT(USART0_TX_DMA_CH)     = sizeof(AuxTx);
 375:Src/util.c    ****             DMA_CHMADDR(USART0_TX_DMA_CH)   = (uint32_t)&AuxTx;
 376:Src/util.c    ****             dma_channel_enable(USART0_TX_DMA_CH);
 377:Src/util.c    ****         }
 378:Src/util.c    ****     #endif
 379:Src/util.c    ****     // Rx USART AUX
 380:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 381:Src/util.c    ****         #ifdef CONTROL_IBUS
 382:Src/util.c    ****         if (!timeoutFlagSerial0) {
 383:Src/util.c    ****             for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 384:Src/util.c    ****                 ibus_captured_value[(i/2)] = CLAMP(command.channels[i] + (command.channels[i+1] << 
 385:Src/util.c    ****             }
 386:Src/util.c    ****             cmd1        = (ibus_captured_value[0] - 500) * 2;                           // Channel 
 387:Src/util.c    ****             cmd2        = (ibus_captured_value[1] - 500) * 2;                           // Channel 
 388:Src/util.c    ****             cmdSwitch   = (uint16_t)(switch_check(ibus_captured_value[6],0)      |      // Channel 
 389:Src/util.c    ****                                      switch_check(ibus_captured_value[7],1) << 1 |      // Channel 
 390:Src/util.c    ****                                      switch_check(ibus_captured_value[8],1) << 3 |      // Channel 
 391:Src/util.c    ****                                      switch_check(ibus_captured_value[9],0) << 5);      // Channel 
 392:Src/util.c    ****         }
 393:Src/util.c    ****         #endif
 394:Src/util.c    **** 
 395:Src/util.c    ****         if (timeoutCntSerial0++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 396:Src/util.c    ****             timeoutFlagSerial0 = 1;                                 // Timeout detected
 397:Src/util.c    ****             timeoutCntSerial0  = SERIAL_TIMEOUT;                    // Limit timout counter value
 398:Src/util.c    ****             cmd1 = cmd2 = 0;                                        // Set commands to 0
 399:Src/util.c    ****             cmdSwitch &= ~(1U << 0);                                // Clear Bit 0, to switch to de
 400:Src/util.c    ****         }
 401:Src/util.c    ****         // if (timeoutFlagSerial0 && main_loop_counter % 100 == 0) {   // In case of timeout bring 
 402:Src/util.c    ****         //     toggle_led(LED2_GPIO_Port, LED2_Pin);                   // Toggle the Green LED ever
 403:Src/util.c    ****         // }
 404:Src/util.c    **** 
 405:Src/util.c    ****         #ifdef SERIAL_DEBUG
 406:Src/util.c    ****             // Print MPU data to Console
 407:Src/util.c    ****             if (main_loop_counter % 50 == 0) {
 408:Src/util.c    ****                 aux_print_to_console();
 409:Src/util.c    ****             }
 410:Src/util.c    ****         #endif
 411:Src/util.c    ****     #endif
 412:Src/util.c    **** }
 845              		.loc 1 412 1 is_stmt 0 view .LVU249
 846 011c 03B0     		add	sp, sp, #12
 847              	.LCFI10:
 848              		.cfi_def_cfa_offset 36
 849              		@ sp needed
 850 011e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 851              	.L38:
 852 0122 00BF     		.align	2
 853              	.L37:
 854 0124 00000000 		.word	main_loop_counter
 855 0128 CDCCCCCC 		.word	-858993459
 856 012c 00000000 		.word	.LANCHOR0
 857 0130 00000000 		.word	mpu
ARM GAS  /tmp/cc9tOEVd.s 			page 25


 858 0134 00000000 		.word	.LANCHOR2
 859 0138 00000000 		.word	.LANCHOR6
 860 013c 00000000 		.word	.LANCHOR5
 861 0140 00000240 		.word	1073872896
 862 0144 00000000 		.word	.LANCHOR7
 863 0148 00000000 		.word	.LANCHOR8
 864              		.cfi_endproc
 865              	.LFE66:
 867              		.section	.text.handle_leds,"ax",%progbits
 868              		.align	1
 869              		.global	handle_leds
 870              		.syntax unified
 871              		.thumb
 872              		.thumb_func
 873              		.fpu softvfp
 875              	handle_leds:
 876              	.LFB67:
 413:Src/util.c    **** 
 414:Src/util.c    **** /*
 415:Src/util.c    ****  * Handle of the sideboard LEDs
 416:Src/util.c    ****  */
 417:Src/util.c    **** void handle_leds(void) {
 877              		.loc 1 417 24 is_stmt 1 view -0
 878              		.cfi_startproc
 879              		@ args = 0, pretend = 0, frame = 0
 880              		@ frame_needed = 0, uses_anonymous_args = 0
 418:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 419:Src/util.c    ****         if (!timeoutFlagSerial1) {
 881              		.loc 1 419 9 view .LVU251
 417:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 882              		.loc 1 417 24 is_stmt 0 view .LVU252
 883 0000 10B5     		push	{r4, lr}
 884              	.LCFI11:
 885              		.cfi_def_cfa_offset 8
 886              		.cfi_offset 4, -8
 887              		.cfi_offset 14, -4
 888              		.loc 1 419 13 view .LVU253
 889 0002 244B     		ldr	r3, .L52
 890              		.loc 1 419 12 view .LVU254
 891 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 892 0006 002B     		cmp	r3, #0
 893 0008 43D1     		bne	.L39
 420:Src/util.c    ****             if (Feedback.cmdLed & LED1_SET) { gpio_bit_set(LED1_GPIO_Port, LED1_Pin); } else { gpio
 894              		.loc 1 420 13 is_stmt 1 view .LVU255
 895              		.loc 1 420 25 is_stmt 0 view .LVU256
 896 000a 234C     		ldr	r4, .L52+4
 897              		.loc 1 420 47 view .LVU257
 898 000c 0121     		movs	r1, #1
 899              		.loc 1 420 16 view .LVU258
 900 000e A38D     		ldrh	r3, [r4, #44]
 901              		.loc 1 420 47 view .LVU259
 902 0010 4FF09040 		mov	r0, #1207959552
 903              		.loc 1 420 16 view .LVU260
 904 0014 DA07     		lsls	r2, r3, #31
 905 0016 29D5     		bpl	.L41
 906              		.loc 1 420 47 is_stmt 1 discriminator 1 view .LVU261
 907 0018 FFF7FEFF 		bl	gpio_bit_set
ARM GAS  /tmp/cc9tOEVd.s 			page 26


 908              	.LVL53:
 909              	.L42:
 421:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 910              		.loc 1 421 13 view .LVU262
 911              		.loc 1 421 16 is_stmt 0 view .LVU263
 912 001c A38D     		ldrh	r3, [r4, #44]
 913              		.loc 1 421 47 view .LVU264
 914 001e 4FF40071 		mov	r1, #512
 915              		.loc 1 421 16 view .LVU265
 916 0022 9B07     		lsls	r3, r3, #30
 917              		.loc 1 421 47 view .LVU266
 918 0024 1D48     		ldr	r0, .L52+8
 919              		.loc 1 421 16 view .LVU267
 920 0026 24D5     		bpl	.L43
 921              		.loc 1 421 47 is_stmt 1 discriminator 1 view .LVU268
 922 0028 FFF7FEFF 		bl	gpio_bit_set
 923              	.LVL54:
 924              	.L44:
 422:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 925              		.loc 1 422 13 view .LVU269
 926              		.loc 1 422 16 is_stmt 0 view .LVU270
 927 002c A38D     		ldrh	r3, [r4, #44]
 928              		.loc 1 422 47 view .LVU271
 929 002e 4FF48071 		mov	r1, #256
 930              		.loc 1 422 16 view .LVU272
 931 0032 5A07     		lsls	r2, r3, #29
 932              		.loc 1 422 47 view .LVU273
 933 0034 1948     		ldr	r0, .L52+8
 934              		.loc 1 422 16 view .LVU274
 935 0036 1FD5     		bpl	.L45
 936              		.loc 1 422 47 is_stmt 1 discriminator 1 view .LVU275
 937 0038 FFF7FEFF 		bl	gpio_bit_set
 938              	.LVL55:
 939              	.L46:
 423:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 940              		.loc 1 423 13 view .LVU276
 941              		.loc 1 423 16 is_stmt 0 view .LVU277
 942 003c A38D     		ldrh	r3, [r4, #44]
 943              		.loc 1 423 47 view .LVU278
 944 003e 2021     		movs	r1, #32
 945              		.loc 1 423 16 view .LVU279
 946 0040 1B07     		lsls	r3, r3, #28
 947              		.loc 1 423 47 view .LVU280
 948 0042 1648     		ldr	r0, .L52+8
 949              		.loc 1 423 16 view .LVU281
 950 0044 1BD5     		bpl	.L47
 951              		.loc 1 423 47 is_stmt 1 discriminator 1 view .LVU282
 952 0046 FFF7FEFF 		bl	gpio_bit_set
 953              	.LVL56:
 954              	.L48:
 424:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 955              		.loc 1 424 13 view .LVU283
 956              		.loc 1 424 16 is_stmt 0 view .LVU284
 957 004a A38D     		ldrh	r3, [r4, #44]
 958              		.loc 1 424 47 view .LVU285
 959 004c 1021     		movs	r1, #16
 960              		.loc 1 424 16 view .LVU286
ARM GAS  /tmp/cc9tOEVd.s 			page 27


 961 004e DA06     		lsls	r2, r3, #27
 962              		.loc 1 424 47 view .LVU287
 963 0050 1248     		ldr	r0, .L52+8
 964              		.loc 1 424 16 view .LVU288
 965 0052 17D5     		bpl	.L49
 966              		.loc 1 424 47 is_stmt 1 discriminator 1 view .LVU289
 967 0054 FFF7FEFF 		bl	gpio_bit_set
 968              	.LVL57:
 969              	.L50:
 425:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 970              		.loc 1 425 13 view .LVU290
 971              		.loc 1 425 16 is_stmt 0 view .LVU291
 972 0058 A38D     		ldrh	r3, [r4, #44]
 973              		.loc 1 425 47 view .LVU292
 974 005a 4FF48061 		mov	r1, #1024
 975              		.loc 1 425 16 view .LVU293
 976 005e 1B07     		lsls	r3, r3, #28
 977              		.loc 1 425 47 view .LVU294
 978 0060 0E48     		ldr	r0, .L52+8
 979              		.loc 1 425 16 view .LVU295
 980 0062 12D5     		bpl	.L51
 981              		.loc 1 425 47 is_stmt 1 discriminator 1 view .LVU296
 426:Src/util.c    ****         }
 427:Src/util.c    ****     #endif
 428:Src/util.c    **** }
 982              		.loc 1 428 1 is_stmt 0 discriminator 1 view .LVU297
 983 0064 BDE81040 		pop	{r4, lr}
 984              	.LCFI12:
 985              		.cfi_remember_state
 986              		.cfi_restore 14
 987              		.cfi_restore 4
 988              		.cfi_def_cfa_offset 0
 425:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 989              		.loc 1 425 47 discriminator 1 view .LVU298
 990 0068 FFF7FEBF 		b	gpio_bit_set
 991              	.LVL58:
 992              	.L41:
 993              	.LCFI13:
 994              		.cfi_restore_state
 420:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 995              		.loc 1 420 96 is_stmt 1 discriminator 2 view .LVU299
 996 006c FFF7FEFF 		bl	gpio_bit_reset
 997              	.LVL59:
 998 0070 D4E7     		b	.L42
 999              	.L43:
 421:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 1000              		.loc 1 421 96 discriminator 2 view .LVU300
 1001 0072 FFF7FEFF 		bl	gpio_bit_reset
 1002              	.LVL60:
 1003 0076 D9E7     		b	.L44
 1004              	.L45:
 422:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 1005              		.loc 1 422 96 discriminator 2 view .LVU301
 1006 0078 FFF7FEFF 		bl	gpio_bit_reset
 1007              	.LVL61:
 1008 007c DEE7     		b	.L46
 1009              	.L47:
ARM GAS  /tmp/cc9tOEVd.s 			page 28


 423:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 1010              		.loc 1 423 96 discriminator 2 view .LVU302
 1011 007e FFF7FEFF 		bl	gpio_bit_reset
 1012              	.LVL62:
 1013 0082 E2E7     		b	.L48
 1014              	.L49:
 424:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 1015              		.loc 1 424 96 discriminator 2 view .LVU303
 1016 0084 FFF7FEFF 		bl	gpio_bit_reset
 1017              	.LVL63:
 1018 0088 E6E7     		b	.L50
 1019              	.L51:
 425:Src/util.c    ****         }
 1020              		.loc 1 425 96 discriminator 2 view .LVU304
 1021              		.loc 1 428 1 is_stmt 0 discriminator 2 view .LVU305
 1022 008a BDE81040 		pop	{r4, lr}
 1023              	.LCFI14:
 1024              		.cfi_remember_state
 1025              		.cfi_restore 14
 1026              		.cfi_restore 4
 1027              		.cfi_def_cfa_offset 0
 425:Src/util.c    ****         }
 1028              		.loc 1 425 96 discriminator 2 view .LVU306
 1029 008e FFF7FEBF 		b	gpio_bit_reset
 1030              	.LVL64:
 1031              	.L39:
 1032              	.LCFI15:
 1033              		.cfi_restore_state
 1034              		.loc 1 428 1 view .LVU307
 1035 0092 10BD     		pop	{r4, pc}
 1036              	.L53:
 1037              		.align	2
 1038              	.L52:
 1039 0094 00000000 		.word	.LANCHOR8
 1040 0098 00000000 		.word	.LANCHOR9
 1041 009c 00040048 		.word	1207960576
 1042              		.cfi_endproc
 1043              	.LFE67:
 1045              		.section	.text.usart_process_data,"ax",%progbits
 1046              		.align	1
 1047              		.global	usart_process_data
 1048              		.syntax unified
 1049              		.thumb
 1050              		.thumb_func
 1051              		.fpu softvfp
 1053              	usart_process_data:
 1054              	.LVL65:
 1055              	.LFB69:
 429:Src/util.c    **** 
 430:Src/util.c    **** 
 431:Src/util.c    **** /* =========================== USART1 READ Functions =========================== */
 432:Src/util.c    **** 
 433:Src/util.c    **** void usart1_rx_check(void)
 434:Src/util.c    **** {
 435:Src/util.c    ****     #ifdef SERIAL_DEBUG
 436:Src/util.c    ****     static uint32_t old_pos;
 437:Src/util.c    ****     uint32_t pos;
ARM GAS  /tmp/cc9tOEVd.s 			page 29


 438:Src/util.c    **** 
 439:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 440:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 441:Src/util.c    ****         if (pos > old_pos) {                                                    // "Linear" buffer 
 442:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], pos - old_pos);           // Process data
 443:Src/util.c    ****         } else {                                                                // "Overflow" buffe
 444:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], rx1_buffer_len - old_pos);// First Process da
 445:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 446:Src/util.c    ****                 usart_process_debug(&rx1_buffer[0], pos);                       // Process remainin
 447:Src/util.c    ****             }
 448:Src/util.c    ****         }
 449:Src/util.c    ****     }
 450:Src/util.c    ****     old_pos = pos;                                                              // Update old posit
 451:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 452:Src/util.c    ****         old_pos = 0;
 453:Src/util.c    ****     }
 454:Src/util.c    ****     #endif // SERIAL_DEBUG
 455:Src/util.c    **** 
 456:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 457:Src/util.c    ****     static uint32_t old_pos;
 458:Src/util.c    ****     uint32_t pos;
 459:Src/util.c    ****     uint8_t *ptr;
 460:Src/util.c    **** 
 461:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 462:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 463:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 464:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 465:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 466:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 467:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 468:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 469:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 470:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 471:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 472:Src/util.c    ****             }
 473:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 474:Src/util.c    ****         }
 475:Src/util.c    ****     }
 476:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 477:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 478:Src/util.c    ****         old_pos = 0;
 479:Src/util.c    ****     }
 480:Src/util.c    ****     #endif // SERIAL_FEEDBACK
 481:Src/util.c    **** }
 482:Src/util.c    **** 
 483:Src/util.c    **** /*
 484:Src/util.c    ****  * Process Rx debug user command input
 485:Src/util.c    ****  */
 486:Src/util.c    **** #ifdef SERIAL_DEBUG
 487:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
 488:Src/util.c    **** {
 489:Src/util.c    ****     for (; len > 0; len--, userCommand++) {
 490:Src/util.c    ****         if (*userCommand != '\n' && *userCommand != '\r') {     // Do not accept 'new line' and 'ca
 491:Src/util.c    ****             log_i("Command = %c\r\n", *userCommand);
 492:Src/util.c    ****             mpu_handle_input(*userCommand);
 493:Src/util.c    ****         }
 494:Src/util.c    ****     }
ARM GAS  /tmp/cc9tOEVd.s 			page 30


 495:Src/util.c    **** }
 496:Src/util.c    **** #endif // SERIAL_DEBUG
 497:Src/util.c    **** 
 498:Src/util.c    **** /*
 499:Src/util.c    ****  * Process Rx data
 500:Src/util.c    ****  * - if the Feedback_in data is valid (correct START_FRAME and checksum) copy the Feedback_in to Fe
 501:Src/util.c    ****  */
 502:Src/util.c    **** #ifdef SERIAL_FEEDBACK
 503:Src/util.c    **** void usart_process_data(SerialFeedback *Feedback_in, SerialFeedback *Feedback_out)
 504:Src/util.c    **** {
 1056              		.loc 1 504 1 is_stmt 1 view -0
 1057              		.cfi_startproc
 1058              		@ args = 0, pretend = 0, frame = 0
 1059              		@ frame_needed = 0, uses_anonymous_args = 0
 505:Src/util.c    ****     uint16_t checksum;
 1060              		.loc 1 505 5 view .LVU309
 506:Src/util.c    ****     if (Feedback_in->start == SERIAL_START_FRAME) {
 1061              		.loc 1 506 5 view .LVU310
 1062              		.loc 1 506 8 is_stmt 0 view .LVU311
 1063 0000 4AF6CD33 		movw	r3, #43981
 1064 0004 0288     		ldrh	r2, [r0]
 504:Src/util.c    ****     uint16_t checksum;
 1065              		.loc 1 504 1 view .LVU312
 1066 0006 10B5     		push	{r4, lr}
 1067              	.LCFI16:
 1068              		.cfi_def_cfa_offset 8
 1069              		.cfi_offset 4, -8
 1070              		.cfi_offset 14, -4
 1071              		.loc 1 506 8 view .LVU313
 1072 0008 9A42     		cmp	r2, r3
 1073 000a 1ED1     		bne	.L54
 1074              	.LVL66:
 1075              	.LBB24:
 1076              	.LBI24:
 503:Src/util.c    **** {
 1077              		.loc 1 503 6 is_stmt 1 view .LVU314
 1078              	.LBB25:
 507:Src/util.c    ****         checksum = (uint16_t)(Feedback_in->start ^ Feedback_in->cmd1 ^ Feedback_in->cmd2 ^ Feedback
 1079              		.loc 1 507 9 view .LVU315
 508:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 509:Src/util.c    ****         if (Feedback_in->checksum == checksum) {
 1080              		.loc 1 509 9 view .LVU316
 508:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 1081              		.loc 1 508 80 is_stmt 0 view .LVU317
 1082 000c 8488     		ldrh	r4, [r0, #4]
 1083 000e 4388     		ldrh	r3, [r0, #2]
 1084 0010 6340     		eors	r3, r3, r4
 1085 0012 848D     		ldrh	r4, [r0, #44]
 1086 0014 6340     		eors	r3, r3, r4
 1087 0016 C488     		ldrh	r4, [r0, #6]
 1088 0018 6340     		eors	r3, r3, r4
 1089 001a 0489     		ldrh	r4, [r0, #8]
 1090 001c 6340     		eors	r3, r3, r4
 1091 001e 4489     		ldrh	r4, [r0, #10]
 1092 0020 6340     		eors	r3, r3, r4
 1093 0022 8489     		ldrh	r4, [r0, #12]
 1094 0024 6340     		eors	r3, r3, r4
ARM GAS  /tmp/cc9tOEVd.s 			page 31


 1095 0026 5A40     		eors	r2, r2, r3
 1096              		.loc 1 509 12 view .LVU318
 1097 0028 C38D     		ldrh	r3, [r0, #46]
 1098 002a 92B2     		uxth	r2, r2
 1099 002c 9342     		cmp	r3, r2
 1100 002e 0CD1     		bne	.L54
 510:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1101              		.loc 1 510 13 is_stmt 1 view .LVU319
 1102              		.loc 1 510 27 is_stmt 0 view .LVU320
 1103 0030 00F13003 		add	r3, r0, #48
 1104              	.LVL67:
 1105              	.L56:
 1106              		.loc 1 510 27 view .LVU321
 1107 0034 50F8042B 		ldr	r2, [r0], #4	@ unaligned
 1108 0038 9842     		cmp	r0, r3
 1109 003a 41F8042B 		str	r2, [r1], #4	@ unaligned
 1110 003e F9D1     		bne	.L56
 511:Src/util.c    ****             timeoutCntSerial1  = 0;     // Reset timeout counter
 1111              		.loc 1 511 13 is_stmt 1 view .LVU322
 1112              		.loc 1 511 32 is_stmt 0 view .LVU323
 1113 0040 0023     		movs	r3, #0
 1114              	.LVL68:
 1115              		.loc 1 511 32 view .LVU324
 1116 0042 024A     		ldr	r2, .L58
 1117 0044 1380     		strh	r3, [r2]	@ movhi
 512:Src/util.c    ****             timeoutFlagSerial1 = 0;     // Clear timeout flag
 1118              		.loc 1 512 13 is_stmt 1 view .LVU325
 1119              		.loc 1 512 32 is_stmt 0 view .LVU326
 1120 0046 024A     		ldr	r2, .L58+4
 1121 0048 1370     		strb	r3, [r2]
 1122              	.LVL69:
 1123              	.L54:
 1124              		.loc 1 512 32 view .LVU327
 1125              	.LBE25:
 1126              	.LBE24:
 513:Src/util.c    ****         }
 514:Src/util.c    ****     }
 515:Src/util.c    **** }
 1127              		.loc 1 515 1 view .LVU328
 1128 004a 10BD     		pop	{r4, pc}
 1129              	.L59:
 1130              		.align	2
 1131              	.L58:
 1132 004c 00000000 		.word	.LANCHOR7
 1133 0050 00000000 		.word	.LANCHOR8
 1134              		.cfi_endproc
 1135              	.LFE69:
 1137              		.section	.text.usart1_rx_check,"ax",%progbits
 1138              		.align	1
 1139              		.global	usart1_rx_check
 1140              		.syntax unified
 1141              		.thumb
 1142              		.thumb_func
 1143              		.fpu softvfp
 1145              	usart1_rx_check:
 1146              	.LFB68:
 434:Src/util.c    ****     #ifdef SERIAL_DEBUG
ARM GAS  /tmp/cc9tOEVd.s 			page 32


 1147              		.loc 1 434 1 is_stmt 1 view -0
 1148              		.cfi_startproc
 1149              		@ args = 0, pretend = 0, frame = 0
 1150              		@ frame_needed = 0, uses_anonymous_args = 0
 457:Src/util.c    ****     uint32_t pos;
 1151              		.loc 1 457 5 view .LVU330
 458:Src/util.c    ****     uint8_t *ptr;
 1152              		.loc 1 458 5 view .LVU331
 459:Src/util.c    **** 
 1153              		.loc 1 459 5 view .LVU332
 461:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1154              		.loc 1 461 5 view .LVU333
 434:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1155              		.loc 1 434 1 is_stmt 0 view .LVU334
 1156 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1157              	.LCFI17:
 1158              		.cfi_def_cfa_offset 24
 1159              		.cfi_offset 3, -24
 1160              		.cfi_offset 4, -20
 1161              		.cfi_offset 5, -16
 1162              		.cfi_offset 6, -12
 1163              		.cfi_offset 7, -8
 1164              		.cfi_offset 14, -4
 461:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1165              		.loc 1 461 28 view .LVU335
 1166 0002 0420     		movs	r0, #4
 1167 0004 FFF7FEFF 		bl	dma_transfer_number_get
 1168              	.LVL70:
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1169              		.loc 1 462 13 view .LVU336
 1170 0008 194D     		ldr	r5, .L71
 461:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1171              		.loc 1 461 9 view .LVU337
 1172 000a C0F58074 		rsb	r4, r0, #256
 1173              	.LVL71:
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1174              		.loc 1 462 5 is_stmt 1 view .LVU338
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1175              		.loc 1 462 13 is_stmt 0 view .LVU339
 1176 000e 2968     		ldr	r1, [r5]
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1177              		.loc 1 462 8 view .LVU340
 1178 0010 A142     		cmp	r1, r4
 1179 0012 12D0     		beq	.L61
 463:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 1180              		.loc 1 463 9 is_stmt 1 view .LVU341
 1181              	.LVL72:
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1182              		.loc 1 464 9 view .LVU342
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1183              		.loc 1 464 12 is_stmt 0 view .LVU343
 1184 0014 18D2     		bcs	.L62
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1185              		.loc 1 464 35 discriminator 1 view .LVU344
 1186 0016 631A     		subs	r3, r4, r1
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1187              		.loc 1 464 27 discriminator 1 view .LVU345
ARM GAS  /tmp/cc9tOEVd.s 			page 33


 1188 0018 302B     		cmp	r3, #48
 1189 001a 15D1     		bne	.L62
 465:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1190              		.loc 1 465 13 is_stmt 1 view .LVU346
 465:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1191              		.loc 1 465 25 is_stmt 0 view .LVU347
 1192 001c 154B     		ldr	r3, .L71+4
 1193 001e 1944     		add	r1, r1, r3
 465:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1194              		.loc 1 465 13 view .LVU348
 1195 0020 154B     		ldr	r3, .L71+8
 1196 0022 01F13002 		add	r2, r1, #48
 1197              	.L63:
 1198 0026 51F8040B 		ldr	r0, [r1], #4	@ unaligned
 1199 002a 9142     		cmp	r1, r2
 1200 002c 43F8040B 		str	r0, [r3], #4	@ unaligned
 1201 0030 F9D1     		bne	.L63
 1202              	.LVL73:
 1203              	.L64:
 473:Src/util.c    ****         }
 1204              		.loc 1 473 13 is_stmt 1 view .LVU349
 1205 0032 1249     		ldr	r1, .L71+12
 1206 0034 1048     		ldr	r0, .L71+8
 1207 0036 FFF7FEFF 		bl	usart_process_data
 1208              	.LVL74:
 1209              	.L61:
 476:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1210              		.loc 1 476 5 view .LVU350
 477:Src/util.c    ****         old_pos = 0;
 1211              		.loc 1 477 5 view .LVU351
 477:Src/util.c    ****         old_pos = 0;
 1212              		.loc 1 477 8 is_stmt 0 view .LVU352
 1213 003a B4F5807F 		cmp	r4, #256
 478:Src/util.c    ****     }
 1214              		.loc 1 478 17 view .LVU353
 1215 003e 0ABF     		itet	eq
 1216 0040 0023     		moveq	r3, #0
 476:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1217              		.loc 1 476 13 view .LVU354
 1218 0042 2C60     		strne	r4, [r5]
 478:Src/util.c    ****     }
 1219              		.loc 1 478 9 is_stmt 1 view .LVU355
 478:Src/util.c    ****     }
 1220              		.loc 1 478 17 is_stmt 0 view .LVU356
 1221 0044 2B60     		streq	r3, [r5]
 481:Src/util.c    **** 
 1222              		.loc 1 481 1 view .LVU357
 1223 0046 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1224              	.LVL75:
 1225              	.L62:
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1226              		.loc 1 467 16 is_stmt 1 view .LVU358
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1227              		.loc 1 467 36 is_stmt 0 view .LVU359
 1228 0048 C1F58076 		rsb	r6, r1, #256
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1229              		.loc 1 467 46 view .LVU360
ARM GAS  /tmp/cc9tOEVd.s 			page 34


 1230 004c 3319     		adds	r3, r6, r4
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1231              		.loc 1 467 19 view .LVU361
 1232 004e 302B     		cmp	r3, #48
 1233 0050 F3D1     		bne	.L61
 468:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1234              		.loc 1 468 13 is_stmt 1 view .LVU362
 1235 0052 094B     		ldr	r3, .L71+8
 468:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1236              		.loc 1 468 25 is_stmt 0 view .LVU363
 1237 0054 074F     		ldr	r7, .L71+4
 468:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1238              		.loc 1 468 13 view .LVU364
 1239 0056 3246     		mov	r2, r6
 1240 0058 1846     		mov	r0, r3
 1241 005a 3944     		add	r1, r1, r7
 1242 005c FFF7FEFF 		bl	memcpy
 1243              	.LVL76:
 469:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1244              		.loc 1 469 13 is_stmt 1 view .LVU365
 469:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1245              		.loc 1 469 16 is_stmt 0 view .LVU366
 1246 0060 002C     		cmp	r4, #0
 1247 0062 E6D0     		beq	.L64
 470:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 1248              		.loc 1 470 17 is_stmt 1 view .LVU367
 1249              	.LVL77:
 471:Src/util.c    ****             }
 1250              		.loc 1 471 17 view .LVU368
 1251 0064 2246     		mov	r2, r4
 1252 0066 3946     		mov	r1, r7
 1253 0068 3044     		add	r0, r0, r6
 1254 006a FFF7FEFF 		bl	memcpy
 1255              	.LVL78:
 1256 006e E0E7     		b	.L64
 1257              	.L72:
 1258              		.align	2
 1259              	.L71:
 1260 0070 00000000 		.word	.LANCHOR10
 1261 0074 00000000 		.word	.LANCHOR1
 1262 0078 00000000 		.word	.LANCHOR11
 1263 007c 00000000 		.word	.LANCHOR9
 1264              		.cfi_endproc
 1265              	.LFE68:
 1267              		.section	.text.usart0_rx_check,"ax",%progbits
 1268              		.align	1
 1269              		.global	usart0_rx_check
 1270              		.syntax unified
 1271              		.thumb
 1272              		.thumb_func
 1273              		.fpu softvfp
 1275              	usart0_rx_check:
 1276              	.LFB70:
 516:Src/util.c    **** #endif // SERIAL_FEEDBACK
 517:Src/util.c    **** 
 518:Src/util.c    **** 
 519:Src/util.c    **** /* =========================== USART0 READ Functions =========================== */
ARM GAS  /tmp/cc9tOEVd.s 			page 35


 520:Src/util.c    **** 
 521:Src/util.c    **** /*
 522:Src/util.c    ****  * Check for new data received on USART with DMA: refactored function from https://github.com/MaJer
 523:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 524:Src/util.c    ****  */
 525:Src/util.c    **** void usart0_rx_check(void)
 526:Src/util.c    **** {
 1277              		.loc 1 526 1 view -0
 1278              		.cfi_startproc
 1279              		@ args = 0, pretend = 0, frame = 0
 1280              		@ frame_needed = 0, uses_anonymous_args = 0
 1281              		@ link register save eliminated.
 527:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 528:Src/util.c    ****     static uint32_t old_pos;
 529:Src/util.c    ****     uint32_t pos;
 530:Src/util.c    ****     uint8_t *ptr;
 531:Src/util.c    **** 
 532:Src/util.c    ****     pos = rx0_buffer_len - dma_transfer_number_get(USART0_RX_DMA_CH);           // Calculate curren
 533:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 534:Src/util.c    ****         ptr = (uint8_t *)&command_raw;                                          // Initialize the p
 535:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == command_len) {                  // "Linear" buffer 
 536:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], command_len);                     // Copy data. This 
 537:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 538:Src/util.c    ****         } else if ((rx0_buffer_len - old_pos + pos) == command_len) {           // "Overflow" buffe
 539:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], rx0_buffer_len - old_pos);        // First copy data 
 540:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 541:Src/util.c    ****                 ptr += rx0_buffer_len - old_pos;                                // Update position
 542:Src/util.c    ****                 memcpy(ptr, &rx0_buffer[0], pos);                               // Copy remaining d
 543:Src/util.c    ****             }
 544:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 545:Src/util.c    ****         }
 546:Src/util.c    ****     }
 547:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 548:Src/util.c    ****     if (old_pos == rx0_buffer_len) {                                            // Check and manual
 549:Src/util.c    ****         old_pos = 0;
 550:Src/util.c    ****     }
 551:Src/util.c    ****     #endif  // SERIAL_AUX_RX
 552:Src/util.c    **** }
 1282              		.loc 1 552 1 view .LVU370
 1283 0000 7047     		bx	lr
 1284              		.cfi_endproc
 1285              	.LFE70:
 1287              		.section	.text.aux_print_to_console,"ax",%progbits
 1288              		.align	1
 1289              		.global	aux_print_to_console
 1290              		.syntax unified
 1291              		.thumb
 1292              		.thumb_func
 1293              		.fpu softvfp
 1295              	aux_print_to_console:
 1296              	.LFB80:
 1297              		.cfi_startproc
 1298              		@ args = 0, pretend = 0, frame = 0
 1299              		@ frame_needed = 0, uses_anonymous_args = 0
 1300              		@ link register save eliminated.
 1301 0000 7047     		bx	lr
 1302              		.cfi_endproc
ARM GAS  /tmp/cc9tOEVd.s 			page 36


 1303              	.LFE80:
 1305              		.section	.text.i2c_writeBytes,"ax",%progbits
 1306              		.align	1
 1307              		.global	i2c_writeBytes
 1308              		.syntax unified
 1309              		.thumb
 1310              		.thumb_func
 1311              		.fpu softvfp
 1313              	i2c_writeBytes:
 1314              	.LVL79:
 1315              	.LFB72:
 553:Src/util.c    **** 
 554:Src/util.c    **** /*
 555:Src/util.c    ****  * Process command UART0 Rx data
 556:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
 557:Src/util.c    ****  */
 558:Src/util.c    **** #ifdef SERIAL_AUX_RX
 559:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out)
 560:Src/util.c    **** {
 561:Src/util.c    ****   #ifdef CONTROL_IBUS
 562:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
 563:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
 564:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
 565:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
 566:Src/util.c    ****       }
 567:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
 568:Src/util.c    ****         *command_out = *command_in;
 569:Src/util.c    ****         timeoutCntSerial0  = 0;        // Reset timeout counter
 570:Src/util.c    ****         timeoutFlagSerial0 = 0;        // Clear timeout flag
 571:Src/util.c    ****       }
 572:Src/util.c    ****     }
 573:Src/util.c    ****   #endif
 574:Src/util.c    **** }
 575:Src/util.c    **** #endif
 576:Src/util.c    **** 
 577:Src/util.c    **** 
 578:Src/util.c    **** /* =========================== AUX Serial Print data =========================== */
 579:Src/util.c    **** 
 580:Src/util.c    **** void aux_print_to_console(void)
 581:Src/util.c    **** {
 582:Src/util.c    **** #if defined(SERIAL_DEBUG) && defined(SERIAL_AUX_RX)
 583:Src/util.c    ****     #ifdef CONTROL_IBUS
 584:Src/util.c    ****     if (print_aux & PRINT_AUX) {
 585:Src/util.c    ****         log_i( "Ch1: %d Ch2: %d Sw: %u\r\n", cmd1, cmd2, cmdSwitch);
 586:Src/util.c    ****     }
 587:Src/util.c    ****     #endif
 588:Src/util.c    **** #endif
 589:Src/util.c    **** }
 590:Src/util.c    **** 
 591:Src/util.c    **** 
 592:Src/util.c    **** /* =========================== I2C WRITE Functions =========================== */
 593:Src/util.c    **** 
 594:Src/util.c    **** /*
 595:Src/util.c    ****  * write bytes to chip register
 596:Src/util.c    ****  */
 597:Src/util.c    **** int8_t i2c_writeBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data)
 598:Src/util.c    **** {
ARM GAS  /tmp/cc9tOEVd.s 			page 37


 1316              		.loc 1 598 1 view -0
 1317              		.cfi_startproc
 1318              		@ args = 0, pretend = 0, frame = 0
 1319              		@ frame_needed = 0, uses_anonymous_args = 0
 599:Src/util.c    **** 
 600:Src/util.c    ****     // assign WRITE command
 601:Src/util.c    ****     i2c_ReadWriteCmd    = WRITE;
 1320              		.loc 1 601 5 view .LVU372
 598:Src/util.c    **** 
 1321              		.loc 1 598 1 is_stmt 0 view .LVU373
 1322 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1323              	.LCFI18:
 1324              		.cfi_def_cfa_offset 24
 1325              		.cfi_offset 4, -24
 1326              		.cfi_offset 5, -20
 1327              		.cfi_offset 6, -16
 1328              		.cfi_offset 7, -12
 1329              		.cfi_offset 8, -8
 1330              		.cfi_offset 14, -4
 1331              		.loc 1 601 25 view .LVU374
 1332 0004 0124     		movs	r4, #1
 602:Src/util.c    **** 
 603:Src/util.c    ****     // assign inputs
 604:Src/util.c    ****     i2c_status          = -1;
 1333              		.loc 1 604 25 view .LVU375
 1334 0006 FF26     		movs	r6, #255
 601:Src/util.c    **** 
 1335              		.loc 1 601 25 view .LVU376
 1336 0008 184D     		ldr	r5, .L88
 605:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1337              		.loc 1 605 37 view .LVU377
 1338 000a A040     		lsls	r0, r0, r4
 1339              	.LVL80:
 601:Src/util.c    **** 
 1340              		.loc 1 601 25 view .LVU378
 1341 000c 2C70     		strb	r4, [r5]
 604:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1342              		.loc 1 604 5 is_stmt 1 view .LVU379
 604:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1343              		.loc 1 604 25 is_stmt 0 view .LVU380
 1344 000e 184D     		ldr	r5, .L88+4
 1345              		.loc 1 605 37 view .LVU381
 1346 0010 C0B2     		uxtb	r0, r0
 604:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1347              		.loc 1 604 25 view .LVU382
 1348 0012 2E70     		strb	r6, [r5]
 1349              		.loc 1 605 5 is_stmt 1 view .LVU383
 1350              		.loc 1 605 25 is_stmt 0 view .LVU384
 1351 0014 174E     		ldr	r6, .L88+8
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 607:Src/util.c    ****     i2c_txbuffer        = data;
 608:Src/util.c    ****     i2c_nDABytes        = length;
 609:Src/util.c    ****     i2c_nRABytes        = 1;
 610:Src/util.c    **** 
 611:Src/util.c    ****     uint16_t i2c_timeout = 0;
 612:Src/util.c    **** 
 613:Src/util.c    ****     // enable the I2C0 interrupt
ARM GAS  /tmp/cc9tOEVd.s 			page 38


 614:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 615:Src/util.c    **** 
 616:Src/util.c    ****     // the master waits until the I2C bus is idle
 617:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1352              		.loc 1 617 11 view .LVU385
 1353 0016 184F     		ldr	r7, .L88+12
 605:Src/util.c    ****     i2c_regAddress      = regAddr;
 1354              		.loc 1 605 25 view .LVU386
 1355 0018 3070     		strb	r0, [r6]
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 1356              		.loc 1 606 5 is_stmt 1 view .LVU387
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 1357              		.loc 1 606 25 is_stmt 0 view .LVU388
 1358 001a 1848     		ldr	r0, .L88+16
 608:Src/util.c    ****     i2c_nRABytes        = 1;
 1359              		.loc 1 608 25 view .LVU389
 1360 001c 184E     		ldr	r6, .L88+20
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 1361              		.loc 1 606 25 view .LVU390
 1362 001e 0170     		strb	r1, [r0]
 607:Src/util.c    ****     i2c_nDABytes        = length;
 1363              		.loc 1 607 5 is_stmt 1 view .LVU391
 607:Src/util.c    ****     i2c_nDABytes        = length;
 1364              		.loc 1 607 25 is_stmt 0 view .LVU392
 1365 0020 1849     		ldr	r1, .L88+24
 1366              	.LVL81:
 614:Src/util.c    **** 
 1367              		.loc 1 614 5 view .LVU393
 1368 0022 1948     		ldr	r0, .L88+28
 607:Src/util.c    ****     i2c_nDABytes        = length;
 1369              		.loc 1 607 25 view .LVU394
 1370 0024 0B60     		str	r3, [r1]
 608:Src/util.c    ****     i2c_nRABytes        = 1;
 1371              		.loc 1 608 5 is_stmt 1 view .LVU395
 609:Src/util.c    **** 
 1372              		.loc 1 609 25 is_stmt 0 view .LVU396
 1373 0026 194B     		ldr	r3, .L88+32
 1374              	.LVL82:
 614:Src/util.c    **** 
 1375              		.loc 1 614 5 view .LVU397
 1376 0028 4FF4E061 		mov	r1, #1792
 608:Src/util.c    ****     i2c_nRABytes        = 1;
 1377              		.loc 1 608 25 view .LVU398
 1378 002c 3270     		strb	r2, [r6]
 1379              	.LVL83:
 609:Src/util.c    **** 
 1380              		.loc 1 609 5 is_stmt 1 view .LVU399
 609:Src/util.c    **** 
 1381              		.loc 1 609 25 is_stmt 0 view .LVU400
 1382 002e 1C70     		strb	r4, [r3]
 611:Src/util.c    **** 
 1383              		.loc 1 611 5 is_stmt 1 view .LVU401
 1384              	.LVL84:
 614:Src/util.c    **** 
 1385              		.loc 1 614 5 view .LVU402
 1386 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1387              	.LVL85:
ARM GAS  /tmp/cc9tOEVd.s 			page 39


 1388              		.loc 1 617 5 view .LVU403
 1389              		.loc 1 617 10 is_stmt 0 view .LVU404
 1390 0034 44F62164 		movw	r4, #20001
 1391              		.loc 1 617 11 view .LVU405
 1392 0038 DFF84C80 		ldr	r8, .L88+28
 1393              	.LVL86:
 1394              	.L77:
 1395              		.loc 1 617 75 is_stmt 1 discriminator 2 view .LVU406
 1396              		.loc 1 617 10 discriminator 2 view .LVU407
 1397              		.loc 1 617 11 is_stmt 0 discriminator 2 view .LVU408
 1398 003c 3946     		mov	r1, r7
 1399 003e 4046     		mov	r0, r8
 1400 0040 FFF7FEFF 		bl	i2c_flag_get
 1401              	.LVL87:
 1402              		.loc 1 617 10 discriminator 2 view .LVU409
 1403 0044 18B1     		cbz	r0, .L76
 1404              	.LVL88:
 1405              		.loc 1 617 50 discriminator 1 view .LVU410
 1406 0046 013C     		subs	r4, r4, #1
 1407              	.LVL89:
 1408              		.loc 1 617 50 discriminator 1 view .LVU411
 1409 0048 A4B2     		uxth	r4, r4
 1410 004a 002C     		cmp	r4, #0
 1411 004c F6D1     		bne	.L77
 1412              	.L76:
 618:Src/util.c    **** 
 619:Src/util.c    ****     // the master sends a start condition to I2C bus
 620:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1413              		.loc 1 620 5 is_stmt 1 view .LVU412
 1414 004e 0E48     		ldr	r0, .L88+28
 1415 0050 FFF7FEFF 		bl	i2c_start_on_bus
 1416              	.LVL90:
 621:Src/util.c    ****     
 622:Src/util.c    ****     // Wait until all data bytes are sent/received
 623:Src/util.c    ****     i2c_timeout = 0;
 1417              		.loc 1 623 5 view .LVU413
 624:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1418              		.loc 1 624 5 view .LVU414
 1419              		.loc 1 624 10 is_stmt 0 view .LVU415
 1420 0054 44F62163 		movw	r3, #20001
 1421              	.LVL91:
 1422              	.L79:
 1423              		.loc 1 624 53 is_stmt 1 discriminator 2 view .LVU416
 1424              		.loc 1 624 10 discriminator 2 view .LVU417
 1425              		.loc 1 624 24 is_stmt 0 discriminator 2 view .LVU418
 1426 0058 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1427              		.loc 1 624 10 discriminator 2 view .LVU419
 1428 005a 1AB1     		cbz	r2, .L78
 1429              	.LVL92:
 1430              		.loc 1 624 28 discriminator 1 view .LVU420
 1431 005c 013B     		subs	r3, r3, #1
 1432              	.LVL93:
 1433              		.loc 1 624 28 discriminator 1 view .LVU421
 1434 005e 9BB2     		uxth	r3, r3
 1435 0060 002B     		cmp	r3, #0
 1436 0062 F9D1     		bne	.L79
 1437              	.L78:
ARM GAS  /tmp/cc9tOEVd.s 			page 40


 625:Src/util.c    **** 
 626:Src/util.c    ****     return i2c_status;
 1438              		.loc 1 626 5 is_stmt 1 view .LVU422
 1439              		.loc 1 626 12 is_stmt 0 view .LVU423
 1440 0064 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 627:Src/util.c    **** 
 628:Src/util.c    **** }
 1441              		.loc 1 628 1 view .LVU424
 1442 0066 40B2     		sxtb	r0, r0
 1443 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1444              	.L89:
 1445              		.align	2
 1446              	.L88:
 1447 006c 00000000 		.word	.LANCHOR12
 1448 0070 00000000 		.word	.LANCHOR13
 1449 0074 00000000 		.word	.LANCHOR14
 1450 0078 02000080 		.word	-2147483646
 1451 007c 00000000 		.word	.LANCHOR15
 1452 0080 00000000 		.word	.LANCHOR17
 1453 0084 00000000 		.word	.LANCHOR16
 1454 0088 00540040 		.word	1073763328
 1455 008c 00000000 		.word	.LANCHOR18
 1456              		.cfi_endproc
 1457              	.LFE72:
 1459              		.section	.text.i2c_writeByte,"ax",%progbits
 1460              		.align	1
 1461              		.global	i2c_writeByte
 1462              		.syntax unified
 1463              		.thumb
 1464              		.thumb_func
 1465              		.fpu softvfp
 1467              	i2c_writeByte:
 1468              	.LVL94:
 1469              	.LFB73:
 629:Src/util.c    **** 
 630:Src/util.c    **** 
 631:Src/util.c    **** /*
 632:Src/util.c    ****  * write 1 byte to chip register
 633:Src/util.c    ****  */
 634:Src/util.c    **** int8_t i2c_writeByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t data)
 635:Src/util.c    **** {
 1470              		.loc 1 635 1 is_stmt 1 view -0
 1471              		.cfi_startproc
 1472              		@ args = 0, pretend = 0, frame = 8
 1473              		@ frame_needed = 0, uses_anonymous_args = 0
 636:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1474              		.loc 1 636 5 view .LVU426
 635:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1475              		.loc 1 635 1 is_stmt 0 view .LVU427
 1476 0000 07B5     		push	{r0, r1, r2, lr}
 1477              	.LCFI19:
 1478              		.cfi_def_cfa_offset 16
 1479              		.cfi_offset 14, -4
 635:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1480              		.loc 1 635 1 view .LVU428
 1481 0002 8DF80720 		strb	r2, [sp, #7]
 1482              		.loc 1 636 12 view .LVU429
ARM GAS  /tmp/cc9tOEVd.s 			page 41


 1483 0006 0DF10703 		add	r3, sp, #7
 1484 000a 0122     		movs	r2, #1
 1485              	.LVL95:
 1486              		.loc 1 636 12 view .LVU430
 1487 000c FFF7FEFF 		bl	i2c_writeBytes
 1488              	.LVL96:
 637:Src/util.c    **** }
 1489              		.loc 1 637 1 view .LVU431
 1490 0010 03B0     		add	sp, sp, #12
 1491              	.LCFI20:
 1492              		.cfi_def_cfa_offset 4
 1493              		@ sp needed
 1494 0012 5DF804FB 		ldr	pc, [sp], #4
 1495              		.cfi_endproc
 1496              	.LFE73:
 1498              		.section	.text.i2c_readBytes,"ax",%progbits
 1499              		.align	1
 1500              		.global	i2c_readBytes
 1501              		.syntax unified
 1502              		.thumb
 1503              		.thumb_func
 1504              		.fpu softvfp
 1506              	i2c_readBytes:
 1507              	.LVL97:
 1508              	.LFB75:
 638:Src/util.c    **** 
 639:Src/util.c    **** 
 640:Src/util.c    **** /*
 641:Src/util.c    ****  * write one bit to chip register
 642:Src/util.c    ****  */
 643:Src/util.c    **** int8_t i2c_writeBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 644:Src/util.c    ****     uint8_t b;
 645:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 646:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 647:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 648:Src/util.c    **** }
 649:Src/util.c    **** 
 650:Src/util.c    **** 
 651:Src/util.c    **** 
 652:Src/util.c    **** /* =========================== I2C READ Functions =========================== */
 653:Src/util.c    **** 
 654:Src/util.c    **** /*
 655:Src/util.c    ****  * read bytes from chip register
 656:Src/util.c    ****  */
 657:Src/util.c    **** int8_t i2c_readBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data) 
 658:Src/util.c    **** {
 1509              		.loc 1 658 1 is_stmt 1 view -0
 1510              		.cfi_startproc
 1511              		@ args = 0, pretend = 0, frame = 0
 1512              		@ frame_needed = 0, uses_anonymous_args = 0
 659:Src/util.c    **** 
 660:Src/util.c    ****     // assign READ command
 661:Src/util.c    ****     i2c_ReadWriteCmd    = READ;
 1513              		.loc 1 661 5 view .LVU433
 658:Src/util.c    **** 
 1514              		.loc 1 658 1 is_stmt 0 view .LVU434
 1515 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
ARM GAS  /tmp/cc9tOEVd.s 			page 42


 1516              	.LCFI21:
 1517              		.cfi_def_cfa_offset 24
 1518              		.cfi_offset 4, -24
 1519              		.cfi_offset 5, -20
 1520              		.cfi_offset 6, -16
 1521              		.cfi_offset 7, -12
 1522              		.cfi_offset 8, -8
 1523              		.cfi_offset 14, -4
 1524              		.loc 1 661 25 view .LVU435
 1525 0004 0024     		movs	r4, #0
 662:Src/util.c    ****     
 663:Src/util.c    ****     // assign inputs
 664:Src/util.c    ****     i2c_status          = -1;
 1526              		.loc 1 664 25 view .LVU436
 1527 0006 FF26     		movs	r6, #255
 661:Src/util.c    ****     
 1528              		.loc 1 661 25 view .LVU437
 1529 0008 1C4D     		ldr	r5, .L105
 665:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1530              		.loc 1 665 37 view .LVU438
 1531 000a 4000     		lsls	r0, r0, #1
 1532              	.LVL98:
 661:Src/util.c    ****     
 1533              		.loc 1 661 25 view .LVU439
 1534 000c 2C70     		strb	r4, [r5]
 664:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1535              		.loc 1 664 5 is_stmt 1 view .LVU440
 664:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1536              		.loc 1 664 25 is_stmt 0 view .LVU441
 1537 000e 1C4D     		ldr	r5, .L105+4
 1538              		.loc 1 665 37 view .LVU442
 1539 0010 C0B2     		uxtb	r0, r0
 664:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1540              		.loc 1 664 25 view .LVU443
 1541 0012 2E70     		strb	r6, [r5]
 1542              		.loc 1 665 5 is_stmt 1 view .LVU444
 1543              		.loc 1 665 25 is_stmt 0 view .LVU445
 1544 0014 1B4E     		ldr	r6, .L105+8
 1545 0016 3070     		strb	r0, [r6]
 666:Src/util.c    ****     i2c_regAddress      = regAddr;
 1546              		.loc 1 666 5 is_stmt 1 view .LVU446
 1547              		.loc 1 666 25 is_stmt 0 view .LVU447
 1548 0018 1B48     		ldr	r0, .L105+12
 667:Src/util.c    ****     i2c_rxbuffer        = data;
 668:Src/util.c    ****     i2c_nDABytes        = length;
 1549              		.loc 1 668 25 view .LVU448
 1550 001a 1C4E     		ldr	r6, .L105+16
 666:Src/util.c    ****     i2c_regAddress      = regAddr;
 1551              		.loc 1 666 25 view .LVU449
 1552 001c 0170     		strb	r1, [r0]
 667:Src/util.c    ****     i2c_rxbuffer        = data;
 1553              		.loc 1 667 5 is_stmt 1 view .LVU450
 1554              		.loc 1 668 25 is_stmt 0 view .LVU451
 1555 001e 3270     		strb	r2, [r6]
 669:Src/util.c    ****     i2c_nRABytes        = 1;
 1556              		.loc 1 669 25 view .LVU452
 1557 0020 0122     		movs	r2, #1
ARM GAS  /tmp/cc9tOEVd.s 			page 43


 1558              	.LVL99:
 667:Src/util.c    ****     i2c_rxbuffer        = data;
 1559              		.loc 1 667 25 view .LVU453
 1560 0022 1B49     		ldr	r1, .L105+20
 1561              	.LVL100:
 670:Src/util.c    **** 
 671:Src/util.c    ****     uint16_t i2c_timeout = 0;
 672:Src/util.c    **** 
 673:Src/util.c    ****     // enable the I2C0 interrupt
 674:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 1562              		.loc 1 674 5 view .LVU454
 1563 0024 1B48     		ldr	r0, .L105+24
 667:Src/util.c    ****     i2c_nDABytes        = length;
 1564              		.loc 1 667 25 view .LVU455
 1565 0026 0B60     		str	r3, [r1]
 668:Src/util.c    ****     i2c_nRABytes        = 1;
 1566              		.loc 1 668 5 is_stmt 1 view .LVU456
 669:Src/util.c    **** 
 1567              		.loc 1 669 5 view .LVU457
 669:Src/util.c    **** 
 1568              		.loc 1 669 25 is_stmt 0 view .LVU458
 1569 0028 1B4B     		ldr	r3, .L105+28
 1570              	.LVL101:
 1571              		.loc 1 674 5 view .LVU459
 1572 002a 4FF4E061 		mov	r1, #1792
 669:Src/util.c    **** 
 1573              		.loc 1 669 25 view .LVU460
 1574 002e 1A70     		strb	r2, [r3]
 1575              	.LVL102:
 671:Src/util.c    **** 
 1576              		.loc 1 671 5 is_stmt 1 view .LVU461
 1577              		.loc 1 674 5 view .LVU462
 1578 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1579              	.LVL103:
 675:Src/util.c    **** 
 676:Src/util.c    ****     if(2 == i2c_nDABytes){
 1580              		.loc 1 676 5 view .LVU463
 1581              		.loc 1 676 10 is_stmt 0 view .LVU464
 1582 0034 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1583              		.loc 1 676 7 view .LVU465
 1584 0036 022B     		cmp	r3, #2
 1585 0038 03D1     		bne	.L92
 677:Src/util.c    ****         i2c_ackpos_config(MPU_I2C, I2C_ACKPOS_NEXT);    // send ACK for the next byte
 1586              		.loc 1 677 9 is_stmt 1 view .LVU466
 1587 003a 2146     		mov	r1, r4
 1588 003c 1548     		ldr	r0, .L105+24
 1589 003e FFF7FEFF 		bl	i2c_ackpos_config
 1590              	.LVL104:
 1591              	.L92:
 658:Src/util.c    **** 
 1592              		.loc 1 658 1 is_stmt 0 discriminator 2 view .LVU467
 1593 0042 44F62164 		movw	r4, #20001
 678:Src/util.c    ****     }
 679:Src/util.c    **** 
 680:Src/util.c    ****     // the master waits until the I2C bus is idle
 681:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1594              		.loc 1 681 11 discriminator 2 view .LVU468
ARM GAS  /tmp/cc9tOEVd.s 			page 44


 1595 0046 154F     		ldr	r7, .L105+32
 1596 0048 DFF84880 		ldr	r8, .L105+24
 1597              	.LVL105:
 1598              	.L94:
 1599              		.loc 1 681 75 is_stmt 1 discriminator 2 view .LVU469
 1600              		.loc 1 681 10 discriminator 2 view .LVU470
 1601              		.loc 1 681 11 is_stmt 0 discriminator 2 view .LVU471
 1602 004c 3946     		mov	r1, r7
 1603 004e 4046     		mov	r0, r8
 1604 0050 FFF7FEFF 		bl	i2c_flag_get
 1605              	.LVL106:
 1606              		.loc 1 681 10 discriminator 2 view .LVU472
 1607 0054 18B1     		cbz	r0, .L93
 1608              	.LVL107:
 1609              		.loc 1 681 50 discriminator 1 view .LVU473
 1610 0056 013C     		subs	r4, r4, #1
 1611              	.LVL108:
 1612              		.loc 1 681 50 discriminator 1 view .LVU474
 1613 0058 A4B2     		uxth	r4, r4
 1614 005a 002C     		cmp	r4, #0
 1615 005c F6D1     		bne	.L94
 1616              	.L93:
 682:Src/util.c    **** 
 683:Src/util.c    ****     // the master sends a start condition to I2C bus
 684:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1617              		.loc 1 684 5 is_stmt 1 view .LVU475
 1618 005e 0D48     		ldr	r0, .L105+24
 1619 0060 FFF7FEFF 		bl	i2c_start_on_bus
 1620              	.LVL109:
 685:Src/util.c    **** 
 686:Src/util.c    ****     // Wait until all data bytes are sent/received
 687:Src/util.c    ****     i2c_timeout = 0;
 1621              		.loc 1 687 5 view .LVU476
 688:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1622              		.loc 1 688 5 view .LVU477
 1623              		.loc 1 688 10 is_stmt 0 view .LVU478
 1624 0064 44F62163 		movw	r3, #20001
 1625              	.LVL110:
 1626              	.L96:
 1627              		.loc 1 688 53 is_stmt 1 discriminator 2 view .LVU479
 1628              		.loc 1 688 10 discriminator 2 view .LVU480
 1629              		.loc 1 688 24 is_stmt 0 discriminator 2 view .LVU481
 1630 0068 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1631              		.loc 1 688 10 discriminator 2 view .LVU482
 1632 006a 1AB1     		cbz	r2, .L95
 1633              	.LVL111:
 1634              		.loc 1 688 28 discriminator 1 view .LVU483
 1635 006c 013B     		subs	r3, r3, #1
 1636              	.LVL112:
 1637              		.loc 1 688 28 discriminator 1 view .LVU484
 1638 006e 9BB2     		uxth	r3, r3
 1639 0070 002B     		cmp	r3, #0
 1640 0072 F9D1     		bne	.L96
 1641              	.L95:
 689:Src/util.c    **** 
 690:Src/util.c    ****     // Return status
 691:Src/util.c    ****     return i2c_status;
ARM GAS  /tmp/cc9tOEVd.s 			page 45


 1642              		.loc 1 691 5 is_stmt 1 view .LVU485
 1643              		.loc 1 691 12 is_stmt 0 view .LVU486
 1644 0074 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 692:Src/util.c    **** 
 693:Src/util.c    **** }
 1645              		.loc 1 693 1 view .LVU487
 1646 0076 40B2     		sxtb	r0, r0
 1647 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1648              	.L106:
 1649              		.align	2
 1650              	.L105:
 1651 007c 00000000 		.word	.LANCHOR12
 1652 0080 00000000 		.word	.LANCHOR13
 1653 0084 00000000 		.word	.LANCHOR14
 1654 0088 00000000 		.word	.LANCHOR15
 1655 008c 00000000 		.word	.LANCHOR17
 1656 0090 00000000 		.word	.LANCHOR19
 1657 0094 00540040 		.word	1073763328
 1658 0098 00000000 		.word	.LANCHOR18
 1659 009c 02000080 		.word	-2147483646
 1660              		.cfi_endproc
 1661              	.LFE75:
 1663              		.section	.text.i2c_readByte,"ax",%progbits
 1664              		.align	1
 1665              		.global	i2c_readByte
 1666              		.syntax unified
 1667              		.thumb
 1668              		.thumb_func
 1669              		.fpu softvfp
 1671              	i2c_readByte:
 1672              	.LVL113:
 1673              	.LFB76:
 694:Src/util.c    **** 
 695:Src/util.c    **** 
 696:Src/util.c    **** /*
 697:Src/util.c    ****  * read 1 byte from chip register
 698:Src/util.c    ****  */
 699:Src/util.c    **** int8_t i2c_readByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t *data)
 700:Src/util.c    **** {
 1674              		.loc 1 700 1 is_stmt 1 view -0
 1675              		.cfi_startproc
 1676              		@ args = 0, pretend = 0, frame = 0
 1677              		@ frame_needed = 0, uses_anonymous_args = 0
 1678              		@ link register save eliminated.
 701:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1679              		.loc 1 701 5 view .LVU489
 700:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1680              		.loc 1 700 1 is_stmt 0 view .LVU490
 1681 0000 1346     		mov	r3, r2
 1682              		.loc 1 701 12 view .LVU491
 1683 0002 0122     		movs	r2, #1
 1684              	.LVL114:
 1685              		.loc 1 701 12 view .LVU492
 1686 0004 FFF7FEBF 		b	i2c_readBytes
 1687              	.LVL115:
 1688              		.loc 1 701 12 view .LVU493
 1689              		.cfi_endproc
ARM GAS  /tmp/cc9tOEVd.s 			page 46


 1690              	.LFE76:
 1692              		.section	.text.i2c_writeBit,"ax",%progbits
 1693              		.align	1
 1694              		.global	i2c_writeBit
 1695              		.syntax unified
 1696              		.thumb
 1697              		.thumb_func
 1698              		.fpu softvfp
 1700              	i2c_writeBit:
 1701              	.LVL116:
 1702              	.LFB74:
 643:Src/util.c    ****     uint8_t b;
 1703              		.loc 1 643 87 is_stmt 1 view -0
 1704              		.cfi_startproc
 1705              		@ args = 0, pretend = 0, frame = 8
 1706              		@ frame_needed = 0, uses_anonymous_args = 0
 644:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 1707              		.loc 1 644 5 view .LVU495
 645:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1708              		.loc 1 645 5 view .LVU496
 643:Src/util.c    ****     uint8_t b;
 1709              		.loc 1 643 87 is_stmt 0 view .LVU497
 1710 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 1711              	.LCFI22:
 1712              		.cfi_def_cfa_offset 32
 1713              		.cfi_offset 4, -24
 1714              		.cfi_offset 5, -20
 1715              		.cfi_offset 6, -16
 1716              		.cfi_offset 7, -12
 1717              		.cfi_offset 8, -8
 1718              		.cfi_offset 14, -4
 643:Src/util.c    ****     uint8_t b;
 1719              		.loc 1 643 87 view .LVU498
 1720 0004 9046     		mov	r8, r2
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1721              		.loc 1 646 31 view .LVU499
 1722 0006 0124     		movs	r4, #1
 643:Src/util.c    ****     uint8_t b;
 1723              		.loc 1 643 87 view .LVU500
 1724 0008 1F46     		mov	r7, r3
 645:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1725              		.loc 1 645 5 view .LVU501
 1726 000a 0DF10702 		add	r2, sp, #7
 1727              	.LVL117:
 643:Src/util.c    ****     uint8_t b;
 1728              		.loc 1 643 87 view .LVU502
 1729 000e 0546     		mov	r5, r0
 1730 0010 0E46     		mov	r6, r1
 645:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1731              		.loc 1 645 5 view .LVU503
 1732 0012 FFF7FEFF 		bl	i2c_readByte
 1733              	.LVL118:
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1734              		.loc 1 646 5 is_stmt 1 view .LVU504
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1735              		.loc 1 646 31 is_stmt 0 view .LVU505
 1736 0016 04FA08F2 		lsl	r2, r4, r8
ARM GAS  /tmp/cc9tOEVd.s 			page 47


 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1737              		.loc 1 646 26 view .LVU506
 1738 001a 52B2     		sxtb	r2, r2
 1739 001c 9DF80740 		ldrb	r4, [sp, #7]	@ zero_extendqisi2
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1740              		.loc 1 646 7 view .LVU507
 1741 0020 57B1     		cbz	r7, .L109
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1742              		.loc 1 646 26 discriminator 1 view .LVU508
 1743 0022 2243     		orrs	r2, r2, r4
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1744              		.loc 1 646 7 discriminator 1 view .LVU509
 1745 0024 D2B2     		uxtb	r2, r2
 1746              	.L110:
 647:Src/util.c    **** }
 1747              		.loc 1 647 12 discriminator 4 view .LVU510
 1748 0026 3146     		mov	r1, r6
 1749 0028 2846     		mov	r0, r5
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1750              		.loc 1 646 7 discriminator 4 view .LVU511
 1751 002a 8DF80720 		strb	r2, [sp, #7]
 647:Src/util.c    **** }
 1752              		.loc 1 647 5 is_stmt 1 discriminator 4 view .LVU512
 647:Src/util.c    **** }
 1753              		.loc 1 647 12 is_stmt 0 discriminator 4 view .LVU513
 1754 002e FFF7FEFF 		bl	i2c_writeByte
 1755              	.LVL119:
 648:Src/util.c    **** 
 1756              		.loc 1 648 1 discriminator 4 view .LVU514
 1757 0032 02B0     		add	sp, sp, #8
 1758              	.LCFI23:
 1759              		.cfi_remember_state
 1760              		.cfi_def_cfa_offset 24
 1761              		@ sp needed
 1762 0034 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1763              	.L109:
 1764              	.LCFI24:
 1765              		.cfi_restore_state
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1766              		.loc 1 646 7 discriminator 2 view .LVU515
 1767 0038 24EA0202 		bic	r2, r4, r2
 1768 003c F3E7     		b	.L110
 1769              		.cfi_endproc
 1770              	.LFE74:
 1772              		.section	.text.i2c_readBit,"ax",%progbits
 1773              		.align	1
 1774              		.global	i2c_readBit
 1775              		.syntax unified
 1776              		.thumb
 1777              		.thumb_func
 1778              		.fpu softvfp
 1780              	i2c_readBit:
 1781              	.LVL120:
 1782              	.LFB77:
 702:Src/util.c    **** }
 703:Src/util.c    **** 
 704:Src/util.c    **** 
ARM GAS  /tmp/cc9tOEVd.s 			page 48


 705:Src/util.c    **** /*
 706:Src/util.c    ****  * read 1 bit from chip register
 707:Src/util.c    ****  */
 708:Src/util.c    **** int8_t i2c_readBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data)
 709:Src/util.c    **** {
 1783              		.loc 1 709 1 is_stmt 1 view -0
 1784              		.cfi_startproc
 1785              		@ args = 0, pretend = 0, frame = 8
 1786              		@ frame_needed = 0, uses_anonymous_args = 0
 710:Src/util.c    ****     uint8_t b;
 1787              		.loc 1 710 5 view .LVU517
 711:Src/util.c    ****     int8_t status = i2c_readByte(slaveAddr, regAddr, &b);
 1788              		.loc 1 711 5 view .LVU518
 709:Src/util.c    ****     uint8_t b;
 1789              		.loc 1 709 1 is_stmt 0 view .LVU519
 1790 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1791              	.LCFI25:
 1792              		.cfi_def_cfa_offset 24
 1793              		.cfi_offset 4, -12
 1794              		.cfi_offset 5, -8
 1795              		.cfi_offset 14, -4
 709:Src/util.c    ****     uint8_t b;
 1796              		.loc 1 709 1 view .LVU520
 1797 0002 1546     		mov	r5, r2
 1798              		.loc 1 711 21 view .LVU521
 1799 0004 0DF10702 		add	r2, sp, #7
 1800              	.LVL121:
 709:Src/util.c    ****     uint8_t b;
 1801              		.loc 1 709 1 view .LVU522
 1802 0008 1C46     		mov	r4, r3
 1803              		.loc 1 711 21 view .LVU523
 1804 000a FFF7FEFF 		bl	i2c_readByte
 1805              	.LVL122:
 712:Src/util.c    ****     *data = b & (1 << bitNum);
 1806              		.loc 1 712 5 is_stmt 1 view .LVU524
 1807              		.loc 1 712 20 is_stmt 0 view .LVU525
 1808 000e 0121     		movs	r1, #1
 1809              		.loc 1 712 15 view .LVU526
 1810 0010 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1811              		.loc 1 712 20 view .LVU527
 1812 0014 01FA05F2 		lsl	r2, r1, r5
 1813              		.loc 1 712 15 view .LVU528
 1814 0018 1A40     		ands	r2, r2, r3
 1815              		.loc 1 712 11 view .LVU529
 1816 001a 2270     		strb	r2, [r4]
 713:Src/util.c    ****     return status;
 1817              		.loc 1 713 5 is_stmt 1 view .LVU530
 714:Src/util.c    **** }
 1818              		.loc 1 714 1 is_stmt 0 view .LVU531
 1819 001c 03B0     		add	sp, sp, #12
 1820              	.LCFI26:
 1821              		.cfi_def_cfa_offset 12
 1822              		@ sp needed
 1823 001e 30BD     		pop	{r4, r5, pc}
 1824              		.loc 1 714 1 view .LVU532
 1825              		.cfi_endproc
 1826              	.LFE77:
ARM GAS  /tmp/cc9tOEVd.s 			page 49


 1828              		.global	buffer
 1829              		.global	i2c_nRABytes
 1830              		.global	i2c_nDABytes
 1831              		.global	i2c_rxbuffer
 1832              		.global	i2c_txbuffer
 1833              		.global	i2c_slaveAddress
 1834              		.global	i2c_regAddress
 1835              		.global	i2c_ReadWriteCmd
 1836              		.global	i2c_status
 1837              		.section	.bss.Feedback,"aw",%nobits
 1838              		.align	1
 1839              		.set	.LANCHOR9,. + 0
 1842              	Feedback:
 1843 0000 00000000 		.space	48
 1843      00000000 
 1843      00000000 
 1843      00000000 
 1843      00000000 
 1844              		.section	.bss.FeedbackRaw,"aw",%nobits
 1845              		.align	1
 1846              		.set	.LANCHOR11,. + 0
 1849              	FeedbackRaw:
 1850 0000 00000000 		.space	48
 1850      00000000 
 1850      00000000 
 1850      00000000 
 1850      00000000 
 1851              		.section	.bss.buffer,"aw",%nobits
 1854              	buffer:
 1855 0000 00000000 		.space	14
 1855      00000000 
 1855      00000000 
 1855      0000
 1856              		.section	.bss.i2c_ReadWriteCmd,"aw",%nobits
 1857              		.set	.LANCHOR12,. + 0
 1860              	i2c_ReadWriteCmd:
 1861 0000 00       		.space	1
 1862              		.section	.bss.i2c_nDABytes,"aw",%nobits
 1863              		.set	.LANCHOR17,. + 0
 1866              	i2c_nDABytes:
 1867 0000 00       		.space	1
 1868              		.section	.bss.i2c_nRABytes,"aw",%nobits
 1869              		.set	.LANCHOR18,. + 0
 1872              	i2c_nRABytes:
 1873 0000 00       		.space	1
 1874              		.section	.bss.i2c_regAddress,"aw",%nobits
 1875              		.set	.LANCHOR15,. + 0
 1878              	i2c_regAddress:
 1879 0000 00       		.space	1
 1880              		.section	.bss.i2c_rxbuffer,"aw",%nobits
 1881              		.align	2
 1882              		.set	.LANCHOR19,. + 0
 1885              	i2c_rxbuffer:
 1886 0000 00000000 		.space	4
 1887              		.section	.bss.i2c_slaveAddress,"aw",%nobits
 1888              		.set	.LANCHOR14,. + 0
 1891              	i2c_slaveAddress:
ARM GAS  /tmp/cc9tOEVd.s 			page 50


 1892 0000 00       		.space	1
 1893              		.section	.bss.i2c_status,"aw",%nobits
 1894              		.set	.LANCHOR13,. + 0
 1897              	i2c_status:
 1898 0000 00       		.space	1
 1899              		.section	.bss.i2c_txbuffer,"aw",%nobits
 1900              		.align	2
 1901              		.set	.LANCHOR16,. + 0
 1904              	i2c_txbuffer:
 1905 0000 00000000 		.space	4
 1906              		.section	.bss.mpuStatus,"aw",%nobits
 1907              		.set	.LANCHOR2,. + 0
 1910              	mpuStatus:
 1911 0000 00       		.space	1
 1912              		.section	.bss.old_pos.0,"aw",%nobits
 1913              		.align	2
 1914              		.set	.LANCHOR10,. + 0
 1917              	old_pos.0:
 1918 0000 00000000 		.space	4
 1919              		.section	.bss.rx1_buffer,"aw",%nobits
 1920              		.set	.LANCHOR1,. + 0
 1923              	rx1_buffer:
 1924 0000 00000000 		.space	256
 1924      00000000 
 1924      00000000 
 1924      00000000 
 1924      00000000 
 1925              		.section	.bss.sensor1,"aw",%nobits
 1926              		.set	.LANCHOR5,. + 0
 1929              	sensor1:
 1930 0000 00       		.space	1
 1931              		.section	.bss.sensor1_read,"aw",%nobits
 1932              		.set	.LANCHOR3,. + 0
 1935              	sensor1_read:
 1936 0000 00       		.space	1
 1937              		.section	.bss.sensor2,"aw",%nobits
 1938              		.set	.LANCHOR6,. + 0
 1941              	sensor2:
 1942 0000 00       		.space	1
 1943              		.section	.bss.sensor2_read,"aw",%nobits
 1944              		.set	.LANCHOR4,. + 0
 1947              	sensor2_read:
 1948 0000 00       		.space	1
 1949              		.section	.bss.sideboard_imu,"aw",%nobits
 1950              		.set	.LANCHOR0,. + 0
 1953              	sideboard_imu:
 1954 0000 00000000 		.space	42
 1954      00000000 
 1954      00000000 
 1954      00000000 
 1954      00000000 
 1955              		.section	.bss.timeoutCntSerial1,"aw",%nobits
 1956              		.align	1
 1957              		.set	.LANCHOR7,. + 0
 1960              	timeoutCntSerial1:
 1961 0000 0000     		.space	2
 1962              		.section	.bss.timeoutFlagSerial1,"aw",%nobits
ARM GAS  /tmp/cc9tOEVd.s 			page 51


 1963              		.set	.LANCHOR8,. + 0
 1966              	timeoutFlagSerial1:
 1967 0000 00       		.space	1
 1968              		.text
 1969              	.Letext0:
 1970              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1971              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1972              		.file 4 "Drivers/CMSIS/Include/gd32f1x0.h"
 1973              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dma.h"
 1974              		.file 6 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 1975              		.file 7 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 1976              		.file 8 "Inc/util.h"
 1977              		.file 9 "Inc/defines.h"
 1978              		.file 10 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_i2c.h"
 1979              		.file 11 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_gpio.h"
 1980              		.file 12 "Inc/mpu6050.h"
 1981              		.file 13 "Inc/setup.h"
 1982              		.file 14 "Inc/systick.h"
 1983              		.file 15 "<built-in>"
ARM GAS  /tmp/cc9tOEVd.s 			page 52


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/cc9tOEVd.s:16     .text.consoleLog:0000000000000000 $t
     /tmp/cc9tOEVd.s:24     .text.consoleLog:0000000000000000 consoleLog
     /tmp/cc9tOEVd.s:39     .text.toggle_led:0000000000000000 $t
     /tmp/cc9tOEVd.s:46     .text.toggle_led:0000000000000000 toggle_led
     /tmp/cc9tOEVd.s:65     .text.intro_demo_led:0000000000000000 $t
     /tmp/cc9tOEVd.s:72     .text.intro_demo_led:0000000000000000 intro_demo_led
     /tmp/cc9tOEVd.s:223    .text.intro_demo_led:00000000000000cc $d
     /tmp/cc9tOEVd.s:228    .text.switch_check:0000000000000000 $t
     /tmp/cc9tOEVd.s:235    .text.switch_check:0000000000000000 switch_check
     /tmp/cc9tOEVd.s:283    .text.input_init:0000000000000000 $t
     /tmp/cc9tOEVd.s:290    .text.input_init:0000000000000000 input_init
     /tmp/cc9tOEVd.s:358    .text.input_init:0000000000000040 $d
     /tmp/cc9tOEVd.s:367    .text.handle_mpu6050:0000000000000000 $t
     /tmp/cc9tOEVd.s:374    .text.handle_mpu6050:0000000000000000 handle_mpu6050
     /tmp/cc9tOEVd.s:425    .text.handle_mpu6050:000000000000002c $d
     /tmp/cc9tOEVd.s:431    .text.handle_sensors:0000000000000000 $t
     /tmp/cc9tOEVd.s:438    .text.handle_sensors:0000000000000000 handle_sensors
     /tmp/cc9tOEVd.s:596    .text.handle_sensors:000000000000007c $d
     /tmp/cc9tOEVd.s:606    .text.handle_usart:0000000000000000 $t
     /tmp/cc9tOEVd.s:613    .text.handle_usart:0000000000000000 handle_usart
     /tmp/cc9tOEVd.s:854    .text.handle_usart:0000000000000124 $d
     /tmp/cc9tOEVd.s:868    .text.handle_leds:0000000000000000 $t
     /tmp/cc9tOEVd.s:875    .text.handle_leds:0000000000000000 handle_leds
     /tmp/cc9tOEVd.s:1039   .text.handle_leds:0000000000000094 $d
     /tmp/cc9tOEVd.s:1046   .text.usart_process_data:0000000000000000 $t
     /tmp/cc9tOEVd.s:1053   .text.usart_process_data:0000000000000000 usart_process_data
     /tmp/cc9tOEVd.s:1132   .text.usart_process_data:000000000000004c $d
     /tmp/cc9tOEVd.s:1138   .text.usart1_rx_check:0000000000000000 $t
     /tmp/cc9tOEVd.s:1145   .text.usart1_rx_check:0000000000000000 usart1_rx_check
     /tmp/cc9tOEVd.s:1260   .text.usart1_rx_check:0000000000000070 $d
     /tmp/cc9tOEVd.s:1268   .text.usart0_rx_check:0000000000000000 $t
     /tmp/cc9tOEVd.s:1275   .text.usart0_rx_check:0000000000000000 usart0_rx_check
     /tmp/cc9tOEVd.s:1288   .text.aux_print_to_console:0000000000000000 $t
     /tmp/cc9tOEVd.s:1295   .text.aux_print_to_console:0000000000000000 aux_print_to_console
     /tmp/cc9tOEVd.s:1306   .text.i2c_writeBytes:0000000000000000 $t
     /tmp/cc9tOEVd.s:1313   .text.i2c_writeBytes:0000000000000000 i2c_writeBytes
     /tmp/cc9tOEVd.s:1447   .text.i2c_writeBytes:000000000000006c $d
     /tmp/cc9tOEVd.s:1460   .text.i2c_writeByte:0000000000000000 $t
     /tmp/cc9tOEVd.s:1467   .text.i2c_writeByte:0000000000000000 i2c_writeByte
     /tmp/cc9tOEVd.s:1499   .text.i2c_readBytes:0000000000000000 $t
     /tmp/cc9tOEVd.s:1506   .text.i2c_readBytes:0000000000000000 i2c_readBytes
     /tmp/cc9tOEVd.s:1651   .text.i2c_readBytes:000000000000007c $d
     /tmp/cc9tOEVd.s:1664   .text.i2c_readByte:0000000000000000 $t
     /tmp/cc9tOEVd.s:1671   .text.i2c_readByte:0000000000000000 i2c_readByte
     /tmp/cc9tOEVd.s:1693   .text.i2c_writeBit:0000000000000000 $t
     /tmp/cc9tOEVd.s:1700   .text.i2c_writeBit:0000000000000000 i2c_writeBit
     /tmp/cc9tOEVd.s:1773   .text.i2c_readBit:0000000000000000 $t
     /tmp/cc9tOEVd.s:1780   .text.i2c_readBit:0000000000000000 i2c_readBit
     /tmp/cc9tOEVd.s:1854   .bss.buffer:0000000000000000 buffer
     /tmp/cc9tOEVd.s:1872   .bss.i2c_nRABytes:0000000000000000 i2c_nRABytes
     /tmp/cc9tOEVd.s:1866   .bss.i2c_nDABytes:0000000000000000 i2c_nDABytes
     /tmp/cc9tOEVd.s:1885   .bss.i2c_rxbuffer:0000000000000000 i2c_rxbuffer
     /tmp/cc9tOEVd.s:1904   .bss.i2c_txbuffer:0000000000000000 i2c_txbuffer
     /tmp/cc9tOEVd.s:1891   .bss.i2c_slaveAddress:0000000000000000 i2c_slaveAddress
     /tmp/cc9tOEVd.s:1878   .bss.i2c_regAddress:0000000000000000 i2c_regAddress
ARM GAS  /tmp/cc9tOEVd.s 			page 53


     /tmp/cc9tOEVd.s:1860   .bss.i2c_ReadWriteCmd:0000000000000000 i2c_ReadWriteCmd
     /tmp/cc9tOEVd.s:1897   .bss.i2c_status:0000000000000000 i2c_status
     /tmp/cc9tOEVd.s:1838   .bss.Feedback:0000000000000000 $d
     /tmp/cc9tOEVd.s:1842   .bss.Feedback:0000000000000000 Feedback
     /tmp/cc9tOEVd.s:1845   .bss.FeedbackRaw:0000000000000000 $d
     /tmp/cc9tOEVd.s:1849   .bss.FeedbackRaw:0000000000000000 FeedbackRaw
     /tmp/cc9tOEVd.s:1855   .bss.buffer:0000000000000000 $d
     /tmp/cc9tOEVd.s:1861   .bss.i2c_ReadWriteCmd:0000000000000000 $d
     /tmp/cc9tOEVd.s:1867   .bss.i2c_nDABytes:0000000000000000 $d
     /tmp/cc9tOEVd.s:1873   .bss.i2c_nRABytes:0000000000000000 $d
     /tmp/cc9tOEVd.s:1879   .bss.i2c_regAddress:0000000000000000 $d
     /tmp/cc9tOEVd.s:1881   .bss.i2c_rxbuffer:0000000000000000 $d
     /tmp/cc9tOEVd.s:1892   .bss.i2c_slaveAddress:0000000000000000 $d
     /tmp/cc9tOEVd.s:1898   .bss.i2c_status:0000000000000000 $d
     /tmp/cc9tOEVd.s:1900   .bss.i2c_txbuffer:0000000000000000 $d
     /tmp/cc9tOEVd.s:1910   .bss.mpuStatus:0000000000000000 mpuStatus
     /tmp/cc9tOEVd.s:1911   .bss.mpuStatus:0000000000000000 $d
     /tmp/cc9tOEVd.s:1913   .bss.old_pos.0:0000000000000000 $d
     /tmp/cc9tOEVd.s:1917   .bss.old_pos.0:0000000000000000 old_pos.0
     /tmp/cc9tOEVd.s:1923   .bss.rx1_buffer:0000000000000000 rx1_buffer
     /tmp/cc9tOEVd.s:1924   .bss.rx1_buffer:0000000000000000 $d
     /tmp/cc9tOEVd.s:1929   .bss.sensor1:0000000000000000 sensor1
     /tmp/cc9tOEVd.s:1930   .bss.sensor1:0000000000000000 $d
     /tmp/cc9tOEVd.s:1935   .bss.sensor1_read:0000000000000000 sensor1_read
     /tmp/cc9tOEVd.s:1936   .bss.sensor1_read:0000000000000000 $d
     /tmp/cc9tOEVd.s:1941   .bss.sensor2:0000000000000000 sensor2
     /tmp/cc9tOEVd.s:1942   .bss.sensor2:0000000000000000 $d
     /tmp/cc9tOEVd.s:1947   .bss.sensor2_read:0000000000000000 sensor2_read
     /tmp/cc9tOEVd.s:1948   .bss.sensor2_read:0000000000000000 $d
     /tmp/cc9tOEVd.s:1953   .bss.sideboard_imu:0000000000000000 sideboard_imu
     /tmp/cc9tOEVd.s:1954   .bss.sideboard_imu:0000000000000000 $d
     /tmp/cc9tOEVd.s:1956   .bss.timeoutCntSerial1:0000000000000000 $d
     /tmp/cc9tOEVd.s:1960   .bss.timeoutCntSerial1:0000000000000000 timeoutCntSerial1
     /tmp/cc9tOEVd.s:1966   .bss.timeoutFlagSerial1:0000000000000000 timeoutFlagSerial1
     /tmp/cc9tOEVd.s:1967   .bss.timeoutFlagSerial1:0000000000000000 $d

UNDEFINED SYMBOLS
gpio_bit_set
gpio_bit_reset
delay_1ms
usart_Tx_DMA_config
usart_Rx_DMA_config
mpu_config
mpu_get_data
main_loop_counter
gpio_input_bit_get
dma_transfer_number_get
dma_channel_disable
dma_channel_enable
mpu
memcpy
i2c_interrupt_enable
i2c_flag_get
i2c_start_on_bus
i2c_ackpos_config
