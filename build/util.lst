ARM GAS  /tmp/ccPeOSOQ.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.consoleLog,"ax",%progbits
  16              		.align	1
  17              		.global	consoleLog
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	consoleLog:
  25              	.LVL0:
  26              	.LFB59:
  27              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-sideboard-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <string.h>
  23:Src/util.c    **** #include "systick.h"
  24:Src/util.c    **** #include "gd32f1x0.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "config.h"
  27:Src/util.c    **** #include "setup.h"
  28:Src/util.c    **** #include "util.h"
  29:Src/util.c    **** #include "mpu6050.h"
  30:Src/util.c    **** 
  31:Src/util.c    **** // USART1 variables
ARM GAS  /tmp/ccPeOSOQ.s 			page 2


  32:Src/util.c    **** #ifdef SERIAL_CONTROL
  33:Src/util.c    **** //static SerialSideboard Sideboard;
  34:Src/util.c    **** static SideboardImuRaw sideboard_imu;
  35:Src/util.c    **** #endif
  36:Src/util.c    **** 
  37:Src/util.c    **** #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
  38:Src/util.c    **** static uint8_t  rx1_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  39:Src/util.c    **** static uint32_t rx1_buffer_len = ARRAY_LEN(rx1_buffer);
  40:Src/util.c    **** #endif
  41:Src/util.c    **** 
  42:Src/util.c    **** #ifdef SERIAL_FEEDBACK
  43:Src/util.c    **** static SerialFeedback Feedback;
  44:Src/util.c    **** static SerialFeedback FeedbackRaw;
  45:Src/util.c    **** static uint16_t timeoutCntSerial1  = 0;         // Timeout counter for UART1 Rx Serial
  46:Src/util.c    **** static uint8_t  timeoutFlagSerial1 = 0;         // Timeout Flag for UART1 Rx Serial: 0 = OK, 1 = Pr
  47:Src/util.c    **** static uint32_t Feedback_len  = sizeof(Feedback);
  48:Src/util.c    **** #endif
  49:Src/util.c    **** 
  50:Src/util.c    **** // USART0 variables
  51:Src/util.c    **** #ifdef SERIAL_AUX_TX
  52:Src/util.c    **** static SerialAuxTx AuxTx;
  53:Src/util.c    **** #endif
  54:Src/util.c    **** 
  55:Src/util.c    **** #ifdef SERIAL_AUX_RX
  56:Src/util.c    **** static uint8_t  rx0_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  57:Src/util.c    **** static uint32_t rx0_buffer_len = ARRAY_LEN(rx0_buffer);
  58:Src/util.c    **** #endif
  59:Src/util.c    **** 
  60:Src/util.c    **** #ifdef SERIAL_AUX_RX
  61:Src/util.c    **** static SerialCommand command;
  62:Src/util.c    **** static SerialCommand command_raw;
  63:Src/util.c    **** static uint16_t timeoutCntSerial0  = 0;         // Timeout counter for UART0 Rx Serial
  64:Src/util.c    **** static uint8_t  timeoutFlagSerial0 = 0;         // Timeout Flag for UART0 Rx Serial: 0 = OK, 1 = Pr
  65:Src/util.c    **** static uint32_t command_len = sizeof(command);
  66:Src/util.c    **** extern uint8_t  print_aux;
  67:Src/util.c    ****   #ifdef CONTROL_IBUS
  68:Src/util.c    ****   static uint16_t ibus_chksum;
  69:Src/util.c    ****   static uint16_t ibus_captured_value[IBUS_NUM_CHANNELS];
  70:Src/util.c    ****   #endif
  71:Src/util.c    **** #endif
  72:Src/util.c    **** 
  73:Src/util.c    **** #if (defined(SERIAL_AUX_RX) && defined(CONTROL_IBUS)) || defined(SERIAL_CONTROL)
  74:Src/util.c    **** static int16_t  cmd1, cmd2;
  75:Src/util.c    **** static uint16_t cmdSwitch;
  76:Src/util.c    **** #endif
  77:Src/util.c    **** 
  78:Src/util.c    **** // Optical sensors variables
  79:Src/util.c    **** static FlagStatus   sensor1, sensor2;           // holds the sensor1 and sensor 2 values
  80:Src/util.c    **** static FlagStatus   sensor1_read, sensor2_read; // holds the instantaneous Read for sensor1 and sen
  81:Src/util.c    **** 
  82:Src/util.c    **** // MPU variables
  83:Src/util.c    **** extern MPU_Data     mpu;                        // holds the MPU-6050 data
  84:Src/util.c    **** #if defined(MPU_SENSOR_ENABLE) || defined(SERIAL_CONTROL)
  85:Src/util.c    **** static ErrStatus    mpuStatus;                  // holds the MPU-6050 status: SUCCESS or ERROR
  86:Src/util.c    **** #endif
  87:Src/util.c    **** 
  88:Src/util.c    **** extern uint32_t     main_loop_counter;          // main loop counter to perform task scheduling ins
ARM GAS  /tmp/ccPeOSOQ.s 			page 3


  89:Src/util.c    **** 
  90:Src/util.c    **** // MAIN I2C variables
  91:Src/util.c    **** volatile int8_t     i2c_status;
  92:Src/util.c    **** volatile i2c_cmd    i2c_ReadWriteCmd;
  93:Src/util.c    **** volatile uint8_t    i2c_regAddress;
  94:Src/util.c    **** volatile uint8_t    i2c_slaveAddress;
  95:Src/util.c    **** volatile uint8_t*   i2c_txbuffer;
  96:Src/util.c    **** volatile uint8_t*   i2c_rxbuffer;
  97:Src/util.c    **** volatile uint8_t    i2c_nDABytes;
  98:Src/util.c    **** volatile  int8_t    i2c_nRABytes;
  99:Src/util.c    **** volatile uint8_t    buffer[14];
 100:Src/util.c    **** 
 101:Src/util.c    **** #ifdef AUX45_USE_I2C
 102:Src/util.c    **** // AUX I2C variables
 103:Src/util.c    **** volatile int8_t     i2c_aux_status;
 104:Src/util.c    **** volatile i2c_cmd    i2c_aux_ReadWriteCmd;
 105:Src/util.c    **** volatile uint8_t    i2c_aux_regAddress;
 106:Src/util.c    **** volatile uint8_t    i2c_aux_slaveAddress;
 107:Src/util.c    **** volatile uint8_t*   i2c_aux_txbuffer;
 108:Src/util.c    **** volatile uint8_t*   i2c_aux_rxbuffer;
 109:Src/util.c    **** volatile uint8_t    i2c_aux_nDABytes;
 110:Src/util.c    **** volatile  int8_t    i2c_aux_nRABytes;
 111:Src/util.c    **** #endif
 112:Src/util.c    **** 
 113:Src/util.c    **** 
 114:Src/util.c    **** 
 115:Src/util.c    **** /* =========================== General Functions =========================== */
 116:Src/util.c    **** 
 117:Src/util.c    **** void consoleLog(char *message)
 118:Src/util.c    **** {
  28              		.loc 1 118 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
 119:Src/util.c    ****   #ifdef SERIAL_DEBUG
 120:Src/util.c    ****     log_i("%s", message);
 121:Src/util.c    ****   #endif
 122:Src/util.c    **** }
  33              		.loc 1 122 1 view .LVU1
  34 0000 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE59:
  38              		.section	.text.toggle_led,"ax",%progbits
  39              		.align	1
  40              		.global	toggle_led
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	toggle_led:
  47              	.LVL1:
  48              	.LFB60:
 123:Src/util.c    **** 
 124:Src/util.c    **** 
 125:Src/util.c    **** /* retarget the C library printf function to the USART */
 126:Src/util.c    **** #ifdef SERIAL_DEBUG	
ARM GAS  /tmp/ccPeOSOQ.s 			page 4


 127:Src/util.c    ****     #ifdef __GNUC__
 128:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 129:Src/util.c    ****     #else
 130:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 131:Src/util.c    ****     #endif
 132:Src/util.c    ****     PUTCHAR_PROTOTYPE {
 133:Src/util.c    ****         usart_data_transmit(USART_MAIN, (uint8_t)ch);
 134:Src/util.c    ****         while(RESET == usart_flag_get(USART_MAIN, USART_FLAG_TBE));
 135:Src/util.c    ****         return ch;
 136:Src/util.c    ****     }
 137:Src/util.c    ****     
 138:Src/util.c    ****     #ifdef __GNUC__
 139:Src/util.c    ****         int _write(int file, char *data, int len) {
 140:Src/util.c    ****             int i;
 141:Src/util.c    ****             for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 142:Src/util.c    ****             return len; 
 143:Src/util.c    ****         }
 144:Src/util.c    ****     #endif
 145:Src/util.c    **** #endif
 146:Src/util.c    **** 
 147:Src/util.c    **** 
 148:Src/util.c    **** void toggle_led(uint32_t gpio_periph, uint32_t pin)
 149:Src/util.c    **** {
  49              		.loc 1 149 1 view -0
  50              		.cfi_startproc
  51              		@ args = 0, pretend = 0, frame = 0
  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
 150:Src/util.c    ****     GPIO_OCTL(gpio_periph) ^= pin;
  54              		.loc 1 150 5 view .LVU3
  55              		.loc 1 150 28 is_stmt 0 view .LVU4
  56 0000 4369     		ldr	r3, [r0, #20]
  57 0002 4B40     		eors	r3, r3, r1
  58 0004 4361     		str	r3, [r0, #20]
 151:Src/util.c    **** }
  59              		.loc 1 151 1 view .LVU5
  60 0006 7047     		bx	lr
  61              		.cfi_endproc
  62              	.LFE60:
  64              		.section	.text.intro_demo_led,"ax",%progbits
  65              		.align	1
  66              		.global	intro_demo_led
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu softvfp
  72              	intro_demo_led:
  73              	.LVL2:
  74              	.LFB61:
 152:Src/util.c    **** 
 153:Src/util.c    **** 
 154:Src/util.c    **** void intro_demo_led(uint32_t tDelay)
 155:Src/util.c    **** {
  75              		.loc 1 155 1 is_stmt 1 view -0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccPeOSOQ.s 			page 5


 156:Src/util.c    ****     int i;
  79              		.loc 1 156 5 view .LVU7
 157:Src/util.c    **** 
 158:Src/util.c    ****     for (i = 0; i < 3; i++) {
  80              		.loc 1 158 5 view .LVU8
  81              		.loc 1 158 17 view .LVU9
 155:Src/util.c    ****     int i;
  82              		.loc 1 155 1 is_stmt 0 view .LVU10
  83 0000 70B5     		push	{r4, r5, r6, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 16
  86              		.cfi_offset 4, -16
  87              		.cfi_offset 5, -12
  88              		.cfi_offset 6, -8
  89              		.cfi_offset 14, -4
 155:Src/util.c    ****     int i;
  90              		.loc 1 155 1 view .LVU11
  91 0002 0546     		mov	r5, r0
  92 0004 0326     		movs	r6, #3
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 160:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
  93              		.loc 1 160 9 view .LVU12
  94 0006 314C     		ldr	r4, .L8
  95              	.LVL3:
  96              	.L4:
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
  97              		.loc 1 159 9 is_stmt 1 discriminator 3 view .LVU13
  98 0008 0121     		movs	r1, #1
  99 000a 4FF09040 		mov	r0, #1207959552
 100 000e FFF7FEFF 		bl	gpio_bit_set
 101              	.LVL4:
 102              		.loc 1 160 9 discriminator 3 view .LVU14
 103 0012 4FF48071 		mov	r1, #256
 104 0016 2046     		mov	r0, r4
 105 0018 FFF7FEFF 		bl	gpio_bit_reset
 106              	.LVL5:
 161:Src/util.c    ****         delay_1ms(tDelay);
 107              		.loc 1 161 9 discriminator 3 view .LVU15
 108 001c 2846     		mov	r0, r5
 109 001e FFF7FEFF 		bl	delay_1ms
 110              	.LVL6:
 162:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 111              		.loc 1 162 9 discriminator 3 view .LVU16
 112 0022 4FF40071 		mov	r1, #512
 113 0026 2046     		mov	r0, r4
 114 0028 FFF7FEFF 		bl	gpio_bit_set
 115              	.LVL7:
 163:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 116              		.loc 1 163 9 discriminator 3 view .LVU17
 117 002c 0121     		movs	r1, #1
 118 002e 4FF09040 		mov	r0, #1207959552
 119 0032 FFF7FEFF 		bl	gpio_bit_reset
 120              	.LVL8:
 164:Src/util.c    ****         delay_1ms(tDelay);
 121              		.loc 1 164 9 discriminator 3 view .LVU18
 122 0036 2846     		mov	r0, r5
 123 0038 FFF7FEFF 		bl	delay_1ms
ARM GAS  /tmp/ccPeOSOQ.s 			page 6


 124              	.LVL9:
 165:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 125              		.loc 1 165 9 discriminator 3 view .LVU19
 126 003c 4FF48071 		mov	r1, #256
 127 0040 2046     		mov	r0, r4
 128 0042 FFF7FEFF 		bl	gpio_bit_set
 129              	.LVL10:
 166:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 130              		.loc 1 166 9 discriminator 3 view .LVU20
 131 0046 4FF40071 		mov	r1, #512
 132 004a 2046     		mov	r0, r4
 133 004c FFF7FEFF 		bl	gpio_bit_reset
 134              	.LVL11:
 167:Src/util.c    ****         delay_1ms(tDelay);
 135              		.loc 1 167 9 discriminator 3 view .LVU21
 136 0050 2846     		mov	r0, r5
 137 0052 FFF7FEFF 		bl	delay_1ms
 138              	.LVL12:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 139              		.loc 1 158 24 discriminator 3 view .LVU22
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 140              		.loc 1 158 17 discriminator 3 view .LVU23
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 141              		.loc 1 158 5 is_stmt 0 discriminator 3 view .LVU24
 142 0056 013E     		subs	r6, r6, #1
 143              	.LVL13:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 144              		.loc 1 158 5 discriminator 3 view .LVU25
 145 0058 D6D1     		bne	.L4
 146 005a 0226     		movs	r6, #2
 147              	.LVL14:
 168:Src/util.c    ****     }
 169:Src/util.c    **** 
 170:Src/util.c    ****     for (i = 0; i < 2; i++) {
 171:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 172:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 148              		.loc 1 172 9 view .LVU26
 149 005c 1B4C     		ldr	r4, .L8
 150              	.L5:
 151              	.LVL15:
 171:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 152              		.loc 1 171 9 is_stmt 1 discriminator 3 view .LVU27
 153 005e 0121     		movs	r1, #1
 154 0060 4FF09040 		mov	r0, #1207959552
 155 0064 FFF7FEFF 		bl	gpio_bit_set
 156              	.LVL16:
 157              		.loc 1 172 9 discriminator 3 view .LVU28
 158 0068 4FF40071 		mov	r1, #512
 159 006c 2046     		mov	r0, r4
 160 006e FFF7FEFF 		bl	gpio_bit_set
 161              	.LVL17:
 173:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 162              		.loc 1 173 9 discriminator 3 view .LVU29
 163 0072 4FF48071 		mov	r1, #256
 164 0076 2046     		mov	r0, r4
 165 0078 FFF7FEFF 		bl	gpio_bit_set
 166              	.LVL18:
ARM GAS  /tmp/ccPeOSOQ.s 			page 7


 174:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 167              		.loc 1 174 9 discriminator 3 view .LVU30
 168 007c 2021     		movs	r1, #32
 169 007e 2046     		mov	r0, r4
 170 0080 FFF7FEFF 		bl	gpio_bit_set
 171              	.LVL19:
 175:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 172              		.loc 1 175 9 discriminator 3 view .LVU31
 173 0084 1021     		movs	r1, #16
 174 0086 2046     		mov	r0, r4
 175 0088 FFF7FEFF 		bl	gpio_bit_set
 176              	.LVL20:
 176:Src/util.c    ****         delay_1ms(tDelay);
 177              		.loc 1 176 9 discriminator 3 view .LVU32
 178 008c 2846     		mov	r0, r5
 179 008e FFF7FEFF 		bl	delay_1ms
 180              	.LVL21:
 177:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 181              		.loc 1 177 9 discriminator 3 view .LVU33
 182 0092 0121     		movs	r1, #1
 183 0094 4FF09040 		mov	r0, #1207959552
 184 0098 FFF7FEFF 		bl	gpio_bit_reset
 185              	.LVL22:
 178:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 186              		.loc 1 178 9 discriminator 3 view .LVU34
 187 009c 4FF40071 		mov	r1, #512
 188 00a0 2046     		mov	r0, r4
 189 00a2 FFF7FEFF 		bl	gpio_bit_reset
 190              	.LVL23:
 179:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
 191              		.loc 1 179 9 discriminator 3 view .LVU35
 192 00a6 4FF48071 		mov	r1, #256
 193 00aa 2046     		mov	r0, r4
 194 00ac FFF7FEFF 		bl	gpio_bit_reset
 195              	.LVL24:
 180:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 196              		.loc 1 180 9 discriminator 3 view .LVU36
 197 00b0 2021     		movs	r1, #32
 198 00b2 2046     		mov	r0, r4
 199 00b4 FFF7FEFF 		bl	gpio_bit_reset
 200              	.LVL25:
 181:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 201              		.loc 1 181 9 discriminator 3 view .LVU37
 202 00b8 1021     		movs	r1, #16
 203 00ba 2046     		mov	r0, r4
 204 00bc FFF7FEFF 		bl	gpio_bit_reset
 205              	.LVL26:
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 206              		.loc 1 170 24 discriminator 3 view .LVU38
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 207              		.loc 1 170 17 discriminator 3 view .LVU39
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 208              		.loc 1 170 5 is_stmt 0 discriminator 3 view .LVU40
 209 00c0 012E     		cmp	r6, #1
 210 00c2 00D1     		bne	.L6
 182:Src/util.c    ****     }
 183:Src/util.c    **** }
ARM GAS  /tmp/ccPeOSOQ.s 			page 8


 211              		.loc 1 183 1 view .LVU41
 212 00c4 70BD     		pop	{r4, r5, r6, pc}
 213              	.LVL27:
 214              	.L6:
 215              		.loc 1 183 1 view .LVU42
 216 00c6 0126     		movs	r6, #1
 217              	.LVL28:
 218              		.loc 1 183 1 view .LVU43
 219 00c8 C9E7     		b	.L5
 220              	.L9:
 221 00ca 00BF     		.align	2
 222              	.L8:
 223 00cc 00040048 		.word	1207960576
 224              		.cfi_endproc
 225              	.LFE61:
 227              		.section	.text.switch_check,"ax",%progbits
 228              		.align	1
 229              		.global	switch_check
 230              		.syntax unified
 231              		.thumb
 232              		.thumb_func
 233              		.fpu softvfp
 235              	switch_check:
 236              	.LVL29:
 237              	.LFB62:
 184:Src/util.c    **** 
 185:Src/util.c    **** 
 186:Src/util.c    **** uint8_t switch_check(uint16_t ch, uint8_t type) {
 238              		.loc 1 186 49 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 187:Src/util.c    ****     if (type) { // 3 positions switch
 243              		.loc 1 187 5 view .LVU45
 244              		.loc 1 187 8 is_stmt 0 view .LVU46
 245 0000 41B1     		cbz	r1, .L11
 188:Src/util.c    ****         if      (ch < 250) return 0;    // switch in position 0
 246              		.loc 1 188 9 is_stmt 1 view .LVU47
 247              		.loc 1 188 17 is_stmt 0 view .LVU48
 248 0002 F928     		cmp	r0, #249
 249 0004 0DD9     		bls	.L13
 189:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 250              		.loc 1 189 14 is_stmt 1 view .LVU49
 190:Src/util.c    ****         else               return 2;    // switch in position 2
 251              		.loc 1 190 35 is_stmt 0 view .LVU50
 252 0006 40F25133 		movw	r3, #849
 253 000a 9842     		cmp	r0, r3
 254 000c 94BF     		ite	ls
 255 000e 0120     		movls	r0, #1
 256 0010 0220     		movhi	r0, #2
 257              	.LVL30:
 258              		.loc 1 190 35 view .LVU51
 259 0012 7047     		bx	lr
 260              	.LVL31:
 261              	.L11:
 191:Src/util.c    ****     } else {    // 2 positions switch
ARM GAS  /tmp/ccPeOSOQ.s 			page 9


 192:Src/util.c    ****         return  (ch > 850);
 262              		.loc 1 192 9 is_stmt 1 view .LVU52
 263              		.loc 1 192 21 is_stmt 0 view .LVU53
 264 0014 40F25233 		movw	r3, #850
 265 0018 9842     		cmp	r0, r3
 266 001a 94BF     		ite	ls
 267 001c 0020     		movls	r0, #0
 268              	.LVL32:
 269              		.loc 1 192 21 view .LVU54
 270 001e 0120     		movhi	r0, #1
 271 0020 7047     		bx	lr
 272              	.LVL33:
 273              	.L13:
 188:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 274              		.loc 1 188 35 view .LVU55
 275 0022 0020     		movs	r0, #0
 276              	.LVL34:
 193:Src/util.c    ****     }
 194:Src/util.c    **** }
 277              		.loc 1 194 1 view .LVU56
 278 0024 7047     		bx	lr
 279              		.cfi_endproc
 280              	.LFE62:
 282              		.section	.text.input_init,"ax",%progbits
 283              		.align	1
 284              		.global	input_init
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 288              		.fpu softvfp
 290              	input_init:
 291              	.LFB63:
 195:Src/util.c    **** 
 196:Src/util.c    **** 
 197:Src/util.c    **** /* =========================== Input Initialization Function =========================== */
 198:Src/util.c    **** 
 199:Src/util.c    **** void input_init(void) {
 292              		.loc 1 199 23 is_stmt 1 view -0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 200:Src/util.c    ****     #ifdef SERIAL_CONTROL
 201:Src/util.c    ****         usart_Tx_DMA_config(USART_MAIN, (uint8_t *)&sideboard_imu, sizeof(sideboard_imu));
 296              		.loc 1 201 9 view .LVU58
 199:Src/util.c    ****     #ifdef SERIAL_CONTROL
 297              		.loc 1 199 23 is_stmt 0 view .LVU59
 298 0000 08B5     		push	{r3, lr}
 299              	.LCFI1:
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 3, -8
 302              		.cfi_offset 14, -4
 303              		.loc 1 201 9 view .LVU60
 304 0002 2A22     		movs	r2, #42
 305 0004 0E49     		ldr	r1, .L18
 306 0006 0F48     		ldr	r0, .L18+4
 307 0008 FFF7FEFF 		bl	usart_Tx_DMA_config
 308              	.LVL35:
ARM GAS  /tmp/ccPeOSOQ.s 			page 10


 202:Src/util.c    ****     #endif
 203:Src/util.c    ****     #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
 204:Src/util.c    ****         usart_Rx_DMA_config(USART_MAIN, (uint8_t *)rx1_buffer, sizeof(rx1_buffer));
 309              		.loc 1 204 9 is_stmt 1 view .LVU61
 310 000c 4FF48072 		mov	r2, #256
 311 0010 0D49     		ldr	r1, .L18+8
 312 0012 0C48     		ldr	r0, .L18+4
 313 0014 FFF7FEFF 		bl	usart_Rx_DMA_config
 314              	.LVL36:
 205:Src/util.c    ****     #endif
 206:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 207:Src/util.c    ****         usart_Tx_DMA_config(USART_AUX, (uint8_t *)&AuxTx, sizeof(AuxTx));
 208:Src/util.c    ****     #endif
 209:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 210:Src/util.c    ****         usart_Rx_DMA_config(USART_AUX, (uint8_t *)rx0_buffer, sizeof(rx0_buffer));
 211:Src/util.c    ****     #endif
 212:Src/util.c    **** 
 213:Src/util.c    ****     //intro_demo_led(100);                                // Short LEDs intro demo with 100 ms dela
 214:Src/util.c    **** 
 215:Src/util.c    ****     #ifdef MPU_SENSOR_ENABLE
 216:Src/util.c    ****         if(mpu_config()) {                              // IMU MPU-6050 config
 315              		.loc 1 216 9 view .LVU62
 316              		.loc 1 216 12 is_stmt 0 view .LVU63
 317 0018 FFF7FEFF 		bl	mpu_config
 318              	.LVL37:
 319 001c 0B4B     		ldr	r3, .L18+12
 320              		.loc 1 216 11 view .LVU64
 321 001e 40B1     		cbz	r0, .L16
 217:Src/util.c    ****             mpuStatus = ERROR;
 322              		.loc 1 217 13 is_stmt 1 view .LVU65
 323              		.loc 1 217 23 is_stmt 0 view .LVU66
 324 0020 0022     		movs	r2, #0
 218:Src/util.c    ****             gpio_bit_set(LED1_GPIO_Port, LED1_Pin);     // Turn on RED LED - sensor enabled and NOT
 325              		.loc 1 218 13 view .LVU67
 326 0022 0121     		movs	r1, #1
 327 0024 4FF09040 		mov	r0, #1207959552
 217:Src/util.c    ****             mpuStatus = ERROR;
 328              		.loc 1 217 23 view .LVU68
 329 0028 1A70     		strb	r2, [r3]
 330              		.loc 1 218 13 is_stmt 1 view .LVU69
 331              	.L17:
 219:Src/util.c    ****         }
 220:Src/util.c    ****         else {
 221:Src/util.c    ****             mpuStatus = SUCCESS;
 222:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 223:Src/util.c    ****         }
 224:Src/util.c    ****     #else
 225:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);         // Turn on GREEN LED - sensor disabled
 226:Src/util.c    ****     #endif
 227:Src/util.c    **** 
 228:Src/util.c    ****     #ifdef SERIAL_DEBUG
 229:Src/util.c    ****         mpu_handle_input('h');                          // Print the User Help commands to serial
 230:Src/util.c    ****     #endif
 231:Src/util.c    **** }
 332              		.loc 1 231 1 is_stmt 0 view .LVU70
 333 002a BDE80840 		pop	{r3, lr}
 334              	.LCFI2:
ARM GAS  /tmp/ccPeOSOQ.s 			page 11


 335              		.cfi_remember_state
 336              		.cfi_restore 14
 337              		.cfi_restore 3
 338              		.cfi_def_cfa_offset 0
 222:Src/util.c    ****         }
 339              		.loc 1 222 13 view .LVU71
 340 002e FFF7FEBF 		b	gpio_bit_set
 341              	.LVL38:
 342              	.L16:
 343              	.LCFI3:
 344              		.cfi_restore_state
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 345              		.loc 1 221 13 is_stmt 1 view .LVU72
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 346              		.loc 1 221 23 is_stmt 0 view .LVU73
 347 0032 0122     		movs	r2, #1
 222:Src/util.c    ****         }
 348              		.loc 1 222 13 view .LVU74
 349 0034 4FF40071 		mov	r1, #512
 350 0038 0548     		ldr	r0, .L18+16
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 351              		.loc 1 221 23 view .LVU75
 352 003a 1A70     		strb	r2, [r3]
 222:Src/util.c    ****         }
 353              		.loc 1 222 13 is_stmt 1 view .LVU76
 354 003c F5E7     		b	.L17
 355              	.L19:
 356 003e 00BF     		.align	2
 357              	.L18:
 358 0040 00000000 		.word	.LANCHOR0
 359 0044 00440040 		.word	1073759232
 360 0048 00000000 		.word	.LANCHOR1
 361 004c 00000000 		.word	.LANCHOR2
 362 0050 00040048 		.word	1207960576
 363              		.cfi_endproc
 364              	.LFE63:
 366              		.section	.text.handle_mpu6050,"ax",%progbits
 367              		.align	1
 368              		.global	handle_mpu6050
 369              		.syntax unified
 370              		.thumb
 371              		.thumb_func
 372              		.fpu softvfp
 374              	handle_mpu6050:
 375              	.LFB64:
 232:Src/util.c    **** 
 233:Src/util.c    **** 
 234:Src/util.c    **** /* =========================== Handle Functions =========================== */
 235:Src/util.c    **** 
 236:Src/util.c    **** /*
 237:Src/util.c    ****  * Handle of the MPU-6050 IMU sensor
 238:Src/util.c    ****  */
 239:Src/util.c    **** void handle_mpu6050(void) {
 376              		.loc 1 239 27 view -0
 377              		.cfi_startproc
 378              		@ args = 0, pretend = 0, frame = 0
 379              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccPeOSOQ.s 			page 12


 380              		@ link register save eliminated.
 240:Src/util.c    **** #ifdef MPU_SENSOR_ENABLE
 241:Src/util.c    ****     // Get MPU data. Because the MPU-6050 interrupt pin is not wired we have to check DMP data by p
 242:Src/util.c    ****     if (SUCCESS == mpuStatus) {
 381              		.loc 1 242 5 view .LVU78
 382              		.loc 1 242 17 is_stmt 0 view .LVU79
 383 0000 0A4B     		ldr	r3, .L23
 384 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 385              		.loc 1 242 8 view .LVU80
 386 0004 012B     		cmp	r3, #1
 387 0006 01D1     		bne	.L21
 243:Src/util.c    ****         mpu_get_data();
 388              		.loc 1 243 9 is_stmt 1 view .LVU81
 389 0008 FFF7FEBF 		b	mpu_get_data
 390              	.LVL39:
 391              	.L21:
 244:Src/util.c    ****     } else if (ERROR == mpuStatus && main_loop_counter % 100 == 0) {
 392              		.loc 1 244 12 view .LVU82
 393              		.loc 1 244 15 is_stmt 0 view .LVU83
 394 000c 6BB9     		cbnz	r3, .L20
 395 000e 6422     		movs	r2, #100
 396              		.loc 1 244 56 discriminator 1 view .LVU84
 397 0010 074B     		ldr	r3, .L23+4
 398 0012 1B68     		ldr	r3, [r3]
 399 0014 B3FBF2F1 		udiv	r1, r3, r2
 400 0018 02FB1133 		mls	r3, r2, r1, r3
 401              		.loc 1 244 35 discriminator 1 view .LVU85
 402 001c 2BB9     		cbnz	r3, .L20
 245:Src/util.c    ****         toggle_led(LED1_GPIO_Port, LED1_Pin);                    // Toggle the Red LED every 100 ms
 403              		.loc 1 245 9 is_stmt 1 view .LVU86
 404              	.LVL40:
 405              	.LBB14:
 406              	.LBI14:
 148:Src/util.c    **** {
 407              		.loc 1 148 6 view .LVU87
 408              	.LBB15:
 150:Src/util.c    **** }
 409              		.loc 1 150 5 view .LVU88
 150:Src/util.c    **** }
 410              		.loc 1 150 28 is_stmt 0 view .LVU89
 411 001e 4FF09042 		mov	r2, #1207959552
 412 0022 5369     		ldr	r3, [r2, #20]
 413 0024 83F00103 		eor	r3, r3, #1
 414 0028 5361     		str	r3, [r2, #20]
 415              	.LVL41:
 416              	.L20:
 150:Src/util.c    **** }
 417              		.loc 1 150 28 view .LVU90
 418              	.LBE15:
 419              	.LBE14:
 246:Src/util.c    ****     }
 247:Src/util.c    ****     // Print MPU data to Console
 248:Src/util.c    ****     #ifdef SERIAL_DEBUG
 249:Src/util.c    ****     if (main_loop_counter % 50 == 0) {
 250:Src/util.c    ****         mpu_print_to_console();
 251:Src/util.c    ****     }
 252:Src/util.c    ****     #endif
ARM GAS  /tmp/ccPeOSOQ.s 			page 13


 253:Src/util.c    **** #endif
 254:Src/util.c    **** }
 420              		.loc 1 254 1 view .LVU91
 421 002a 7047     		bx	lr
 422              	.L24:
 423              		.align	2
 424              	.L23:
 425 002c 00000000 		.word	.LANCHOR2
 426 0030 00000000 		.word	main_loop_counter
 427              		.cfi_endproc
 428              	.LFE64:
 430              		.section	.text.handle_sensors,"ax",%progbits
 431              		.align	1
 432              		.global	handle_sensors
 433              		.syntax unified
 434              		.thumb
 435              		.thumb_func
 436              		.fpu softvfp
 438              	handle_sensors:
 439              	.LFB65:
 255:Src/util.c    **** 
 256:Src/util.c    **** /*
 257:Src/util.c    ****  * Handle of the optical sensors
 258:Src/util.c    ****  */
 259:Src/util.c    **** void handle_sensors(void) {
 440              		.loc 1 259 27 is_stmt 1 view -0
 441              		.cfi_startproc
 442              		@ args = 0, pretend = 0, frame = 0
 443              		@ frame_needed = 0, uses_anonymous_args = 0
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 444              		.loc 1 260 5 view .LVU93
 259:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 445              		.loc 1 259 27 is_stmt 0 view .LVU94
 446 0000 38B5     		push	{r3, r4, r5, lr}
 447              	.LCFI4:
 448              		.cfi_def_cfa_offset 16
 449              		.cfi_offset 3, -16
 450              		.cfi_offset 4, -12
 451              		.cfi_offset 5, -8
 452              		.cfi_offset 14, -4
 453              		.loc 1 260 20 view .LVU95
 454 0002 1021     		movs	r1, #16
 455 0004 4FF09040 		mov	r0, #1207959552
 456 0008 FFF7FEFF 		bl	gpio_input_bit_get
 457              	.LVL42:
 458              		.loc 1 260 18 view .LVU96
 459 000c 1B4D     		ldr	r5, .L30
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 460              		.loc 1 261 20 view .LVU97
 461 000e 4FF48041 		mov	r1, #16384
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 462              		.loc 1 260 18 view .LVU98
 463 0012 2870     		strb	r0, [r5]
 464              		.loc 1 261 5 is_stmt 1 view .LVU99
 465              		.loc 1 261 20 is_stmt 0 view .LVU100
 466 0014 1A48     		ldr	r0, .L30+4
 467 0016 FFF7FEFF 		bl	gpio_input_bit_get
ARM GAS  /tmp/ccPeOSOQ.s 			page 14


 468              	.LVL43:
 262:Src/util.c    **** 
 263:Src/util.c    ****     // SENSOR1
 264:Src/util.c    ****     if (sensor1 == RESET && sensor1_read == SET) {
 469              		.loc 1 264 17 view .LVU101
 470 001a 1A4B     		ldr	r3, .L30+8
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 471              		.loc 1 261 18 view .LVU102
 472 001c 1A4C     		ldr	r4, .L30+12
 473              		.loc 1 264 17 view .LVU103
 474 001e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 475              		.loc 1 261 18 view .LVU104
 476 0020 2070     		strb	r0, [r4]
 477              		.loc 1 264 5 is_stmt 1 view .LVU105
 478              		.loc 1 264 8 is_stmt 0 view .LVU106
 479 0022 A2B9     		cbnz	r2, .L26
 480              		.loc 1 264 26 discriminator 1 view .LVU107
 481 0024 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 482 0026 012A     		cmp	r2, #1
 483 0028 04D1     		bne	.L27
 265:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 266:Src/util.c    ****         sensor1 = SET;
 484              		.loc 1 266 9 is_stmt 1 view .LVU108
 267:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 485              		.loc 1 267 9 is_stmt 0 view .LVU109
 486 002a 2021     		movs	r1, #32
 487 002c 1748     		ldr	r0, .L30+16
 266:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 488              		.loc 1 266 17 view .LVU110
 489 002e 1A70     		strb	r2, [r3]
 490              		.loc 1 267 9 is_stmt 1 view .LVU111
 491 0030 FFF7FEFF 		bl	gpio_bit_set
 492              	.LVL44:
 268:Src/util.c    ****         consoleLog("SENSOR 1 ON\r\n");
 493              		.loc 1 268 9 view .LVU112
 494              	.LBB16:
 495              	.LBI16:
 117:Src/util.c    **** {
 496              		.loc 1 117 6 view .LVU113
 497              	.LBB17:
 122:Src/util.c    **** 
 498              		.loc 1 122 1 view .LVU114
 499              	.L27:
 122:Src/util.c    **** 
 500              		.loc 1 122 1 is_stmt 0 view .LVU115
 501              	.LBE17:
 502              	.LBE16:
 269:Src/util.c    ****     } else if(sensor1 == SET && sensor1_read == RESET) {
 270:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 271:Src/util.c    ****         sensor1 = RESET;
 272:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 273:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 274:Src/util.c    ****     }
 275:Src/util.c    **** 
 276:Src/util.c    ****     // SENSOR2
 277:Src/util.c    ****     if (sensor2 == RESET && sensor2_read == SET) {
ARM GAS  /tmp/ccPeOSOQ.s 			page 15


 503              		.loc 1 277 5 is_stmt 1 view .LVU116
 504              		.loc 1 277 17 is_stmt 0 view .LVU117
 505 0034 164B     		ldr	r3, .L30+20
 506 0036 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 507              		.loc 1 277 8 view .LVU118
 508 0038 A2B9     		cbnz	r2, .L28
 509              		.loc 1 277 26 discriminator 1 view .LVU119
 510 003a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 511 003c 012A     		cmp	r2, #1
 512 003e 1CD1     		bne	.L25
 278:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 279:Src/util.c    ****         sensor2 = SET;
 513              		.loc 1 279 9 is_stmt 1 view .LVU120
 514              		.loc 1 279 17 is_stmt 0 view .LVU121
 515 0040 1A70     		strb	r2, [r3]
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 516              		.loc 1 280 9 is_stmt 1 view .LVU122
 517 0042 1021     		movs	r1, #16
 281:Src/util.c    ****         consoleLog("SENSOR 2 ON\r\n");
 282:Src/util.c    ****     } else if (sensor2 == SET && sensor2_read == RESET) {
 283:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 284:Src/util.c    ****         sensor2 = RESET;
 285:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 286:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 287:Src/util.c    ****     }
 288:Src/util.c    **** 
 289:Src/util.c    ****     if (sensor1 == SET) {
 290:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 291:Src/util.c    ****     }
 292:Src/util.c    ****     if (sensor2 == SET) {
 293:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 294:Src/util.c    ****     }
 295:Src/util.c    **** }
 518              		.loc 1 295 1 is_stmt 0 view .LVU123
 519 0044 BDE83840 		pop	{r3, r4, r5, lr}
 520              	.LCFI5:
 521              		.cfi_remember_state
 522              		.cfi_restore 14
 523              		.cfi_restore 5
 524              		.cfi_restore 4
 525              		.cfi_restore 3
 526              		.cfi_def_cfa_offset 0
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 527              		.loc 1 280 9 view .LVU124
 528 0048 1048     		ldr	r0, .L30+16
 529 004a FFF7FEBF 		b	gpio_bit_set
 530              	.LVL45:
 531              	.L26:
 532              	.LCFI6:
 533              		.cfi_restore_state
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 534              		.loc 1 269 12 is_stmt 1 view .LVU125
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 535              		.loc 1 269 14 is_stmt 0 view .LVU126
 536 004e 012A     		cmp	r2, #1
 537 0050 F0D1     		bne	.L27
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
ARM GAS  /tmp/ccPeOSOQ.s 			page 16


 538              		.loc 1 269 30 discriminator 1 view .LVU127
 539 0052 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 540 0054 002A     		cmp	r2, #0
 541 0056 EDD1     		bne	.L27
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 542              		.loc 1 271 9 is_stmt 1 view .LVU128
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 543              		.loc 1 272 9 is_stmt 0 view .LVU129
 544 0058 2021     		movs	r1, #32
 545 005a 0C48     		ldr	r0, .L30+16
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 546              		.loc 1 271 17 view .LVU130
 547 005c 1A70     		strb	r2, [r3]
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 548              		.loc 1 272 9 is_stmt 1 view .LVU131
 549 005e FFF7FEFF 		bl	gpio_bit_reset
 550              	.LVL46:
 273:Src/util.c    ****     }
 551              		.loc 1 273 9 view .LVU132
 552              	.LBB18:
 553              	.LBI18:
 117:Src/util.c    **** {
 554              		.loc 1 117 6 view .LVU133
 555              	.LBB19:
 122:Src/util.c    **** 
 556              		.loc 1 122 1 view .LVU134
 557 0062 E7E7     		b	.L27
 558              	.LVL47:
 559              	.L28:
 122:Src/util.c    **** 
 560              		.loc 1 122 1 is_stmt 0 view .LVU135
 561              	.LBE19:
 562              	.LBE18:
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 563              		.loc 1 282 12 is_stmt 1 view .LVU136
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 564              		.loc 1 282 15 is_stmt 0 view .LVU137
 565 0064 012A     		cmp	r2, #1
 566 0066 08D1     		bne	.L25
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 567              		.loc 1 282 31 discriminator 1 view .LVU138
 568 0068 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 569 006a 32B9     		cbnz	r2, .L25
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 570              		.loc 1 284 9 is_stmt 1 view .LVU139
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 571              		.loc 1 284 17 is_stmt 0 view .LVU140
 572 006c 1A70     		strb	r2, [r3]
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 573              		.loc 1 285 9 is_stmt 1 view .LVU141
 574 006e 1021     		movs	r1, #16
 575              		.loc 1 295 1 is_stmt 0 view .LVU142
 576 0070 BDE83840 		pop	{r3, r4, r5, lr}
 577              	.LCFI7:
 578              		.cfi_remember_state
 579              		.cfi_restore 14
 580              		.cfi_restore 5
ARM GAS  /tmp/ccPeOSOQ.s 			page 17


 581              		.cfi_restore 4
 582              		.cfi_restore 3
 583              		.cfi_def_cfa_offset 0
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 584              		.loc 1 285 9 view .LVU143
 585 0074 0548     		ldr	r0, .L30+16
 586 0076 FFF7FEBF 		b	gpio_bit_reset
 587              	.LVL48:
 588              	.L25:
 589              	.LCFI8:
 590              		.cfi_restore_state
 591              		.loc 1 295 1 view .LVU144
 592 007a 38BD     		pop	{r3, r4, r5, pc}
 593              	.L31:
 594              		.align	2
 595              	.L30:
 596 007c 00000000 		.word	.LANCHOR3
 597 0080 00080048 		.word	1207961600
 598 0084 00000000 		.word	.LANCHOR5
 599 0088 00000000 		.word	.LANCHOR4
 600 008c 00040048 		.word	1207960576
 601 0090 00000000 		.word	.LANCHOR6
 602              		.cfi_endproc
 603              	.LFE65:
 605              		.section	.text.handle_usart,"ax",%progbits
 606              		.align	1
 607              		.global	handle_usart
 608              		.syntax unified
 609              		.thumb
 610              		.thumb_func
 611              		.fpu softvfp
 613              	handle_usart:
 614              	.LFB66:
 296:Src/util.c    **** 
 297:Src/util.c    **** 
 298:Src/util.c    **** 
 299:Src/util.c    **** 
 300:Src/util.c    **** /*
 301:Src/util.c    ****  * Handle of the USART data
 302:Src/util.c    ****  */
 303:Src/util.c    **** void handle_usart(void) {
 615              		.loc 1 303 25 is_stmt 1 view -0
 616              		.cfi_startproc
 617              		@ args = 0, pretend = 0, frame = 0
 618              		@ frame_needed = 0, uses_anonymous_args = 0
 304:Src/util.c    ****     // Tx USART MAIN
 305:Src/util.c    ****     #ifdef SERIAL_CONTROL
 306:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART1_TX_DMA_CH) == 0) {     // 
 619              		.loc 1 306 9 view .LVU146
 620              		.loc 1 306 31 is_stmt 0 view .LVU147
 621 0000 454B     		ldr	r3, .L37
 303:Src/util.c    ****     // Tx USART MAIN
 622              		.loc 1 303 25 view .LVU148
 623 0002 464A     		ldr	r2, .L37+4
 624 0004 1B68     		ldr	r3, [r3]
 625 0006 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 626              	.LCFI9:
ARM GAS  /tmp/ccPeOSOQ.s 			page 18


 627              		.cfi_def_cfa_offset 24
 628              		.cfi_offset 4, -24
 629              		.cfi_offset 5, -20
 630              		.cfi_offset 6, -16
 631              		.cfi_offset 7, -12
 632              		.cfi_offset 8, -8
 633              		.cfi_offset 14, -4
 303:Src/util.c    ****     // Tx USART MAIN
 634              		.loc 1 303 25 view .LVU149
 635 000a 5343     		muls	r3, r2, r3
 636              		.loc 1 306 12 view .LVU150
 637 000c B3F1333F 		cmp	r3, #858993459
 638 0010 73D8     		bhi	.L34
 639              		.loc 1 306 43 discriminator 1 view .LVU151
 640 0012 0320     		movs	r0, #3
 641 0014 FFF7FEFF 		bl	dma_transfer_number_get
 642              	.LVL49:
 643              		.loc 1 306 40 discriminator 1 view .LVU152
 644 0018 0028     		cmp	r0, #0
 645 001a 6ED1     		bne	.L34
 307:Src/util.c    ****             sideboard_imu.start =   (uint16_t)SERIAL_START_FRAME;
 646              		.loc 1 307 13 is_stmt 1 view .LVU153
 647              		.loc 1 307 33 is_stmt 0 view .LVU154
 648 001c 6FF03203 		mvn	r3, #50
 649 0020 3F4C     		ldr	r4, .L37+8
 650 0022 2370     		strb	r3, [r4]
 651 0024 6FF05403 		mvn	r3, #84
 652 0028 6370     		strb	r3, [r4, #1]
 308:Src/util.c    ****             sideboard_imu.cmd1 =    (int16_t)0;
 653              		.loc 1 308 13 is_stmt 1 view .LVU155
 309:Src/util.c    ****             sideboard_imu.cmd2 =    (int16_t)0;
 310:Src/util.c    ****             sideboard_imu.pitch =   (int16_t)mpu.euler.pitch;
 654              		.loc 1 310 55 is_stmt 0 view .LVU156
 655 002a 3E4B     		ldr	r3, .L37+12
 308:Src/util.c    ****             sideboard_imu.cmd1 =    (int16_t)0;
 656              		.loc 1 308 32 view .LVU157
 657 002c A070     		strb	r0, [r4, #2]
 311:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 658              		.loc 1 311 54 view .LVU158
 659 002e B3F90210 		ldrsh	r1, [r3, #2]
 310:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 660              		.loc 1 310 55 view .LVU159
 661 0032 B3F91E20 		ldrsh	r2, [r3, #30]
 662              		.loc 1 311 34 view .LVU160
 663 0036 2181     		strh	r1, [r4, #8]	@ unaligned
 312:Src/util.c    ****   
 313:Src/util.c    ****             sideboard_imu.gyro_x =  (int16_t)mpu.gyro.x;
 314:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 664              		.loc 1 314 34 view .LVU161
 665 0038 A181     		strh	r1, [r4, #12]	@ unaligned
 315:Src/util.c    ****             sideboard_imu.gyro_z =  (int16_t)mpu.gyro.z;
 316:Src/util.c    ****             
 317:Src/util.c    ****             sideboard_imu.accel_x = (int16_t)mpu.accel.x;
 318:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 319:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 320:Src/util.c    ****         
 321:Src/util.c    ****             sideboard_imu.quat_w = (int16_t)34;//mpu.quat.w;
ARM GAS  /tmp/ccPeOSOQ.s 			page 19


 666              		.loc 1 321 34 view .LVU162
 667 003a 2221     		movs	r1, #34
 668 003c A175     		strb	r1, [r4, #22]
 322:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)-1234;//mpu.quat.x;
 669              		.loc 1 322 34 view .LVU163
 670 003e 2E21     		movs	r1, #46
 671 0040 2176     		strb	r1, [r4, #24]
 672 0042 6FF00401 		mvn	r1, #4
 673 0046 6176     		strb	r1, [r4, #25]
 323:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)5322;//mpu.quat.y;
 674              		.loc 1 323 34 view .LVU164
 675 0048 6FF03501 		mvn	r1, #53
 676 004c A176     		strb	r1, [r4, #26]
 677 004e 1421     		movs	r1, #20
 678 0050 E176     		strb	r1, [r4, #27]
 324:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)-876;//mpu.quat.z;
 679              		.loc 1 324 34 view .LVU165
 680 0052 6FF06B01 		mvn	r1, #107
 681 0056 2177     		strb	r1, [r4, #28]
 682 0058 6FF00301 		mvn	r1, #3
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 683              		.loc 1 317 55 view .LVU166
 684 005c B3F906C0 		ldrsh	ip, [r3, #6]
 313:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 685              		.loc 1 313 54 view .LVU167
 686 0060 B3F900E0 		ldrsh	lr, [r3]
 315:Src/util.c    ****             
 687              		.loc 1 315 54 view .LVU168
 688 0064 B3F90480 		ldrsh	r8, [r3, #4]
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 689              		.loc 1 318 55 view .LVU169
 690 0068 B3F90870 		ldrsh	r7, [r3, #8]
 319:Src/util.c    ****         
 691              		.loc 1 319 55 view .LVU170
 692 006c B3F90A60 		ldrsh	r6, [r3, #10]
 325:Src/util.c    ****  
 326:Src/util.c    ****             sideboard_imu.euler_pitch = (int16_t)mpu.euler.pitch;
 327:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 693              		.loc 1 327 58 view .LVU171
 694 0070 B3F91C50 		ldrsh	r5, [r3, #28]
 310:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 695              		.loc 1 310 33 view .LVU172
 696 0074 E280     		strh	r2, [r4, #6]	@ unaligned
 326:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 697              		.loc 1 326 39 view .LVU173
 698 0076 E283     		strh	r2, [r4, #30]	@ unaligned
 328:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 329:Src/util.c    ****             
 330:Src/util.c    ****             sideboard_imu.temperature = (int16_t)mpu.temp;
 331:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 699              		.loc 1 331 87 view .LVU174
 700 0078 2B4A     		ldr	r2, .L37+16
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 701              		.loc 1 317 35 view .LVU175
 702 007a A4F810C0 		strh	ip, [r4, #16]	@ unaligned
 313:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 703              		.loc 1 313 34 view .LVU176
ARM GAS  /tmp/ccPeOSOQ.s 			page 20


 704 007e A4F80AE0 		strh	lr, [r4, #10]	@ unaligned
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 705              		.loc 1 318 35 view .LVU177
 706 0082 6782     		strh	r7, [r4, #18]	@ unaligned
 319:Src/util.c    ****         
 707              		.loc 1 319 35 view .LVU178
 708 0084 A682     		strh	r6, [r4, #20]	@ unaligned
 324:Src/util.c    ****  
 709              		.loc 1 324 34 view .LVU179
 710 0086 6177     		strb	r1, [r4, #29]
 327:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 711              		.loc 1 327 38 view .LVU180
 712 0088 2584     		strh	r5, [r4, #32]	@ unaligned
 308:Src/util.c    ****             sideboard_imu.cmd2 =    (int16_t)0;
 713              		.loc 1 308 32 view .LVU181
 714 008a E070     		strb	r0, [r4, #3]
 309:Src/util.c    ****             sideboard_imu.pitch =   (int16_t)mpu.euler.pitch;
 715              		.loc 1 309 13 is_stmt 1 view .LVU182
 309:Src/util.c    ****             sideboard_imu.pitch =   (int16_t)mpu.euler.pitch;
 716              		.loc 1 309 32 is_stmt 0 view .LVU183
 717 008c 2071     		strb	r0, [r4, #4]
 718 008e 6071     		strb	r0, [r4, #5]
 310:Src/util.c    ****             sideboard_imu.dPitch =  (int16_t)mpu.gyro.y;
 719              		.loc 1 310 13 is_stmt 1 view .LVU184
 311:Src/util.c    ****   
 720              		.loc 1 311 13 view .LVU185
 313:Src/util.c    ****             sideboard_imu.gyro_y =  (int16_t)mpu.gyro.y;
 721              		.loc 1 313 13 view .LVU186
 314:Src/util.c    ****             sideboard_imu.gyro_z =  (int16_t)mpu.gyro.z;
 722              		.loc 1 314 13 view .LVU187
 315:Src/util.c    ****             
 723              		.loc 1 315 13 view .LVU188
 315:Src/util.c    ****             
 724              		.loc 1 315 34 is_stmt 0 view .LVU189
 725 0090 A4F80E80 		strh	r8, [r4, #14]	@ unaligned
 317:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 726              		.loc 1 317 13 is_stmt 1 view .LVU190
 318:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 727              		.loc 1 318 13 view .LVU191
 319:Src/util.c    ****         
 728              		.loc 1 319 13 view .LVU192
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)-1234;//mpu.quat.x;
 729              		.loc 1 321 13 view .LVU193
 321:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)-1234;//mpu.quat.x;
 730              		.loc 1 321 34 is_stmt 0 view .LVU194
 731 0094 E075     		strb	r0, [r4, #23]
 322:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)5322;//mpu.quat.y;
 732              		.loc 1 322 13 is_stmt 1 view .LVU195
 323:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)-876;//mpu.quat.z;
 733              		.loc 1 323 13 view .LVU196
 324:Src/util.c    ****  
 734              		.loc 1 324 13 view .LVU197
 326:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 735              		.loc 1 326 13 view .LVU198
 327:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 736              		.loc 1 327 13 view .LVU199
 328:Src/util.c    ****             
ARM GAS  /tmp/ccPeOSOQ.s 			page 21


 737              		.loc 1 328 13 view .LVU200
 328:Src/util.c    ****             
 738              		.loc 1 328 57 is_stmt 0 view .LVU201
 739 0096 B3F92000 		ldrsh	r0, [r3, #32]
 740              		.loc 1 331 87 view .LVU202
 741 009a 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 742              		.loc 1 331 106 view .LVU203
 743 009c 234A     		ldr	r2, .L37+20
 332:Src/util.c    **** 
 333:Src/util.c    ****             sideboard_imu.checksum = (uint16_t)(
 334:Src/util.c    ****                 sideboard_imu.start ^
 335:Src/util.c    ****                 sideboard_imu.cmd1 ^ sideboard_imu.cmd2 ^
 336:Src/util.c    ****                 sideboard_imu.pitch ^ sideboard_imu.dPitch ^
 337:Src/util.c    ****                 sideboard_imu.gyro_x ^ sideboard_imu.gyro_y ^ sideboard_imu.gyro_z ^
 338:Src/util.c    ****                 sideboard_imu.accel_x ^ sideboard_imu.accel_y ^ sideboard_imu.accel_z ^
 339:Src/util.c    ****                 sideboard_imu.quat_w ^ sideboard_imu.quat_x ^ sideboard_imu.quat_y ^ sideboard_imu.
 340:Src/util.c    ****                 sideboard_imu.euler_pitch ^ sideboard_imu.euler_roll ^ sideboard_imu.euler_yaw ^
 341:Src/util.c    ****                 sideboard_imu.temperature ^ sideboard_imu.sensors
 744              		.loc 1 341 43 view .LVU204
 745 009e 8EEA080E 		eor	lr, lr, r8
 331:Src/util.c    **** 
 746              		.loc 1 331 106 view .LVU205
 747 00a2 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 748              		.loc 1 330 53 view .LVU206
 749 00a4 B3F92230 		ldrsh	r3, [r3, #34]
 331:Src/util.c    **** 
 750              		.loc 1 331 106 view .LVU207
 751 00a8 9200     		lsls	r2, r2, #2
 331:Src/util.c    **** 
 752              		.loc 1 331 93 view .LVU208
 753 00aa 42EA4101 		orr	r1, r2, r1, lsl #1
 331:Src/util.c    **** 
 754              		.loc 1 331 76 view .LVU209
 755 00ae 204A     		ldr	r2, .L37+24
 328:Src/util.c    ****             
 756              		.loc 1 328 37 view .LVU210
 757 00b0 6084     		strh	r0, [r4, #34]	@ unaligned
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 758              		.loc 1 330 13 is_stmt 1 view .LVU211
 331:Src/util.c    **** 
 759              		.loc 1 331 76 is_stmt 0 view .LVU212
 760 00b2 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 330:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 761              		.loc 1 330 39 view .LVU213
 762 00b4 A384     		strh	r3, [r4, #36]	@ unaligned
 331:Src/util.c    **** 
 763              		.loc 1 331 13 is_stmt 1 view .LVU214
 331:Src/util.c    **** 
 764              		.loc 1 331 93 is_stmt 0 view .LVU215
 765 00b6 0A43     		orrs	r2, r2, r1
 331:Src/util.c    **** 
 766              		.loc 1 331 35 view .LVU216
 767 00b8 E284     		strh	r2, [r4, #38]	@ unaligned
 333:Src/util.c    ****                 sideboard_imu.start ^
 768              		.loc 1 333 13 is_stmt 1 view .LVU217
 769              		.loc 1 341 43 is_stmt 0 view .LVU218
ARM GAS  /tmp/ccPeOSOQ.s 			page 22


 770 00ba 82EA0E02 		eor	r2, r2, lr
 771 00be 8CEA0202 		eor	r2, ip, r2
 772 00c2 5740     		eors	r7, r7, r2
 773 00c4 7E40     		eors	r6, r6, r7
 774 00c6 7540     		eors	r5, r5, r6
 775 00c8 6840     		eors	r0, r0, r5
 776 00ca 4340     		eors	r3, r3, r0
 777 00cc 83F43843 		eor	r3, r3, #47104
 778 00d0 83F09F03 		eor	r3, r3, #159
 342:Src/util.c    ****             );
 343:Src/util.c    ****         
 344:Src/util.c    ****             dma_channel_disable(USART1_TX_DMA_CH);
 779              		.loc 1 344 13 view .LVU219
 780 00d4 0320     		movs	r0, #3
 333:Src/util.c    ****                 sideboard_imu.start ^
 781              		.loc 1 333 36 view .LVU220
 782 00d6 2385     		strh	r3, [r4, #40]	@ unaligned
 783              		.loc 1 344 13 is_stmt 1 view .LVU221
 784 00d8 FFF7FEFF 		bl	dma_channel_disable
 785              	.LVL50:
 345:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 786              		.loc 1 345 13 view .LVU222
 787              		.loc 1 345 45 is_stmt 0 view .LVU223
 788 00dc 2A22     		movs	r2, #42
 789 00de 154B     		ldr	r3, .L37+28
 346:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 347:Src/util.c    ****             dma_channel_enable(USART1_TX_DMA_CH);
 790              		.loc 1 347 13 view .LVU224
 791 00e0 0320     		movs	r0, #3
 345:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 792              		.loc 1 345 45 view .LVU225
 793 00e2 9A64     		str	r2, [r3, #72]
 346:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 794              		.loc 1 346 13 is_stmt 1 view .LVU226
 346:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 795              		.loc 1 346 45 is_stmt 0 view .LVU227
 796 00e4 1C65     		str	r4, [r3, #80]
 797              		.loc 1 347 13 is_stmt 1 view .LVU228
 798 00e6 FFF7FEFF 		bl	dma_channel_enable
 799              	.LVL51:
 348:Src/util.c    **** 
 349:Src/util.c    **** 
 350:Src/util.c    ****             toggle_led(LED2_GPIO_Port, LED2_Pin); //toggle green
 800              		.loc 1 350 13 view .LVU229
 801              	.LBB20:
 802              	.LBI20:
 148:Src/util.c    **** {
 803              		.loc 1 148 6 view .LVU230
 804              	.LBB21:
 150:Src/util.c    **** }
 805              		.loc 1 150 5 view .LVU231
 150:Src/util.c    **** }
 806              		.loc 1 150 28 is_stmt 0 view .LVU232
 807 00ea 4FF09042 		mov	r2, #1207959552
 808 00ee D2F81434 		ldr	r3, [r2, #1044]
 809 00f2 83F40073 		eor	r3, r3, #512
 810 00f6 C2F81434 		str	r3, [r2, #1044]
ARM GAS  /tmp/ccPeOSOQ.s 			page 23


 811              	.LVL52:
 812              	.L34:
 150:Src/util.c    **** }
 813              		.loc 1 150 28 view .LVU233
 814              	.LBE21:
 815              	.LBE20:
 351:Src/util.c    **** 
 352:Src/util.c    ****         }
 353:Src/util.c    ****     #endif
 354:Src/util.c    ****     // Rx USART MAIN
 355:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 356:Src/util.c    ****         if (timeoutCntSerial1++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 816              		.loc 1 356 9 is_stmt 1 view .LVU234
 817              		.loc 1 356 30 is_stmt 0 view .LVU235
 818 00fa 0F4B     		ldr	r3, .L37+32
 819 00fc 1A88     		ldrh	r2, [r3]
 820 00fe 511C     		adds	r1, r2, #1
 821              		.loc 1 356 12 view .LVU236
 822 0100 B2F5167F 		cmp	r2, #600
 823              		.loc 1 356 30 view .LVU237
 824 0104 1980     		strh	r1, [r3]	@ movhi
 825              		.loc 1 356 12 view .LVU238
 826 0106 05D3     		bcc	.L32
 357:Src/util.c    ****             timeoutFlagSerial1 = 1;                                 // Timeout detected
 827              		.loc 1 357 13 is_stmt 1 view .LVU239
 828              		.loc 1 357 32 is_stmt 0 view .LVU240
 829 0108 0121     		movs	r1, #1
 830 010a 0C4A     		ldr	r2, .L37+36
 831 010c 1170     		strb	r1, [r2]
 358:Src/util.c    ****             timeoutCntSerial1  = SERIAL_TIMEOUT;                    // Limit timout counter value
 832              		.loc 1 358 13 is_stmt 1 view .LVU241
 833              		.loc 1 358 32 is_stmt 0 view .LVU242
 834 010e 4FF41672 		mov	r2, #600
 835 0112 1A80     		strh	r2, [r3]	@ movhi
 359:Src/util.c    ****         }
 360:Src/util.c    ****         if (timeoutFlagSerial1 && main_loop_counter % 100 == 0) {   // In case of timeout bring the
 836              		.loc 1 360 9 is_stmt 1 view .LVU243
 361:Src/util.c    ****             //toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED ever
 362:Src/util.c    ****         }
 837              		.loc 1 362 9 view .LVU244
 838              	.L32:
 363:Src/util.c    ****     #endif
 364:Src/util.c    **** 
 365:Src/util.c    ****     // Tx USART AUX
 366:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 367:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART0_TX_DMA_CH) == 0) {     // 
 368:Src/util.c    ****             AuxTx.start     = (uint16_t)SERIAL_START_FRAME;
 369:Src/util.c    ****             AuxTx.signal1   = (int16_t)sensor1;
 370:Src/util.c    ****             AuxTx.signal2   = (int16_t)sensor2;
 371:Src/util.c    ****             AuxTx.checksum  = (uint16_t)(AuxTx.start ^ AuxTx.signal1 ^ AuxTx.signal2);
 372:Src/util.c    ****         
 373:Src/util.c    ****             dma_channel_disable(USART0_TX_DMA_CH);
 374:Src/util.c    ****             DMA_CHCNT(USART0_TX_DMA_CH)     = sizeof(AuxTx);
 375:Src/util.c    ****             DMA_CHMADDR(USART0_TX_DMA_CH)   = (uint32_t)&AuxTx;
 376:Src/util.c    ****             dma_channel_enable(USART0_TX_DMA_CH);
 377:Src/util.c    ****         }
 378:Src/util.c    ****     #endif
ARM GAS  /tmp/ccPeOSOQ.s 			page 24


 379:Src/util.c    ****     // Rx USART AUX
 380:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 381:Src/util.c    ****         #ifdef CONTROL_IBUS
 382:Src/util.c    ****         if (!timeoutFlagSerial0) {
 383:Src/util.c    ****             for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 384:Src/util.c    ****                 ibus_captured_value[(i/2)] = CLAMP(command.channels[i] + (command.channels[i+1] << 
 385:Src/util.c    ****             }
 386:Src/util.c    ****             cmd1        = (ibus_captured_value[0] - 500) * 2;                           // Channel 
 387:Src/util.c    ****             cmd2        = (ibus_captured_value[1] - 500) * 2;                           // Channel 
 388:Src/util.c    ****             cmdSwitch   = (uint16_t)(switch_check(ibus_captured_value[6],0)      |      // Channel 
 389:Src/util.c    ****                                      switch_check(ibus_captured_value[7],1) << 1 |      // Channel 
 390:Src/util.c    ****                                      switch_check(ibus_captured_value[8],1) << 3 |      // Channel 
 391:Src/util.c    ****                                      switch_check(ibus_captured_value[9],0) << 5);      // Channel 
 392:Src/util.c    ****         }
 393:Src/util.c    ****         #endif
 394:Src/util.c    **** 
 395:Src/util.c    ****         if (timeoutCntSerial0++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 396:Src/util.c    ****             timeoutFlagSerial0 = 1;                                 // Timeout detected
 397:Src/util.c    ****             timeoutCntSerial0  = SERIAL_TIMEOUT;                    // Limit timout counter value
 398:Src/util.c    ****             cmd1 = cmd2 = 0;                                        // Set commands to 0
 399:Src/util.c    ****             cmdSwitch &= ~(1U << 0);                                // Clear Bit 0, to switch to de
 400:Src/util.c    ****         }
 401:Src/util.c    ****         // if (timeoutFlagSerial0 && main_loop_counter % 100 == 0) {   // In case of timeout bring 
 402:Src/util.c    ****         //     toggle_led(LED2_GPIO_Port, LED2_Pin);                   // Toggle the Green LED ever
 403:Src/util.c    ****         // }
 404:Src/util.c    **** 
 405:Src/util.c    ****         #ifdef SERIAL_DEBUG
 406:Src/util.c    ****             // Print MPU data to Console
 407:Src/util.c    ****             if (main_loop_counter % 50 == 0) {
 408:Src/util.c    ****                 aux_print_to_console();
 409:Src/util.c    ****             }
 410:Src/util.c    ****         #endif
 411:Src/util.c    ****     #endif
 412:Src/util.c    **** }
 839              		.loc 1 412 1 is_stmt 0 view .LVU245
 840 0114 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 841              	.L38:
 842              		.align	2
 843              	.L37:
 844 0118 00000000 		.word	main_loop_counter
 845 011c CDCCCCCC 		.word	-858993459
 846 0120 00000000 		.word	.LANCHOR0
 847 0124 00000000 		.word	mpu
 848 0128 00000000 		.word	.LANCHOR6
 849 012c 00000000 		.word	.LANCHOR2
 850 0130 00000000 		.word	.LANCHOR5
 851 0134 00000240 		.word	1073872896
 852 0138 00000000 		.word	.LANCHOR7
 853 013c 00000000 		.word	.LANCHOR8
 854              		.cfi_endproc
 855              	.LFE66:
 857              		.section	.text.handle_leds,"ax",%progbits
 858              		.align	1
 859              		.global	handle_leds
 860              		.syntax unified
 861              		.thumb
 862              		.thumb_func
ARM GAS  /tmp/ccPeOSOQ.s 			page 25


 863              		.fpu softvfp
 865              	handle_leds:
 866              	.LFB67:
 413:Src/util.c    **** 
 414:Src/util.c    **** /*
 415:Src/util.c    ****  * Handle of the sideboard LEDs
 416:Src/util.c    ****  */
 417:Src/util.c    **** void handle_leds(void) {
 867              		.loc 1 417 24 is_stmt 1 view -0
 868              		.cfi_startproc
 869              		@ args = 0, pretend = 0, frame = 0
 870              		@ frame_needed = 0, uses_anonymous_args = 0
 418:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 419:Src/util.c    ****         if (!timeoutFlagSerial1) {
 871              		.loc 1 419 9 view .LVU247
 417:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 872              		.loc 1 417 24 is_stmt 0 view .LVU248
 873 0000 10B5     		push	{r4, lr}
 874              	.LCFI10:
 875              		.cfi_def_cfa_offset 8
 876              		.cfi_offset 4, -8
 877              		.cfi_offset 14, -4
 878              		.loc 1 419 13 view .LVU249
 879 0002 244B     		ldr	r3, .L52
 880              		.loc 1 419 12 view .LVU250
 881 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 882 0006 002B     		cmp	r3, #0
 883 0008 43D1     		bne	.L39
 420:Src/util.c    ****             if (Feedback.cmdLed & LED1_SET) { gpio_bit_set(LED1_GPIO_Port, LED1_Pin); } else { gpio
 884              		.loc 1 420 13 is_stmt 1 view .LVU251
 885              		.loc 1 420 25 is_stmt 0 view .LVU252
 886 000a 234C     		ldr	r4, .L52+4
 887              		.loc 1 420 47 view .LVU253
 888 000c 0121     		movs	r1, #1
 889              		.loc 1 420 16 view .LVU254
 890 000e A38D     		ldrh	r3, [r4, #44]
 891              		.loc 1 420 47 view .LVU255
 892 0010 4FF09040 		mov	r0, #1207959552
 893              		.loc 1 420 16 view .LVU256
 894 0014 DA07     		lsls	r2, r3, #31
 895 0016 29D5     		bpl	.L41
 896              		.loc 1 420 47 is_stmt 1 discriminator 1 view .LVU257
 897 0018 FFF7FEFF 		bl	gpio_bit_set
 898              	.LVL53:
 899              	.L42:
 421:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 900              		.loc 1 421 13 view .LVU258
 901              		.loc 1 421 16 is_stmt 0 view .LVU259
 902 001c A38D     		ldrh	r3, [r4, #44]
 903              		.loc 1 421 47 view .LVU260
 904 001e 4FF40071 		mov	r1, #512
 905              		.loc 1 421 16 view .LVU261
 906 0022 9B07     		lsls	r3, r3, #30
 907              		.loc 1 421 47 view .LVU262
 908 0024 1D48     		ldr	r0, .L52+8
 909              		.loc 1 421 16 view .LVU263
 910 0026 24D5     		bpl	.L43
ARM GAS  /tmp/ccPeOSOQ.s 			page 26


 911              		.loc 1 421 47 is_stmt 1 discriminator 1 view .LVU264
 912 0028 FFF7FEFF 		bl	gpio_bit_set
 913              	.LVL54:
 914              	.L44:
 422:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 915              		.loc 1 422 13 view .LVU265
 916              		.loc 1 422 16 is_stmt 0 view .LVU266
 917 002c A38D     		ldrh	r3, [r4, #44]
 918              		.loc 1 422 47 view .LVU267
 919 002e 4FF48071 		mov	r1, #256
 920              		.loc 1 422 16 view .LVU268
 921 0032 5A07     		lsls	r2, r3, #29
 922              		.loc 1 422 47 view .LVU269
 923 0034 1948     		ldr	r0, .L52+8
 924              		.loc 1 422 16 view .LVU270
 925 0036 1FD5     		bpl	.L45
 926              		.loc 1 422 47 is_stmt 1 discriminator 1 view .LVU271
 927 0038 FFF7FEFF 		bl	gpio_bit_set
 928              	.LVL55:
 929              	.L46:
 423:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 930              		.loc 1 423 13 view .LVU272
 931              		.loc 1 423 16 is_stmt 0 view .LVU273
 932 003c A38D     		ldrh	r3, [r4, #44]
 933              		.loc 1 423 47 view .LVU274
 934 003e 2021     		movs	r1, #32
 935              		.loc 1 423 16 view .LVU275
 936 0040 1B07     		lsls	r3, r3, #28
 937              		.loc 1 423 47 view .LVU276
 938 0042 1648     		ldr	r0, .L52+8
 939              		.loc 1 423 16 view .LVU277
 940 0044 1BD5     		bpl	.L47
 941              		.loc 1 423 47 is_stmt 1 discriminator 1 view .LVU278
 942 0046 FFF7FEFF 		bl	gpio_bit_set
 943              	.LVL56:
 944              	.L48:
 424:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 945              		.loc 1 424 13 view .LVU279
 946              		.loc 1 424 16 is_stmt 0 view .LVU280
 947 004a A38D     		ldrh	r3, [r4, #44]
 948              		.loc 1 424 47 view .LVU281
 949 004c 1021     		movs	r1, #16
 950              		.loc 1 424 16 view .LVU282
 951 004e DA06     		lsls	r2, r3, #27
 952              		.loc 1 424 47 view .LVU283
 953 0050 1248     		ldr	r0, .L52+8
 954              		.loc 1 424 16 view .LVU284
 955 0052 17D5     		bpl	.L49
 956              		.loc 1 424 47 is_stmt 1 discriminator 1 view .LVU285
 957 0054 FFF7FEFF 		bl	gpio_bit_set
 958              	.LVL57:
 959              	.L50:
 425:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 960              		.loc 1 425 13 view .LVU286
 961              		.loc 1 425 16 is_stmt 0 view .LVU287
 962 0058 A38D     		ldrh	r3, [r4, #44]
 963              		.loc 1 425 47 view .LVU288
ARM GAS  /tmp/ccPeOSOQ.s 			page 27


 964 005a 4FF48061 		mov	r1, #1024
 965              		.loc 1 425 16 view .LVU289
 966 005e 1B07     		lsls	r3, r3, #28
 967              		.loc 1 425 47 view .LVU290
 968 0060 0E48     		ldr	r0, .L52+8
 969              		.loc 1 425 16 view .LVU291
 970 0062 12D5     		bpl	.L51
 971              		.loc 1 425 47 is_stmt 1 discriminator 1 view .LVU292
 426:Src/util.c    ****         }
 427:Src/util.c    ****     #endif
 428:Src/util.c    **** }
 972              		.loc 1 428 1 is_stmt 0 discriminator 1 view .LVU293
 973 0064 BDE81040 		pop	{r4, lr}
 974              	.LCFI11:
 975              		.cfi_remember_state
 976              		.cfi_restore 14
 977              		.cfi_restore 4
 978              		.cfi_def_cfa_offset 0
 425:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 979              		.loc 1 425 47 discriminator 1 view .LVU294
 980 0068 FFF7FEBF 		b	gpio_bit_set
 981              	.LVL58:
 982              	.L41:
 983              	.LCFI12:
 984              		.cfi_restore_state
 420:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 985              		.loc 1 420 96 is_stmt 1 discriminator 2 view .LVU295
 986 006c FFF7FEFF 		bl	gpio_bit_reset
 987              	.LVL59:
 988 0070 D4E7     		b	.L42
 989              	.L43:
 421:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 990              		.loc 1 421 96 discriminator 2 view .LVU296
 991 0072 FFF7FEFF 		bl	gpio_bit_reset
 992              	.LVL60:
 993 0076 D9E7     		b	.L44
 994              	.L45:
 422:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 995              		.loc 1 422 96 discriminator 2 view .LVU297
 996 0078 FFF7FEFF 		bl	gpio_bit_reset
 997              	.LVL61:
 998 007c DEE7     		b	.L46
 999              	.L47:
 423:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 1000              		.loc 1 423 96 discriminator 2 view .LVU298
 1001 007e FFF7FEFF 		bl	gpio_bit_reset
 1002              	.LVL62:
 1003 0082 E2E7     		b	.L48
 1004              	.L49:
 424:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 1005              		.loc 1 424 96 discriminator 2 view .LVU299
 1006 0084 FFF7FEFF 		bl	gpio_bit_reset
 1007              	.LVL63:
 1008 0088 E6E7     		b	.L50
 1009              	.L51:
 425:Src/util.c    ****         }
 1010              		.loc 1 425 96 discriminator 2 view .LVU300
ARM GAS  /tmp/ccPeOSOQ.s 			page 28


 1011              		.loc 1 428 1 is_stmt 0 discriminator 2 view .LVU301
 1012 008a BDE81040 		pop	{r4, lr}
 1013              	.LCFI13:
 1014              		.cfi_remember_state
 1015              		.cfi_restore 14
 1016              		.cfi_restore 4
 1017              		.cfi_def_cfa_offset 0
 425:Src/util.c    ****         }
 1018              		.loc 1 425 96 discriminator 2 view .LVU302
 1019 008e FFF7FEBF 		b	gpio_bit_reset
 1020              	.LVL64:
 1021              	.L39:
 1022              	.LCFI14:
 1023              		.cfi_restore_state
 1024              		.loc 1 428 1 view .LVU303
 1025 0092 10BD     		pop	{r4, pc}
 1026              	.L53:
 1027              		.align	2
 1028              	.L52:
 1029 0094 00000000 		.word	.LANCHOR8
 1030 0098 00000000 		.word	.LANCHOR9
 1031 009c 00040048 		.word	1207960576
 1032              		.cfi_endproc
 1033              	.LFE67:
 1035              		.section	.text.usart_process_data,"ax",%progbits
 1036              		.align	1
 1037              		.global	usart_process_data
 1038              		.syntax unified
 1039              		.thumb
 1040              		.thumb_func
 1041              		.fpu softvfp
 1043              	usart_process_data:
 1044              	.LVL65:
 1045              	.LFB69:
 429:Src/util.c    **** 
 430:Src/util.c    **** 
 431:Src/util.c    **** /* =========================== USART1 READ Functions =========================== */
 432:Src/util.c    **** 
 433:Src/util.c    **** void usart1_rx_check(void)
 434:Src/util.c    **** {
 435:Src/util.c    ****     #ifdef SERIAL_DEBUG
 436:Src/util.c    ****     static uint32_t old_pos;
 437:Src/util.c    ****     uint32_t pos;
 438:Src/util.c    **** 
 439:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 440:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 441:Src/util.c    ****         if (pos > old_pos) {                                                    // "Linear" buffer 
 442:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], pos - old_pos);           // Process data
 443:Src/util.c    ****         } else {                                                                // "Overflow" buffe
 444:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], rx1_buffer_len - old_pos);// First Process da
 445:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 446:Src/util.c    ****                 usart_process_debug(&rx1_buffer[0], pos);                       // Process remainin
 447:Src/util.c    ****             }
 448:Src/util.c    ****         }
 449:Src/util.c    ****     }
 450:Src/util.c    ****     old_pos = pos;                                                              // Update old posit
 451:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
ARM GAS  /tmp/ccPeOSOQ.s 			page 29


 452:Src/util.c    ****         old_pos = 0;
 453:Src/util.c    ****     }
 454:Src/util.c    ****     #endif // SERIAL_DEBUG
 455:Src/util.c    **** 
 456:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 457:Src/util.c    ****     static uint32_t old_pos;
 458:Src/util.c    ****     uint32_t pos;
 459:Src/util.c    ****     uint8_t *ptr;
 460:Src/util.c    **** 
 461:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 462:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 463:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 464:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 465:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 466:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 467:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 468:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 469:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 470:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 471:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 472:Src/util.c    ****             }
 473:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 474:Src/util.c    ****         }
 475:Src/util.c    ****     }
 476:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 477:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 478:Src/util.c    ****         old_pos = 0;
 479:Src/util.c    ****     }
 480:Src/util.c    ****     #endif // SERIAL_FEEDBACK
 481:Src/util.c    **** }
 482:Src/util.c    **** 
 483:Src/util.c    **** /*
 484:Src/util.c    ****  * Process Rx debug user command input
 485:Src/util.c    ****  */
 486:Src/util.c    **** #ifdef SERIAL_DEBUG
 487:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
 488:Src/util.c    **** {
 489:Src/util.c    ****     for (; len > 0; len--, userCommand++) {
 490:Src/util.c    ****         if (*userCommand != '\n' && *userCommand != '\r') {     // Do not accept 'new line' and 'ca
 491:Src/util.c    ****             log_i("Command = %c\r\n", *userCommand);
 492:Src/util.c    ****             mpu_handle_input(*userCommand);
 493:Src/util.c    ****         }
 494:Src/util.c    ****     }
 495:Src/util.c    **** }
 496:Src/util.c    **** #endif // SERIAL_DEBUG
 497:Src/util.c    **** 
 498:Src/util.c    **** /*
 499:Src/util.c    ****  * Process Rx data
 500:Src/util.c    ****  * - if the Feedback_in data is valid (correct START_FRAME and checksum) copy the Feedback_in to Fe
 501:Src/util.c    ****  */
 502:Src/util.c    **** #ifdef SERIAL_FEEDBACK
 503:Src/util.c    **** void usart_process_data(SerialFeedback *Feedback_in, SerialFeedback *Feedback_out)
 504:Src/util.c    **** {
 1046              		.loc 1 504 1 is_stmt 1 view -0
 1047              		.cfi_startproc
 1048              		@ args = 0, pretend = 0, frame = 0
 1049              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccPeOSOQ.s 			page 30


 505:Src/util.c    ****     uint16_t checksum;
 1050              		.loc 1 505 5 view .LVU305
 506:Src/util.c    ****     if (Feedback_in->start == SERIAL_START_FRAME) {
 1051              		.loc 1 506 5 view .LVU306
 1052              		.loc 1 506 8 is_stmt 0 view .LVU307
 1053 0000 4AF6CD33 		movw	r3, #43981
 1054 0004 0288     		ldrh	r2, [r0]
 504:Src/util.c    ****     uint16_t checksum;
 1055              		.loc 1 504 1 view .LVU308
 1056 0006 10B5     		push	{r4, lr}
 1057              	.LCFI15:
 1058              		.cfi_def_cfa_offset 8
 1059              		.cfi_offset 4, -8
 1060              		.cfi_offset 14, -4
 1061              		.loc 1 506 8 view .LVU309
 1062 0008 9A42     		cmp	r2, r3
 1063 000a 1ED1     		bne	.L54
 1064              	.LVL66:
 1065              	.LBB24:
 1066              	.LBI24:
 503:Src/util.c    **** {
 1067              		.loc 1 503 6 is_stmt 1 view .LVU310
 1068              	.LBB25:
 507:Src/util.c    ****         checksum = (uint16_t)(Feedback_in->start ^ Feedback_in->cmd1 ^ Feedback_in->cmd2 ^ Feedback
 1069              		.loc 1 507 9 view .LVU311
 508:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 509:Src/util.c    ****         if (Feedback_in->checksum == checksum) {
 1070              		.loc 1 509 9 view .LVU312
 508:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 1071              		.loc 1 508 80 is_stmt 0 view .LVU313
 1072 000c 8488     		ldrh	r4, [r0, #4]
 1073 000e 4388     		ldrh	r3, [r0, #2]
 1074 0010 6340     		eors	r3, r3, r4
 1075 0012 848D     		ldrh	r4, [r0, #44]
 1076 0014 6340     		eors	r3, r3, r4
 1077 0016 C488     		ldrh	r4, [r0, #6]
 1078 0018 6340     		eors	r3, r3, r4
 1079 001a 0489     		ldrh	r4, [r0, #8]
 1080 001c 6340     		eors	r3, r3, r4
 1081 001e 4489     		ldrh	r4, [r0, #10]
 1082 0020 6340     		eors	r3, r3, r4
 1083 0022 8489     		ldrh	r4, [r0, #12]
 1084 0024 6340     		eors	r3, r3, r4
 1085 0026 5A40     		eors	r2, r2, r3
 1086              		.loc 1 509 12 view .LVU314
 1087 0028 C38D     		ldrh	r3, [r0, #46]
 1088 002a 92B2     		uxth	r2, r2
 1089 002c 9342     		cmp	r3, r2
 1090 002e 0CD1     		bne	.L54
 510:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1091              		.loc 1 510 13 is_stmt 1 view .LVU315
 1092              		.loc 1 510 27 is_stmt 0 view .LVU316
 1093 0030 00F13003 		add	r3, r0, #48
 1094              	.LVL67:
 1095              	.L56:
 1096              		.loc 1 510 27 view .LVU317
 1097 0034 50F8042B 		ldr	r2, [r0], #4	@ unaligned
ARM GAS  /tmp/ccPeOSOQ.s 			page 31


 1098 0038 9842     		cmp	r0, r3
 1099 003a 41F8042B 		str	r2, [r1], #4	@ unaligned
 1100 003e F9D1     		bne	.L56
 511:Src/util.c    ****             timeoutCntSerial1  = 0;     // Reset timeout counter
 1101              		.loc 1 511 13 is_stmt 1 view .LVU318
 1102              		.loc 1 511 32 is_stmt 0 view .LVU319
 1103 0040 0023     		movs	r3, #0
 1104              	.LVL68:
 1105              		.loc 1 511 32 view .LVU320
 1106 0042 024A     		ldr	r2, .L58
 1107 0044 1380     		strh	r3, [r2]	@ movhi
 512:Src/util.c    ****             timeoutFlagSerial1 = 0;     // Clear timeout flag
 1108              		.loc 1 512 13 is_stmt 1 view .LVU321
 1109              		.loc 1 512 32 is_stmt 0 view .LVU322
 1110 0046 024A     		ldr	r2, .L58+4
 1111 0048 1370     		strb	r3, [r2]
 1112              	.LVL69:
 1113              	.L54:
 1114              		.loc 1 512 32 view .LVU323
 1115              	.LBE25:
 1116              	.LBE24:
 513:Src/util.c    ****         }
 514:Src/util.c    ****     }
 515:Src/util.c    **** }
 1117              		.loc 1 515 1 view .LVU324
 1118 004a 10BD     		pop	{r4, pc}
 1119              	.L59:
 1120              		.align	2
 1121              	.L58:
 1122 004c 00000000 		.word	.LANCHOR7
 1123 0050 00000000 		.word	.LANCHOR8
 1124              		.cfi_endproc
 1125              	.LFE69:
 1127              		.section	.text.usart1_rx_check,"ax",%progbits
 1128              		.align	1
 1129              		.global	usart1_rx_check
 1130              		.syntax unified
 1131              		.thumb
 1132              		.thumb_func
 1133              		.fpu softvfp
 1135              	usart1_rx_check:
 1136              	.LFB68:
 434:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1137              		.loc 1 434 1 is_stmt 1 view -0
 1138              		.cfi_startproc
 1139              		@ args = 0, pretend = 0, frame = 0
 1140              		@ frame_needed = 0, uses_anonymous_args = 0
 457:Src/util.c    ****     uint32_t pos;
 1141              		.loc 1 457 5 view .LVU326
 458:Src/util.c    ****     uint8_t *ptr;
 1142              		.loc 1 458 5 view .LVU327
 459:Src/util.c    **** 
 1143              		.loc 1 459 5 view .LVU328
 461:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1144              		.loc 1 461 5 view .LVU329
 434:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1145              		.loc 1 434 1 is_stmt 0 view .LVU330
ARM GAS  /tmp/ccPeOSOQ.s 			page 32


 1146 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1147              	.LCFI16:
 1148              		.cfi_def_cfa_offset 24
 1149              		.cfi_offset 3, -24
 1150              		.cfi_offset 4, -20
 1151              		.cfi_offset 5, -16
 1152              		.cfi_offset 6, -12
 1153              		.cfi_offset 7, -8
 1154              		.cfi_offset 14, -4
 461:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1155              		.loc 1 461 28 view .LVU331
 1156 0002 0420     		movs	r0, #4
 1157 0004 FFF7FEFF 		bl	dma_transfer_number_get
 1158              	.LVL70:
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1159              		.loc 1 462 13 view .LVU332
 1160 0008 194D     		ldr	r5, .L71
 461:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1161              		.loc 1 461 9 view .LVU333
 1162 000a C0F58074 		rsb	r4, r0, #256
 1163              	.LVL71:
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1164              		.loc 1 462 5 is_stmt 1 view .LVU334
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1165              		.loc 1 462 13 is_stmt 0 view .LVU335
 1166 000e 2968     		ldr	r1, [r5]
 462:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1167              		.loc 1 462 8 view .LVU336
 1168 0010 A142     		cmp	r1, r4
 1169 0012 12D0     		beq	.L61
 463:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 1170              		.loc 1 463 9 is_stmt 1 view .LVU337
 1171              	.LVL72:
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1172              		.loc 1 464 9 view .LVU338
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1173              		.loc 1 464 12 is_stmt 0 view .LVU339
 1174 0014 18D2     		bcs	.L62
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1175              		.loc 1 464 35 discriminator 1 view .LVU340
 1176 0016 631A     		subs	r3, r4, r1
 464:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1177              		.loc 1 464 27 discriminator 1 view .LVU341
 1178 0018 302B     		cmp	r3, #48
 1179 001a 15D1     		bne	.L62
 465:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1180              		.loc 1 465 13 is_stmt 1 view .LVU342
 465:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1181              		.loc 1 465 25 is_stmt 0 view .LVU343
 1182 001c 154B     		ldr	r3, .L71+4
 1183 001e 1944     		add	r1, r1, r3
 465:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1184              		.loc 1 465 13 view .LVU344
 1185 0020 154B     		ldr	r3, .L71+8
 1186 0022 01F13002 		add	r2, r1, #48
 1187              	.L63:
 1188 0026 51F8040B 		ldr	r0, [r1], #4	@ unaligned
ARM GAS  /tmp/ccPeOSOQ.s 			page 33


 1189 002a 9142     		cmp	r1, r2
 1190 002c 43F8040B 		str	r0, [r3], #4	@ unaligned
 1191 0030 F9D1     		bne	.L63
 1192              	.LVL73:
 1193              	.L64:
 473:Src/util.c    ****         }
 1194              		.loc 1 473 13 is_stmt 1 view .LVU345
 1195 0032 1249     		ldr	r1, .L71+12
 1196 0034 1048     		ldr	r0, .L71+8
 1197 0036 FFF7FEFF 		bl	usart_process_data
 1198              	.LVL74:
 1199              	.L61:
 476:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1200              		.loc 1 476 5 view .LVU346
 477:Src/util.c    ****         old_pos = 0;
 1201              		.loc 1 477 5 view .LVU347
 477:Src/util.c    ****         old_pos = 0;
 1202              		.loc 1 477 8 is_stmt 0 view .LVU348
 1203 003a B4F5807F 		cmp	r4, #256
 478:Src/util.c    ****     }
 1204              		.loc 1 478 17 view .LVU349
 1205 003e 0ABF     		itet	eq
 1206 0040 0023     		moveq	r3, #0
 476:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1207              		.loc 1 476 13 view .LVU350
 1208 0042 2C60     		strne	r4, [r5]
 478:Src/util.c    ****     }
 1209              		.loc 1 478 9 is_stmt 1 view .LVU351
 478:Src/util.c    ****     }
 1210              		.loc 1 478 17 is_stmt 0 view .LVU352
 1211 0044 2B60     		streq	r3, [r5]
 481:Src/util.c    **** 
 1212              		.loc 1 481 1 view .LVU353
 1213 0046 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1214              	.LVL75:
 1215              	.L62:
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1216              		.loc 1 467 16 is_stmt 1 view .LVU354
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1217              		.loc 1 467 36 is_stmt 0 view .LVU355
 1218 0048 C1F58076 		rsb	r6, r1, #256
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1219              		.loc 1 467 46 view .LVU356
 1220 004c 3319     		adds	r3, r6, r4
 467:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1221              		.loc 1 467 19 view .LVU357
 1222 004e 302B     		cmp	r3, #48
 1223 0050 F3D1     		bne	.L61
 468:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1224              		.loc 1 468 13 is_stmt 1 view .LVU358
 1225 0052 094B     		ldr	r3, .L71+8
 468:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1226              		.loc 1 468 25 is_stmt 0 view .LVU359
 1227 0054 074F     		ldr	r7, .L71+4
 468:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1228              		.loc 1 468 13 view .LVU360
 1229 0056 3246     		mov	r2, r6
ARM GAS  /tmp/ccPeOSOQ.s 			page 34


 1230 0058 1846     		mov	r0, r3
 1231 005a 3944     		add	r1, r1, r7
 1232 005c FFF7FEFF 		bl	memcpy
 1233              	.LVL76:
 469:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1234              		.loc 1 469 13 is_stmt 1 view .LVU361
 469:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1235              		.loc 1 469 16 is_stmt 0 view .LVU362
 1236 0060 002C     		cmp	r4, #0
 1237 0062 E6D0     		beq	.L64
 470:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 1238              		.loc 1 470 17 is_stmt 1 view .LVU363
 1239              	.LVL77:
 471:Src/util.c    ****             }
 1240              		.loc 1 471 17 view .LVU364
 1241 0064 2246     		mov	r2, r4
 1242 0066 3946     		mov	r1, r7
 1243 0068 3044     		add	r0, r0, r6
 1244 006a FFF7FEFF 		bl	memcpy
 1245              	.LVL78:
 1246 006e E0E7     		b	.L64
 1247              	.L72:
 1248              		.align	2
 1249              	.L71:
 1250 0070 00000000 		.word	.LANCHOR10
 1251 0074 00000000 		.word	.LANCHOR1
 1252 0078 00000000 		.word	.LANCHOR11
 1253 007c 00000000 		.word	.LANCHOR9
 1254              		.cfi_endproc
 1255              	.LFE68:
 1257              		.section	.text.usart0_rx_check,"ax",%progbits
 1258              		.align	1
 1259              		.global	usart0_rx_check
 1260              		.syntax unified
 1261              		.thumb
 1262              		.thumb_func
 1263              		.fpu softvfp
 1265              	usart0_rx_check:
 1266              	.LFB70:
 516:Src/util.c    **** #endif // SERIAL_FEEDBACK
 517:Src/util.c    **** 
 518:Src/util.c    **** 
 519:Src/util.c    **** /* =========================== USART0 READ Functions =========================== */
 520:Src/util.c    **** 
 521:Src/util.c    **** /*
 522:Src/util.c    ****  * Check for new data received on USART with DMA: refactored function from https://github.com/MaJer
 523:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 524:Src/util.c    ****  */
 525:Src/util.c    **** void usart0_rx_check(void)
 526:Src/util.c    **** {
 1267              		.loc 1 526 1 view -0
 1268              		.cfi_startproc
 1269              		@ args = 0, pretend = 0, frame = 0
 1270              		@ frame_needed = 0, uses_anonymous_args = 0
 1271              		@ link register save eliminated.
 527:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 528:Src/util.c    ****     static uint32_t old_pos;
ARM GAS  /tmp/ccPeOSOQ.s 			page 35


 529:Src/util.c    ****     uint32_t pos;
 530:Src/util.c    ****     uint8_t *ptr;
 531:Src/util.c    **** 
 532:Src/util.c    ****     pos = rx0_buffer_len - dma_transfer_number_get(USART0_RX_DMA_CH);           // Calculate curren
 533:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 534:Src/util.c    ****         ptr = (uint8_t *)&command_raw;                                          // Initialize the p
 535:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == command_len) {                  // "Linear" buffer 
 536:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], command_len);                     // Copy data. This 
 537:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 538:Src/util.c    ****         } else if ((rx0_buffer_len - old_pos + pos) == command_len) {           // "Overflow" buffe
 539:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], rx0_buffer_len - old_pos);        // First copy data 
 540:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 541:Src/util.c    ****                 ptr += rx0_buffer_len - old_pos;                                // Update position
 542:Src/util.c    ****                 memcpy(ptr, &rx0_buffer[0], pos);                               // Copy remaining d
 543:Src/util.c    ****             }
 544:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 545:Src/util.c    ****         }
 546:Src/util.c    ****     }
 547:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 548:Src/util.c    ****     if (old_pos == rx0_buffer_len) {                                            // Check and manual
 549:Src/util.c    ****         old_pos = 0;
 550:Src/util.c    ****     }
 551:Src/util.c    ****     #endif  // SERIAL_AUX_RX
 552:Src/util.c    **** }
 1272              		.loc 1 552 1 view .LVU366
 1273 0000 7047     		bx	lr
 1274              		.cfi_endproc
 1275              	.LFE70:
 1277              		.section	.text.aux_print_to_console,"ax",%progbits
 1278              		.align	1
 1279              		.global	aux_print_to_console
 1280              		.syntax unified
 1281              		.thumb
 1282              		.thumb_func
 1283              		.fpu softvfp
 1285              	aux_print_to_console:
 1286              	.LFB80:
 1287              		.cfi_startproc
 1288              		@ args = 0, pretend = 0, frame = 0
 1289              		@ frame_needed = 0, uses_anonymous_args = 0
 1290              		@ link register save eliminated.
 1291 0000 7047     		bx	lr
 1292              		.cfi_endproc
 1293              	.LFE80:
 1295              		.section	.text.i2c_writeBytes,"ax",%progbits
 1296              		.align	1
 1297              		.global	i2c_writeBytes
 1298              		.syntax unified
 1299              		.thumb
 1300              		.thumb_func
 1301              		.fpu softvfp
 1303              	i2c_writeBytes:
 1304              	.LVL79:
 1305              	.LFB72:
 553:Src/util.c    **** 
 554:Src/util.c    **** /*
 555:Src/util.c    ****  * Process command UART0 Rx data
ARM GAS  /tmp/ccPeOSOQ.s 			page 36


 556:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
 557:Src/util.c    ****  */
 558:Src/util.c    **** #ifdef SERIAL_AUX_RX
 559:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out)
 560:Src/util.c    **** {
 561:Src/util.c    ****   #ifdef CONTROL_IBUS
 562:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
 563:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
 564:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
 565:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
 566:Src/util.c    ****       }
 567:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
 568:Src/util.c    ****         *command_out = *command_in;
 569:Src/util.c    ****         timeoutCntSerial0  = 0;        // Reset timeout counter
 570:Src/util.c    ****         timeoutFlagSerial0 = 0;        // Clear timeout flag
 571:Src/util.c    ****       }
 572:Src/util.c    ****     }
 573:Src/util.c    ****   #endif
 574:Src/util.c    **** }
 575:Src/util.c    **** #endif
 576:Src/util.c    **** 
 577:Src/util.c    **** 
 578:Src/util.c    **** /* =========================== AUX Serial Print data =========================== */
 579:Src/util.c    **** 
 580:Src/util.c    **** void aux_print_to_console(void)
 581:Src/util.c    **** {
 582:Src/util.c    **** #if defined(SERIAL_DEBUG) && defined(SERIAL_AUX_RX)
 583:Src/util.c    ****     #ifdef CONTROL_IBUS
 584:Src/util.c    ****     if (print_aux & PRINT_AUX) {
 585:Src/util.c    ****         log_i( "Ch1: %d Ch2: %d Sw: %u\r\n", cmd1, cmd2, cmdSwitch);
 586:Src/util.c    ****     }
 587:Src/util.c    ****     #endif
 588:Src/util.c    **** #endif
 589:Src/util.c    **** }
 590:Src/util.c    **** 
 591:Src/util.c    **** 
 592:Src/util.c    **** /* =========================== I2C WRITE Functions =========================== */
 593:Src/util.c    **** 
 594:Src/util.c    **** /*
 595:Src/util.c    ****  * write bytes to chip register
 596:Src/util.c    ****  */
 597:Src/util.c    **** int8_t i2c_writeBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data)
 598:Src/util.c    **** {
 1306              		.loc 1 598 1 view -0
 1307              		.cfi_startproc
 1308              		@ args = 0, pretend = 0, frame = 0
 1309              		@ frame_needed = 0, uses_anonymous_args = 0
 599:Src/util.c    **** 
 600:Src/util.c    ****     // assign WRITE command
 601:Src/util.c    ****     i2c_ReadWriteCmd    = WRITE;
 1310              		.loc 1 601 5 view .LVU368
 598:Src/util.c    **** 
 1311              		.loc 1 598 1 is_stmt 0 view .LVU369
 1312 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1313              	.LCFI17:
 1314              		.cfi_def_cfa_offset 24
 1315              		.cfi_offset 4, -24
ARM GAS  /tmp/ccPeOSOQ.s 			page 37


 1316              		.cfi_offset 5, -20
 1317              		.cfi_offset 6, -16
 1318              		.cfi_offset 7, -12
 1319              		.cfi_offset 8, -8
 1320              		.cfi_offset 14, -4
 1321              		.loc 1 601 25 view .LVU370
 1322 0004 0124     		movs	r4, #1
 602:Src/util.c    **** 
 603:Src/util.c    ****     // assign inputs
 604:Src/util.c    ****     i2c_status          = -1;
 1323              		.loc 1 604 25 view .LVU371
 1324 0006 FF26     		movs	r6, #255
 601:Src/util.c    **** 
 1325              		.loc 1 601 25 view .LVU372
 1326 0008 184D     		ldr	r5, .L88
 605:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1327              		.loc 1 605 37 view .LVU373
 1328 000a A040     		lsls	r0, r0, r4
 1329              	.LVL80:
 601:Src/util.c    **** 
 1330              		.loc 1 601 25 view .LVU374
 1331 000c 2C70     		strb	r4, [r5]
 604:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1332              		.loc 1 604 5 is_stmt 1 view .LVU375
 604:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1333              		.loc 1 604 25 is_stmt 0 view .LVU376
 1334 000e 184D     		ldr	r5, .L88+4
 1335              		.loc 1 605 37 view .LVU377
 1336 0010 C0B2     		uxtb	r0, r0
 604:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1337              		.loc 1 604 25 view .LVU378
 1338 0012 2E70     		strb	r6, [r5]
 1339              		.loc 1 605 5 is_stmt 1 view .LVU379
 1340              		.loc 1 605 25 is_stmt 0 view .LVU380
 1341 0014 174E     		ldr	r6, .L88+8
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 607:Src/util.c    ****     i2c_txbuffer        = data;
 608:Src/util.c    ****     i2c_nDABytes        = length;
 609:Src/util.c    ****     i2c_nRABytes        = 1;
 610:Src/util.c    **** 
 611:Src/util.c    ****     uint16_t i2c_timeout = 0;
 612:Src/util.c    **** 
 613:Src/util.c    ****     // enable the I2C0 interrupt
 614:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 615:Src/util.c    **** 
 616:Src/util.c    ****     // the master waits until the I2C bus is idle
 617:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1342              		.loc 1 617 11 view .LVU381
 1343 0016 184F     		ldr	r7, .L88+12
 605:Src/util.c    ****     i2c_regAddress      = regAddr;
 1344              		.loc 1 605 25 view .LVU382
 1345 0018 3070     		strb	r0, [r6]
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 1346              		.loc 1 606 5 is_stmt 1 view .LVU383
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 1347              		.loc 1 606 25 is_stmt 0 view .LVU384
 1348 001a 1848     		ldr	r0, .L88+16
ARM GAS  /tmp/ccPeOSOQ.s 			page 38


 608:Src/util.c    ****     i2c_nRABytes        = 1;
 1349              		.loc 1 608 25 view .LVU385
 1350 001c 184E     		ldr	r6, .L88+20
 606:Src/util.c    ****     i2c_regAddress      = regAddr;
 1351              		.loc 1 606 25 view .LVU386
 1352 001e 0170     		strb	r1, [r0]
 607:Src/util.c    ****     i2c_nDABytes        = length;
 1353              		.loc 1 607 5 is_stmt 1 view .LVU387
 607:Src/util.c    ****     i2c_nDABytes        = length;
 1354              		.loc 1 607 25 is_stmt 0 view .LVU388
 1355 0020 1849     		ldr	r1, .L88+24
 1356              	.LVL81:
 614:Src/util.c    **** 
 1357              		.loc 1 614 5 view .LVU389
 1358 0022 1948     		ldr	r0, .L88+28
 607:Src/util.c    ****     i2c_nDABytes        = length;
 1359              		.loc 1 607 25 view .LVU390
 1360 0024 0B60     		str	r3, [r1]
 608:Src/util.c    ****     i2c_nRABytes        = 1;
 1361              		.loc 1 608 5 is_stmt 1 view .LVU391
 609:Src/util.c    **** 
 1362              		.loc 1 609 25 is_stmt 0 view .LVU392
 1363 0026 194B     		ldr	r3, .L88+32
 1364              	.LVL82:
 614:Src/util.c    **** 
 1365              		.loc 1 614 5 view .LVU393
 1366 0028 4FF4E061 		mov	r1, #1792
 608:Src/util.c    ****     i2c_nRABytes        = 1;
 1367              		.loc 1 608 25 view .LVU394
 1368 002c 3270     		strb	r2, [r6]
 1369              	.LVL83:
 609:Src/util.c    **** 
 1370              		.loc 1 609 5 is_stmt 1 view .LVU395
 609:Src/util.c    **** 
 1371              		.loc 1 609 25 is_stmt 0 view .LVU396
 1372 002e 1C70     		strb	r4, [r3]
 611:Src/util.c    **** 
 1373              		.loc 1 611 5 is_stmt 1 view .LVU397
 1374              	.LVL84:
 614:Src/util.c    **** 
 1375              		.loc 1 614 5 view .LVU398
 1376 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1377              	.LVL85:
 1378              		.loc 1 617 5 view .LVU399
 1379              		.loc 1 617 10 is_stmt 0 view .LVU400
 1380 0034 44F62164 		movw	r4, #20001
 1381              		.loc 1 617 11 view .LVU401
 1382 0038 DFF84C80 		ldr	r8, .L88+28
 1383              	.LVL86:
 1384              	.L77:
 1385              		.loc 1 617 75 is_stmt 1 discriminator 2 view .LVU402
 1386              		.loc 1 617 10 discriminator 2 view .LVU403
 1387              		.loc 1 617 11 is_stmt 0 discriminator 2 view .LVU404
 1388 003c 3946     		mov	r1, r7
 1389 003e 4046     		mov	r0, r8
 1390 0040 FFF7FEFF 		bl	i2c_flag_get
 1391              	.LVL87:
ARM GAS  /tmp/ccPeOSOQ.s 			page 39


 1392              		.loc 1 617 10 discriminator 2 view .LVU405
 1393 0044 18B1     		cbz	r0, .L76
 1394              	.LVL88:
 1395              		.loc 1 617 50 discriminator 1 view .LVU406
 1396 0046 013C     		subs	r4, r4, #1
 1397              	.LVL89:
 1398              		.loc 1 617 50 discriminator 1 view .LVU407
 1399 0048 A4B2     		uxth	r4, r4
 1400 004a 002C     		cmp	r4, #0
 1401 004c F6D1     		bne	.L77
 1402              	.L76:
 618:Src/util.c    **** 
 619:Src/util.c    ****     // the master sends a start condition to I2C bus
 620:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1403              		.loc 1 620 5 is_stmt 1 view .LVU408
 1404 004e 0E48     		ldr	r0, .L88+28
 1405 0050 FFF7FEFF 		bl	i2c_start_on_bus
 1406              	.LVL90:
 621:Src/util.c    ****     
 622:Src/util.c    ****     // Wait until all data bytes are sent/received
 623:Src/util.c    ****     i2c_timeout = 0;
 1407              		.loc 1 623 5 view .LVU409
 624:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1408              		.loc 1 624 5 view .LVU410
 1409              		.loc 1 624 10 is_stmt 0 view .LVU411
 1410 0054 44F62163 		movw	r3, #20001
 1411              	.LVL91:
 1412              	.L79:
 1413              		.loc 1 624 53 is_stmt 1 discriminator 2 view .LVU412
 1414              		.loc 1 624 10 discriminator 2 view .LVU413
 1415              		.loc 1 624 24 is_stmt 0 discriminator 2 view .LVU414
 1416 0058 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1417              		.loc 1 624 10 discriminator 2 view .LVU415
 1418 005a 1AB1     		cbz	r2, .L78
 1419              	.LVL92:
 1420              		.loc 1 624 28 discriminator 1 view .LVU416
 1421 005c 013B     		subs	r3, r3, #1
 1422              	.LVL93:
 1423              		.loc 1 624 28 discriminator 1 view .LVU417
 1424 005e 9BB2     		uxth	r3, r3
 1425 0060 002B     		cmp	r3, #0
 1426 0062 F9D1     		bne	.L79
 1427              	.L78:
 625:Src/util.c    **** 
 626:Src/util.c    ****     return i2c_status;
 1428              		.loc 1 626 5 is_stmt 1 view .LVU418
 1429              		.loc 1 626 12 is_stmt 0 view .LVU419
 1430 0064 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 627:Src/util.c    **** 
 628:Src/util.c    **** }
 1431              		.loc 1 628 1 view .LVU420
 1432 0066 40B2     		sxtb	r0, r0
 1433 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1434              	.L89:
 1435              		.align	2
 1436              	.L88:
 1437 006c 00000000 		.word	.LANCHOR12
ARM GAS  /tmp/ccPeOSOQ.s 			page 40


 1438 0070 00000000 		.word	.LANCHOR13
 1439 0074 00000000 		.word	.LANCHOR14
 1440 0078 02000080 		.word	-2147483646
 1441 007c 00000000 		.word	.LANCHOR15
 1442 0080 00000000 		.word	.LANCHOR17
 1443 0084 00000000 		.word	.LANCHOR16
 1444 0088 00540040 		.word	1073763328
 1445 008c 00000000 		.word	.LANCHOR18
 1446              		.cfi_endproc
 1447              	.LFE72:
 1449              		.section	.text.i2c_writeByte,"ax",%progbits
 1450              		.align	1
 1451              		.global	i2c_writeByte
 1452              		.syntax unified
 1453              		.thumb
 1454              		.thumb_func
 1455              		.fpu softvfp
 1457              	i2c_writeByte:
 1458              	.LVL94:
 1459              	.LFB73:
 629:Src/util.c    **** 
 630:Src/util.c    **** 
 631:Src/util.c    **** /*
 632:Src/util.c    ****  * write 1 byte to chip register
 633:Src/util.c    ****  */
 634:Src/util.c    **** int8_t i2c_writeByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t data)
 635:Src/util.c    **** {
 1460              		.loc 1 635 1 is_stmt 1 view -0
 1461              		.cfi_startproc
 1462              		@ args = 0, pretend = 0, frame = 8
 1463              		@ frame_needed = 0, uses_anonymous_args = 0
 636:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1464              		.loc 1 636 5 view .LVU422
 635:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1465              		.loc 1 635 1 is_stmt 0 view .LVU423
 1466 0000 07B5     		push	{r0, r1, r2, lr}
 1467              	.LCFI18:
 1468              		.cfi_def_cfa_offset 16
 1469              		.cfi_offset 14, -4
 635:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1470              		.loc 1 635 1 view .LVU424
 1471 0002 8DF80720 		strb	r2, [sp, #7]
 1472              		.loc 1 636 12 view .LVU425
 1473 0006 0DF10703 		add	r3, sp, #7
 1474 000a 0122     		movs	r2, #1
 1475              	.LVL95:
 1476              		.loc 1 636 12 view .LVU426
 1477 000c FFF7FEFF 		bl	i2c_writeBytes
 1478              	.LVL96:
 637:Src/util.c    **** }
 1479              		.loc 1 637 1 view .LVU427
 1480 0010 03B0     		add	sp, sp, #12
 1481              	.LCFI19:
 1482              		.cfi_def_cfa_offset 4
 1483              		@ sp needed
 1484 0012 5DF804FB 		ldr	pc, [sp], #4
 1485              		.cfi_endproc
ARM GAS  /tmp/ccPeOSOQ.s 			page 41


 1486              	.LFE73:
 1488              		.section	.text.i2c_readBytes,"ax",%progbits
 1489              		.align	1
 1490              		.global	i2c_readBytes
 1491              		.syntax unified
 1492              		.thumb
 1493              		.thumb_func
 1494              		.fpu softvfp
 1496              	i2c_readBytes:
 1497              	.LVL97:
 1498              	.LFB75:
 638:Src/util.c    **** 
 639:Src/util.c    **** 
 640:Src/util.c    **** /*
 641:Src/util.c    ****  * write one bit to chip register
 642:Src/util.c    ****  */
 643:Src/util.c    **** int8_t i2c_writeBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 644:Src/util.c    ****     uint8_t b;
 645:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 646:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 647:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 648:Src/util.c    **** }
 649:Src/util.c    **** 
 650:Src/util.c    **** 
 651:Src/util.c    **** 
 652:Src/util.c    **** /* =========================== I2C READ Functions =========================== */
 653:Src/util.c    **** 
 654:Src/util.c    **** /*
 655:Src/util.c    ****  * read bytes from chip register
 656:Src/util.c    ****  */
 657:Src/util.c    **** int8_t i2c_readBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data) 
 658:Src/util.c    **** {
 1499              		.loc 1 658 1 is_stmt 1 view -0
 1500              		.cfi_startproc
 1501              		@ args = 0, pretend = 0, frame = 0
 1502              		@ frame_needed = 0, uses_anonymous_args = 0
 659:Src/util.c    **** 
 660:Src/util.c    ****     // assign READ command
 661:Src/util.c    ****     i2c_ReadWriteCmd    = READ;
 1503              		.loc 1 661 5 view .LVU429
 658:Src/util.c    **** 
 1504              		.loc 1 658 1 is_stmt 0 view .LVU430
 1505 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1506              	.LCFI20:
 1507              		.cfi_def_cfa_offset 24
 1508              		.cfi_offset 4, -24
 1509              		.cfi_offset 5, -20
 1510              		.cfi_offset 6, -16
 1511              		.cfi_offset 7, -12
 1512              		.cfi_offset 8, -8
 1513              		.cfi_offset 14, -4
 1514              		.loc 1 661 25 view .LVU431
 1515 0004 0024     		movs	r4, #0
 662:Src/util.c    ****     
 663:Src/util.c    ****     // assign inputs
 664:Src/util.c    ****     i2c_status          = -1;
 1516              		.loc 1 664 25 view .LVU432
ARM GAS  /tmp/ccPeOSOQ.s 			page 42


 1517 0006 FF26     		movs	r6, #255
 661:Src/util.c    ****     
 1518              		.loc 1 661 25 view .LVU433
 1519 0008 1C4D     		ldr	r5, .L105
 665:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1520              		.loc 1 665 37 view .LVU434
 1521 000a 4000     		lsls	r0, r0, #1
 1522              	.LVL98:
 661:Src/util.c    ****     
 1523              		.loc 1 661 25 view .LVU435
 1524 000c 2C70     		strb	r4, [r5]
 664:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1525              		.loc 1 664 5 is_stmt 1 view .LVU436
 664:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1526              		.loc 1 664 25 is_stmt 0 view .LVU437
 1527 000e 1C4D     		ldr	r5, .L105+4
 1528              		.loc 1 665 37 view .LVU438
 1529 0010 C0B2     		uxtb	r0, r0
 664:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1530              		.loc 1 664 25 view .LVU439
 1531 0012 2E70     		strb	r6, [r5]
 1532              		.loc 1 665 5 is_stmt 1 view .LVU440
 1533              		.loc 1 665 25 is_stmt 0 view .LVU441
 1534 0014 1B4E     		ldr	r6, .L105+8
 1535 0016 3070     		strb	r0, [r6]
 666:Src/util.c    ****     i2c_regAddress      = regAddr;
 1536              		.loc 1 666 5 is_stmt 1 view .LVU442
 1537              		.loc 1 666 25 is_stmt 0 view .LVU443
 1538 0018 1B48     		ldr	r0, .L105+12
 667:Src/util.c    ****     i2c_rxbuffer        = data;
 668:Src/util.c    ****     i2c_nDABytes        = length;
 1539              		.loc 1 668 25 view .LVU444
 1540 001a 1C4E     		ldr	r6, .L105+16
 666:Src/util.c    ****     i2c_regAddress      = regAddr;
 1541              		.loc 1 666 25 view .LVU445
 1542 001c 0170     		strb	r1, [r0]
 667:Src/util.c    ****     i2c_rxbuffer        = data;
 1543              		.loc 1 667 5 is_stmt 1 view .LVU446
 1544              		.loc 1 668 25 is_stmt 0 view .LVU447
 1545 001e 3270     		strb	r2, [r6]
 669:Src/util.c    ****     i2c_nRABytes        = 1;
 1546              		.loc 1 669 25 view .LVU448
 1547 0020 0122     		movs	r2, #1
 1548              	.LVL99:
 667:Src/util.c    ****     i2c_rxbuffer        = data;
 1549              		.loc 1 667 25 view .LVU449
 1550 0022 1B49     		ldr	r1, .L105+20
 1551              	.LVL100:
 670:Src/util.c    **** 
 671:Src/util.c    ****     uint16_t i2c_timeout = 0;
 672:Src/util.c    **** 
 673:Src/util.c    ****     // enable the I2C0 interrupt
 674:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 1552              		.loc 1 674 5 view .LVU450
 1553 0024 1B48     		ldr	r0, .L105+24
 667:Src/util.c    ****     i2c_nDABytes        = length;
 1554              		.loc 1 667 25 view .LVU451
ARM GAS  /tmp/ccPeOSOQ.s 			page 43


 1555 0026 0B60     		str	r3, [r1]
 668:Src/util.c    ****     i2c_nRABytes        = 1;
 1556              		.loc 1 668 5 is_stmt 1 view .LVU452
 669:Src/util.c    **** 
 1557              		.loc 1 669 5 view .LVU453
 669:Src/util.c    **** 
 1558              		.loc 1 669 25 is_stmt 0 view .LVU454
 1559 0028 1B4B     		ldr	r3, .L105+28
 1560              	.LVL101:
 1561              		.loc 1 674 5 view .LVU455
 1562 002a 4FF4E061 		mov	r1, #1792
 669:Src/util.c    **** 
 1563              		.loc 1 669 25 view .LVU456
 1564 002e 1A70     		strb	r2, [r3]
 1565              	.LVL102:
 671:Src/util.c    **** 
 1566              		.loc 1 671 5 is_stmt 1 view .LVU457
 1567              		.loc 1 674 5 view .LVU458
 1568 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1569              	.LVL103:
 675:Src/util.c    **** 
 676:Src/util.c    ****     if(2 == i2c_nDABytes){
 1570              		.loc 1 676 5 view .LVU459
 1571              		.loc 1 676 10 is_stmt 0 view .LVU460
 1572 0034 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1573              		.loc 1 676 7 view .LVU461
 1574 0036 022B     		cmp	r3, #2
 1575 0038 03D1     		bne	.L92
 677:Src/util.c    ****         i2c_ackpos_config(MPU_I2C, I2C_ACKPOS_NEXT);    // send ACK for the next byte
 1576              		.loc 1 677 9 is_stmt 1 view .LVU462
 1577 003a 2146     		mov	r1, r4
 1578 003c 1548     		ldr	r0, .L105+24
 1579 003e FFF7FEFF 		bl	i2c_ackpos_config
 1580              	.LVL104:
 1581              	.L92:
 658:Src/util.c    **** 
 1582              		.loc 1 658 1 is_stmt 0 discriminator 2 view .LVU463
 1583 0042 44F62164 		movw	r4, #20001
 678:Src/util.c    ****     }
 679:Src/util.c    **** 
 680:Src/util.c    ****     // the master waits until the I2C bus is idle
 681:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1584              		.loc 1 681 11 discriminator 2 view .LVU464
 1585 0046 154F     		ldr	r7, .L105+32
 1586 0048 DFF84880 		ldr	r8, .L105+24
 1587              	.LVL105:
 1588              	.L94:
 1589              		.loc 1 681 75 is_stmt 1 discriminator 2 view .LVU465
 1590              		.loc 1 681 10 discriminator 2 view .LVU466
 1591              		.loc 1 681 11 is_stmt 0 discriminator 2 view .LVU467
 1592 004c 3946     		mov	r1, r7
 1593 004e 4046     		mov	r0, r8
 1594 0050 FFF7FEFF 		bl	i2c_flag_get
 1595              	.LVL106:
 1596              		.loc 1 681 10 discriminator 2 view .LVU468
 1597 0054 18B1     		cbz	r0, .L93
 1598              	.LVL107:
ARM GAS  /tmp/ccPeOSOQ.s 			page 44


 1599              		.loc 1 681 50 discriminator 1 view .LVU469
 1600 0056 013C     		subs	r4, r4, #1
 1601              	.LVL108:
 1602              		.loc 1 681 50 discriminator 1 view .LVU470
 1603 0058 A4B2     		uxth	r4, r4
 1604 005a 002C     		cmp	r4, #0
 1605 005c F6D1     		bne	.L94
 1606              	.L93:
 682:Src/util.c    **** 
 683:Src/util.c    ****     // the master sends a start condition to I2C bus
 684:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1607              		.loc 1 684 5 is_stmt 1 view .LVU471
 1608 005e 0D48     		ldr	r0, .L105+24
 1609 0060 FFF7FEFF 		bl	i2c_start_on_bus
 1610              	.LVL109:
 685:Src/util.c    **** 
 686:Src/util.c    ****     // Wait until all data bytes are sent/received
 687:Src/util.c    ****     i2c_timeout = 0;
 1611              		.loc 1 687 5 view .LVU472
 688:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1612              		.loc 1 688 5 view .LVU473
 1613              		.loc 1 688 10 is_stmt 0 view .LVU474
 1614 0064 44F62163 		movw	r3, #20001
 1615              	.LVL110:
 1616              	.L96:
 1617              		.loc 1 688 53 is_stmt 1 discriminator 2 view .LVU475
 1618              		.loc 1 688 10 discriminator 2 view .LVU476
 1619              		.loc 1 688 24 is_stmt 0 discriminator 2 view .LVU477
 1620 0068 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1621              		.loc 1 688 10 discriminator 2 view .LVU478
 1622 006a 1AB1     		cbz	r2, .L95
 1623              	.LVL111:
 1624              		.loc 1 688 28 discriminator 1 view .LVU479
 1625 006c 013B     		subs	r3, r3, #1
 1626              	.LVL112:
 1627              		.loc 1 688 28 discriminator 1 view .LVU480
 1628 006e 9BB2     		uxth	r3, r3
 1629 0070 002B     		cmp	r3, #0
 1630 0072 F9D1     		bne	.L96
 1631              	.L95:
 689:Src/util.c    **** 
 690:Src/util.c    ****     // Return status
 691:Src/util.c    ****     return i2c_status;
 1632              		.loc 1 691 5 is_stmt 1 view .LVU481
 1633              		.loc 1 691 12 is_stmt 0 view .LVU482
 1634 0074 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 692:Src/util.c    **** 
 693:Src/util.c    **** }
 1635              		.loc 1 693 1 view .LVU483
 1636 0076 40B2     		sxtb	r0, r0
 1637 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1638              	.L106:
 1639              		.align	2
 1640              	.L105:
 1641 007c 00000000 		.word	.LANCHOR12
 1642 0080 00000000 		.word	.LANCHOR13
 1643 0084 00000000 		.word	.LANCHOR14
ARM GAS  /tmp/ccPeOSOQ.s 			page 45


 1644 0088 00000000 		.word	.LANCHOR15
 1645 008c 00000000 		.word	.LANCHOR17
 1646 0090 00000000 		.word	.LANCHOR19
 1647 0094 00540040 		.word	1073763328
 1648 0098 00000000 		.word	.LANCHOR18
 1649 009c 02000080 		.word	-2147483646
 1650              		.cfi_endproc
 1651              	.LFE75:
 1653              		.section	.text.i2c_readByte,"ax",%progbits
 1654              		.align	1
 1655              		.global	i2c_readByte
 1656              		.syntax unified
 1657              		.thumb
 1658              		.thumb_func
 1659              		.fpu softvfp
 1661              	i2c_readByte:
 1662              	.LVL113:
 1663              	.LFB76:
 694:Src/util.c    **** 
 695:Src/util.c    **** 
 696:Src/util.c    **** /*
 697:Src/util.c    ****  * read 1 byte from chip register
 698:Src/util.c    ****  */
 699:Src/util.c    **** int8_t i2c_readByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t *data)
 700:Src/util.c    **** {
 1664              		.loc 1 700 1 is_stmt 1 view -0
 1665              		.cfi_startproc
 1666              		@ args = 0, pretend = 0, frame = 0
 1667              		@ frame_needed = 0, uses_anonymous_args = 0
 1668              		@ link register save eliminated.
 701:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1669              		.loc 1 701 5 view .LVU485
 700:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1670              		.loc 1 700 1 is_stmt 0 view .LVU486
 1671 0000 1346     		mov	r3, r2
 1672              		.loc 1 701 12 view .LVU487
 1673 0002 0122     		movs	r2, #1
 1674              	.LVL114:
 1675              		.loc 1 701 12 view .LVU488
 1676 0004 FFF7FEBF 		b	i2c_readBytes
 1677              	.LVL115:
 1678              		.loc 1 701 12 view .LVU489
 1679              		.cfi_endproc
 1680              	.LFE76:
 1682              		.section	.text.i2c_writeBit,"ax",%progbits
 1683              		.align	1
 1684              		.global	i2c_writeBit
 1685              		.syntax unified
 1686              		.thumb
 1687              		.thumb_func
 1688              		.fpu softvfp
 1690              	i2c_writeBit:
 1691              	.LVL116:
 1692              	.LFB74:
 643:Src/util.c    ****     uint8_t b;
 1693              		.loc 1 643 87 is_stmt 1 view -0
 1694              		.cfi_startproc
ARM GAS  /tmp/ccPeOSOQ.s 			page 46


 1695              		@ args = 0, pretend = 0, frame = 8
 1696              		@ frame_needed = 0, uses_anonymous_args = 0
 644:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 1697              		.loc 1 644 5 view .LVU491
 645:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1698              		.loc 1 645 5 view .LVU492
 643:Src/util.c    ****     uint8_t b;
 1699              		.loc 1 643 87 is_stmt 0 view .LVU493
 1700 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 1701              	.LCFI21:
 1702              		.cfi_def_cfa_offset 32
 1703              		.cfi_offset 4, -24
 1704              		.cfi_offset 5, -20
 1705              		.cfi_offset 6, -16
 1706              		.cfi_offset 7, -12
 1707              		.cfi_offset 8, -8
 1708              		.cfi_offset 14, -4
 643:Src/util.c    ****     uint8_t b;
 1709              		.loc 1 643 87 view .LVU494
 1710 0004 9046     		mov	r8, r2
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1711              		.loc 1 646 31 view .LVU495
 1712 0006 0124     		movs	r4, #1
 643:Src/util.c    ****     uint8_t b;
 1713              		.loc 1 643 87 view .LVU496
 1714 0008 1F46     		mov	r7, r3
 645:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1715              		.loc 1 645 5 view .LVU497
 1716 000a 0DF10702 		add	r2, sp, #7
 1717              	.LVL117:
 643:Src/util.c    ****     uint8_t b;
 1718              		.loc 1 643 87 view .LVU498
 1719 000e 0546     		mov	r5, r0
 1720 0010 0E46     		mov	r6, r1
 645:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1721              		.loc 1 645 5 view .LVU499
 1722 0012 FFF7FEFF 		bl	i2c_readByte
 1723              	.LVL118:
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1724              		.loc 1 646 5 is_stmt 1 view .LVU500
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1725              		.loc 1 646 31 is_stmt 0 view .LVU501
 1726 0016 04FA08F2 		lsl	r2, r4, r8
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1727              		.loc 1 646 26 view .LVU502
 1728 001a 52B2     		sxtb	r2, r2
 1729 001c 9DF80740 		ldrb	r4, [sp, #7]	@ zero_extendqisi2
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1730              		.loc 1 646 7 view .LVU503
 1731 0020 57B1     		cbz	r7, .L109
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1732              		.loc 1 646 26 discriminator 1 view .LVU504
 1733 0022 2243     		orrs	r2, r2, r4
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1734              		.loc 1 646 7 discriminator 1 view .LVU505
 1735 0024 D2B2     		uxtb	r2, r2
 1736              	.L110:
ARM GAS  /tmp/ccPeOSOQ.s 			page 47


 647:Src/util.c    **** }
 1737              		.loc 1 647 12 discriminator 4 view .LVU506
 1738 0026 3146     		mov	r1, r6
 1739 0028 2846     		mov	r0, r5
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1740              		.loc 1 646 7 discriminator 4 view .LVU507
 1741 002a 8DF80720 		strb	r2, [sp, #7]
 647:Src/util.c    **** }
 1742              		.loc 1 647 5 is_stmt 1 discriminator 4 view .LVU508
 647:Src/util.c    **** }
 1743              		.loc 1 647 12 is_stmt 0 discriminator 4 view .LVU509
 1744 002e FFF7FEFF 		bl	i2c_writeByte
 1745              	.LVL119:
 648:Src/util.c    **** 
 1746              		.loc 1 648 1 discriminator 4 view .LVU510
 1747 0032 02B0     		add	sp, sp, #8
 1748              	.LCFI22:
 1749              		.cfi_remember_state
 1750              		.cfi_def_cfa_offset 24
 1751              		@ sp needed
 1752 0034 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1753              	.L109:
 1754              	.LCFI23:
 1755              		.cfi_restore_state
 646:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1756              		.loc 1 646 7 discriminator 2 view .LVU511
 1757 0038 24EA0202 		bic	r2, r4, r2
 1758 003c F3E7     		b	.L110
 1759              		.cfi_endproc
 1760              	.LFE74:
 1762              		.section	.text.i2c_readBit,"ax",%progbits
 1763              		.align	1
 1764              		.global	i2c_readBit
 1765              		.syntax unified
 1766              		.thumb
 1767              		.thumb_func
 1768              		.fpu softvfp
 1770              	i2c_readBit:
 1771              	.LVL120:
 1772              	.LFB77:
 702:Src/util.c    **** }
 703:Src/util.c    **** 
 704:Src/util.c    **** 
 705:Src/util.c    **** /*
 706:Src/util.c    ****  * read 1 bit from chip register
 707:Src/util.c    ****  */
 708:Src/util.c    **** int8_t i2c_readBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data)
 709:Src/util.c    **** {
 1773              		.loc 1 709 1 is_stmt 1 view -0
 1774              		.cfi_startproc
 1775              		@ args = 0, pretend = 0, frame = 8
 1776              		@ frame_needed = 0, uses_anonymous_args = 0
 710:Src/util.c    ****     uint8_t b;
 1777              		.loc 1 710 5 view .LVU513
 711:Src/util.c    ****     int8_t status = i2c_readByte(slaveAddr, regAddr, &b);
 1778              		.loc 1 711 5 view .LVU514
 709:Src/util.c    ****     uint8_t b;
ARM GAS  /tmp/ccPeOSOQ.s 			page 48


 1779              		.loc 1 709 1 is_stmt 0 view .LVU515
 1780 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1781              	.LCFI24:
 1782              		.cfi_def_cfa_offset 24
 1783              		.cfi_offset 4, -12
 1784              		.cfi_offset 5, -8
 1785              		.cfi_offset 14, -4
 709:Src/util.c    ****     uint8_t b;
 1786              		.loc 1 709 1 view .LVU516
 1787 0002 1546     		mov	r5, r2
 1788              		.loc 1 711 21 view .LVU517
 1789 0004 0DF10702 		add	r2, sp, #7
 1790              	.LVL121:
 709:Src/util.c    ****     uint8_t b;
 1791              		.loc 1 709 1 view .LVU518
 1792 0008 1C46     		mov	r4, r3
 1793              		.loc 1 711 21 view .LVU519
 1794 000a FFF7FEFF 		bl	i2c_readByte
 1795              	.LVL122:
 712:Src/util.c    ****     *data = b & (1 << bitNum);
 1796              		.loc 1 712 5 is_stmt 1 view .LVU520
 1797              		.loc 1 712 20 is_stmt 0 view .LVU521
 1798 000e 0121     		movs	r1, #1
 1799              		.loc 1 712 15 view .LVU522
 1800 0010 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1801              		.loc 1 712 20 view .LVU523
 1802 0014 01FA05F2 		lsl	r2, r1, r5
 1803              		.loc 1 712 15 view .LVU524
 1804 0018 1A40     		ands	r2, r2, r3
 1805              		.loc 1 712 11 view .LVU525
 1806 001a 2270     		strb	r2, [r4]
 713:Src/util.c    ****     return status;
 1807              		.loc 1 713 5 is_stmt 1 view .LVU526
 714:Src/util.c    **** }
 1808              		.loc 1 714 1 is_stmt 0 view .LVU527
 1809 001c 03B0     		add	sp, sp, #12
 1810              	.LCFI25:
 1811              		.cfi_def_cfa_offset 12
 1812              		@ sp needed
 1813 001e 30BD     		pop	{r4, r5, pc}
 1814              		.loc 1 714 1 view .LVU528
 1815              		.cfi_endproc
 1816              	.LFE77:
 1818              		.global	buffer
 1819              		.global	i2c_nRABytes
 1820              		.global	i2c_nDABytes
 1821              		.global	i2c_rxbuffer
 1822              		.global	i2c_txbuffer
 1823              		.global	i2c_slaveAddress
 1824              		.global	i2c_regAddress
 1825              		.global	i2c_ReadWriteCmd
 1826              		.global	i2c_status
 1827              		.section	.bss.Feedback,"aw",%nobits
 1828              		.align	1
 1829              		.set	.LANCHOR9,. + 0
 1832              	Feedback:
 1833 0000 00000000 		.space	48
ARM GAS  /tmp/ccPeOSOQ.s 			page 49


 1833      00000000 
 1833      00000000 
 1833      00000000 
 1833      00000000 
 1834              		.section	.bss.FeedbackRaw,"aw",%nobits
 1835              		.align	1
 1836              		.set	.LANCHOR11,. + 0
 1839              	FeedbackRaw:
 1840 0000 00000000 		.space	48
 1840      00000000 
 1840      00000000 
 1840      00000000 
 1840      00000000 
 1841              		.section	.bss.buffer,"aw",%nobits
 1844              	buffer:
 1845 0000 00000000 		.space	14
 1845      00000000 
 1845      00000000 
 1845      0000
 1846              		.section	.bss.i2c_ReadWriteCmd,"aw",%nobits
 1847              		.set	.LANCHOR12,. + 0
 1850              	i2c_ReadWriteCmd:
 1851 0000 00       		.space	1
 1852              		.section	.bss.i2c_nDABytes,"aw",%nobits
 1853              		.set	.LANCHOR17,. + 0
 1856              	i2c_nDABytes:
 1857 0000 00       		.space	1
 1858              		.section	.bss.i2c_nRABytes,"aw",%nobits
 1859              		.set	.LANCHOR18,. + 0
 1862              	i2c_nRABytes:
 1863 0000 00       		.space	1
 1864              		.section	.bss.i2c_regAddress,"aw",%nobits
 1865              		.set	.LANCHOR15,. + 0
 1868              	i2c_regAddress:
 1869 0000 00       		.space	1
 1870              		.section	.bss.i2c_rxbuffer,"aw",%nobits
 1871              		.align	2
 1872              		.set	.LANCHOR19,. + 0
 1875              	i2c_rxbuffer:
 1876 0000 00000000 		.space	4
 1877              		.section	.bss.i2c_slaveAddress,"aw",%nobits
 1878              		.set	.LANCHOR14,. + 0
 1881              	i2c_slaveAddress:
 1882 0000 00       		.space	1
 1883              		.section	.bss.i2c_status,"aw",%nobits
 1884              		.set	.LANCHOR13,. + 0
 1887              	i2c_status:
 1888 0000 00       		.space	1
 1889              		.section	.bss.i2c_txbuffer,"aw",%nobits
 1890              		.align	2
 1891              		.set	.LANCHOR16,. + 0
 1894              	i2c_txbuffer:
 1895 0000 00000000 		.space	4
 1896              		.section	.bss.mpuStatus,"aw",%nobits
 1897              		.set	.LANCHOR2,. + 0
 1900              	mpuStatus:
 1901 0000 00       		.space	1
ARM GAS  /tmp/ccPeOSOQ.s 			page 50


 1902              		.section	.bss.old_pos.0,"aw",%nobits
 1903              		.align	2
 1904              		.set	.LANCHOR10,. + 0
 1907              	old_pos.0:
 1908 0000 00000000 		.space	4
 1909              		.section	.bss.rx1_buffer,"aw",%nobits
 1910              		.set	.LANCHOR1,. + 0
 1913              	rx1_buffer:
 1914 0000 00000000 		.space	256
 1914      00000000 
 1914      00000000 
 1914      00000000 
 1914      00000000 
 1915              		.section	.bss.sensor1,"aw",%nobits
 1916              		.set	.LANCHOR5,. + 0
 1919              	sensor1:
 1920 0000 00       		.space	1
 1921              		.section	.bss.sensor1_read,"aw",%nobits
 1922              		.set	.LANCHOR3,. + 0
 1925              	sensor1_read:
 1926 0000 00       		.space	1
 1927              		.section	.bss.sensor2,"aw",%nobits
 1928              		.set	.LANCHOR6,. + 0
 1931              	sensor2:
 1932 0000 00       		.space	1
 1933              		.section	.bss.sensor2_read,"aw",%nobits
 1934              		.set	.LANCHOR4,. + 0
 1937              	sensor2_read:
 1938 0000 00       		.space	1
 1939              		.section	.bss.sideboard_imu,"aw",%nobits
 1940              		.set	.LANCHOR0,. + 0
 1943              	sideboard_imu:
 1944 0000 00000000 		.space	42
 1944      00000000 
 1944      00000000 
 1944      00000000 
 1944      00000000 
 1945              		.section	.bss.timeoutCntSerial1,"aw",%nobits
 1946              		.align	1
 1947              		.set	.LANCHOR7,. + 0
 1950              	timeoutCntSerial1:
 1951 0000 0000     		.space	2
 1952              		.section	.bss.timeoutFlagSerial1,"aw",%nobits
 1953              		.set	.LANCHOR8,. + 0
 1956              	timeoutFlagSerial1:
 1957 0000 00       		.space	1
 1958              		.text
 1959              	.Letext0:
 1960              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1961              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1962              		.file 4 "Drivers/CMSIS/Include/gd32f1x0.h"
 1963              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dma.h"
 1964              		.file 6 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 1965              		.file 7 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 1966              		.file 8 "Inc/util.h"
 1967              		.file 9 "Inc/defines.h"
 1968              		.file 10 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_i2c.h"
ARM GAS  /tmp/ccPeOSOQ.s 			page 51


 1969              		.file 11 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_gpio.h"
 1970              		.file 12 "Inc/mpu6050.h"
 1971              		.file 13 "Inc/setup.h"
 1972              		.file 14 "Inc/systick.h"
 1973              		.file 15 "<built-in>"
ARM GAS  /tmp/ccPeOSOQ.s 			page 52


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccPeOSOQ.s:16     .text.consoleLog:0000000000000000 $t
     /tmp/ccPeOSOQ.s:24     .text.consoleLog:0000000000000000 consoleLog
     /tmp/ccPeOSOQ.s:39     .text.toggle_led:0000000000000000 $t
     /tmp/ccPeOSOQ.s:46     .text.toggle_led:0000000000000000 toggle_led
     /tmp/ccPeOSOQ.s:65     .text.intro_demo_led:0000000000000000 $t
     /tmp/ccPeOSOQ.s:72     .text.intro_demo_led:0000000000000000 intro_demo_led
     /tmp/ccPeOSOQ.s:223    .text.intro_demo_led:00000000000000cc $d
     /tmp/ccPeOSOQ.s:228    .text.switch_check:0000000000000000 $t
     /tmp/ccPeOSOQ.s:235    .text.switch_check:0000000000000000 switch_check
     /tmp/ccPeOSOQ.s:283    .text.input_init:0000000000000000 $t
     /tmp/ccPeOSOQ.s:290    .text.input_init:0000000000000000 input_init
     /tmp/ccPeOSOQ.s:358    .text.input_init:0000000000000040 $d
     /tmp/ccPeOSOQ.s:367    .text.handle_mpu6050:0000000000000000 $t
     /tmp/ccPeOSOQ.s:374    .text.handle_mpu6050:0000000000000000 handle_mpu6050
     /tmp/ccPeOSOQ.s:425    .text.handle_mpu6050:000000000000002c $d
     /tmp/ccPeOSOQ.s:431    .text.handle_sensors:0000000000000000 $t
     /tmp/ccPeOSOQ.s:438    .text.handle_sensors:0000000000000000 handle_sensors
     /tmp/ccPeOSOQ.s:596    .text.handle_sensors:000000000000007c $d
     /tmp/ccPeOSOQ.s:606    .text.handle_usart:0000000000000000 $t
     /tmp/ccPeOSOQ.s:613    .text.handle_usart:0000000000000000 handle_usart
     /tmp/ccPeOSOQ.s:844    .text.handle_usart:0000000000000118 $d
     /tmp/ccPeOSOQ.s:858    .text.handle_leds:0000000000000000 $t
     /tmp/ccPeOSOQ.s:865    .text.handle_leds:0000000000000000 handle_leds
     /tmp/ccPeOSOQ.s:1029   .text.handle_leds:0000000000000094 $d
     /tmp/ccPeOSOQ.s:1036   .text.usart_process_data:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1043   .text.usart_process_data:0000000000000000 usart_process_data
     /tmp/ccPeOSOQ.s:1122   .text.usart_process_data:000000000000004c $d
     /tmp/ccPeOSOQ.s:1128   .text.usart1_rx_check:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1135   .text.usart1_rx_check:0000000000000000 usart1_rx_check
     /tmp/ccPeOSOQ.s:1250   .text.usart1_rx_check:0000000000000070 $d
     /tmp/ccPeOSOQ.s:1258   .text.usart0_rx_check:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1265   .text.usart0_rx_check:0000000000000000 usart0_rx_check
     /tmp/ccPeOSOQ.s:1278   .text.aux_print_to_console:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1285   .text.aux_print_to_console:0000000000000000 aux_print_to_console
     /tmp/ccPeOSOQ.s:1296   .text.i2c_writeBytes:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1303   .text.i2c_writeBytes:0000000000000000 i2c_writeBytes
     /tmp/ccPeOSOQ.s:1437   .text.i2c_writeBytes:000000000000006c $d
     /tmp/ccPeOSOQ.s:1450   .text.i2c_writeByte:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1457   .text.i2c_writeByte:0000000000000000 i2c_writeByte
     /tmp/ccPeOSOQ.s:1489   .text.i2c_readBytes:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1496   .text.i2c_readBytes:0000000000000000 i2c_readBytes
     /tmp/ccPeOSOQ.s:1641   .text.i2c_readBytes:000000000000007c $d
     /tmp/ccPeOSOQ.s:1654   .text.i2c_readByte:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1661   .text.i2c_readByte:0000000000000000 i2c_readByte
     /tmp/ccPeOSOQ.s:1683   .text.i2c_writeBit:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1690   .text.i2c_writeBit:0000000000000000 i2c_writeBit
     /tmp/ccPeOSOQ.s:1763   .text.i2c_readBit:0000000000000000 $t
     /tmp/ccPeOSOQ.s:1770   .text.i2c_readBit:0000000000000000 i2c_readBit
     /tmp/ccPeOSOQ.s:1844   .bss.buffer:0000000000000000 buffer
     /tmp/ccPeOSOQ.s:1862   .bss.i2c_nRABytes:0000000000000000 i2c_nRABytes
     /tmp/ccPeOSOQ.s:1856   .bss.i2c_nDABytes:0000000000000000 i2c_nDABytes
     /tmp/ccPeOSOQ.s:1875   .bss.i2c_rxbuffer:0000000000000000 i2c_rxbuffer
     /tmp/ccPeOSOQ.s:1894   .bss.i2c_txbuffer:0000000000000000 i2c_txbuffer
     /tmp/ccPeOSOQ.s:1881   .bss.i2c_slaveAddress:0000000000000000 i2c_slaveAddress
     /tmp/ccPeOSOQ.s:1868   .bss.i2c_regAddress:0000000000000000 i2c_regAddress
ARM GAS  /tmp/ccPeOSOQ.s 			page 53


     /tmp/ccPeOSOQ.s:1850   .bss.i2c_ReadWriteCmd:0000000000000000 i2c_ReadWriteCmd
     /tmp/ccPeOSOQ.s:1887   .bss.i2c_status:0000000000000000 i2c_status
     /tmp/ccPeOSOQ.s:1828   .bss.Feedback:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1832   .bss.Feedback:0000000000000000 Feedback
     /tmp/ccPeOSOQ.s:1835   .bss.FeedbackRaw:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1839   .bss.FeedbackRaw:0000000000000000 FeedbackRaw
     /tmp/ccPeOSOQ.s:1845   .bss.buffer:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1851   .bss.i2c_ReadWriteCmd:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1857   .bss.i2c_nDABytes:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1863   .bss.i2c_nRABytes:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1869   .bss.i2c_regAddress:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1871   .bss.i2c_rxbuffer:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1882   .bss.i2c_slaveAddress:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1888   .bss.i2c_status:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1890   .bss.i2c_txbuffer:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1900   .bss.mpuStatus:0000000000000000 mpuStatus
     /tmp/ccPeOSOQ.s:1901   .bss.mpuStatus:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1903   .bss.old_pos.0:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1907   .bss.old_pos.0:0000000000000000 old_pos.0
     /tmp/ccPeOSOQ.s:1913   .bss.rx1_buffer:0000000000000000 rx1_buffer
     /tmp/ccPeOSOQ.s:1914   .bss.rx1_buffer:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1919   .bss.sensor1:0000000000000000 sensor1
     /tmp/ccPeOSOQ.s:1920   .bss.sensor1:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1925   .bss.sensor1_read:0000000000000000 sensor1_read
     /tmp/ccPeOSOQ.s:1926   .bss.sensor1_read:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1931   .bss.sensor2:0000000000000000 sensor2
     /tmp/ccPeOSOQ.s:1932   .bss.sensor2:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1937   .bss.sensor2_read:0000000000000000 sensor2_read
     /tmp/ccPeOSOQ.s:1938   .bss.sensor2_read:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1943   .bss.sideboard_imu:0000000000000000 sideboard_imu
     /tmp/ccPeOSOQ.s:1944   .bss.sideboard_imu:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1946   .bss.timeoutCntSerial1:0000000000000000 $d
     /tmp/ccPeOSOQ.s:1950   .bss.timeoutCntSerial1:0000000000000000 timeoutCntSerial1
     /tmp/ccPeOSOQ.s:1956   .bss.timeoutFlagSerial1:0000000000000000 timeoutFlagSerial1
     /tmp/ccPeOSOQ.s:1957   .bss.timeoutFlagSerial1:0000000000000000 $d

UNDEFINED SYMBOLS
gpio_bit_set
gpio_bit_reset
delay_1ms
usart_Tx_DMA_config
usart_Rx_DMA_config
mpu_config
mpu_get_data
main_loop_counter
gpio_input_bit_get
dma_transfer_number_get
dma_channel_disable
dma_channel_enable
mpu
memcpy
i2c_interrupt_enable
i2c_flag_get
i2c_start_on_bus
i2c_ackpos_config
