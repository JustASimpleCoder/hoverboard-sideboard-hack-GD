ARM GAS  /tmp/ccESV1n0.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.consoleLog,"ax",%progbits
  16              		.align	1
  17              		.global	consoleLog
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	consoleLog:
  25              	.LVL0:
  26              	.LFB59:
  27              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-sideboard-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <string.h>
  23:Src/util.c    **** #include "systick.h"
  24:Src/util.c    **** #include "gd32f1x0.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "config.h"
  27:Src/util.c    **** #include "setup.h"
  28:Src/util.c    **** #include "util.h"
  29:Src/util.c    **** #include "mpu6050.h"
  30:Src/util.c    **** 
  31:Src/util.c    **** // USART1 variables
ARM GAS  /tmp/ccESV1n0.s 			page 2


  32:Src/util.c    **** #ifdef SERIAL_CONTROL
  33:Src/util.c    **** static SerialSideboard Sideboard;
  34:Src/util.c    **** #endif
  35:Src/util.c    **** 
  36:Src/util.c    **** #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
  37:Src/util.c    **** static uint8_t  rx1_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  38:Src/util.c    **** static uint32_t rx1_buffer_len = ARRAY_LEN(rx1_buffer);
  39:Src/util.c    **** #endif
  40:Src/util.c    **** 
  41:Src/util.c    **** #ifdef SERIAL_FEEDBACK
  42:Src/util.c    **** static SerialFeedback Feedback;
  43:Src/util.c    **** static SerialFeedback FeedbackRaw;
  44:Src/util.c    **** static uint16_t timeoutCntSerial1  = 0;         // Timeout counter for UART1 Rx Serial
  45:Src/util.c    **** static uint8_t  timeoutFlagSerial1 = 0;         // Timeout Flag for UART1 Rx Serial: 0 = OK, 1 = Pr
  46:Src/util.c    **** static uint32_t Feedback_len  = sizeof(Feedback);
  47:Src/util.c    **** #endif
  48:Src/util.c    **** 
  49:Src/util.c    **** // USART0 variables
  50:Src/util.c    **** #ifdef SERIAL_AUX_TX
  51:Src/util.c    **** static SerialAuxTx AuxTx;
  52:Src/util.c    **** #endif
  53:Src/util.c    **** 
  54:Src/util.c    **** #ifdef SERIAL_AUX_RX
  55:Src/util.c    **** static uint8_t  rx0_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  56:Src/util.c    **** static uint32_t rx0_buffer_len = ARRAY_LEN(rx0_buffer);
  57:Src/util.c    **** #endif
  58:Src/util.c    **** 
  59:Src/util.c    **** #ifdef SERIAL_AUX_RX
  60:Src/util.c    **** static SerialCommand command;
  61:Src/util.c    **** static SerialCommand command_raw;
  62:Src/util.c    **** static uint16_t timeoutCntSerial0  = 0;         // Timeout counter for UART0 Rx Serial
  63:Src/util.c    **** static uint8_t  timeoutFlagSerial0 = 0;         // Timeout Flag for UART0 Rx Serial: 0 = OK, 1 = Pr
  64:Src/util.c    **** static uint32_t command_len = sizeof(command);
  65:Src/util.c    **** extern uint8_t  print_aux;
  66:Src/util.c    ****   #ifdef CONTROL_IBUS
  67:Src/util.c    ****   static uint16_t ibus_chksum;
  68:Src/util.c    ****   static uint16_t ibus_captured_value[IBUS_NUM_CHANNELS];
  69:Src/util.c    ****   #endif
  70:Src/util.c    **** #endif
  71:Src/util.c    **** 
  72:Src/util.c    **** #if (defined(SERIAL_AUX_RX) && defined(CONTROL_IBUS)) || defined(SERIAL_CONTROL)
  73:Src/util.c    **** static int16_t  cmd1, cmd2;
  74:Src/util.c    **** static uint16_t cmdSwitch;
  75:Src/util.c    **** #endif
  76:Src/util.c    **** 
  77:Src/util.c    **** // Optical sensors variables
  78:Src/util.c    **** static FlagStatus   sensor1, sensor2;           // holds the sensor1 and sensor 2 values
  79:Src/util.c    **** static FlagStatus   sensor1_read, sensor2_read; // holds the instantaneous Read for sensor1 and sen
  80:Src/util.c    **** 
  81:Src/util.c    **** // MPU variables
  82:Src/util.c    **** extern MPU_Data     mpu;                        // holds the MPU-6050 data
  83:Src/util.c    **** #if defined(MPU_SENSOR_ENABLE) || defined(SERIAL_CONTROL)
  84:Src/util.c    **** static ErrStatus    mpuStatus;                  // holds the MPU-6050 status: SUCCESS or ERROR
  85:Src/util.c    **** #endif
  86:Src/util.c    **** 
  87:Src/util.c    **** extern uint32_t     main_loop_counter;          // main loop counter to perform task scheduling ins
  88:Src/util.c    **** 
ARM GAS  /tmp/ccESV1n0.s 			page 3


  89:Src/util.c    **** // MAIN I2C variables
  90:Src/util.c    **** volatile int8_t     i2c_status;
  91:Src/util.c    **** volatile i2c_cmd    i2c_ReadWriteCmd;
  92:Src/util.c    **** volatile uint8_t    i2c_regAddress;
  93:Src/util.c    **** volatile uint8_t    i2c_slaveAddress;
  94:Src/util.c    **** volatile uint8_t*   i2c_txbuffer;
  95:Src/util.c    **** volatile uint8_t*   i2c_rxbuffer;
  96:Src/util.c    **** volatile uint8_t    i2c_nDABytes;
  97:Src/util.c    **** volatile  int8_t    i2c_nRABytes;
  98:Src/util.c    **** volatile uint8_t    buffer[14];
  99:Src/util.c    **** 
 100:Src/util.c    **** #ifdef AUX45_USE_I2C
 101:Src/util.c    **** // AUX I2C variables
 102:Src/util.c    **** volatile int8_t     i2c_aux_status;
 103:Src/util.c    **** volatile i2c_cmd    i2c_aux_ReadWriteCmd;
 104:Src/util.c    **** volatile uint8_t    i2c_aux_regAddress;
 105:Src/util.c    **** volatile uint8_t    i2c_aux_slaveAddress;
 106:Src/util.c    **** volatile uint8_t*   i2c_aux_txbuffer;
 107:Src/util.c    **** volatile uint8_t*   i2c_aux_rxbuffer;
 108:Src/util.c    **** volatile uint8_t    i2c_aux_nDABytes;
 109:Src/util.c    **** volatile  int8_t    i2c_aux_nRABytes;
 110:Src/util.c    **** #endif
 111:Src/util.c    **** 
 112:Src/util.c    **** 
 113:Src/util.c    **** 
 114:Src/util.c    **** /* =========================== General Functions =========================== */
 115:Src/util.c    **** 
 116:Src/util.c    **** void consoleLog(char *message)
 117:Src/util.c    **** {
  28              		.loc 1 117 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
 118:Src/util.c    ****   #ifdef SERIAL_DEBUG
 119:Src/util.c    ****     log_i("%s", message);
 120:Src/util.c    ****   #endif
 121:Src/util.c    **** }
  33              		.loc 1 121 1 view .LVU1
  34 0000 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE59:
  38              		.section	.text.toggle_led,"ax",%progbits
  39              		.align	1
  40              		.global	toggle_led
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	toggle_led:
  47              	.LVL1:
  48              	.LFB60:
 122:Src/util.c    **** 
 123:Src/util.c    **** 
 124:Src/util.c    **** /* retarget the C library printf function to the USART */
 125:Src/util.c    **** #ifdef SERIAL_DEBUG	
 126:Src/util.c    ****     #ifdef __GNUC__
ARM GAS  /tmp/ccESV1n0.s 			page 4


 127:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 128:Src/util.c    ****     #else
 129:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 130:Src/util.c    ****     #endif
 131:Src/util.c    ****     PUTCHAR_PROTOTYPE {
 132:Src/util.c    ****         usart_data_transmit(USART_MAIN, (uint8_t)ch);
 133:Src/util.c    ****         while(RESET == usart_flag_get(USART_MAIN, USART_FLAG_TBE));
 134:Src/util.c    ****         return ch;
 135:Src/util.c    ****     }
 136:Src/util.c    ****     
 137:Src/util.c    ****     #ifdef __GNUC__
 138:Src/util.c    ****         int _write(int file, char *data, int len) {
 139:Src/util.c    ****             int i;
 140:Src/util.c    ****             for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 141:Src/util.c    ****             return len; 
 142:Src/util.c    ****         }
 143:Src/util.c    ****     #endif
 144:Src/util.c    **** #endif
 145:Src/util.c    **** 
 146:Src/util.c    **** 
 147:Src/util.c    **** void toggle_led(uint32_t gpio_periph, uint32_t pin)
 148:Src/util.c    **** {
  49              		.loc 1 148 1 view -0
  50              		.cfi_startproc
  51              		@ args = 0, pretend = 0, frame = 0
  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
 149:Src/util.c    ****     GPIO_OCTL(gpio_periph) ^= pin;
  54              		.loc 1 149 5 view .LVU3
  55              		.loc 1 149 28 is_stmt 0 view .LVU4
  56 0000 4369     		ldr	r3, [r0, #20]
  57 0002 4B40     		eors	r3, r3, r1
  58 0004 4361     		str	r3, [r0, #20]
 150:Src/util.c    **** }
  59              		.loc 1 150 1 view .LVU5
  60 0006 7047     		bx	lr
  61              		.cfi_endproc
  62              	.LFE60:
  64              		.section	.text.intro_demo_led,"ax",%progbits
  65              		.align	1
  66              		.global	intro_demo_led
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu softvfp
  72              	intro_demo_led:
  73              	.LVL2:
  74              	.LFB61:
 151:Src/util.c    **** 
 152:Src/util.c    **** 
 153:Src/util.c    **** void intro_demo_led(uint32_t tDelay)
 154:Src/util.c    **** {
  75              		.loc 1 154 1 is_stmt 1 view -0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
 155:Src/util.c    ****     int i;
ARM GAS  /tmp/ccESV1n0.s 			page 5


  79              		.loc 1 155 5 view .LVU7
 156:Src/util.c    **** 
 157:Src/util.c    ****     for (i = 0; i < 3; i++) {
  80              		.loc 1 157 5 view .LVU8
  81              		.loc 1 157 17 view .LVU9
 154:Src/util.c    ****     int i;
  82              		.loc 1 154 1 is_stmt 0 view .LVU10
  83 0000 70B5     		push	{r4, r5, r6, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 16
  86              		.cfi_offset 4, -16
  87              		.cfi_offset 5, -12
  88              		.cfi_offset 6, -8
  89              		.cfi_offset 14, -4
 154:Src/util.c    ****     int i;
  90              		.loc 1 154 1 view .LVU11
  91 0002 0546     		mov	r5, r0
  92 0004 0326     		movs	r6, #3
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 159:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
  93              		.loc 1 159 9 view .LVU12
  94 0006 314C     		ldr	r4, .L8
  95              	.LVL3:
  96              	.L4:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
  97              		.loc 1 158 9 is_stmt 1 discriminator 3 view .LVU13
  98 0008 0121     		movs	r1, #1
  99 000a 4FF09040 		mov	r0, #1207959552
 100 000e FFF7FEFF 		bl	gpio_bit_set
 101              	.LVL4:
 102              		.loc 1 159 9 discriminator 3 view .LVU14
 103 0012 4FF48071 		mov	r1, #256
 104 0016 2046     		mov	r0, r4
 105 0018 FFF7FEFF 		bl	gpio_bit_reset
 106              	.LVL5:
 160:Src/util.c    ****         delay_1ms(tDelay);
 107              		.loc 1 160 9 discriminator 3 view .LVU15
 108 001c 2846     		mov	r0, r5
 109 001e FFF7FEFF 		bl	delay_1ms
 110              	.LVL6:
 161:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 111              		.loc 1 161 9 discriminator 3 view .LVU16
 112 0022 4FF40071 		mov	r1, #512
 113 0026 2046     		mov	r0, r4
 114 0028 FFF7FEFF 		bl	gpio_bit_set
 115              	.LVL7:
 162:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 116              		.loc 1 162 9 discriminator 3 view .LVU17
 117 002c 0121     		movs	r1, #1
 118 002e 4FF09040 		mov	r0, #1207959552
 119 0032 FFF7FEFF 		bl	gpio_bit_reset
 120              	.LVL8:
 163:Src/util.c    ****         delay_1ms(tDelay);
 121              		.loc 1 163 9 discriminator 3 view .LVU18
 122 0036 2846     		mov	r0, r5
 123 0038 FFF7FEFF 		bl	delay_1ms
 124              	.LVL9:
ARM GAS  /tmp/ccESV1n0.s 			page 6


 164:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 125              		.loc 1 164 9 discriminator 3 view .LVU19
 126 003c 4FF48071 		mov	r1, #256
 127 0040 2046     		mov	r0, r4
 128 0042 FFF7FEFF 		bl	gpio_bit_set
 129              	.LVL10:
 165:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 130              		.loc 1 165 9 discriminator 3 view .LVU20
 131 0046 4FF40071 		mov	r1, #512
 132 004a 2046     		mov	r0, r4
 133 004c FFF7FEFF 		bl	gpio_bit_reset
 134              	.LVL11:
 166:Src/util.c    ****         delay_1ms(tDelay);
 135              		.loc 1 166 9 discriminator 3 view .LVU21
 136 0050 2846     		mov	r0, r5
 137 0052 FFF7FEFF 		bl	delay_1ms
 138              	.LVL12:
 157:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 139              		.loc 1 157 24 discriminator 3 view .LVU22
 157:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 140              		.loc 1 157 17 discriminator 3 view .LVU23
 157:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 141              		.loc 1 157 5 is_stmt 0 discriminator 3 view .LVU24
 142 0056 013E     		subs	r6, r6, #1
 143              	.LVL13:
 157:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 144              		.loc 1 157 5 discriminator 3 view .LVU25
 145 0058 D6D1     		bne	.L4
 146 005a 0226     		movs	r6, #2
 147              	.LVL14:
 167:Src/util.c    ****     }
 168:Src/util.c    **** 
 169:Src/util.c    ****     for (i = 0; i < 2; i++) {
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 171:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 148              		.loc 1 171 9 view .LVU26
 149 005c 1B4C     		ldr	r4, .L8
 150              	.L5:
 151              	.LVL15:
 170:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 152              		.loc 1 170 9 is_stmt 1 discriminator 3 view .LVU27
 153 005e 0121     		movs	r1, #1
 154 0060 4FF09040 		mov	r0, #1207959552
 155 0064 FFF7FEFF 		bl	gpio_bit_set
 156              	.LVL16:
 157              		.loc 1 171 9 discriminator 3 view .LVU28
 158 0068 4FF40071 		mov	r1, #512
 159 006c 2046     		mov	r0, r4
 160 006e FFF7FEFF 		bl	gpio_bit_set
 161              	.LVL17:
 172:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 162              		.loc 1 172 9 discriminator 3 view .LVU29
 163 0072 4FF48071 		mov	r1, #256
 164 0076 2046     		mov	r0, r4
 165 0078 FFF7FEFF 		bl	gpio_bit_set
 166              	.LVL18:
 173:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
ARM GAS  /tmp/ccESV1n0.s 			page 7


 167              		.loc 1 173 9 discriminator 3 view .LVU30
 168 007c 2021     		movs	r1, #32
 169 007e 2046     		mov	r0, r4
 170 0080 FFF7FEFF 		bl	gpio_bit_set
 171              	.LVL19:
 174:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 172              		.loc 1 174 9 discriminator 3 view .LVU31
 173 0084 1021     		movs	r1, #16
 174 0086 2046     		mov	r0, r4
 175 0088 FFF7FEFF 		bl	gpio_bit_set
 176              	.LVL20:
 175:Src/util.c    ****         delay_1ms(tDelay);
 177              		.loc 1 175 9 discriminator 3 view .LVU32
 178 008c 2846     		mov	r0, r5
 179 008e FFF7FEFF 		bl	delay_1ms
 180              	.LVL21:
 176:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 181              		.loc 1 176 9 discriminator 3 view .LVU33
 182 0092 0121     		movs	r1, #1
 183 0094 4FF09040 		mov	r0, #1207959552
 184 0098 FFF7FEFF 		bl	gpio_bit_reset
 185              	.LVL22:
 177:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 186              		.loc 1 177 9 discriminator 3 view .LVU34
 187 009c 4FF40071 		mov	r1, #512
 188 00a0 2046     		mov	r0, r4
 189 00a2 FFF7FEFF 		bl	gpio_bit_reset
 190              	.LVL23:
 178:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
 191              		.loc 1 178 9 discriminator 3 view .LVU35
 192 00a6 4FF48071 		mov	r1, #256
 193 00aa 2046     		mov	r0, r4
 194 00ac FFF7FEFF 		bl	gpio_bit_reset
 195              	.LVL24:
 179:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 196              		.loc 1 179 9 discriminator 3 view .LVU36
 197 00b0 2021     		movs	r1, #32
 198 00b2 2046     		mov	r0, r4
 199 00b4 FFF7FEFF 		bl	gpio_bit_reset
 200              	.LVL25:
 180:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 201              		.loc 1 180 9 discriminator 3 view .LVU37
 202 00b8 1021     		movs	r1, #16
 203 00ba 2046     		mov	r0, r4
 204 00bc FFF7FEFF 		bl	gpio_bit_reset
 205              	.LVL26:
 169:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 206              		.loc 1 169 24 discriminator 3 view .LVU38
 169:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 207              		.loc 1 169 17 discriminator 3 view .LVU39
 169:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 208              		.loc 1 169 5 is_stmt 0 discriminator 3 view .LVU40
 209 00c0 012E     		cmp	r6, #1
 210 00c2 00D1     		bne	.L6
 181:Src/util.c    ****     }
 182:Src/util.c    **** }
 211              		.loc 1 182 1 view .LVU41
ARM GAS  /tmp/ccESV1n0.s 			page 8


 212 00c4 70BD     		pop	{r4, r5, r6, pc}
 213              	.LVL27:
 214              	.L6:
 215              		.loc 1 182 1 view .LVU42
 216 00c6 0126     		movs	r6, #1
 217              	.LVL28:
 218              		.loc 1 182 1 view .LVU43
 219 00c8 C9E7     		b	.L5
 220              	.L9:
 221 00ca 00BF     		.align	2
 222              	.L8:
 223 00cc 00040048 		.word	1207960576
 224              		.cfi_endproc
 225              	.LFE61:
 227              		.section	.text.switch_check,"ax",%progbits
 228              		.align	1
 229              		.global	switch_check
 230              		.syntax unified
 231              		.thumb
 232              		.thumb_func
 233              		.fpu softvfp
 235              	switch_check:
 236              	.LVL29:
 237              	.LFB62:
 183:Src/util.c    **** 
 184:Src/util.c    **** 
 185:Src/util.c    **** uint8_t switch_check(uint16_t ch, uint8_t type) {
 238              		.loc 1 185 49 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 186:Src/util.c    ****     if (type) { // 3 positions switch
 243              		.loc 1 186 5 view .LVU45
 244              		.loc 1 186 8 is_stmt 0 view .LVU46
 245 0000 41B1     		cbz	r1, .L11
 187:Src/util.c    ****         if      (ch < 250) return 0;    // switch in position 0
 246              		.loc 1 187 9 is_stmt 1 view .LVU47
 247              		.loc 1 187 17 is_stmt 0 view .LVU48
 248 0002 F928     		cmp	r0, #249
 249 0004 0DD9     		bls	.L13
 188:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 250              		.loc 1 188 14 is_stmt 1 view .LVU49
 189:Src/util.c    ****         else               return 2;    // switch in position 2
 251              		.loc 1 189 35 is_stmt 0 view .LVU50
 252 0006 40F25133 		movw	r3, #849
 253 000a 9842     		cmp	r0, r3
 254 000c 94BF     		ite	ls
 255 000e 0120     		movls	r0, #1
 256 0010 0220     		movhi	r0, #2
 257              	.LVL30:
 258              		.loc 1 189 35 view .LVU51
 259 0012 7047     		bx	lr
 260              	.LVL31:
 261              	.L11:
 190:Src/util.c    ****     } else {    // 2 positions switch
 191:Src/util.c    ****         return  (ch > 850);
ARM GAS  /tmp/ccESV1n0.s 			page 9


 262              		.loc 1 191 9 is_stmt 1 view .LVU52
 263              		.loc 1 191 21 is_stmt 0 view .LVU53
 264 0014 40F25233 		movw	r3, #850
 265 0018 9842     		cmp	r0, r3
 266 001a 94BF     		ite	ls
 267 001c 0020     		movls	r0, #0
 268              	.LVL32:
 269              		.loc 1 191 21 view .LVU54
 270 001e 0120     		movhi	r0, #1
 271 0020 7047     		bx	lr
 272              	.LVL33:
 273              	.L13:
 187:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 274              		.loc 1 187 35 view .LVU55
 275 0022 0020     		movs	r0, #0
 276              	.LVL34:
 192:Src/util.c    ****     }
 193:Src/util.c    **** }
 277              		.loc 1 193 1 view .LVU56
 278 0024 7047     		bx	lr
 279              		.cfi_endproc
 280              	.LFE62:
 282              		.section	.text.input_init,"ax",%progbits
 283              		.align	1
 284              		.global	input_init
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 288              		.fpu softvfp
 290              	input_init:
 291              	.LFB63:
 194:Src/util.c    **** 
 195:Src/util.c    **** 
 196:Src/util.c    **** /* =========================== Input Initialization Function =========================== */
 197:Src/util.c    **** 
 198:Src/util.c    **** void input_init(void) {
 292              		.loc 1 198 23 is_stmt 1 view -0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 199:Src/util.c    ****     #ifdef SERIAL_CONTROL
 200:Src/util.c    ****         usart_Tx_DMA_config(USART_MAIN, (uint8_t *)&Sideboard, sizeof(Sideboard));
 296              		.loc 1 200 9 view .LVU58
 198:Src/util.c    ****     #ifdef SERIAL_CONTROL
 297              		.loc 1 198 23 is_stmt 0 view .LVU59
 298 0000 08B5     		push	{r3, lr}
 299              	.LCFI1:
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 3, -8
 302              		.cfi_offset 14, -4
 303              		.loc 1 200 9 view .LVU60
 304 0002 0E22     		movs	r2, #14
 305 0004 0F49     		ldr	r1, .L18
 306 0006 1048     		ldr	r0, .L18+4
 307 0008 FFF7FEFF 		bl	usart_Tx_DMA_config
 308              	.LVL35:
 201:Src/util.c    ****     #endif
ARM GAS  /tmp/ccESV1n0.s 			page 10


 202:Src/util.c    ****     #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
 203:Src/util.c    ****         usart_Rx_DMA_config(USART_MAIN, (uint8_t *)rx1_buffer, sizeof(rx1_buffer));
 309              		.loc 1 203 9 is_stmt 1 view .LVU61
 310 000c 4022     		movs	r2, #64
 311 000e 0F49     		ldr	r1, .L18+8
 312 0010 0D48     		ldr	r0, .L18+4
 313 0012 FFF7FEFF 		bl	usart_Rx_DMA_config
 314              	.LVL36:
 204:Src/util.c    ****     #endif
 205:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 206:Src/util.c    ****         usart_Tx_DMA_config(USART_AUX, (uint8_t *)&AuxTx, sizeof(AuxTx));
 207:Src/util.c    ****     #endif
 208:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 209:Src/util.c    ****         usart_Rx_DMA_config(USART_AUX, (uint8_t *)rx0_buffer, sizeof(rx0_buffer));
 210:Src/util.c    ****     #endif
 211:Src/util.c    **** 
 212:Src/util.c    ****     intro_demo_led(100);                                // Short LEDs intro demo with 100 ms delay.
 315              		.loc 1 212 5 view .LVU62
 316 0016 6420     		movs	r0, #100
 317 0018 FFF7FEFF 		bl	intro_demo_led
 318              	.LVL37:
 213:Src/util.c    **** 
 214:Src/util.c    ****     #ifdef MPU_SENSOR_ENABLE
 215:Src/util.c    ****         if(mpu_config()) {                              // IMU MPU-6050 config
 319              		.loc 1 215 9 view .LVU63
 320              		.loc 1 215 12 is_stmt 0 view .LVU64
 321 001c FFF7FEFF 		bl	mpu_config
 322              	.LVL38:
 323 0020 0B4B     		ldr	r3, .L18+12
 324              		.loc 1 215 11 view .LVU65
 325 0022 40B1     		cbz	r0, .L16
 216:Src/util.c    ****             mpuStatus = ERROR;
 326              		.loc 1 216 13 is_stmt 1 view .LVU66
 327              		.loc 1 216 23 is_stmt 0 view .LVU67
 328 0024 0022     		movs	r2, #0
 217:Src/util.c    ****             gpio_bit_set(LED1_GPIO_Port, LED1_Pin);     // Turn on RED LED - sensor enabled and NOT
 329              		.loc 1 217 13 view .LVU68
 330 0026 0121     		movs	r1, #1
 331 0028 4FF09040 		mov	r0, #1207959552
 216:Src/util.c    ****             mpuStatus = ERROR;
 332              		.loc 1 216 23 view .LVU69
 333 002c 1A70     		strb	r2, [r3]
 334              		.loc 1 217 13 is_stmt 1 view .LVU70
 335              	.L17:
 218:Src/util.c    ****         }
 219:Src/util.c    ****         else {
 220:Src/util.c    ****             mpuStatus = SUCCESS;
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 222:Src/util.c    ****         }
 223:Src/util.c    ****     #else
 224:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);         // Turn on GREEN LED - sensor disabled
 225:Src/util.c    ****     #endif
 226:Src/util.c    **** 
 227:Src/util.c    ****     #ifdef SERIAL_DEBUG
 228:Src/util.c    ****         mpu_handle_input('h');                          // Print the User Help commands to serial
 229:Src/util.c    ****     #endif
 230:Src/util.c    **** }
ARM GAS  /tmp/ccESV1n0.s 			page 11


 336              		.loc 1 230 1 is_stmt 0 view .LVU71
 337 002e BDE80840 		pop	{r3, lr}
 338              	.LCFI2:
 339              		.cfi_remember_state
 340              		.cfi_restore 14
 341              		.cfi_restore 3
 342              		.cfi_def_cfa_offset 0
 221:Src/util.c    ****         }
 343              		.loc 1 221 13 view .LVU72
 344 0032 FFF7FEBF 		b	gpio_bit_set
 345              	.LVL39:
 346              	.L16:
 347              	.LCFI3:
 348              		.cfi_restore_state
 220:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 349              		.loc 1 220 13 is_stmt 1 view .LVU73
 220:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 350              		.loc 1 220 23 is_stmt 0 view .LVU74
 351 0036 0122     		movs	r2, #1
 221:Src/util.c    ****         }
 352              		.loc 1 221 13 view .LVU75
 353 0038 4FF40071 		mov	r1, #512
 354 003c 0548     		ldr	r0, .L18+16
 220:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 355              		.loc 1 220 23 view .LVU76
 356 003e 1A70     		strb	r2, [r3]
 221:Src/util.c    ****         }
 357              		.loc 1 221 13 is_stmt 1 view .LVU77
 358 0040 F5E7     		b	.L17
 359              	.L19:
 360 0042 00BF     		.align	2
 361              	.L18:
 362 0044 00000000 		.word	.LANCHOR0
 363 0048 00440040 		.word	1073759232
 364 004c 00000000 		.word	.LANCHOR1
 365 0050 00000000 		.word	.LANCHOR2
 366 0054 00040048 		.word	1207960576
 367              		.cfi_endproc
 368              	.LFE63:
 370              		.section	.text.handle_mpu6050,"ax",%progbits
 371              		.align	1
 372              		.global	handle_mpu6050
 373              		.syntax unified
 374              		.thumb
 375              		.thumb_func
 376              		.fpu softvfp
 378              	handle_mpu6050:
 379              	.LFB64:
 231:Src/util.c    **** 
 232:Src/util.c    **** 
 233:Src/util.c    **** /* =========================== Handle Functions =========================== */
 234:Src/util.c    **** 
 235:Src/util.c    **** /*
 236:Src/util.c    ****  * Handle of the MPU-6050 IMU sensor
 237:Src/util.c    ****  */
 238:Src/util.c    **** void handle_mpu6050(void) {
 380              		.loc 1 238 27 view -0
ARM GAS  /tmp/ccESV1n0.s 			page 12


 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              		@ link register save eliminated.
 239:Src/util.c    **** #ifdef MPU_SENSOR_ENABLE
 240:Src/util.c    ****     // Get MPU data. Because the MPU-6050 interrupt pin is not wired we have to check DMP data by p
 241:Src/util.c    ****     if (SUCCESS == mpuStatus) {
 385              		.loc 1 241 5 view .LVU79
 386              		.loc 1 241 17 is_stmt 0 view .LVU80
 387 0000 0A4B     		ldr	r3, .L23
 388 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 389              		.loc 1 241 8 view .LVU81
 390 0004 012B     		cmp	r3, #1
 391 0006 01D1     		bne	.L21
 242:Src/util.c    ****         mpu_get_data();
 392              		.loc 1 242 9 is_stmt 1 view .LVU82
 393 0008 FFF7FEBF 		b	mpu_get_data
 394              	.LVL40:
 395              	.L21:
 243:Src/util.c    ****     } else if (ERROR == mpuStatus && main_loop_counter % 100 == 0) {
 396              		.loc 1 243 12 view .LVU83
 397              		.loc 1 243 15 is_stmt 0 view .LVU84
 398 000c 6BB9     		cbnz	r3, .L20
 399 000e 6422     		movs	r2, #100
 400              		.loc 1 243 56 discriminator 1 view .LVU85
 401 0010 074B     		ldr	r3, .L23+4
 402 0012 1B68     		ldr	r3, [r3]
 403 0014 B3FBF2F1 		udiv	r1, r3, r2
 404 0018 02FB1133 		mls	r3, r2, r1, r3
 405              		.loc 1 243 35 discriminator 1 view .LVU86
 406 001c 2BB9     		cbnz	r3, .L20
 244:Src/util.c    ****         toggle_led(LED1_GPIO_Port, LED1_Pin);                    // Toggle the Red LED every 100 ms
 407              		.loc 1 244 9 is_stmt 1 view .LVU87
 408              	.LVL41:
 409              	.LBB14:
 410              	.LBI14:
 147:Src/util.c    **** {
 411              		.loc 1 147 6 view .LVU88
 412              	.LBB15:
 149:Src/util.c    **** }
 413              		.loc 1 149 5 view .LVU89
 149:Src/util.c    **** }
 414              		.loc 1 149 28 is_stmt 0 view .LVU90
 415 001e 4FF09042 		mov	r2, #1207959552
 416 0022 5369     		ldr	r3, [r2, #20]
 417 0024 83F00103 		eor	r3, r3, #1
 418 0028 5361     		str	r3, [r2, #20]
 419              	.LVL42:
 420              	.L20:
 149:Src/util.c    **** }
 421              		.loc 1 149 28 view .LVU91
 422              	.LBE15:
 423              	.LBE14:
 245:Src/util.c    ****     }
 246:Src/util.c    ****     // Print MPU data to Console
 247:Src/util.c    ****     #ifdef SERIAL_DEBUG
 248:Src/util.c    ****     if (main_loop_counter % 50 == 0) {
ARM GAS  /tmp/ccESV1n0.s 			page 13


 249:Src/util.c    ****         mpu_print_to_console();
 250:Src/util.c    ****     }
 251:Src/util.c    ****     #endif
 252:Src/util.c    **** #endif
 253:Src/util.c    **** }
 424              		.loc 1 253 1 view .LVU92
 425 002a 7047     		bx	lr
 426              	.L24:
 427              		.align	2
 428              	.L23:
 429 002c 00000000 		.word	.LANCHOR2
 430 0030 00000000 		.word	main_loop_counter
 431              		.cfi_endproc
 432              	.LFE64:
 434              		.section	.text.handle_sensors,"ax",%progbits
 435              		.align	1
 436              		.global	handle_sensors
 437              		.syntax unified
 438              		.thumb
 439              		.thumb_func
 440              		.fpu softvfp
 442              	handle_sensors:
 443              	.LFB65:
 254:Src/util.c    **** 
 255:Src/util.c    **** /*
 256:Src/util.c    ****  * Handle of the optical sensors
 257:Src/util.c    ****  */
 258:Src/util.c    **** void handle_sensors(void) {
 444              		.loc 1 258 27 is_stmt 1 view -0
 445              		.cfi_startproc
 446              		@ args = 0, pretend = 0, frame = 0
 447              		@ frame_needed = 0, uses_anonymous_args = 0
 259:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 448              		.loc 1 259 5 view .LVU94
 258:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 449              		.loc 1 258 27 is_stmt 0 view .LVU95
 450 0000 38B5     		push	{r3, r4, r5, lr}
 451              	.LCFI4:
 452              		.cfi_def_cfa_offset 16
 453              		.cfi_offset 3, -16
 454              		.cfi_offset 4, -12
 455              		.cfi_offset 5, -8
 456              		.cfi_offset 14, -4
 457              		.loc 1 259 20 view .LVU96
 458 0002 1021     		movs	r1, #16
 459 0004 4FF09040 		mov	r0, #1207959552
 460 0008 FFF7FEFF 		bl	gpio_input_bit_get
 461              	.LVL43:
 462              		.loc 1 259 18 view .LVU97
 463 000c 1B4D     		ldr	r5, .L30
 260:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 464              		.loc 1 260 20 view .LVU98
 465 000e 4FF48041 		mov	r1, #16384
 259:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 466              		.loc 1 259 18 view .LVU99
 467 0012 2870     		strb	r0, [r5]
 468              		.loc 1 260 5 is_stmt 1 view .LVU100
ARM GAS  /tmp/ccESV1n0.s 			page 14


 469              		.loc 1 260 20 is_stmt 0 view .LVU101
 470 0014 1A48     		ldr	r0, .L30+4
 471 0016 FFF7FEFF 		bl	gpio_input_bit_get
 472              	.LVL44:
 261:Src/util.c    **** 
 262:Src/util.c    ****     // SENSOR1
 263:Src/util.c    ****     if (sensor1 == RESET && sensor1_read == SET) {
 473              		.loc 1 263 17 view .LVU102
 474 001a 1A4B     		ldr	r3, .L30+8
 260:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 475              		.loc 1 260 18 view .LVU103
 476 001c 1A4C     		ldr	r4, .L30+12
 477              		.loc 1 263 17 view .LVU104
 478 001e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 260:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 479              		.loc 1 260 18 view .LVU105
 480 0020 2070     		strb	r0, [r4]
 481              		.loc 1 263 5 is_stmt 1 view .LVU106
 482              		.loc 1 263 8 is_stmt 0 view .LVU107
 483 0022 A2B9     		cbnz	r2, .L26
 484              		.loc 1 263 26 discriminator 1 view .LVU108
 485 0024 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 486 0026 012A     		cmp	r2, #1
 487 0028 04D1     		bne	.L27
 264:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 265:Src/util.c    ****         sensor1 = SET;
 488              		.loc 1 265 9 is_stmt 1 view .LVU109
 266:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 489              		.loc 1 266 9 is_stmt 0 view .LVU110
 490 002a 2021     		movs	r1, #32
 491 002c 1748     		ldr	r0, .L30+16
 265:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 492              		.loc 1 265 17 view .LVU111
 493 002e 1A70     		strb	r2, [r3]
 494              		.loc 1 266 9 is_stmt 1 view .LVU112
 495 0030 FFF7FEFF 		bl	gpio_bit_set
 496              	.LVL45:
 267:Src/util.c    ****         consoleLog("SENSOR 1 ON\r\n");
 497              		.loc 1 267 9 view .LVU113
 498              	.LBB16:
 499              	.LBI16:
 116:Src/util.c    **** {
 500              		.loc 1 116 6 view .LVU114
 501              	.LBB17:
 121:Src/util.c    **** 
 502              		.loc 1 121 1 view .LVU115
 503              	.L27:
 121:Src/util.c    **** 
 504              		.loc 1 121 1 is_stmt 0 view .LVU116
 505              	.LBE17:
 506              	.LBE16:
 268:Src/util.c    ****     } else if(sensor1 == SET && sensor1_read == RESET) {
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 270:Src/util.c    ****         sensor1 = RESET;
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 273:Src/util.c    ****     }
ARM GAS  /tmp/ccESV1n0.s 			page 15


 274:Src/util.c    **** 
 275:Src/util.c    ****     // SENSOR2
 276:Src/util.c    ****     if (sensor2 == RESET && sensor2_read == SET) {
 507              		.loc 1 276 5 is_stmt 1 view .LVU117
 508              		.loc 1 276 17 is_stmt 0 view .LVU118
 509 0034 164B     		ldr	r3, .L30+20
 510 0036 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 511              		.loc 1 276 8 view .LVU119
 512 0038 A2B9     		cbnz	r2, .L28
 513              		.loc 1 276 26 discriminator 1 view .LVU120
 514 003a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 515 003c 012A     		cmp	r2, #1
 516 003e 1CD1     		bne	.L25
 277:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 278:Src/util.c    ****         sensor2 = SET;
 517              		.loc 1 278 9 is_stmt 1 view .LVU121
 518              		.loc 1 278 17 is_stmt 0 view .LVU122
 519 0040 1A70     		strb	r2, [r3]
 279:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 520              		.loc 1 279 9 is_stmt 1 view .LVU123
 521 0042 1021     		movs	r1, #16
 280:Src/util.c    ****         consoleLog("SENSOR 2 ON\r\n");
 281:Src/util.c    ****     } else if (sensor2 == SET && sensor2_read == RESET) {
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 283:Src/util.c    ****         sensor2 = RESET;
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 286:Src/util.c    ****     }
 287:Src/util.c    **** 
 288:Src/util.c    ****     if (sensor1 == SET) {
 289:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 290:Src/util.c    ****     }
 291:Src/util.c    ****     if (sensor2 == SET) {
 292:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 293:Src/util.c    ****     }
 294:Src/util.c    **** }
 522              		.loc 1 294 1 is_stmt 0 view .LVU124
 523 0044 BDE83840 		pop	{r3, r4, r5, lr}
 524              	.LCFI5:
 525              		.cfi_remember_state
 526              		.cfi_restore 14
 527              		.cfi_restore 5
 528              		.cfi_restore 4
 529              		.cfi_restore 3
 530              		.cfi_def_cfa_offset 0
 279:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 531              		.loc 1 279 9 view .LVU125
 532 0048 1048     		ldr	r0, .L30+16
 533 004a FFF7FEBF 		b	gpio_bit_set
 534              	.LVL46:
 535              	.L26:
 536              	.LCFI6:
 537              		.cfi_restore_state
 268:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 538              		.loc 1 268 12 is_stmt 1 view .LVU126
 268:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 539              		.loc 1 268 14 is_stmt 0 view .LVU127
ARM GAS  /tmp/ccESV1n0.s 			page 16


 540 004e 012A     		cmp	r2, #1
 541 0050 F0D1     		bne	.L27
 268:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 542              		.loc 1 268 30 discriminator 1 view .LVU128
 543 0052 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 544 0054 002A     		cmp	r2, #0
 545 0056 EDD1     		bne	.L27
 270:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 546              		.loc 1 270 9 is_stmt 1 view .LVU129
 271:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 547              		.loc 1 271 9 is_stmt 0 view .LVU130
 548 0058 2021     		movs	r1, #32
 549 005a 0C48     		ldr	r0, .L30+16
 270:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 550              		.loc 1 270 17 view .LVU131
 551 005c 1A70     		strb	r2, [r3]
 271:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 552              		.loc 1 271 9 is_stmt 1 view .LVU132
 553 005e FFF7FEFF 		bl	gpio_bit_reset
 554              	.LVL47:
 272:Src/util.c    ****     }
 555              		.loc 1 272 9 view .LVU133
 556              	.LBB18:
 557              	.LBI18:
 116:Src/util.c    **** {
 558              		.loc 1 116 6 view .LVU134
 559              	.LBB19:
 121:Src/util.c    **** 
 560              		.loc 1 121 1 view .LVU135
 561 0062 E7E7     		b	.L27
 562              	.LVL48:
 563              	.L28:
 121:Src/util.c    **** 
 564              		.loc 1 121 1 is_stmt 0 view .LVU136
 565              	.LBE19:
 566              	.LBE18:
 281:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 567              		.loc 1 281 12 is_stmt 1 view .LVU137
 281:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 568              		.loc 1 281 15 is_stmt 0 view .LVU138
 569 0064 012A     		cmp	r2, #1
 570 0066 08D1     		bne	.L25
 281:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 571              		.loc 1 281 31 discriminator 1 view .LVU139
 572 0068 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 573 006a 32B9     		cbnz	r2, .L25
 283:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 574              		.loc 1 283 9 is_stmt 1 view .LVU140
 283:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 575              		.loc 1 283 17 is_stmt 0 view .LVU141
 576 006c 1A70     		strb	r2, [r3]
 284:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 577              		.loc 1 284 9 is_stmt 1 view .LVU142
 578 006e 1021     		movs	r1, #16
 579              		.loc 1 294 1 is_stmt 0 view .LVU143
 580 0070 BDE83840 		pop	{r3, r4, r5, lr}
 581              	.LCFI7:
ARM GAS  /tmp/ccESV1n0.s 			page 17


 582              		.cfi_remember_state
 583              		.cfi_restore 14
 584              		.cfi_restore 5
 585              		.cfi_restore 4
 586              		.cfi_restore 3
 587              		.cfi_def_cfa_offset 0
 284:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 588              		.loc 1 284 9 view .LVU144
 589 0074 0548     		ldr	r0, .L30+16
 590 0076 FFF7FEBF 		b	gpio_bit_reset
 591              	.LVL49:
 592              	.L25:
 593              	.LCFI8:
 594              		.cfi_restore_state
 595              		.loc 1 294 1 view .LVU145
 596 007a 38BD     		pop	{r3, r4, r5, pc}
 597              	.L31:
 598              		.align	2
 599              	.L30:
 600 007c 00000000 		.word	.LANCHOR3
 601 0080 00080048 		.word	1207961600
 602 0084 00000000 		.word	.LANCHOR5
 603 0088 00000000 		.word	.LANCHOR4
 604 008c 00040048 		.word	1207960576
 605 0090 00000000 		.word	.LANCHOR6
 606              		.cfi_endproc
 607              	.LFE65:
 609              		.section	.text.handle_usart,"ax",%progbits
 610              		.align	1
 611              		.global	handle_usart
 612              		.syntax unified
 613              		.thumb
 614              		.thumb_func
 615              		.fpu softvfp
 617              	handle_usart:
 618              	.LFB66:
 295:Src/util.c    **** 
 296:Src/util.c    **** /*
 297:Src/util.c    ****  * Handle of the USART data
 298:Src/util.c    ****  */
 299:Src/util.c    **** void handle_usart(void) {
 619              		.loc 1 299 25 is_stmt 1 view -0
 620              		.cfi_startproc
 621              		@ args = 0, pretend = 0, frame = 0
 622              		@ frame_needed = 0, uses_anonymous_args = 0
 300:Src/util.c    ****     // Tx USART MAIN
 301:Src/util.c    ****     #ifdef SERIAL_CONTROL
 302:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART1_TX_DMA_CH) == 0) {     // 
 623              		.loc 1 302 9 view .LVU147
 299:Src/util.c    ****     // Tx USART MAIN
 624              		.loc 1 299 25 is_stmt 0 view .LVU148
 625 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 626              	.LCFI9:
 627              		.cfi_def_cfa_offset 24
 628              		.cfi_offset 3, -24
 629              		.cfi_offset 4, -20
 630              		.cfi_offset 5, -16
ARM GAS  /tmp/ccESV1n0.s 			page 18


 631              		.cfi_offset 6, -12
 632              		.cfi_offset 7, -8
 633              		.cfi_offset 14, -4
 634              		.loc 1 302 31 view .LVU149
 635 0002 294D     		ldr	r5, .L40
 299:Src/util.c    ****     // Tx USART MAIN
 636              		.loc 1 299 25 view .LVU150
 637 0004 294A     		ldr	r2, .L40+4
 638 0006 2B68     		ldr	r3, [r5]
 639 0008 5343     		muls	r3, r2, r3
 640              		.loc 1 302 12 view .LVU151
 641 000a B3F1333F 		cmp	r3, #858993459
 642 000e 29D8     		bhi	.L34
 643              		.loc 1 302 43 discriminator 1 view .LVU152
 644 0010 0320     		movs	r0, #3
 645 0012 FFF7FEFF 		bl	dma_transfer_number_get
 646              	.LVL50:
 647              		.loc 1 302 40 discriminator 1 view .LVU153
 648 0016 28BB     		cbnz	r0, .L34
 303:Src/util.c    ****             Sideboard.start     = (uint16_t)SERIAL_START_FRAME;
 649              		.loc 1 303 13 is_stmt 1 view .LVU154
 650              		.loc 1 303 33 is_stmt 0 view .LVU155
 651 0018 4AF6CD31 		movw	r1, #43981
 304:Src/util.c    ****             Sideboard.pitch     = (int16_t)mpu.euler.pitch;
 652              		.loc 1 304 53 view .LVU156
 653 001c 244B     		ldr	r3, .L40+8
 305:Src/util.c    ****             Sideboard.dPitch    = (int16_t)mpu.gyro.y;
 306:Src/util.c    ****             Sideboard.cmd1      = (int16_t)cmd1;
 307:Src/util.c    ****             Sideboard.cmd2      = (int16_t)cmd2; 
 308:Src/util.c    ****             Sideboard.sensors   = (uint16_t)( (cmdSwitch << 8)  | (sensor1 | (sensor2 << 1) | (mpuS
 654              		.loc 1 308 106 view .LVU157
 655 001e 254A     		ldr	r2, .L40+12
 304:Src/util.c    ****             Sideboard.pitch     = (int16_t)mpu.euler.pitch;
 656              		.loc 1 304 53 view .LVU158
 657 0020 B3F91E60 		ldrsh	r6, [r3, #30]
 305:Src/util.c    ****             Sideboard.dPitch    = (int16_t)mpu.gyro.y;
 658              		.loc 1 305 52 view .LVU159
 659 0024 B3F90270 		ldrsh	r7, [r3, #2]
 660              		.loc 1 308 87 view .LVU160
 661 0028 234B     		ldr	r3, .L40+16
 662              		.loc 1 308 106 view .LVU161
 663 002a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 664              		.loc 1 308 87 view .LVU162
 665 002c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 666              		.loc 1 308 106 view .LVU163
 667 002e 9200     		lsls	r2, r2, #2
 668              		.loc 1 308 93 view .LVU164
 669 0030 42EA4302 		orr	r2, r2, r3, lsl #1
 670              		.loc 1 308 76 view .LVU165
 671 0034 214B     		ldr	r3, .L40+20
 303:Src/util.c    ****             Sideboard.pitch     = (int16_t)mpu.euler.pitch;
 672              		.loc 1 303 33 view .LVU166
 673 0036 224C     		ldr	r4, .L40+24
 674              		.loc 1 308 76 view .LVU167
 675 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 304:Src/util.c    ****             Sideboard.pitch     = (int16_t)mpu.euler.pitch;
 676              		.loc 1 304 33 view .LVU168
ARM GAS  /tmp/ccESV1n0.s 			page 19


 677 003a 6680     		strh	r6, [r4, #2]	@ movhi
 678              		.loc 1 308 93 view .LVU169
 679 003c 1343     		orrs	r3, r3, r2
 309:Src/util.c    ****             Sideboard.checksum  = (uint16_t)(Sideboard.start ^ Sideboard.pitch ^ Sideboard.dPitch ^
 680              		.loc 1 309 133 view .LVU170
 681 003e 7E40     		eors	r6, r6, r7
 308:Src/util.c    ****             Sideboard.checksum  = (uint16_t)(Sideboard.start ^ Sideboard.pitch ^ Sideboard.dPitch ^
 682              		.loc 1 308 33 view .LVU171
 683 0040 6381     		strh	r3, [r4, #10]	@ movhi
 684              		.loc 1 309 133 view .LVU172
 685 0042 7340     		eors	r3, r3, r6
 686 0044 4B40     		eors	r3, r3, r1
 306:Src/util.c    ****             Sideboard.cmd2      = (int16_t)cmd2; 
 687              		.loc 1 306 33 view .LVU173
 688 0046 E080     		strh	r0, [r4, #6]	@ movhi
 307:Src/util.c    ****             Sideboard.sensors   = (uint16_t)( (cmdSwitch << 8)  | (sensor1 | (sensor2 << 1) | (mpuS
 689              		.loc 1 307 33 view .LVU174
 690 0048 2081     		strh	r0, [r4, #8]	@ movhi
 310:Src/util.c    ****         
 311:Src/util.c    ****             dma_channel_disable(USART1_TX_DMA_CH);
 691              		.loc 1 311 13 view .LVU175
 692 004a 0320     		movs	r0, #3
 309:Src/util.c    ****         
 693              		.loc 1 309 33 view .LVU176
 694 004c A381     		strh	r3, [r4, #12]	@ movhi
 303:Src/util.c    ****             Sideboard.pitch     = (int16_t)mpu.euler.pitch;
 695              		.loc 1 303 33 view .LVU177
 696 004e 2180     		strh	r1, [r4]	@ movhi
 304:Src/util.c    ****             Sideboard.dPitch    = (int16_t)mpu.gyro.y;
 697              		.loc 1 304 13 is_stmt 1 view .LVU178
 305:Src/util.c    ****             Sideboard.cmd1      = (int16_t)cmd1;
 698              		.loc 1 305 13 view .LVU179
 305:Src/util.c    ****             Sideboard.cmd1      = (int16_t)cmd1;
 699              		.loc 1 305 33 is_stmt 0 view .LVU180
 700 0050 A780     		strh	r7, [r4, #4]	@ movhi
 306:Src/util.c    ****             Sideboard.cmd2      = (int16_t)cmd2; 
 701              		.loc 1 306 13 is_stmt 1 view .LVU181
 307:Src/util.c    ****             Sideboard.sensors   = (uint16_t)( (cmdSwitch << 8)  | (sensor1 | (sensor2 << 1) | (mpuS
 702              		.loc 1 307 13 view .LVU182
 308:Src/util.c    ****             Sideboard.checksum  = (uint16_t)(Sideboard.start ^ Sideboard.pitch ^ Sideboard.dPitch ^
 703              		.loc 1 308 13 view .LVU183
 309:Src/util.c    ****         
 704              		.loc 1 309 13 view .LVU184
 705              		.loc 1 311 13 view .LVU185
 706 0052 FFF7FEFF 		bl	dma_channel_disable
 707              	.LVL51:
 312:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(Sideboard);
 708              		.loc 1 312 13 view .LVU186
 709              		.loc 1 312 45 is_stmt 0 view .LVU187
 710 0056 0E22     		movs	r2, #14
 711 0058 1A4B     		ldr	r3, .L40+28
 313:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&Sideboard;
 314:Src/util.c    ****             dma_channel_enable(USART1_TX_DMA_CH);
 712              		.loc 1 314 13 view .LVU188
 713 005a 0320     		movs	r0, #3
 312:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(Sideboard);
 714              		.loc 1 312 45 view .LVU189
ARM GAS  /tmp/ccESV1n0.s 			page 20


 715 005c 9A64     		str	r2, [r3, #72]
 313:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&Sideboard;
 716              		.loc 1 313 13 is_stmt 1 view .LVU190
 313:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&Sideboard;
 717              		.loc 1 313 45 is_stmt 0 view .LVU191
 718 005e 1C65     		str	r4, [r3, #80]
 719              		.loc 1 314 13 is_stmt 1 view .LVU192
 720 0060 FFF7FEFF 		bl	dma_channel_enable
 721              	.LVL52:
 722              	.L34:
 315:Src/util.c    ****         }
 316:Src/util.c    ****     #endif
 317:Src/util.c    ****     // Rx USART MAIN
 318:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 319:Src/util.c    ****         if (timeoutCntSerial1++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 723              		.loc 1 319 9 view .LVU193
 724              		.loc 1 319 30 is_stmt 0 view .LVU194
 725 0064 184B     		ldr	r3, .L40+32
 726 0066 1A88     		ldrh	r2, [r3]
 727 0068 511C     		adds	r1, r2, #1
 728              		.loc 1 319 12 view .LVU195
 729 006a B2F5167F 		cmp	r2, #600
 730              		.loc 1 319 30 view .LVU196
 731 006e 1980     		strh	r1, [r3]	@ movhi
 732 0070 164A     		ldr	r2, .L40+36
 733              		.loc 1 319 12 view .LVU197
 734 0072 14D3     		bcc	.L36
 320:Src/util.c    ****             timeoutFlagSerial1 = 1;                                 // Timeout detected
 735              		.loc 1 320 13 is_stmt 1 view .LVU198
 736              		.loc 1 320 32 is_stmt 0 view .LVU199
 737 0074 0121     		movs	r1, #1
 738 0076 1170     		strb	r1, [r2]
 321:Src/util.c    ****             timeoutCntSerial1  = SERIAL_TIMEOUT;                    // Limit timout counter value
 739              		.loc 1 321 13 is_stmt 1 view .LVU200
 740              		.loc 1 321 32 is_stmt 0 view .LVU201
 741 0078 4FF41672 		mov	r2, #600
 742 007c 1A80     		strh	r2, [r3]	@ movhi
 322:Src/util.c    ****         }
 323:Src/util.c    ****         if (timeoutFlagSerial1 && main_loop_counter % 100 == 0) {   // In case of timeout bring the
 743              		.loc 1 323 9 is_stmt 1 view .LVU202
 744              	.L37:
 745 007e 6422     		movs	r2, #100
 746 0080 2B68     		ldr	r3, [r5]
 747 0082 B3FBF2F1 		udiv	r1, r3, r2
 748 0086 02FB1133 		mls	r3, r2, r1, r3
 749              		.loc 1 323 32 is_stmt 0 discriminator 1 view .LVU203
 750 008a 5BB9     		cbnz	r3, .L32
 324:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 751              		.loc 1 324 13 is_stmt 1 view .LVU204
 752              	.LVL53:
 753              	.LBB20:
 754              	.LBI20:
 147:Src/util.c    **** {
 755              		.loc 1 147 6 view .LVU205
 756              	.LBB21:
 149:Src/util.c    **** }
 757              		.loc 1 149 5 view .LVU206
ARM GAS  /tmp/ccESV1n0.s 			page 21


 149:Src/util.c    **** }
 758              		.loc 1 149 28 is_stmt 0 view .LVU207
 759 008c 4FF09042 		mov	r2, #1207959552
 760 0090 D2F81434 		ldr	r3, [r2, #1044]
 761 0094 83F48073 		eor	r3, r3, #256
 762 0098 C2F81434 		str	r3, [r2, #1044]
 763              	.LVL54:
 149:Src/util.c    **** }
 764              		.loc 1 149 28 view .LVU208
 765              	.LBE21:
 766              	.LBE20:
 325:Src/util.c    ****         }
 326:Src/util.c    ****     #endif
 327:Src/util.c    **** 
 328:Src/util.c    ****     // Tx USART AUX
 329:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 330:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART0_TX_DMA_CH) == 0) {     // 
 331:Src/util.c    ****             AuxTx.start     = (uint16_t)SERIAL_START_FRAME;
 332:Src/util.c    ****             AuxTx.signal1   = (int16_t)sensor1;
 333:Src/util.c    ****             AuxTx.signal2   = (int16_t)sensor2;
 334:Src/util.c    ****             AuxTx.checksum  = (uint16_t)(AuxTx.start ^ AuxTx.signal1 ^ AuxTx.signal2);
 335:Src/util.c    ****         
 336:Src/util.c    ****             dma_channel_disable(USART0_TX_DMA_CH);
 337:Src/util.c    ****             DMA_CHCNT(USART0_TX_DMA_CH)     = sizeof(AuxTx);
 338:Src/util.c    ****             DMA_CHMADDR(USART0_TX_DMA_CH)   = (uint32_t)&AuxTx;
 339:Src/util.c    ****             dma_channel_enable(USART0_TX_DMA_CH);
 340:Src/util.c    ****         }
 341:Src/util.c    ****     #endif
 342:Src/util.c    ****     // Rx USART AUX
 343:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 344:Src/util.c    ****         #ifdef CONTROL_IBUS
 345:Src/util.c    ****         if (!timeoutFlagSerial0) {
 346:Src/util.c    ****             for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 347:Src/util.c    ****                 ibus_captured_value[(i/2)] = CLAMP(command.channels[i] + (command.channels[i+1] << 
 348:Src/util.c    ****             }
 349:Src/util.c    ****             cmd1        = (ibus_captured_value[0] - 500) * 2;                           // Channel 
 350:Src/util.c    ****             cmd2        = (ibus_captured_value[1] - 500) * 2;                           // Channel 
 351:Src/util.c    ****             cmdSwitch   = (uint16_t)(switch_check(ibus_captured_value[6],0)      |      // Channel 
 352:Src/util.c    ****                                      switch_check(ibus_captured_value[7],1) << 1 |      // Channel 
 353:Src/util.c    ****                                      switch_check(ibus_captured_value[8],1) << 3 |      // Channel 
 354:Src/util.c    ****                                      switch_check(ibus_captured_value[9],0) << 5);      // Channel 
 355:Src/util.c    ****         }
 356:Src/util.c    ****         #endif
 357:Src/util.c    **** 
 358:Src/util.c    ****         if (timeoutCntSerial0++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 359:Src/util.c    ****             timeoutFlagSerial0 = 1;                                 // Timeout detected
 360:Src/util.c    ****             timeoutCntSerial0  = SERIAL_TIMEOUT;                    // Limit timout counter value
 361:Src/util.c    ****             cmd1 = cmd2 = 0;                                        // Set commands to 0
 362:Src/util.c    ****             cmdSwitch &= ~(1U << 0);                                // Clear Bit 0, to switch to de
 363:Src/util.c    ****         }
 364:Src/util.c    ****         // if (timeoutFlagSerial0 && main_loop_counter % 100 == 0) {   // In case of timeout bring 
 365:Src/util.c    ****         //     toggle_led(LED2_GPIO_Port, LED2_Pin);                   // Toggle the Green LED ever
 366:Src/util.c    ****         // }
 367:Src/util.c    **** 
 368:Src/util.c    ****         #ifdef SERIAL_DEBUG
 369:Src/util.c    ****             // Print MPU data to Console
 370:Src/util.c    ****             if (main_loop_counter % 50 == 0) {
ARM GAS  /tmp/ccESV1n0.s 			page 22


 371:Src/util.c    ****                 aux_print_to_console();
 372:Src/util.c    ****             }
 373:Src/util.c    ****         #endif
 374:Src/util.c    ****     #endif
 375:Src/util.c    **** }
 767              		.loc 1 375 1 view .LVU209
 768 009c 02E0     		b	.L32
 769              	.L36:
 323:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 770              		.loc 1 323 9 is_stmt 1 view .LVU210
 323:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 771              		.loc 1 323 12 is_stmt 0 view .LVU211
 772 009e 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 773 00a0 002B     		cmp	r3, #0
 774 00a2 ECD1     		bne	.L37
 775              	.L32:
 776              		.loc 1 375 1 view .LVU212
 777 00a4 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 778              	.L41:
 779 00a6 00BF     		.align	2
 780              	.L40:
 781 00a8 00000000 		.word	main_loop_counter
 782 00ac CDCCCCCC 		.word	-858993459
 783 00b0 00000000 		.word	mpu
 784 00b4 00000000 		.word	.LANCHOR2
 785 00b8 00000000 		.word	.LANCHOR6
 786 00bc 00000000 		.word	.LANCHOR5
 787 00c0 00000000 		.word	.LANCHOR0
 788 00c4 00000240 		.word	1073872896
 789 00c8 00000000 		.word	.LANCHOR7
 790 00cc 00000000 		.word	.LANCHOR8
 791              		.cfi_endproc
 792              	.LFE66:
 794              		.section	.text.handle_leds,"ax",%progbits
 795              		.align	1
 796              		.global	handle_leds
 797              		.syntax unified
 798              		.thumb
 799              		.thumb_func
 800              		.fpu softvfp
 802              	handle_leds:
 803              	.LFB67:
 376:Src/util.c    **** 
 377:Src/util.c    **** /*
 378:Src/util.c    ****  * Handle of the sideboard LEDs
 379:Src/util.c    ****  */
 380:Src/util.c    **** void handle_leds(void) {
 804              		.loc 1 380 24 is_stmt 1 view -0
 805              		.cfi_startproc
 806              		@ args = 0, pretend = 0, frame = 0
 807              		@ frame_needed = 0, uses_anonymous_args = 0
 381:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 382:Src/util.c    ****         if (!timeoutFlagSerial1) {
 808              		.loc 1 382 9 view .LVU214
 380:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 809              		.loc 1 380 24 is_stmt 0 view .LVU215
 810 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/ccESV1n0.s 			page 23


 811              	.LCFI10:
 812              		.cfi_def_cfa_offset 8
 813              		.cfi_offset 4, -8
 814              		.cfi_offset 14, -4
 815              		.loc 1 382 13 view .LVU216
 816 0002 244B     		ldr	r3, .L55
 817              		.loc 1 382 12 view .LVU217
 818 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 819 0006 002B     		cmp	r3, #0
 820 0008 43D1     		bne	.L42
 383:Src/util.c    ****             if (Feedback.cmdLed & LED1_SET) { gpio_bit_set(LED1_GPIO_Port, LED1_Pin); } else { gpio
 821              		.loc 1 383 13 is_stmt 1 view .LVU218
 822              		.loc 1 383 25 is_stmt 0 view .LVU219
 823 000a 234C     		ldr	r4, .L55+4
 824              		.loc 1 383 47 view .LVU220
 825 000c 0121     		movs	r1, #1
 826              		.loc 1 383 16 view .LVU221
 827 000e E389     		ldrh	r3, [r4, #14]
 828              		.loc 1 383 47 view .LVU222
 829 0010 4FF09040 		mov	r0, #1207959552
 830              		.loc 1 383 16 view .LVU223
 831 0014 DA07     		lsls	r2, r3, #31
 832 0016 29D5     		bpl	.L44
 833              		.loc 1 383 47 is_stmt 1 discriminator 1 view .LVU224
 834 0018 FFF7FEFF 		bl	gpio_bit_set
 835              	.LVL55:
 836              	.L45:
 384:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 837              		.loc 1 384 13 view .LVU225
 838              		.loc 1 384 16 is_stmt 0 view .LVU226
 839 001c E389     		ldrh	r3, [r4, #14]
 840              		.loc 1 384 47 view .LVU227
 841 001e 4FF40071 		mov	r1, #512
 842              		.loc 1 384 16 view .LVU228
 843 0022 9B07     		lsls	r3, r3, #30
 844              		.loc 1 384 47 view .LVU229
 845 0024 1D48     		ldr	r0, .L55+8
 846              		.loc 1 384 16 view .LVU230
 847 0026 24D5     		bpl	.L46
 848              		.loc 1 384 47 is_stmt 1 discriminator 1 view .LVU231
 849 0028 FFF7FEFF 		bl	gpio_bit_set
 850              	.LVL56:
 851              	.L47:
 385:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 852              		.loc 1 385 13 view .LVU232
 853              		.loc 1 385 16 is_stmt 0 view .LVU233
 854 002c E389     		ldrh	r3, [r4, #14]
 855              		.loc 1 385 47 view .LVU234
 856 002e 4FF48071 		mov	r1, #256
 857              		.loc 1 385 16 view .LVU235
 858 0032 5A07     		lsls	r2, r3, #29
 859              		.loc 1 385 47 view .LVU236
 860 0034 1948     		ldr	r0, .L55+8
 861              		.loc 1 385 16 view .LVU237
 862 0036 1FD5     		bpl	.L48
 863              		.loc 1 385 47 is_stmt 1 discriminator 1 view .LVU238
 864 0038 FFF7FEFF 		bl	gpio_bit_set
ARM GAS  /tmp/ccESV1n0.s 			page 24


 865              	.LVL57:
 866              	.L49:
 386:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 867              		.loc 1 386 13 view .LVU239
 868              		.loc 1 386 16 is_stmt 0 view .LVU240
 869 003c E389     		ldrh	r3, [r4, #14]
 870              		.loc 1 386 47 view .LVU241
 871 003e 2021     		movs	r1, #32
 872              		.loc 1 386 16 view .LVU242
 873 0040 1B07     		lsls	r3, r3, #28
 874              		.loc 1 386 47 view .LVU243
 875 0042 1648     		ldr	r0, .L55+8
 876              		.loc 1 386 16 view .LVU244
 877 0044 1BD5     		bpl	.L50
 878              		.loc 1 386 47 is_stmt 1 discriminator 1 view .LVU245
 879 0046 FFF7FEFF 		bl	gpio_bit_set
 880              	.LVL58:
 881              	.L51:
 387:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 882              		.loc 1 387 13 view .LVU246
 883              		.loc 1 387 16 is_stmt 0 view .LVU247
 884 004a E389     		ldrh	r3, [r4, #14]
 885              		.loc 1 387 47 view .LVU248
 886 004c 1021     		movs	r1, #16
 887              		.loc 1 387 16 view .LVU249
 888 004e DA06     		lsls	r2, r3, #27
 889              		.loc 1 387 47 view .LVU250
 890 0050 1248     		ldr	r0, .L55+8
 891              		.loc 1 387 16 view .LVU251
 892 0052 17D5     		bpl	.L52
 893              		.loc 1 387 47 is_stmt 1 discriminator 1 view .LVU252
 894 0054 FFF7FEFF 		bl	gpio_bit_set
 895              	.LVL59:
 896              	.L53:
 388:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 897              		.loc 1 388 13 view .LVU253
 898              		.loc 1 388 16 is_stmt 0 view .LVU254
 899 0058 E389     		ldrh	r3, [r4, #14]
 900              		.loc 1 388 47 view .LVU255
 901 005a 4FF48061 		mov	r1, #1024
 902              		.loc 1 388 16 view .LVU256
 903 005e 1B07     		lsls	r3, r3, #28
 904              		.loc 1 388 47 view .LVU257
 905 0060 0E48     		ldr	r0, .L55+8
 906              		.loc 1 388 16 view .LVU258
 907 0062 12D5     		bpl	.L54
 908              		.loc 1 388 47 is_stmt 1 discriminator 1 view .LVU259
 389:Src/util.c    ****         }
 390:Src/util.c    ****     #endif
 391:Src/util.c    **** }
 909              		.loc 1 391 1 is_stmt 0 discriminator 1 view .LVU260
 910 0064 BDE81040 		pop	{r4, lr}
 911              	.LCFI11:
 912              		.cfi_remember_state
 913              		.cfi_restore 14
 914              		.cfi_restore 4
 915              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/ccESV1n0.s 			page 25


 388:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 916              		.loc 1 388 47 discriminator 1 view .LVU261
 917 0068 FFF7FEBF 		b	gpio_bit_set
 918              	.LVL60:
 919              	.L44:
 920              	.LCFI12:
 921              		.cfi_restore_state
 383:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 922              		.loc 1 383 96 is_stmt 1 discriminator 2 view .LVU262
 923 006c FFF7FEFF 		bl	gpio_bit_reset
 924              	.LVL61:
 925 0070 D4E7     		b	.L45
 926              	.L46:
 384:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 927              		.loc 1 384 96 discriminator 2 view .LVU263
 928 0072 FFF7FEFF 		bl	gpio_bit_reset
 929              	.LVL62:
 930 0076 D9E7     		b	.L47
 931              	.L48:
 385:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 932              		.loc 1 385 96 discriminator 2 view .LVU264
 933 0078 FFF7FEFF 		bl	gpio_bit_reset
 934              	.LVL63:
 935 007c DEE7     		b	.L49
 936              	.L50:
 386:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 937              		.loc 1 386 96 discriminator 2 view .LVU265
 938 007e FFF7FEFF 		bl	gpio_bit_reset
 939              	.LVL64:
 940 0082 E2E7     		b	.L51
 941              	.L52:
 387:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 942              		.loc 1 387 96 discriminator 2 view .LVU266
 943 0084 FFF7FEFF 		bl	gpio_bit_reset
 944              	.LVL65:
 945 0088 E6E7     		b	.L53
 946              	.L54:
 388:Src/util.c    ****         }
 947              		.loc 1 388 96 discriminator 2 view .LVU267
 948              		.loc 1 391 1 is_stmt 0 discriminator 2 view .LVU268
 949 008a BDE81040 		pop	{r4, lr}
 950              	.LCFI13:
 951              		.cfi_remember_state
 952              		.cfi_restore 14
 953              		.cfi_restore 4
 954              		.cfi_def_cfa_offset 0
 388:Src/util.c    ****         }
 955              		.loc 1 388 96 discriminator 2 view .LVU269
 956 008e FFF7FEBF 		b	gpio_bit_reset
 957              	.LVL66:
 958              	.L42:
 959              	.LCFI14:
 960              		.cfi_restore_state
 961              		.loc 1 391 1 view .LVU270
 962 0092 10BD     		pop	{r4, pc}
 963              	.L56:
 964              		.align	2
ARM GAS  /tmp/ccESV1n0.s 			page 26


 965              	.L55:
 966 0094 00000000 		.word	.LANCHOR8
 967 0098 00000000 		.word	.LANCHOR9
 968 009c 00040048 		.word	1207960576
 969              		.cfi_endproc
 970              	.LFE67:
 972              		.section	.text.usart_process_data,"ax",%progbits
 973              		.align	1
 974              		.global	usart_process_data
 975              		.syntax unified
 976              		.thumb
 977              		.thumb_func
 978              		.fpu softvfp
 980              	usart_process_data:
 981              	.LVL67:
 982              	.LFB69:
 392:Src/util.c    **** 
 393:Src/util.c    **** 
 394:Src/util.c    **** /* =========================== USART1 READ Functions =========================== */
 395:Src/util.c    **** 
 396:Src/util.c    **** void usart1_rx_check(void)
 397:Src/util.c    **** {
 398:Src/util.c    ****     #ifdef SERIAL_DEBUG
 399:Src/util.c    ****     static uint32_t old_pos;
 400:Src/util.c    ****     uint32_t pos;
 401:Src/util.c    **** 
 402:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 403:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 404:Src/util.c    ****         if (pos > old_pos) {                                                    // "Linear" buffer 
 405:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], pos - old_pos);           // Process data
 406:Src/util.c    ****         } else {                                                                // "Overflow" buffe
 407:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], rx1_buffer_len - old_pos);// First Process da
 408:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 409:Src/util.c    ****                 usart_process_debug(&rx1_buffer[0], pos);                       // Process remainin
 410:Src/util.c    ****             }
 411:Src/util.c    ****         }
 412:Src/util.c    ****     }
 413:Src/util.c    ****     old_pos = pos;                                                              // Update old posit
 414:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 415:Src/util.c    ****         old_pos = 0;
 416:Src/util.c    ****     }
 417:Src/util.c    ****     #endif // SERIAL_DEBUG
 418:Src/util.c    **** 
 419:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 420:Src/util.c    ****     static uint32_t old_pos;
 421:Src/util.c    ****     uint32_t pos;
 422:Src/util.c    ****     uint8_t *ptr;
 423:Src/util.c    **** 
 424:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 425:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 426:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 427:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 428:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 429:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 430:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 431:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 432:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
ARM GAS  /tmp/ccESV1n0.s 			page 27


 433:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 434:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 435:Src/util.c    ****             }
 436:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 437:Src/util.c    ****         }
 438:Src/util.c    ****     }
 439:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 440:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 441:Src/util.c    ****         old_pos = 0;
 442:Src/util.c    ****     }
 443:Src/util.c    ****     #endif // SERIAL_FEEDBACK
 444:Src/util.c    **** }
 445:Src/util.c    **** 
 446:Src/util.c    **** /*
 447:Src/util.c    ****  * Process Rx debug user command input
 448:Src/util.c    ****  */
 449:Src/util.c    **** #ifdef SERIAL_DEBUG
 450:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
 451:Src/util.c    **** {
 452:Src/util.c    ****     for (; len > 0; len--, userCommand++) {
 453:Src/util.c    ****         if (*userCommand != '\n' && *userCommand != '\r') {     // Do not accept 'new line' and 'ca
 454:Src/util.c    ****             log_i("Command = %c\r\n", *userCommand);
 455:Src/util.c    ****             mpu_handle_input(*userCommand);
 456:Src/util.c    ****         }
 457:Src/util.c    ****     }
 458:Src/util.c    **** }
 459:Src/util.c    **** #endif // SERIAL_DEBUG
 460:Src/util.c    **** 
 461:Src/util.c    **** /*
 462:Src/util.c    ****  * Process Rx data
 463:Src/util.c    ****  * - if the Feedback_in data is valid (correct START_FRAME and checksum) copy the Feedback_in to Fe
 464:Src/util.c    ****  */
 465:Src/util.c    **** #ifdef SERIAL_FEEDBACK
 466:Src/util.c    **** void usart_process_data(SerialFeedback *Feedback_in, SerialFeedback *Feedback_out)
 467:Src/util.c    **** {
 983              		.loc 1 467 1 is_stmt 1 view -0
 984              		.cfi_startproc
 985              		@ args = 0, pretend = 0, frame = 0
 986              		@ frame_needed = 0, uses_anonymous_args = 0
 468:Src/util.c    ****     uint16_t checksum;
 987              		.loc 1 468 5 view .LVU272
 469:Src/util.c    ****     if (Feedback_in->start == SERIAL_START_FRAME) {
 988              		.loc 1 469 5 view .LVU273
 989              		.loc 1 469 8 is_stmt 0 view .LVU274
 990 0000 4AF6CD33 		movw	r3, #43981
 991 0004 0288     		ldrh	r2, [r0]
 467:Src/util.c    ****     uint16_t checksum;
 992              		.loc 1 467 1 view .LVU275
 993 0006 10B5     		push	{r4, lr}
 994              	.LCFI15:
 995              		.cfi_def_cfa_offset 8
 996              		.cfi_offset 4, -8
 997              		.cfi_offset 14, -4
 998              		.loc 1 469 8 view .LVU276
 999 0008 9A42     		cmp	r2, r3
 1000 000a 20D1     		bne	.L57
 1001              	.LVL68:
ARM GAS  /tmp/ccESV1n0.s 			page 28


 1002              	.LBB24:
 1003              	.LBI24:
 466:Src/util.c    **** {
 1004              		.loc 1 466 6 is_stmt 1 view .LVU277
 1005              	.LBB25:
 470:Src/util.c    ****         checksum = (uint16_t)(Feedback_in->start ^ Feedback_in->cmd1 ^ Feedback_in->cmd2 ^ Feedback
 1006              		.loc 1 470 9 view .LVU278
 471:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 472:Src/util.c    ****         if (Feedback_in->checksum == checksum) {
 1007              		.loc 1 472 9 view .LVU279
 471:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 1008              		.loc 1 471 80 is_stmt 0 view .LVU280
 1009 000c 8488     		ldrh	r4, [r0, #4]
 1010 000e 4388     		ldrh	r3, [r0, #2]
 1011 0010 6340     		eors	r3, r3, r4
 1012 0012 C489     		ldrh	r4, [r0, #14]
 1013 0014 6340     		eors	r3, r3, r4
 1014 0016 C488     		ldrh	r4, [r0, #6]
 1015 0018 6340     		eors	r3, r3, r4
 1016 001a 0489     		ldrh	r4, [r0, #8]
 1017 001c 6340     		eors	r3, r3, r4
 1018 001e 4489     		ldrh	r4, [r0, #10]
 1019 0020 6340     		eors	r3, r3, r4
 1020 0022 8489     		ldrh	r4, [r0, #12]
 1021 0024 6340     		eors	r3, r3, r4
 1022 0026 5A40     		eors	r2, r2, r3
 1023              		.loc 1 472 12 view .LVU281
 1024 0028 038A     		ldrh	r3, [r0, #16]
 1025 002a 92B2     		uxth	r2, r2
 1026 002c 9342     		cmp	r3, r2
 1027 002e 0ED1     		bne	.L57
 473:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1028              		.loc 1 473 13 is_stmt 1 view .LVU282
 1029              		.loc 1 473 27 is_stmt 0 view .LVU283
 1030 0030 00F11003 		add	r3, r0, #16
 1031              	.LVL69:
 1032              	.L59:
 1033              		.loc 1 473 27 view .LVU284
 1034 0034 50F8042B 		ldr	r2, [r0], #4	@ unaligned
 1035 0038 9842     		cmp	r0, r3
 1036 003a 41F8042B 		str	r2, [r1], #4	@ unaligned
 1037 003e F9D1     		bne	.L59
 1038 0040 0388     		ldrh	r3, [r0]	@ unaligned
 1039              	.LVL70:
 474:Src/util.c    ****             timeoutCntSerial1  = 0;     // Reset timeout counter
 1040              		.loc 1 474 32 view .LVU285
 1041 0042 034A     		ldr	r2, .L61
 473:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1042              		.loc 1 473 27 view .LVU286
 1043 0044 0B80     		strh	r3, [r1]	@ unaligned
 1044              		.loc 1 474 13 is_stmt 1 view .LVU287
 1045              		.loc 1 474 32 is_stmt 0 view .LVU288
 1046 0046 0023     		movs	r3, #0
 1047 0048 1380     		strh	r3, [r2]	@ movhi
 475:Src/util.c    ****             timeoutFlagSerial1 = 0;     // Clear timeout flag
 1048              		.loc 1 475 13 is_stmt 1 view .LVU289
 1049              		.loc 1 475 32 is_stmt 0 view .LVU290
ARM GAS  /tmp/ccESV1n0.s 			page 29


 1050 004a 024A     		ldr	r2, .L61+4
 1051 004c 1370     		strb	r3, [r2]
 1052              	.LVL71:
 1053              	.L57:
 1054              		.loc 1 475 32 view .LVU291
 1055              	.LBE25:
 1056              	.LBE24:
 476:Src/util.c    ****         }
 477:Src/util.c    ****     }
 478:Src/util.c    **** }
 1057              		.loc 1 478 1 view .LVU292
 1058 004e 10BD     		pop	{r4, pc}
 1059              	.L62:
 1060              		.align	2
 1061              	.L61:
 1062 0050 00000000 		.word	.LANCHOR7
 1063 0054 00000000 		.word	.LANCHOR8
 1064              		.cfi_endproc
 1065              	.LFE69:
 1067              		.section	.text.usart1_rx_check,"ax",%progbits
 1068              		.align	1
 1069              		.global	usart1_rx_check
 1070              		.syntax unified
 1071              		.thumb
 1072              		.thumb_func
 1073              		.fpu softvfp
 1075              	usart1_rx_check:
 1076              	.LFB68:
 397:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1077              		.loc 1 397 1 is_stmt 1 view -0
 1078              		.cfi_startproc
 1079              		@ args = 0, pretend = 0, frame = 0
 1080              		@ frame_needed = 0, uses_anonymous_args = 0
 420:Src/util.c    ****     uint32_t pos;
 1081              		.loc 1 420 5 view .LVU294
 421:Src/util.c    ****     uint8_t *ptr;
 1082              		.loc 1 421 5 view .LVU295
 422:Src/util.c    **** 
 1083              		.loc 1 422 5 view .LVU296
 424:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1084              		.loc 1 424 5 view .LVU297
 397:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1085              		.loc 1 397 1 is_stmt 0 view .LVU298
 1086 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1087              	.LCFI16:
 1088              		.cfi_def_cfa_offset 24
 1089              		.cfi_offset 3, -24
 1090              		.cfi_offset 4, -20
 1091              		.cfi_offset 5, -16
 1092              		.cfi_offset 6, -12
 1093              		.cfi_offset 7, -8
 1094              		.cfi_offset 14, -4
 424:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1095              		.loc 1 424 28 view .LVU299
 1096 0002 0420     		movs	r0, #4
 1097 0004 FFF7FEFF 		bl	dma_transfer_number_get
 1098              	.LVL72:
ARM GAS  /tmp/ccESV1n0.s 			page 30


 425:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1099              		.loc 1 425 13 view .LVU300
 1100 0008 1A4D     		ldr	r5, .L74
 424:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1101              		.loc 1 424 9 view .LVU301
 1102 000a C0F14004 		rsb	r4, r0, #64
 1103              	.LVL73:
 425:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1104              		.loc 1 425 5 is_stmt 1 view .LVU302
 425:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1105              		.loc 1 425 13 is_stmt 0 view .LVU303
 1106 000e 2968     		ldr	r1, [r5]
 425:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1107              		.loc 1 425 8 view .LVU304
 1108 0010 A142     		cmp	r1, r4
 1109 0012 14D0     		beq	.L64
 426:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 1110              		.loc 1 426 9 is_stmt 1 view .LVU305
 1111              	.LVL74:
 427:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1112              		.loc 1 427 9 view .LVU306
 427:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1113              		.loc 1 427 12 is_stmt 0 view .LVU307
 1114 0014 19D2     		bcs	.L65
 427:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1115              		.loc 1 427 35 discriminator 1 view .LVU308
 1116 0016 631A     		subs	r3, r4, r1
 427:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1117              		.loc 1 427 27 discriminator 1 view .LVU309
 1118 0018 122B     		cmp	r3, #18
 1119 001a 16D1     		bne	.L65
 428:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1120              		.loc 1 428 13 is_stmt 1 view .LVU310
 428:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1121              		.loc 1 428 25 is_stmt 0 view .LVU311
 1122 001c 164B     		ldr	r3, .L74+4
 1123 001e 1944     		add	r1, r1, r3
 428:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1124              		.loc 1 428 13 view .LVU312
 1125 0020 164B     		ldr	r3, .L74+8
 1126 0022 01F11002 		add	r2, r1, #16
 1127              	.L66:
 1128 0026 51F8040B 		ldr	r0, [r1], #4	@ unaligned
 1129 002a 9142     		cmp	r1, r2
 1130 002c 43F8040B 		str	r0, [r3], #4	@ unaligned
 1131 0030 F9D1     		bne	.L66
 1132 0032 0A88     		ldrh	r2, [r1]	@ unaligned
 1133 0034 1A80     		strh	r2, [r3]	@ unaligned
 429:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 1134              		.loc 1 429 13 is_stmt 1 view .LVU313
 1135              	.LVL75:
 1136              	.L67:
 436:Src/util.c    ****         }
 1137              		.loc 1 436 13 view .LVU314
 1138 0036 1249     		ldr	r1, .L74+12
 1139 0038 1048     		ldr	r0, .L74+8
 1140 003a FFF7FEFF 		bl	usart_process_data
ARM GAS  /tmp/ccESV1n0.s 			page 31


 1141              	.LVL76:
 1142              	.L64:
 439:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1143              		.loc 1 439 5 view .LVU315
 440:Src/util.c    ****         old_pos = 0;
 1144              		.loc 1 440 5 view .LVU316
 440:Src/util.c    ****         old_pos = 0;
 1145              		.loc 1 440 8 is_stmt 0 view .LVU317
 1146 003e 402C     		cmp	r4, #64
 441:Src/util.c    ****     }
 1147              		.loc 1 441 17 view .LVU318
 1148 0040 0ABF     		itet	eq
 1149 0042 0023     		moveq	r3, #0
 439:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1150              		.loc 1 439 13 view .LVU319
 1151 0044 2C60     		strne	r4, [r5]
 441:Src/util.c    ****     }
 1152              		.loc 1 441 9 is_stmt 1 view .LVU320
 441:Src/util.c    ****     }
 1153              		.loc 1 441 17 is_stmt 0 view .LVU321
 1154 0046 2B60     		streq	r3, [r5]
 444:Src/util.c    **** 
 1155              		.loc 1 444 1 view .LVU322
 1156 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1157              	.LVL77:
 1158              	.L65:
 430:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1159              		.loc 1 430 16 is_stmt 1 view .LVU323
 430:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1160              		.loc 1 430 36 is_stmt 0 view .LVU324
 1161 004a C1F14006 		rsb	r6, r1, #64
 430:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1162              		.loc 1 430 46 view .LVU325
 1163 004e 3319     		adds	r3, r6, r4
 430:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1164              		.loc 1 430 19 view .LVU326
 1165 0050 122B     		cmp	r3, #18
 1166 0052 F4D1     		bne	.L64
 431:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1167              		.loc 1 431 13 is_stmt 1 view .LVU327
 1168 0054 094B     		ldr	r3, .L74+8
 431:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1169              		.loc 1 431 25 is_stmt 0 view .LVU328
 1170 0056 084F     		ldr	r7, .L74+4
 431:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1171              		.loc 1 431 13 view .LVU329
 1172 0058 3246     		mov	r2, r6
 1173 005a 1846     		mov	r0, r3
 1174 005c 3944     		add	r1, r1, r7
 1175 005e FFF7FEFF 		bl	memcpy
 1176              	.LVL78:
 432:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1177              		.loc 1 432 13 is_stmt 1 view .LVU330
 432:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1178              		.loc 1 432 16 is_stmt 0 view .LVU331
 1179 0062 002C     		cmp	r4, #0
 1180 0064 E7D0     		beq	.L67
ARM GAS  /tmp/ccESV1n0.s 			page 32


 433:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 1181              		.loc 1 433 17 is_stmt 1 view .LVU332
 1182              	.LVL79:
 434:Src/util.c    ****             }
 1183              		.loc 1 434 17 view .LVU333
 1184 0066 2246     		mov	r2, r4
 1185 0068 3946     		mov	r1, r7
 1186 006a 3044     		add	r0, r0, r6
 1187 006c FFF7FEFF 		bl	memcpy
 1188              	.LVL80:
 1189 0070 E1E7     		b	.L67
 1190              	.L75:
 1191 0072 00BF     		.align	2
 1192              	.L74:
 1193 0074 00000000 		.word	.LANCHOR10
 1194 0078 00000000 		.word	.LANCHOR1
 1195 007c 00000000 		.word	.LANCHOR11
 1196 0080 00000000 		.word	.LANCHOR9
 1197              		.cfi_endproc
 1198              	.LFE68:
 1200              		.section	.text.usart0_rx_check,"ax",%progbits
 1201              		.align	1
 1202              		.global	usart0_rx_check
 1203              		.syntax unified
 1204              		.thumb
 1205              		.thumb_func
 1206              		.fpu softvfp
 1208              	usart0_rx_check:
 1209              	.LFB70:
 479:Src/util.c    **** #endif // SERIAL_FEEDBACK
 480:Src/util.c    **** 
 481:Src/util.c    **** 
 482:Src/util.c    **** /* =========================== USART0 READ Functions =========================== */
 483:Src/util.c    **** 
 484:Src/util.c    **** /*
 485:Src/util.c    ****  * Check for new data received on USART with DMA: refactored function from https://github.com/MaJer
 486:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 487:Src/util.c    ****  */
 488:Src/util.c    **** void usart0_rx_check(void)
 489:Src/util.c    **** {
 1210              		.loc 1 489 1 view -0
 1211              		.cfi_startproc
 1212              		@ args = 0, pretend = 0, frame = 0
 1213              		@ frame_needed = 0, uses_anonymous_args = 0
 1214              		@ link register save eliminated.
 490:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 491:Src/util.c    ****     static uint32_t old_pos;
 492:Src/util.c    ****     uint32_t pos;
 493:Src/util.c    ****     uint8_t *ptr;
 494:Src/util.c    **** 
 495:Src/util.c    ****     pos = rx0_buffer_len - dma_transfer_number_get(USART0_RX_DMA_CH);           // Calculate curren
 496:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 497:Src/util.c    ****         ptr = (uint8_t *)&command_raw;                                          // Initialize the p
 498:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == command_len) {                  // "Linear" buffer 
 499:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], command_len);                     // Copy data. This 
 500:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 501:Src/util.c    ****         } else if ((rx0_buffer_len - old_pos + pos) == command_len) {           // "Overflow" buffe
ARM GAS  /tmp/ccESV1n0.s 			page 33


 502:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], rx0_buffer_len - old_pos);        // First copy data 
 503:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 504:Src/util.c    ****                 ptr += rx0_buffer_len - old_pos;                                // Update position
 505:Src/util.c    ****                 memcpy(ptr, &rx0_buffer[0], pos);                               // Copy remaining d
 506:Src/util.c    ****             }
 507:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 508:Src/util.c    ****         }
 509:Src/util.c    ****     }
 510:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 511:Src/util.c    ****     if (old_pos == rx0_buffer_len) {                                            // Check and manual
 512:Src/util.c    ****         old_pos = 0;
 513:Src/util.c    ****     }
 514:Src/util.c    ****     #endif  // SERIAL_AUX_RX
 515:Src/util.c    **** }
 1215              		.loc 1 515 1 view .LVU335
 1216 0000 7047     		bx	lr
 1217              		.cfi_endproc
 1218              	.LFE70:
 1220              		.section	.text.aux_print_to_console,"ax",%progbits
 1221              		.align	1
 1222              		.global	aux_print_to_console
 1223              		.syntax unified
 1224              		.thumb
 1225              		.thumb_func
 1226              		.fpu softvfp
 1228              	aux_print_to_console:
 1229              	.LFB80:
 1230              		.cfi_startproc
 1231              		@ args = 0, pretend = 0, frame = 0
 1232              		@ frame_needed = 0, uses_anonymous_args = 0
 1233              		@ link register save eliminated.
 1234 0000 7047     		bx	lr
 1235              		.cfi_endproc
 1236              	.LFE80:
 1238              		.section	.text.i2c_writeBytes,"ax",%progbits
 1239              		.align	1
 1240              		.global	i2c_writeBytes
 1241              		.syntax unified
 1242              		.thumb
 1243              		.thumb_func
 1244              		.fpu softvfp
 1246              	i2c_writeBytes:
 1247              	.LVL81:
 1248              	.LFB72:
 516:Src/util.c    **** 
 517:Src/util.c    **** /*
 518:Src/util.c    ****  * Process command UART0 Rx data
 519:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
 520:Src/util.c    ****  */
 521:Src/util.c    **** #ifdef SERIAL_AUX_RX
 522:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out)
 523:Src/util.c    **** {
 524:Src/util.c    ****   #ifdef CONTROL_IBUS
 525:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
 526:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
 527:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
 528:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
ARM GAS  /tmp/ccESV1n0.s 			page 34


 529:Src/util.c    ****       }
 530:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
 531:Src/util.c    ****         *command_out = *command_in;
 532:Src/util.c    ****         timeoutCntSerial0  = 0;        // Reset timeout counter
 533:Src/util.c    ****         timeoutFlagSerial0 = 0;        // Clear timeout flag
 534:Src/util.c    ****       }
 535:Src/util.c    ****     }
 536:Src/util.c    ****   #endif
 537:Src/util.c    **** }
 538:Src/util.c    **** #endif
 539:Src/util.c    **** 
 540:Src/util.c    **** 
 541:Src/util.c    **** /* =========================== AUX Serial Print data =========================== */
 542:Src/util.c    **** 
 543:Src/util.c    **** void aux_print_to_console(void)
 544:Src/util.c    **** {
 545:Src/util.c    **** #if defined(SERIAL_DEBUG) && defined(SERIAL_AUX_RX)
 546:Src/util.c    ****     #ifdef CONTROL_IBUS
 547:Src/util.c    ****     if (print_aux & PRINT_AUX) {
 548:Src/util.c    ****         log_i( "Ch1: %d Ch2: %d Sw: %u\r\n", cmd1, cmd2, cmdSwitch);
 549:Src/util.c    ****     }
 550:Src/util.c    ****     #endif
 551:Src/util.c    **** #endif
 552:Src/util.c    **** }
 553:Src/util.c    **** 
 554:Src/util.c    **** 
 555:Src/util.c    **** /* =========================== I2C WRITE Functions =========================== */
 556:Src/util.c    **** 
 557:Src/util.c    **** /*
 558:Src/util.c    ****  * write bytes to chip register
 559:Src/util.c    ****  */
 560:Src/util.c    **** int8_t i2c_writeBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data)
 561:Src/util.c    **** {
 1249              		.loc 1 561 1 view -0
 1250              		.cfi_startproc
 1251              		@ args = 0, pretend = 0, frame = 0
 1252              		@ frame_needed = 0, uses_anonymous_args = 0
 562:Src/util.c    **** 
 563:Src/util.c    ****     // assign WRITE command
 564:Src/util.c    ****     i2c_ReadWriteCmd    = WRITE;
 1253              		.loc 1 564 5 view .LVU337
 561:Src/util.c    **** 
 1254              		.loc 1 561 1 is_stmt 0 view .LVU338
 1255 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1256              	.LCFI17:
 1257              		.cfi_def_cfa_offset 24
 1258              		.cfi_offset 4, -24
 1259              		.cfi_offset 5, -20
 1260              		.cfi_offset 6, -16
 1261              		.cfi_offset 7, -12
 1262              		.cfi_offset 8, -8
 1263              		.cfi_offset 14, -4
 1264              		.loc 1 564 25 view .LVU339
 1265 0004 0124     		movs	r4, #1
 565:Src/util.c    **** 
 566:Src/util.c    ****     // assign inputs
 567:Src/util.c    ****     i2c_status          = -1;
ARM GAS  /tmp/ccESV1n0.s 			page 35


 1266              		.loc 1 567 25 view .LVU340
 1267 0006 FF26     		movs	r6, #255
 564:Src/util.c    **** 
 1268              		.loc 1 564 25 view .LVU341
 1269 0008 184D     		ldr	r5, .L91
 568:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1270              		.loc 1 568 37 view .LVU342
 1271 000a A040     		lsls	r0, r0, r4
 1272              	.LVL82:
 564:Src/util.c    **** 
 1273              		.loc 1 564 25 view .LVU343
 1274 000c 2C70     		strb	r4, [r5]
 567:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1275              		.loc 1 567 5 is_stmt 1 view .LVU344
 567:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1276              		.loc 1 567 25 is_stmt 0 view .LVU345
 1277 000e 184D     		ldr	r5, .L91+4
 1278              		.loc 1 568 37 view .LVU346
 1279 0010 C0B2     		uxtb	r0, r0
 567:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1280              		.loc 1 567 25 view .LVU347
 1281 0012 2E70     		strb	r6, [r5]
 1282              		.loc 1 568 5 is_stmt 1 view .LVU348
 1283              		.loc 1 568 25 is_stmt 0 view .LVU349
 1284 0014 174E     		ldr	r6, .L91+8
 569:Src/util.c    ****     i2c_regAddress      = regAddr;
 570:Src/util.c    ****     i2c_txbuffer        = data;
 571:Src/util.c    ****     i2c_nDABytes        = length;
 572:Src/util.c    ****     i2c_nRABytes        = 1;
 573:Src/util.c    **** 
 574:Src/util.c    ****     uint16_t i2c_timeout = 0;
 575:Src/util.c    **** 
 576:Src/util.c    ****     // enable the I2C0 interrupt
 577:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 578:Src/util.c    **** 
 579:Src/util.c    ****     // the master waits until the I2C bus is idle
 580:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1285              		.loc 1 580 11 view .LVU350
 1286 0016 184F     		ldr	r7, .L91+12
 568:Src/util.c    ****     i2c_regAddress      = regAddr;
 1287              		.loc 1 568 25 view .LVU351
 1288 0018 3070     		strb	r0, [r6]
 569:Src/util.c    ****     i2c_regAddress      = regAddr;
 1289              		.loc 1 569 5 is_stmt 1 view .LVU352
 569:Src/util.c    ****     i2c_regAddress      = regAddr;
 1290              		.loc 1 569 25 is_stmt 0 view .LVU353
 1291 001a 1848     		ldr	r0, .L91+16
 571:Src/util.c    ****     i2c_nRABytes        = 1;
 1292              		.loc 1 571 25 view .LVU354
 1293 001c 184E     		ldr	r6, .L91+20
 569:Src/util.c    ****     i2c_regAddress      = regAddr;
 1294              		.loc 1 569 25 view .LVU355
 1295 001e 0170     		strb	r1, [r0]
 570:Src/util.c    ****     i2c_nDABytes        = length;
 1296              		.loc 1 570 5 is_stmt 1 view .LVU356
 570:Src/util.c    ****     i2c_nDABytes        = length;
 1297              		.loc 1 570 25 is_stmt 0 view .LVU357
ARM GAS  /tmp/ccESV1n0.s 			page 36


 1298 0020 1849     		ldr	r1, .L91+24
 1299              	.LVL83:
 577:Src/util.c    **** 
 1300              		.loc 1 577 5 view .LVU358
 1301 0022 1948     		ldr	r0, .L91+28
 570:Src/util.c    ****     i2c_nDABytes        = length;
 1302              		.loc 1 570 25 view .LVU359
 1303 0024 0B60     		str	r3, [r1]
 571:Src/util.c    ****     i2c_nRABytes        = 1;
 1304              		.loc 1 571 5 is_stmt 1 view .LVU360
 572:Src/util.c    **** 
 1305              		.loc 1 572 25 is_stmt 0 view .LVU361
 1306 0026 194B     		ldr	r3, .L91+32
 1307              	.LVL84:
 577:Src/util.c    **** 
 1308              		.loc 1 577 5 view .LVU362
 1309 0028 4FF4E061 		mov	r1, #1792
 571:Src/util.c    ****     i2c_nRABytes        = 1;
 1310              		.loc 1 571 25 view .LVU363
 1311 002c 3270     		strb	r2, [r6]
 1312              	.LVL85:
 572:Src/util.c    **** 
 1313              		.loc 1 572 5 is_stmt 1 view .LVU364
 572:Src/util.c    **** 
 1314              		.loc 1 572 25 is_stmt 0 view .LVU365
 1315 002e 1C70     		strb	r4, [r3]
 574:Src/util.c    **** 
 1316              		.loc 1 574 5 is_stmt 1 view .LVU366
 1317              	.LVL86:
 577:Src/util.c    **** 
 1318              		.loc 1 577 5 view .LVU367
 1319 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1320              	.LVL87:
 1321              		.loc 1 580 5 view .LVU368
 1322              		.loc 1 580 10 is_stmt 0 view .LVU369
 1323 0034 44F62164 		movw	r4, #20001
 1324              		.loc 1 580 11 view .LVU370
 1325 0038 DFF84C80 		ldr	r8, .L91+28
 1326              	.LVL88:
 1327              	.L80:
 1328              		.loc 1 580 75 is_stmt 1 discriminator 2 view .LVU371
 1329              		.loc 1 580 10 discriminator 2 view .LVU372
 1330              		.loc 1 580 11 is_stmt 0 discriminator 2 view .LVU373
 1331 003c 3946     		mov	r1, r7
 1332 003e 4046     		mov	r0, r8
 1333 0040 FFF7FEFF 		bl	i2c_flag_get
 1334              	.LVL89:
 1335              		.loc 1 580 10 discriminator 2 view .LVU374
 1336 0044 18B1     		cbz	r0, .L79
 1337              	.LVL90:
 1338              		.loc 1 580 50 discriminator 1 view .LVU375
 1339 0046 013C     		subs	r4, r4, #1
 1340              	.LVL91:
 1341              		.loc 1 580 50 discriminator 1 view .LVU376
 1342 0048 A4B2     		uxth	r4, r4
 1343 004a 002C     		cmp	r4, #0
 1344 004c F6D1     		bne	.L80
ARM GAS  /tmp/ccESV1n0.s 			page 37


 1345              	.L79:
 581:Src/util.c    **** 
 582:Src/util.c    ****     // the master sends a start condition to I2C bus
 583:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1346              		.loc 1 583 5 is_stmt 1 view .LVU377
 1347 004e 0E48     		ldr	r0, .L91+28
 1348 0050 FFF7FEFF 		bl	i2c_start_on_bus
 1349              	.LVL92:
 584:Src/util.c    ****     
 585:Src/util.c    ****     // Wait until all data bytes are sent/received
 586:Src/util.c    ****     i2c_timeout = 0;
 1350              		.loc 1 586 5 view .LVU378
 587:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1351              		.loc 1 587 5 view .LVU379
 1352              		.loc 1 587 10 is_stmt 0 view .LVU380
 1353 0054 44F62163 		movw	r3, #20001
 1354              	.LVL93:
 1355              	.L82:
 1356              		.loc 1 587 53 is_stmt 1 discriminator 2 view .LVU381
 1357              		.loc 1 587 10 discriminator 2 view .LVU382
 1358              		.loc 1 587 24 is_stmt 0 discriminator 2 view .LVU383
 1359 0058 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1360              		.loc 1 587 10 discriminator 2 view .LVU384
 1361 005a 1AB1     		cbz	r2, .L81
 1362              	.LVL94:
 1363              		.loc 1 587 28 discriminator 1 view .LVU385
 1364 005c 013B     		subs	r3, r3, #1
 1365              	.LVL95:
 1366              		.loc 1 587 28 discriminator 1 view .LVU386
 1367 005e 9BB2     		uxth	r3, r3
 1368 0060 002B     		cmp	r3, #0
 1369 0062 F9D1     		bne	.L82
 1370              	.L81:
 588:Src/util.c    **** 
 589:Src/util.c    ****     return i2c_status;
 1371              		.loc 1 589 5 is_stmt 1 view .LVU387
 1372              		.loc 1 589 12 is_stmt 0 view .LVU388
 1373 0064 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 590:Src/util.c    **** 
 591:Src/util.c    **** }
 1374              		.loc 1 591 1 view .LVU389
 1375 0066 40B2     		sxtb	r0, r0
 1376 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1377              	.L92:
 1378              		.align	2
 1379              	.L91:
 1380 006c 00000000 		.word	.LANCHOR12
 1381 0070 00000000 		.word	.LANCHOR13
 1382 0074 00000000 		.word	.LANCHOR14
 1383 0078 02000080 		.word	-2147483646
 1384 007c 00000000 		.word	.LANCHOR15
 1385 0080 00000000 		.word	.LANCHOR17
 1386 0084 00000000 		.word	.LANCHOR16
 1387 0088 00540040 		.word	1073763328
 1388 008c 00000000 		.word	.LANCHOR18
 1389              		.cfi_endproc
 1390              	.LFE72:
ARM GAS  /tmp/ccESV1n0.s 			page 38


 1392              		.section	.text.i2c_writeByte,"ax",%progbits
 1393              		.align	1
 1394              		.global	i2c_writeByte
 1395              		.syntax unified
 1396              		.thumb
 1397              		.thumb_func
 1398              		.fpu softvfp
 1400              	i2c_writeByte:
 1401              	.LVL96:
 1402              	.LFB73:
 592:Src/util.c    **** 
 593:Src/util.c    **** 
 594:Src/util.c    **** /*
 595:Src/util.c    ****  * write 1 byte to chip register
 596:Src/util.c    ****  */
 597:Src/util.c    **** int8_t i2c_writeByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t data)
 598:Src/util.c    **** {
 1403              		.loc 1 598 1 is_stmt 1 view -0
 1404              		.cfi_startproc
 1405              		@ args = 0, pretend = 0, frame = 8
 1406              		@ frame_needed = 0, uses_anonymous_args = 0
 599:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1407              		.loc 1 599 5 view .LVU391
 598:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1408              		.loc 1 598 1 is_stmt 0 view .LVU392
 1409 0000 07B5     		push	{r0, r1, r2, lr}
 1410              	.LCFI18:
 1411              		.cfi_def_cfa_offset 16
 1412              		.cfi_offset 14, -4
 598:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1413              		.loc 1 598 1 view .LVU393
 1414 0002 8DF80720 		strb	r2, [sp, #7]
 1415              		.loc 1 599 12 view .LVU394
 1416 0006 0DF10703 		add	r3, sp, #7
 1417 000a 0122     		movs	r2, #1
 1418              	.LVL97:
 1419              		.loc 1 599 12 view .LVU395
 1420 000c FFF7FEFF 		bl	i2c_writeBytes
 1421              	.LVL98:
 600:Src/util.c    **** }
 1422              		.loc 1 600 1 view .LVU396
 1423 0010 03B0     		add	sp, sp, #12
 1424              	.LCFI19:
 1425              		.cfi_def_cfa_offset 4
 1426              		@ sp needed
 1427 0012 5DF804FB 		ldr	pc, [sp], #4
 1428              		.cfi_endproc
 1429              	.LFE73:
 1431              		.section	.text.i2c_readBytes,"ax",%progbits
 1432              		.align	1
 1433              		.global	i2c_readBytes
 1434              		.syntax unified
 1435              		.thumb
 1436              		.thumb_func
 1437              		.fpu softvfp
 1439              	i2c_readBytes:
 1440              	.LVL99:
ARM GAS  /tmp/ccESV1n0.s 			page 39


 1441              	.LFB75:
 601:Src/util.c    **** 
 602:Src/util.c    **** 
 603:Src/util.c    **** /*
 604:Src/util.c    ****  * write one bit to chip register
 605:Src/util.c    ****  */
 606:Src/util.c    **** int8_t i2c_writeBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 607:Src/util.c    ****     uint8_t b;
 608:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 609:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 610:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 611:Src/util.c    **** }
 612:Src/util.c    **** 
 613:Src/util.c    **** 
 614:Src/util.c    **** 
 615:Src/util.c    **** /* =========================== I2C READ Functions =========================== */
 616:Src/util.c    **** 
 617:Src/util.c    **** /*
 618:Src/util.c    ****  * read bytes from chip register
 619:Src/util.c    ****  */
 620:Src/util.c    **** int8_t i2c_readBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data) 
 621:Src/util.c    **** {
 1442              		.loc 1 621 1 is_stmt 1 view -0
 1443              		.cfi_startproc
 1444              		@ args = 0, pretend = 0, frame = 0
 1445              		@ frame_needed = 0, uses_anonymous_args = 0
 622:Src/util.c    **** 
 623:Src/util.c    ****     // assign READ command
 624:Src/util.c    ****     i2c_ReadWriteCmd    = READ;
 1446              		.loc 1 624 5 view .LVU398
 621:Src/util.c    **** 
 1447              		.loc 1 621 1 is_stmt 0 view .LVU399
 1448 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1449              	.LCFI20:
 1450              		.cfi_def_cfa_offset 24
 1451              		.cfi_offset 4, -24
 1452              		.cfi_offset 5, -20
 1453              		.cfi_offset 6, -16
 1454              		.cfi_offset 7, -12
 1455              		.cfi_offset 8, -8
 1456              		.cfi_offset 14, -4
 1457              		.loc 1 624 25 view .LVU400
 1458 0004 0024     		movs	r4, #0
 625:Src/util.c    ****     
 626:Src/util.c    ****     // assign inputs
 627:Src/util.c    ****     i2c_status          = -1;
 1459              		.loc 1 627 25 view .LVU401
 1460 0006 FF26     		movs	r6, #255
 624:Src/util.c    ****     
 1461              		.loc 1 624 25 view .LVU402
 1462 0008 1C4D     		ldr	r5, .L108
 628:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1463              		.loc 1 628 37 view .LVU403
 1464 000a 4000     		lsls	r0, r0, #1
 1465              	.LVL100:
 624:Src/util.c    ****     
 1466              		.loc 1 624 25 view .LVU404
ARM GAS  /tmp/ccESV1n0.s 			page 40


 1467 000c 2C70     		strb	r4, [r5]
 627:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1468              		.loc 1 627 5 is_stmt 1 view .LVU405
 627:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1469              		.loc 1 627 25 is_stmt 0 view .LVU406
 1470 000e 1C4D     		ldr	r5, .L108+4
 1471              		.loc 1 628 37 view .LVU407
 1472 0010 C0B2     		uxtb	r0, r0
 627:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1473              		.loc 1 627 25 view .LVU408
 1474 0012 2E70     		strb	r6, [r5]
 1475              		.loc 1 628 5 is_stmt 1 view .LVU409
 1476              		.loc 1 628 25 is_stmt 0 view .LVU410
 1477 0014 1B4E     		ldr	r6, .L108+8
 1478 0016 3070     		strb	r0, [r6]
 629:Src/util.c    ****     i2c_regAddress      = regAddr;
 1479              		.loc 1 629 5 is_stmt 1 view .LVU411
 1480              		.loc 1 629 25 is_stmt 0 view .LVU412
 1481 0018 1B48     		ldr	r0, .L108+12
 630:Src/util.c    ****     i2c_rxbuffer        = data;
 631:Src/util.c    ****     i2c_nDABytes        = length;
 1482              		.loc 1 631 25 view .LVU413
 1483 001a 1C4E     		ldr	r6, .L108+16
 629:Src/util.c    ****     i2c_regAddress      = regAddr;
 1484              		.loc 1 629 25 view .LVU414
 1485 001c 0170     		strb	r1, [r0]
 630:Src/util.c    ****     i2c_rxbuffer        = data;
 1486              		.loc 1 630 5 is_stmt 1 view .LVU415
 1487              		.loc 1 631 25 is_stmt 0 view .LVU416
 1488 001e 3270     		strb	r2, [r6]
 632:Src/util.c    ****     i2c_nRABytes        = 1;
 1489              		.loc 1 632 25 view .LVU417
 1490 0020 0122     		movs	r2, #1
 1491              	.LVL101:
 630:Src/util.c    ****     i2c_rxbuffer        = data;
 1492              		.loc 1 630 25 view .LVU418
 1493 0022 1B49     		ldr	r1, .L108+20
 1494              	.LVL102:
 633:Src/util.c    **** 
 634:Src/util.c    ****     uint16_t i2c_timeout = 0;
 635:Src/util.c    **** 
 636:Src/util.c    ****     // enable the I2C0 interrupt
 637:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 1495              		.loc 1 637 5 view .LVU419
 1496 0024 1B48     		ldr	r0, .L108+24
 630:Src/util.c    ****     i2c_nDABytes        = length;
 1497              		.loc 1 630 25 view .LVU420
 1498 0026 0B60     		str	r3, [r1]
 631:Src/util.c    ****     i2c_nRABytes        = 1;
 1499              		.loc 1 631 5 is_stmt 1 view .LVU421
 632:Src/util.c    **** 
 1500              		.loc 1 632 5 view .LVU422
 632:Src/util.c    **** 
 1501              		.loc 1 632 25 is_stmt 0 view .LVU423
 1502 0028 1B4B     		ldr	r3, .L108+28
 1503              	.LVL103:
 1504              		.loc 1 637 5 view .LVU424
ARM GAS  /tmp/ccESV1n0.s 			page 41


 1505 002a 4FF4E061 		mov	r1, #1792
 632:Src/util.c    **** 
 1506              		.loc 1 632 25 view .LVU425
 1507 002e 1A70     		strb	r2, [r3]
 1508              	.LVL104:
 634:Src/util.c    **** 
 1509              		.loc 1 634 5 is_stmt 1 view .LVU426
 1510              		.loc 1 637 5 view .LVU427
 1511 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1512              	.LVL105:
 638:Src/util.c    **** 
 639:Src/util.c    ****     if(2 == i2c_nDABytes){
 1513              		.loc 1 639 5 view .LVU428
 1514              		.loc 1 639 10 is_stmt 0 view .LVU429
 1515 0034 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1516              		.loc 1 639 7 view .LVU430
 1517 0036 022B     		cmp	r3, #2
 1518 0038 03D1     		bne	.L95
 640:Src/util.c    ****         i2c_ackpos_config(MPU_I2C, I2C_ACKPOS_NEXT);    // send ACK for the next byte
 1519              		.loc 1 640 9 is_stmt 1 view .LVU431
 1520 003a 2146     		mov	r1, r4
 1521 003c 1548     		ldr	r0, .L108+24
 1522 003e FFF7FEFF 		bl	i2c_ackpos_config
 1523              	.LVL106:
 1524              	.L95:
 621:Src/util.c    **** 
 1525              		.loc 1 621 1 is_stmt 0 discriminator 2 view .LVU432
 1526 0042 44F62164 		movw	r4, #20001
 641:Src/util.c    ****     }
 642:Src/util.c    **** 
 643:Src/util.c    ****     // the master waits until the I2C bus is idle
 644:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1527              		.loc 1 644 11 discriminator 2 view .LVU433
 1528 0046 154F     		ldr	r7, .L108+32
 1529 0048 DFF84880 		ldr	r8, .L108+24
 1530              	.LVL107:
 1531              	.L97:
 1532              		.loc 1 644 75 is_stmt 1 discriminator 2 view .LVU434
 1533              		.loc 1 644 10 discriminator 2 view .LVU435
 1534              		.loc 1 644 11 is_stmt 0 discriminator 2 view .LVU436
 1535 004c 3946     		mov	r1, r7
 1536 004e 4046     		mov	r0, r8
 1537 0050 FFF7FEFF 		bl	i2c_flag_get
 1538              	.LVL108:
 1539              		.loc 1 644 10 discriminator 2 view .LVU437
 1540 0054 18B1     		cbz	r0, .L96
 1541              	.LVL109:
 1542              		.loc 1 644 50 discriminator 1 view .LVU438
 1543 0056 013C     		subs	r4, r4, #1
 1544              	.LVL110:
 1545              		.loc 1 644 50 discriminator 1 view .LVU439
 1546 0058 A4B2     		uxth	r4, r4
 1547 005a 002C     		cmp	r4, #0
 1548 005c F6D1     		bne	.L97
 1549              	.L96:
 645:Src/util.c    **** 
 646:Src/util.c    ****     // the master sends a start condition to I2C bus
ARM GAS  /tmp/ccESV1n0.s 			page 42


 647:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1550              		.loc 1 647 5 is_stmt 1 view .LVU440
 1551 005e 0D48     		ldr	r0, .L108+24
 1552 0060 FFF7FEFF 		bl	i2c_start_on_bus
 1553              	.LVL111:
 648:Src/util.c    **** 
 649:Src/util.c    ****     // Wait until all data bytes are sent/received
 650:Src/util.c    ****     i2c_timeout = 0;
 1554              		.loc 1 650 5 view .LVU441
 651:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1555              		.loc 1 651 5 view .LVU442
 1556              		.loc 1 651 10 is_stmt 0 view .LVU443
 1557 0064 44F62163 		movw	r3, #20001
 1558              	.LVL112:
 1559              	.L99:
 1560              		.loc 1 651 53 is_stmt 1 discriminator 2 view .LVU444
 1561              		.loc 1 651 10 discriminator 2 view .LVU445
 1562              		.loc 1 651 24 is_stmt 0 discriminator 2 view .LVU446
 1563 0068 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1564              		.loc 1 651 10 discriminator 2 view .LVU447
 1565 006a 1AB1     		cbz	r2, .L98
 1566              	.LVL113:
 1567              		.loc 1 651 28 discriminator 1 view .LVU448
 1568 006c 013B     		subs	r3, r3, #1
 1569              	.LVL114:
 1570              		.loc 1 651 28 discriminator 1 view .LVU449
 1571 006e 9BB2     		uxth	r3, r3
 1572 0070 002B     		cmp	r3, #0
 1573 0072 F9D1     		bne	.L99
 1574              	.L98:
 652:Src/util.c    **** 
 653:Src/util.c    ****     // Return status
 654:Src/util.c    ****     return i2c_status;
 1575              		.loc 1 654 5 is_stmt 1 view .LVU450
 1576              		.loc 1 654 12 is_stmt 0 view .LVU451
 1577 0074 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 655:Src/util.c    **** 
 656:Src/util.c    **** }
 1578              		.loc 1 656 1 view .LVU452
 1579 0076 40B2     		sxtb	r0, r0
 1580 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1581              	.L109:
 1582              		.align	2
 1583              	.L108:
 1584 007c 00000000 		.word	.LANCHOR12
 1585 0080 00000000 		.word	.LANCHOR13
 1586 0084 00000000 		.word	.LANCHOR14
 1587 0088 00000000 		.word	.LANCHOR15
 1588 008c 00000000 		.word	.LANCHOR17
 1589 0090 00000000 		.word	.LANCHOR19
 1590 0094 00540040 		.word	1073763328
 1591 0098 00000000 		.word	.LANCHOR18
 1592 009c 02000080 		.word	-2147483646
 1593              		.cfi_endproc
 1594              	.LFE75:
 1596              		.section	.text.i2c_readByte,"ax",%progbits
 1597              		.align	1
ARM GAS  /tmp/ccESV1n0.s 			page 43


 1598              		.global	i2c_readByte
 1599              		.syntax unified
 1600              		.thumb
 1601              		.thumb_func
 1602              		.fpu softvfp
 1604              	i2c_readByte:
 1605              	.LVL115:
 1606              	.LFB76:
 657:Src/util.c    **** 
 658:Src/util.c    **** 
 659:Src/util.c    **** /*
 660:Src/util.c    ****  * read 1 byte from chip register
 661:Src/util.c    ****  */
 662:Src/util.c    **** int8_t i2c_readByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t *data)
 663:Src/util.c    **** {
 1607              		.loc 1 663 1 is_stmt 1 view -0
 1608              		.cfi_startproc
 1609              		@ args = 0, pretend = 0, frame = 0
 1610              		@ frame_needed = 0, uses_anonymous_args = 0
 1611              		@ link register save eliminated.
 664:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1612              		.loc 1 664 5 view .LVU454
 663:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1613              		.loc 1 663 1 is_stmt 0 view .LVU455
 1614 0000 1346     		mov	r3, r2
 1615              		.loc 1 664 12 view .LVU456
 1616 0002 0122     		movs	r2, #1
 1617              	.LVL116:
 1618              		.loc 1 664 12 view .LVU457
 1619 0004 FFF7FEBF 		b	i2c_readBytes
 1620              	.LVL117:
 1621              		.loc 1 664 12 view .LVU458
 1622              		.cfi_endproc
 1623              	.LFE76:
 1625              		.section	.text.i2c_writeBit,"ax",%progbits
 1626              		.align	1
 1627              		.global	i2c_writeBit
 1628              		.syntax unified
 1629              		.thumb
 1630              		.thumb_func
 1631              		.fpu softvfp
 1633              	i2c_writeBit:
 1634              	.LVL118:
 1635              	.LFB74:
 606:Src/util.c    ****     uint8_t b;
 1636              		.loc 1 606 87 is_stmt 1 view -0
 1637              		.cfi_startproc
 1638              		@ args = 0, pretend = 0, frame = 8
 1639              		@ frame_needed = 0, uses_anonymous_args = 0
 607:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 1640              		.loc 1 607 5 view .LVU460
 608:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1641              		.loc 1 608 5 view .LVU461
 606:Src/util.c    ****     uint8_t b;
 1642              		.loc 1 606 87 is_stmt 0 view .LVU462
 1643 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 1644              	.LCFI21:
ARM GAS  /tmp/ccESV1n0.s 			page 44


 1645              		.cfi_def_cfa_offset 32
 1646              		.cfi_offset 4, -24
 1647              		.cfi_offset 5, -20
 1648              		.cfi_offset 6, -16
 1649              		.cfi_offset 7, -12
 1650              		.cfi_offset 8, -8
 1651              		.cfi_offset 14, -4
 606:Src/util.c    ****     uint8_t b;
 1652              		.loc 1 606 87 view .LVU463
 1653 0004 9046     		mov	r8, r2
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1654              		.loc 1 609 31 view .LVU464
 1655 0006 0124     		movs	r4, #1
 606:Src/util.c    ****     uint8_t b;
 1656              		.loc 1 606 87 view .LVU465
 1657 0008 1F46     		mov	r7, r3
 608:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1658              		.loc 1 608 5 view .LVU466
 1659 000a 0DF10702 		add	r2, sp, #7
 1660              	.LVL119:
 606:Src/util.c    ****     uint8_t b;
 1661              		.loc 1 606 87 view .LVU467
 1662 000e 0546     		mov	r5, r0
 1663 0010 0E46     		mov	r6, r1
 608:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1664              		.loc 1 608 5 view .LVU468
 1665 0012 FFF7FEFF 		bl	i2c_readByte
 1666              	.LVL120:
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1667              		.loc 1 609 5 is_stmt 1 view .LVU469
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1668              		.loc 1 609 31 is_stmt 0 view .LVU470
 1669 0016 04FA08F2 		lsl	r2, r4, r8
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1670              		.loc 1 609 26 view .LVU471
 1671 001a 52B2     		sxtb	r2, r2
 1672 001c 9DF80740 		ldrb	r4, [sp, #7]	@ zero_extendqisi2
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1673              		.loc 1 609 7 view .LVU472
 1674 0020 57B1     		cbz	r7, .L112
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1675              		.loc 1 609 26 discriminator 1 view .LVU473
 1676 0022 2243     		orrs	r2, r2, r4
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1677              		.loc 1 609 7 discriminator 1 view .LVU474
 1678 0024 D2B2     		uxtb	r2, r2
 1679              	.L113:
 610:Src/util.c    **** }
 1680              		.loc 1 610 12 discriminator 4 view .LVU475
 1681 0026 3146     		mov	r1, r6
 1682 0028 2846     		mov	r0, r5
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1683              		.loc 1 609 7 discriminator 4 view .LVU476
 1684 002a 8DF80720 		strb	r2, [sp, #7]
 610:Src/util.c    **** }
 1685              		.loc 1 610 5 is_stmt 1 discriminator 4 view .LVU477
 610:Src/util.c    **** }
ARM GAS  /tmp/ccESV1n0.s 			page 45


 1686              		.loc 1 610 12 is_stmt 0 discriminator 4 view .LVU478
 1687 002e FFF7FEFF 		bl	i2c_writeByte
 1688              	.LVL121:
 611:Src/util.c    **** 
 1689              		.loc 1 611 1 discriminator 4 view .LVU479
 1690 0032 02B0     		add	sp, sp, #8
 1691              	.LCFI22:
 1692              		.cfi_remember_state
 1693              		.cfi_def_cfa_offset 24
 1694              		@ sp needed
 1695 0034 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1696              	.L112:
 1697              	.LCFI23:
 1698              		.cfi_restore_state
 609:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1699              		.loc 1 609 7 discriminator 2 view .LVU480
 1700 0038 24EA0202 		bic	r2, r4, r2
 1701 003c F3E7     		b	.L113
 1702              		.cfi_endproc
 1703              	.LFE74:
 1705              		.section	.text.i2c_readBit,"ax",%progbits
 1706              		.align	1
 1707              		.global	i2c_readBit
 1708              		.syntax unified
 1709              		.thumb
 1710              		.thumb_func
 1711              		.fpu softvfp
 1713              	i2c_readBit:
 1714              	.LVL122:
 1715              	.LFB77:
 665:Src/util.c    **** }
 666:Src/util.c    **** 
 667:Src/util.c    **** 
 668:Src/util.c    **** /*
 669:Src/util.c    ****  * read 1 bit from chip register
 670:Src/util.c    ****  */
 671:Src/util.c    **** int8_t i2c_readBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data)
 672:Src/util.c    **** {
 1716              		.loc 1 672 1 is_stmt 1 view -0
 1717              		.cfi_startproc
 1718              		@ args = 0, pretend = 0, frame = 8
 1719              		@ frame_needed = 0, uses_anonymous_args = 0
 673:Src/util.c    ****     uint8_t b;
 1720              		.loc 1 673 5 view .LVU482
 674:Src/util.c    ****     int8_t status = i2c_readByte(slaveAddr, regAddr, &b);
 1721              		.loc 1 674 5 view .LVU483
 672:Src/util.c    ****     uint8_t b;
 1722              		.loc 1 672 1 is_stmt 0 view .LVU484
 1723 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1724              	.LCFI24:
 1725              		.cfi_def_cfa_offset 24
 1726              		.cfi_offset 4, -12
 1727              		.cfi_offset 5, -8
 1728              		.cfi_offset 14, -4
 672:Src/util.c    ****     uint8_t b;
 1729              		.loc 1 672 1 view .LVU485
 1730 0002 1546     		mov	r5, r2
ARM GAS  /tmp/ccESV1n0.s 			page 46


 1731              		.loc 1 674 21 view .LVU486
 1732 0004 0DF10702 		add	r2, sp, #7
 1733              	.LVL123:
 672:Src/util.c    ****     uint8_t b;
 1734              		.loc 1 672 1 view .LVU487
 1735 0008 1C46     		mov	r4, r3
 1736              		.loc 1 674 21 view .LVU488
 1737 000a FFF7FEFF 		bl	i2c_readByte
 1738              	.LVL124:
 675:Src/util.c    ****     *data = b & (1 << bitNum);
 1739              		.loc 1 675 5 is_stmt 1 view .LVU489
 1740              		.loc 1 675 20 is_stmt 0 view .LVU490
 1741 000e 0121     		movs	r1, #1
 1742              		.loc 1 675 15 view .LVU491
 1743 0010 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1744              		.loc 1 675 20 view .LVU492
 1745 0014 01FA05F2 		lsl	r2, r1, r5
 1746              		.loc 1 675 15 view .LVU493
 1747 0018 1A40     		ands	r2, r2, r3
 1748              		.loc 1 675 11 view .LVU494
 1749 001a 2270     		strb	r2, [r4]
 676:Src/util.c    ****     return status;
 1750              		.loc 1 676 5 is_stmt 1 view .LVU495
 677:Src/util.c    **** }
 1751              		.loc 1 677 1 is_stmt 0 view .LVU496
 1752 001c 03B0     		add	sp, sp, #12
 1753              	.LCFI25:
 1754              		.cfi_def_cfa_offset 12
 1755              		@ sp needed
 1756 001e 30BD     		pop	{r4, r5, pc}
 1757              		.loc 1 677 1 view .LVU497
 1758              		.cfi_endproc
 1759              	.LFE77:
 1761              		.global	buffer
 1762              		.global	i2c_nRABytes
 1763              		.global	i2c_nDABytes
 1764              		.global	i2c_rxbuffer
 1765              		.global	i2c_txbuffer
 1766              		.global	i2c_slaveAddress
 1767              		.global	i2c_regAddress
 1768              		.global	i2c_ReadWriteCmd
 1769              		.global	i2c_status
 1770              		.section	.bss.Feedback,"aw",%nobits
 1771              		.align	1
 1772              		.set	.LANCHOR9,. + 0
 1775              	Feedback:
 1776 0000 00000000 		.space	18
 1776      00000000 
 1776      00000000 
 1776      00000000 
 1776      0000
 1777              		.section	.bss.FeedbackRaw,"aw",%nobits
 1778              		.align	1
 1779              		.set	.LANCHOR11,. + 0
 1782              	FeedbackRaw:
 1783 0000 00000000 		.space	18
 1783      00000000 
ARM GAS  /tmp/ccESV1n0.s 			page 47


 1783      00000000 
 1783      00000000 
 1783      0000
 1784              		.section	.bss.Sideboard,"aw",%nobits
 1785              		.align	1
 1786              		.set	.LANCHOR0,. + 0
 1789              	Sideboard:
 1790 0000 00000000 		.space	14
 1790      00000000 
 1790      00000000 
 1790      0000
 1791              		.section	.bss.buffer,"aw",%nobits
 1794              	buffer:
 1795 0000 00000000 		.space	14
 1795      00000000 
 1795      00000000 
 1795      0000
 1796              		.section	.bss.i2c_ReadWriteCmd,"aw",%nobits
 1797              		.set	.LANCHOR12,. + 0
 1800              	i2c_ReadWriteCmd:
 1801 0000 00       		.space	1
 1802              		.section	.bss.i2c_nDABytes,"aw",%nobits
 1803              		.set	.LANCHOR17,. + 0
 1806              	i2c_nDABytes:
 1807 0000 00       		.space	1
 1808              		.section	.bss.i2c_nRABytes,"aw",%nobits
 1809              		.set	.LANCHOR18,. + 0
 1812              	i2c_nRABytes:
 1813 0000 00       		.space	1
 1814              		.section	.bss.i2c_regAddress,"aw",%nobits
 1815              		.set	.LANCHOR15,. + 0
 1818              	i2c_regAddress:
 1819 0000 00       		.space	1
 1820              		.section	.bss.i2c_rxbuffer,"aw",%nobits
 1821              		.align	2
 1822              		.set	.LANCHOR19,. + 0
 1825              	i2c_rxbuffer:
 1826 0000 00000000 		.space	4
 1827              		.section	.bss.i2c_slaveAddress,"aw",%nobits
 1828              		.set	.LANCHOR14,. + 0
 1831              	i2c_slaveAddress:
 1832 0000 00       		.space	1
 1833              		.section	.bss.i2c_status,"aw",%nobits
 1834              		.set	.LANCHOR13,. + 0
 1837              	i2c_status:
 1838 0000 00       		.space	1
 1839              		.section	.bss.i2c_txbuffer,"aw",%nobits
 1840              		.align	2
 1841              		.set	.LANCHOR16,. + 0
 1844              	i2c_txbuffer:
 1845 0000 00000000 		.space	4
 1846              		.section	.bss.mpuStatus,"aw",%nobits
 1847              		.set	.LANCHOR2,. + 0
 1850              	mpuStatus:
 1851 0000 00       		.space	1
 1852              		.section	.bss.old_pos.0,"aw",%nobits
 1853              		.align	2
ARM GAS  /tmp/ccESV1n0.s 			page 48


 1854              		.set	.LANCHOR10,. + 0
 1857              	old_pos.0:
 1858 0000 00000000 		.space	4
 1859              		.section	.bss.rx1_buffer,"aw",%nobits
 1860              		.set	.LANCHOR1,. + 0
 1863              	rx1_buffer:
 1864 0000 00000000 		.space	64
 1864      00000000 
 1864      00000000 
 1864      00000000 
 1864      00000000 
 1865              		.section	.bss.sensor1,"aw",%nobits
 1866              		.set	.LANCHOR5,. + 0
 1869              	sensor1:
 1870 0000 00       		.space	1
 1871              		.section	.bss.sensor1_read,"aw",%nobits
 1872              		.set	.LANCHOR3,. + 0
 1875              	sensor1_read:
 1876 0000 00       		.space	1
 1877              		.section	.bss.sensor2,"aw",%nobits
 1878              		.set	.LANCHOR6,. + 0
 1881              	sensor2:
 1882 0000 00       		.space	1
 1883              		.section	.bss.sensor2_read,"aw",%nobits
 1884              		.set	.LANCHOR4,. + 0
 1887              	sensor2_read:
 1888 0000 00       		.space	1
 1889              		.section	.bss.timeoutCntSerial1,"aw",%nobits
 1890              		.align	1
 1891              		.set	.LANCHOR7,. + 0
 1894              	timeoutCntSerial1:
 1895 0000 0000     		.space	2
 1896              		.section	.bss.timeoutFlagSerial1,"aw",%nobits
 1897              		.set	.LANCHOR8,. + 0
 1900              	timeoutFlagSerial1:
 1901 0000 00       		.space	1
 1902              		.text
 1903              	.Letext0:
 1904              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1905              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1906              		.file 4 "Drivers/CMSIS/Include/gd32f1x0.h"
 1907              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dma.h"
 1908              		.file 6 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 1909              		.file 7 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 1910              		.file 8 "Inc/util.h"
 1911              		.file 9 "Inc/defines.h"
 1912              		.file 10 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_i2c.h"
 1913              		.file 11 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_gpio.h"
 1914              		.file 12 "Inc/mpu6050.h"
 1915              		.file 13 "Inc/setup.h"
 1916              		.file 14 "Inc/systick.h"
 1917              		.file 15 "<built-in>"
ARM GAS  /tmp/ccESV1n0.s 			page 49


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccESV1n0.s:16     .text.consoleLog:0000000000000000 $t
     /tmp/ccESV1n0.s:24     .text.consoleLog:0000000000000000 consoleLog
     /tmp/ccESV1n0.s:39     .text.toggle_led:0000000000000000 $t
     /tmp/ccESV1n0.s:46     .text.toggle_led:0000000000000000 toggle_led
     /tmp/ccESV1n0.s:65     .text.intro_demo_led:0000000000000000 $t
     /tmp/ccESV1n0.s:72     .text.intro_demo_led:0000000000000000 intro_demo_led
     /tmp/ccESV1n0.s:223    .text.intro_demo_led:00000000000000cc $d
     /tmp/ccESV1n0.s:228    .text.switch_check:0000000000000000 $t
     /tmp/ccESV1n0.s:235    .text.switch_check:0000000000000000 switch_check
     /tmp/ccESV1n0.s:283    .text.input_init:0000000000000000 $t
     /tmp/ccESV1n0.s:290    .text.input_init:0000000000000000 input_init
     /tmp/ccESV1n0.s:362    .text.input_init:0000000000000044 $d
     /tmp/ccESV1n0.s:371    .text.handle_mpu6050:0000000000000000 $t
     /tmp/ccESV1n0.s:378    .text.handle_mpu6050:0000000000000000 handle_mpu6050
     /tmp/ccESV1n0.s:429    .text.handle_mpu6050:000000000000002c $d
     /tmp/ccESV1n0.s:435    .text.handle_sensors:0000000000000000 $t
     /tmp/ccESV1n0.s:442    .text.handle_sensors:0000000000000000 handle_sensors
     /tmp/ccESV1n0.s:600    .text.handle_sensors:000000000000007c $d
     /tmp/ccESV1n0.s:610    .text.handle_usart:0000000000000000 $t
     /tmp/ccESV1n0.s:617    .text.handle_usart:0000000000000000 handle_usart
     /tmp/ccESV1n0.s:781    .text.handle_usart:00000000000000a8 $d
     /tmp/ccESV1n0.s:795    .text.handle_leds:0000000000000000 $t
     /tmp/ccESV1n0.s:802    .text.handle_leds:0000000000000000 handle_leds
     /tmp/ccESV1n0.s:966    .text.handle_leds:0000000000000094 $d
     /tmp/ccESV1n0.s:973    .text.usart_process_data:0000000000000000 $t
     /tmp/ccESV1n0.s:980    .text.usart_process_data:0000000000000000 usart_process_data
     /tmp/ccESV1n0.s:1062   .text.usart_process_data:0000000000000050 $d
     /tmp/ccESV1n0.s:1068   .text.usart1_rx_check:0000000000000000 $t
     /tmp/ccESV1n0.s:1075   .text.usart1_rx_check:0000000000000000 usart1_rx_check
     /tmp/ccESV1n0.s:1193   .text.usart1_rx_check:0000000000000074 $d
     /tmp/ccESV1n0.s:1201   .text.usart0_rx_check:0000000000000000 $t
     /tmp/ccESV1n0.s:1208   .text.usart0_rx_check:0000000000000000 usart0_rx_check
     /tmp/ccESV1n0.s:1221   .text.aux_print_to_console:0000000000000000 $t
     /tmp/ccESV1n0.s:1228   .text.aux_print_to_console:0000000000000000 aux_print_to_console
     /tmp/ccESV1n0.s:1239   .text.i2c_writeBytes:0000000000000000 $t
     /tmp/ccESV1n0.s:1246   .text.i2c_writeBytes:0000000000000000 i2c_writeBytes
     /tmp/ccESV1n0.s:1380   .text.i2c_writeBytes:000000000000006c $d
     /tmp/ccESV1n0.s:1393   .text.i2c_writeByte:0000000000000000 $t
     /tmp/ccESV1n0.s:1400   .text.i2c_writeByte:0000000000000000 i2c_writeByte
     /tmp/ccESV1n0.s:1432   .text.i2c_readBytes:0000000000000000 $t
     /tmp/ccESV1n0.s:1439   .text.i2c_readBytes:0000000000000000 i2c_readBytes
     /tmp/ccESV1n0.s:1584   .text.i2c_readBytes:000000000000007c $d
     /tmp/ccESV1n0.s:1597   .text.i2c_readByte:0000000000000000 $t
     /tmp/ccESV1n0.s:1604   .text.i2c_readByte:0000000000000000 i2c_readByte
     /tmp/ccESV1n0.s:1626   .text.i2c_writeBit:0000000000000000 $t
     /tmp/ccESV1n0.s:1633   .text.i2c_writeBit:0000000000000000 i2c_writeBit
     /tmp/ccESV1n0.s:1706   .text.i2c_readBit:0000000000000000 $t
     /tmp/ccESV1n0.s:1713   .text.i2c_readBit:0000000000000000 i2c_readBit
     /tmp/ccESV1n0.s:1794   .bss.buffer:0000000000000000 buffer
     /tmp/ccESV1n0.s:1812   .bss.i2c_nRABytes:0000000000000000 i2c_nRABytes
     /tmp/ccESV1n0.s:1806   .bss.i2c_nDABytes:0000000000000000 i2c_nDABytes
     /tmp/ccESV1n0.s:1825   .bss.i2c_rxbuffer:0000000000000000 i2c_rxbuffer
     /tmp/ccESV1n0.s:1844   .bss.i2c_txbuffer:0000000000000000 i2c_txbuffer
     /tmp/ccESV1n0.s:1831   .bss.i2c_slaveAddress:0000000000000000 i2c_slaveAddress
     /tmp/ccESV1n0.s:1818   .bss.i2c_regAddress:0000000000000000 i2c_regAddress
ARM GAS  /tmp/ccESV1n0.s 			page 50


     /tmp/ccESV1n0.s:1800   .bss.i2c_ReadWriteCmd:0000000000000000 i2c_ReadWriteCmd
     /tmp/ccESV1n0.s:1837   .bss.i2c_status:0000000000000000 i2c_status
     /tmp/ccESV1n0.s:1771   .bss.Feedback:0000000000000000 $d
     /tmp/ccESV1n0.s:1775   .bss.Feedback:0000000000000000 Feedback
     /tmp/ccESV1n0.s:1778   .bss.FeedbackRaw:0000000000000000 $d
     /tmp/ccESV1n0.s:1782   .bss.FeedbackRaw:0000000000000000 FeedbackRaw
     /tmp/ccESV1n0.s:1785   .bss.Sideboard:0000000000000000 $d
     /tmp/ccESV1n0.s:1789   .bss.Sideboard:0000000000000000 Sideboard
     /tmp/ccESV1n0.s:1795   .bss.buffer:0000000000000000 $d
     /tmp/ccESV1n0.s:1801   .bss.i2c_ReadWriteCmd:0000000000000000 $d
     /tmp/ccESV1n0.s:1807   .bss.i2c_nDABytes:0000000000000000 $d
     /tmp/ccESV1n0.s:1813   .bss.i2c_nRABytes:0000000000000000 $d
     /tmp/ccESV1n0.s:1819   .bss.i2c_regAddress:0000000000000000 $d
     /tmp/ccESV1n0.s:1821   .bss.i2c_rxbuffer:0000000000000000 $d
     /tmp/ccESV1n0.s:1832   .bss.i2c_slaveAddress:0000000000000000 $d
     /tmp/ccESV1n0.s:1838   .bss.i2c_status:0000000000000000 $d
     /tmp/ccESV1n0.s:1840   .bss.i2c_txbuffer:0000000000000000 $d
     /tmp/ccESV1n0.s:1850   .bss.mpuStatus:0000000000000000 mpuStatus
     /tmp/ccESV1n0.s:1851   .bss.mpuStatus:0000000000000000 $d
     /tmp/ccESV1n0.s:1853   .bss.old_pos.0:0000000000000000 $d
     /tmp/ccESV1n0.s:1857   .bss.old_pos.0:0000000000000000 old_pos.0
     /tmp/ccESV1n0.s:1863   .bss.rx1_buffer:0000000000000000 rx1_buffer
     /tmp/ccESV1n0.s:1864   .bss.rx1_buffer:0000000000000000 $d
     /tmp/ccESV1n0.s:1869   .bss.sensor1:0000000000000000 sensor1
     /tmp/ccESV1n0.s:1870   .bss.sensor1:0000000000000000 $d
     /tmp/ccESV1n0.s:1875   .bss.sensor1_read:0000000000000000 sensor1_read
     /tmp/ccESV1n0.s:1876   .bss.sensor1_read:0000000000000000 $d
     /tmp/ccESV1n0.s:1881   .bss.sensor2:0000000000000000 sensor2
     /tmp/ccESV1n0.s:1882   .bss.sensor2:0000000000000000 $d
     /tmp/ccESV1n0.s:1887   .bss.sensor2_read:0000000000000000 sensor2_read
     /tmp/ccESV1n0.s:1888   .bss.sensor2_read:0000000000000000 $d
     /tmp/ccESV1n0.s:1890   .bss.timeoutCntSerial1:0000000000000000 $d
     /tmp/ccESV1n0.s:1894   .bss.timeoutCntSerial1:0000000000000000 timeoutCntSerial1
     /tmp/ccESV1n0.s:1900   .bss.timeoutFlagSerial1:0000000000000000 timeoutFlagSerial1
     /tmp/ccESV1n0.s:1901   .bss.timeoutFlagSerial1:0000000000000000 $d

UNDEFINED SYMBOLS
gpio_bit_set
gpio_bit_reset
delay_1ms
usart_Tx_DMA_config
usart_Rx_DMA_config
mpu_config
mpu_get_data
main_loop_counter
gpio_input_bit_get
dma_transfer_number_get
dma_channel_disable
dma_channel_enable
mpu
memcpy
i2c_interrupt_enable
i2c_flag_get
i2c_start_on_bus
i2c_ackpos_config
