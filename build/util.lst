ARM GAS  /tmp/ccy0IG4C.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.consoleLog,"ax",%progbits
  16              		.align	1
  17              		.global	consoleLog
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	consoleLog:
  25              	.LVL0:
  26              	.LFB59:
  27              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-sideboard-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <string.h>
  23:Src/util.c    **** #include "systick.h"
  24:Src/util.c    **** #include "gd32f1x0.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "config.h"
  27:Src/util.c    **** #include "setup.h"
  28:Src/util.c    **** #include "util.h"
  29:Src/util.c    **** #include "mpu6050.h"
  30:Src/util.c    **** 
  31:Src/util.c    **** // USART1 variables
ARM GAS  /tmp/ccy0IG4C.s 			page 2


  32:Src/util.c    **** #ifdef SERIAL_CONTROL
  33:Src/util.c    **** static SerialSideboard Sideboard;
  34:Src/util.c    **** static SideboardImuRaw sideboard_imu;
  35:Src/util.c    **** #endif
  36:Src/util.c    **** 
  37:Src/util.c    **** #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
  38:Src/util.c    **** static uint8_t  rx1_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  39:Src/util.c    **** static uint32_t rx1_buffer_len = ARRAY_LEN(rx1_buffer);
  40:Src/util.c    **** #endif
  41:Src/util.c    **** 
  42:Src/util.c    **** #ifdef SERIAL_FEEDBACK
  43:Src/util.c    **** static SerialFeedback Feedback;
  44:Src/util.c    **** static SerialFeedback FeedbackRaw;
  45:Src/util.c    **** static uint16_t timeoutCntSerial1  = 0;         // Timeout counter for UART1 Rx Serial
  46:Src/util.c    **** static uint8_t  timeoutFlagSerial1 = 0;         // Timeout Flag for UART1 Rx Serial: 0 = OK, 1 = Pr
  47:Src/util.c    **** static uint32_t Feedback_len  = sizeof(Feedback);
  48:Src/util.c    **** #endif
  49:Src/util.c    **** 
  50:Src/util.c    **** // USART0 variables
  51:Src/util.c    **** #ifdef SERIAL_AUX_TX
  52:Src/util.c    **** static SerialAuxTx AuxTx;
  53:Src/util.c    **** #endif
  54:Src/util.c    **** 
  55:Src/util.c    **** #ifdef SERIAL_AUX_RX
  56:Src/util.c    **** static uint8_t  rx0_buffer[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
  57:Src/util.c    **** static uint32_t rx0_buffer_len = ARRAY_LEN(rx0_buffer);
  58:Src/util.c    **** #endif
  59:Src/util.c    **** 
  60:Src/util.c    **** #ifdef SERIAL_AUX_RX
  61:Src/util.c    **** static SerialCommand command;
  62:Src/util.c    **** static SerialCommand command_raw;
  63:Src/util.c    **** static uint16_t timeoutCntSerial0  = 0;         // Timeout counter for UART0 Rx Serial
  64:Src/util.c    **** static uint8_t  timeoutFlagSerial0 = 0;         // Timeout Flag for UART0 Rx Serial: 0 = OK, 1 = Pr
  65:Src/util.c    **** static uint32_t command_len = sizeof(command);
  66:Src/util.c    **** extern uint8_t  print_aux;
  67:Src/util.c    ****   #ifdef CONTROL_IBUS
  68:Src/util.c    ****   static uint16_t ibus_chksum;
  69:Src/util.c    ****   static uint16_t ibus_captured_value[IBUS_NUM_CHANNELS];
  70:Src/util.c    ****   #endif
  71:Src/util.c    **** #endif
  72:Src/util.c    **** 
  73:Src/util.c    **** #if (defined(SERIAL_AUX_RX) && defined(CONTROL_IBUS)) || defined(SERIAL_CONTROL)
  74:Src/util.c    **** static int16_t  cmd1, cmd2;
  75:Src/util.c    **** static uint16_t cmdSwitch;
  76:Src/util.c    **** #endif
  77:Src/util.c    **** 
  78:Src/util.c    **** // Optical sensors variables
  79:Src/util.c    **** static FlagStatus   sensor1, sensor2;           // holds the sensor1 and sensor 2 values
  80:Src/util.c    **** static FlagStatus   sensor1_read, sensor2_read; // holds the instantaneous Read for sensor1 and sen
  81:Src/util.c    **** 
  82:Src/util.c    **** // MPU variables
  83:Src/util.c    **** extern MPU_Data     mpu;                        // holds the MPU-6050 data
  84:Src/util.c    **** #if defined(MPU_SENSOR_ENABLE) || defined(SERIAL_CONTROL)
  85:Src/util.c    **** static ErrStatus    mpuStatus;                  // holds the MPU-6050 status: SUCCESS or ERROR
  86:Src/util.c    **** #endif
  87:Src/util.c    **** 
  88:Src/util.c    **** extern uint32_t     main_loop_counter;          // main loop counter to perform task scheduling ins
ARM GAS  /tmp/ccy0IG4C.s 			page 3


  89:Src/util.c    **** 
  90:Src/util.c    **** // MAIN I2C variables
  91:Src/util.c    **** volatile int8_t     i2c_status;
  92:Src/util.c    **** volatile i2c_cmd    i2c_ReadWriteCmd;
  93:Src/util.c    **** volatile uint8_t    i2c_regAddress;
  94:Src/util.c    **** volatile uint8_t    i2c_slaveAddress;
  95:Src/util.c    **** volatile uint8_t*   i2c_txbuffer;
  96:Src/util.c    **** volatile uint8_t*   i2c_rxbuffer;
  97:Src/util.c    **** volatile uint8_t    i2c_nDABytes;
  98:Src/util.c    **** volatile  int8_t    i2c_nRABytes;
  99:Src/util.c    **** volatile uint8_t    buffer[14];
 100:Src/util.c    **** 
 101:Src/util.c    **** #ifdef AUX45_USE_I2C
 102:Src/util.c    **** // AUX I2C variables
 103:Src/util.c    **** volatile int8_t     i2c_aux_status;
 104:Src/util.c    **** volatile i2c_cmd    i2c_aux_ReadWriteCmd;
 105:Src/util.c    **** volatile uint8_t    i2c_aux_regAddress;
 106:Src/util.c    **** volatile uint8_t    i2c_aux_slaveAddress;
 107:Src/util.c    **** volatile uint8_t*   i2c_aux_txbuffer;
 108:Src/util.c    **** volatile uint8_t*   i2c_aux_rxbuffer;
 109:Src/util.c    **** volatile uint8_t    i2c_aux_nDABytes;
 110:Src/util.c    **** volatile  int8_t    i2c_aux_nRABytes;
 111:Src/util.c    **** #endif
 112:Src/util.c    **** 
 113:Src/util.c    **** 
 114:Src/util.c    **** 
 115:Src/util.c    **** /* =========================== General Functions =========================== */
 116:Src/util.c    **** 
 117:Src/util.c    **** void consoleLog(char *message)
 118:Src/util.c    **** {
  28              		.loc 1 118 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
 119:Src/util.c    ****   #ifdef SERIAL_DEBUG
 120:Src/util.c    ****     log_i("%s", message);
 121:Src/util.c    ****   #endif
 122:Src/util.c    **** }
  33              		.loc 1 122 1 view .LVU1
  34 0000 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE59:
  38              		.section	.text.toggle_led,"ax",%progbits
  39              		.align	1
  40              		.global	toggle_led
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	toggle_led:
  47              	.LVL1:
  48              	.LFB60:
 123:Src/util.c    **** 
 124:Src/util.c    **** 
 125:Src/util.c    **** /* retarget the C library printf function to the USART */
 126:Src/util.c    **** #ifdef SERIAL_DEBUG	
ARM GAS  /tmp/ccy0IG4C.s 			page 4


 127:Src/util.c    ****     #ifdef __GNUC__
 128:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 129:Src/util.c    ****     #else
 130:Src/util.c    ****         #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 131:Src/util.c    ****     #endif
 132:Src/util.c    ****     PUTCHAR_PROTOTYPE {
 133:Src/util.c    ****         usart_data_transmit(USART_MAIN, (uint8_t)ch);
 134:Src/util.c    ****         while(RESET == usart_flag_get(USART_MAIN, USART_FLAG_TBE));
 135:Src/util.c    ****         return ch;
 136:Src/util.c    ****     }
 137:Src/util.c    ****     
 138:Src/util.c    ****     #ifdef __GNUC__
 139:Src/util.c    ****         int _write(int file, char *data, int len) {
 140:Src/util.c    ****             int i;
 141:Src/util.c    ****             for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 142:Src/util.c    ****             return len; 
 143:Src/util.c    ****         }
 144:Src/util.c    ****     #endif
 145:Src/util.c    **** #endif
 146:Src/util.c    **** 
 147:Src/util.c    **** 
 148:Src/util.c    **** void toggle_led(uint32_t gpio_periph, uint32_t pin)
 149:Src/util.c    **** {
  49              		.loc 1 149 1 view -0
  50              		.cfi_startproc
  51              		@ args = 0, pretend = 0, frame = 0
  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
 150:Src/util.c    ****     GPIO_OCTL(gpio_periph) ^= pin;
  54              		.loc 1 150 5 view .LVU3
  55              		.loc 1 150 28 is_stmt 0 view .LVU4
  56 0000 4369     		ldr	r3, [r0, #20]
  57 0002 4B40     		eors	r3, r3, r1
  58 0004 4361     		str	r3, [r0, #20]
 151:Src/util.c    **** }
  59              		.loc 1 151 1 view .LVU5
  60 0006 7047     		bx	lr
  61              		.cfi_endproc
  62              	.LFE60:
  64              		.section	.text.intro_demo_led,"ax",%progbits
  65              		.align	1
  66              		.global	intro_demo_led
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu softvfp
  72              	intro_demo_led:
  73              	.LVL2:
  74              	.LFB61:
 152:Src/util.c    **** 
 153:Src/util.c    **** 
 154:Src/util.c    **** void intro_demo_led(uint32_t tDelay)
 155:Src/util.c    **** {
  75              		.loc 1 155 1 is_stmt 1 view -0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccy0IG4C.s 			page 5


 156:Src/util.c    ****     int i;
  79              		.loc 1 156 5 view .LVU7
 157:Src/util.c    **** 
 158:Src/util.c    ****     for (i = 0; i < 3; i++) {
  80              		.loc 1 158 5 view .LVU8
  81              		.loc 1 158 17 view .LVU9
 155:Src/util.c    ****     int i;
  82              		.loc 1 155 1 is_stmt 0 view .LVU10
  83 0000 70B5     		push	{r4, r5, r6, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 16
  86              		.cfi_offset 4, -16
  87              		.cfi_offset 5, -12
  88              		.cfi_offset 6, -8
  89              		.cfi_offset 14, -4
 155:Src/util.c    ****     int i;
  90              		.loc 1 155 1 view .LVU11
  91 0002 0546     		mov	r5, r0
  92 0004 0326     		movs	r6, #3
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 160:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
  93              		.loc 1 160 9 view .LVU12
  94 0006 314C     		ldr	r4, .L8
  95              	.LVL3:
  96              	.L4:
 159:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
  97              		.loc 1 159 9 is_stmt 1 discriminator 3 view .LVU13
  98 0008 0121     		movs	r1, #1
  99 000a 4FF09040 		mov	r0, #1207959552
 100 000e FFF7FEFF 		bl	gpio_bit_set
 101              	.LVL4:
 102              		.loc 1 160 9 discriminator 3 view .LVU14
 103 0012 4FF48071 		mov	r1, #256
 104 0016 2046     		mov	r0, r4
 105 0018 FFF7FEFF 		bl	gpio_bit_reset
 106              	.LVL5:
 161:Src/util.c    ****         delay_1ms(tDelay);
 107              		.loc 1 161 9 discriminator 3 view .LVU15
 108 001c 2846     		mov	r0, r5
 109 001e FFF7FEFF 		bl	delay_1ms
 110              	.LVL6:
 162:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 111              		.loc 1 162 9 discriminator 3 view .LVU16
 112 0022 4FF40071 		mov	r1, #512
 113 0026 2046     		mov	r0, r4
 114 0028 FFF7FEFF 		bl	gpio_bit_set
 115              	.LVL7:
 163:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 116              		.loc 1 163 9 discriminator 3 view .LVU17
 117 002c 0121     		movs	r1, #1
 118 002e 4FF09040 		mov	r0, #1207959552
 119 0032 FFF7FEFF 		bl	gpio_bit_reset
 120              	.LVL8:
 164:Src/util.c    ****         delay_1ms(tDelay);
 121              		.loc 1 164 9 discriminator 3 view .LVU18
 122 0036 2846     		mov	r0, r5
 123 0038 FFF7FEFF 		bl	delay_1ms
ARM GAS  /tmp/ccy0IG4C.s 			page 6


 124              	.LVL9:
 165:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 125              		.loc 1 165 9 discriminator 3 view .LVU19
 126 003c 4FF48071 		mov	r1, #256
 127 0040 2046     		mov	r0, r4
 128 0042 FFF7FEFF 		bl	gpio_bit_set
 129              	.LVL10:
 166:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 130              		.loc 1 166 9 discriminator 3 view .LVU20
 131 0046 4FF40071 		mov	r1, #512
 132 004a 2046     		mov	r0, r4
 133 004c FFF7FEFF 		bl	gpio_bit_reset
 134              	.LVL11:
 167:Src/util.c    ****         delay_1ms(tDelay);
 135              		.loc 1 167 9 discriminator 3 view .LVU21
 136 0050 2846     		mov	r0, r5
 137 0052 FFF7FEFF 		bl	delay_1ms
 138              	.LVL12:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 139              		.loc 1 158 24 discriminator 3 view .LVU22
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 140              		.loc 1 158 17 discriminator 3 view .LVU23
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 141              		.loc 1 158 5 is_stmt 0 discriminator 3 view .LVU24
 142 0056 013E     		subs	r6, r6, #1
 143              	.LVL13:
 158:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 144              		.loc 1 158 5 discriminator 3 view .LVU25
 145 0058 D6D1     		bne	.L4
 146 005a 0226     		movs	r6, #2
 147              	.LVL14:
 168:Src/util.c    ****     }
 169:Src/util.c    **** 
 170:Src/util.c    ****     for (i = 0; i < 2; i++) {
 171:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 172:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 148              		.loc 1 172 9 view .LVU26
 149 005c 1B4C     		ldr	r4, .L8
 150              	.L5:
 151              	.LVL15:
 171:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);
 152              		.loc 1 171 9 is_stmt 1 discriminator 3 view .LVU27
 153 005e 0121     		movs	r1, #1
 154 0060 4FF09040 		mov	r0, #1207959552
 155 0064 FFF7FEFF 		bl	gpio_bit_set
 156              	.LVL16:
 157              		.loc 1 172 9 discriminator 3 view .LVU28
 158 0068 4FF40071 		mov	r1, #512
 159 006c 2046     		mov	r0, r4
 160 006e FFF7FEFF 		bl	gpio_bit_set
 161              	.LVL17:
 173:Src/util.c    ****         gpio_bit_set(LED3_GPIO_Port, LED3_Pin);
 162              		.loc 1 173 9 discriminator 3 view .LVU29
 163 0072 4FF48071 		mov	r1, #256
 164 0076 2046     		mov	r0, r4
 165 0078 FFF7FEFF 		bl	gpio_bit_set
 166              	.LVL18:
ARM GAS  /tmp/ccy0IG4C.s 			page 7


 174:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 167              		.loc 1 174 9 discriminator 3 view .LVU30
 168 007c 2021     		movs	r1, #32
 169 007e 2046     		mov	r0, r4
 170 0080 FFF7FEFF 		bl	gpio_bit_set
 171              	.LVL19:
 175:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 172              		.loc 1 175 9 discriminator 3 view .LVU31
 173 0084 1021     		movs	r1, #16
 174 0086 2046     		mov	r0, r4
 175 0088 FFF7FEFF 		bl	gpio_bit_set
 176              	.LVL20:
 176:Src/util.c    ****         delay_1ms(tDelay);
 177              		.loc 1 176 9 discriminator 3 view .LVU32
 178 008c 2846     		mov	r0, r5
 179 008e FFF7FEFF 		bl	delay_1ms
 180              	.LVL21:
 177:Src/util.c    ****         gpio_bit_reset(LED1_GPIO_Port, LED1_Pin);
 181              		.loc 1 177 9 discriminator 3 view .LVU33
 182 0092 0121     		movs	r1, #1
 183 0094 4FF09040 		mov	r0, #1207959552
 184 0098 FFF7FEFF 		bl	gpio_bit_reset
 185              	.LVL22:
 178:Src/util.c    ****         gpio_bit_reset(LED2_GPIO_Port, LED2_Pin);
 186              		.loc 1 178 9 discriminator 3 view .LVU34
 187 009c 4FF40071 		mov	r1, #512
 188 00a0 2046     		mov	r0, r4
 189 00a2 FFF7FEFF 		bl	gpio_bit_reset
 190              	.LVL23:
 179:Src/util.c    ****         gpio_bit_reset(LED3_GPIO_Port, LED3_Pin);
 191              		.loc 1 179 9 discriminator 3 view .LVU35
 192 00a6 4FF48071 		mov	r1, #256
 193 00aa 2046     		mov	r0, r4
 194 00ac FFF7FEFF 		bl	gpio_bit_reset
 195              	.LVL24:
 180:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 196              		.loc 1 180 9 discriminator 3 view .LVU36
 197 00b0 2021     		movs	r1, #32
 198 00b2 2046     		mov	r0, r4
 199 00b4 FFF7FEFF 		bl	gpio_bit_reset
 200              	.LVL25:
 181:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 201              		.loc 1 181 9 discriminator 3 view .LVU37
 202 00b8 1021     		movs	r1, #16
 203 00ba 2046     		mov	r0, r4
 204 00bc FFF7FEFF 		bl	gpio_bit_reset
 205              	.LVL26:
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 206              		.loc 1 170 24 discriminator 3 view .LVU38
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 207              		.loc 1 170 17 discriminator 3 view .LVU39
 170:Src/util.c    ****         gpio_bit_set(LED1_GPIO_Port, LED1_Pin);
 208              		.loc 1 170 5 is_stmt 0 discriminator 3 view .LVU40
 209 00c0 012E     		cmp	r6, #1
 210 00c2 00D1     		bne	.L6
 182:Src/util.c    ****     }
 183:Src/util.c    **** }
ARM GAS  /tmp/ccy0IG4C.s 			page 8


 211              		.loc 1 183 1 view .LVU41
 212 00c4 70BD     		pop	{r4, r5, r6, pc}
 213              	.LVL27:
 214              	.L6:
 215              		.loc 1 183 1 view .LVU42
 216 00c6 0126     		movs	r6, #1
 217              	.LVL28:
 218              		.loc 1 183 1 view .LVU43
 219 00c8 C9E7     		b	.L5
 220              	.L9:
 221 00ca 00BF     		.align	2
 222              	.L8:
 223 00cc 00040048 		.word	1207960576
 224              		.cfi_endproc
 225              	.LFE61:
 227              		.section	.text.switch_check,"ax",%progbits
 228              		.align	1
 229              		.global	switch_check
 230              		.syntax unified
 231              		.thumb
 232              		.thumb_func
 233              		.fpu softvfp
 235              	switch_check:
 236              	.LVL29:
 237              	.LFB62:
 184:Src/util.c    **** 
 185:Src/util.c    **** 
 186:Src/util.c    **** uint8_t switch_check(uint16_t ch, uint8_t type) {
 238              		.loc 1 186 49 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 187:Src/util.c    ****     if (type) { // 3 positions switch
 243              		.loc 1 187 5 view .LVU45
 244              		.loc 1 187 8 is_stmt 0 view .LVU46
 245 0000 41B1     		cbz	r1, .L11
 188:Src/util.c    ****         if      (ch < 250) return 0;    // switch in position 0
 246              		.loc 1 188 9 is_stmt 1 view .LVU47
 247              		.loc 1 188 17 is_stmt 0 view .LVU48
 248 0002 F928     		cmp	r0, #249
 249 0004 0DD9     		bls	.L13
 189:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 250              		.loc 1 189 14 is_stmt 1 view .LVU49
 190:Src/util.c    ****         else               return 2;    // switch in position 2
 251              		.loc 1 190 35 is_stmt 0 view .LVU50
 252 0006 40F25133 		movw	r3, #849
 253 000a 9842     		cmp	r0, r3
 254 000c 94BF     		ite	ls
 255 000e 0120     		movls	r0, #1
 256 0010 0220     		movhi	r0, #2
 257              	.LVL30:
 258              		.loc 1 190 35 view .LVU51
 259 0012 7047     		bx	lr
 260              	.LVL31:
 261              	.L11:
 191:Src/util.c    ****     } else {    // 2 positions switch
ARM GAS  /tmp/ccy0IG4C.s 			page 9


 192:Src/util.c    ****         return  (ch > 850);
 262              		.loc 1 192 9 is_stmt 1 view .LVU52
 263              		.loc 1 192 21 is_stmt 0 view .LVU53
 264 0014 40F25233 		movw	r3, #850
 265 0018 9842     		cmp	r0, r3
 266 001a 94BF     		ite	ls
 267 001c 0020     		movls	r0, #0
 268              	.LVL32:
 269              		.loc 1 192 21 view .LVU54
 270 001e 0120     		movhi	r0, #1
 271 0020 7047     		bx	lr
 272              	.LVL33:
 273              	.L13:
 188:Src/util.c    ****         else if (ch < 850) return 1;    // switch in position 1
 274              		.loc 1 188 35 view .LVU55
 275 0022 0020     		movs	r0, #0
 276              	.LVL34:
 193:Src/util.c    ****     }
 194:Src/util.c    **** }
 277              		.loc 1 194 1 view .LVU56
 278 0024 7047     		bx	lr
 279              		.cfi_endproc
 280              	.LFE62:
 282              		.section	.text.input_init,"ax",%progbits
 283              		.align	1
 284              		.global	input_init
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 288              		.fpu softvfp
 290              	input_init:
 291              	.LFB63:
 195:Src/util.c    **** 
 196:Src/util.c    **** 
 197:Src/util.c    **** /* =========================== Input Initialization Function =========================== */
 198:Src/util.c    **** 
 199:Src/util.c    **** void input_init(void) {
 292              		.loc 1 199 23 is_stmt 1 view -0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 200:Src/util.c    ****     #ifdef SERIAL_CONTROL
 201:Src/util.c    ****         usart_Tx_DMA_config(USART_MAIN, (uint8_t *)&Sideboard, sizeof(Sideboard));
 296              		.loc 1 201 9 view .LVU58
 199:Src/util.c    ****     #ifdef SERIAL_CONTROL
 297              		.loc 1 199 23 is_stmt 0 view .LVU59
 298 0000 08B5     		push	{r3, lr}
 299              	.LCFI1:
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 3, -8
 302              		.cfi_offset 14, -4
 303              		.loc 1 201 9 view .LVU60
 304 0002 0E22     		movs	r2, #14
 305 0004 0F49     		ldr	r1, .L18
 306 0006 1048     		ldr	r0, .L18+4
 307 0008 FFF7FEFF 		bl	usart_Tx_DMA_config
 308              	.LVL35:
ARM GAS  /tmp/ccy0IG4C.s 			page 10


 202:Src/util.c    ****     #endif
 203:Src/util.c    ****     #if defined(SERIAL_DEBUG) || defined(SERIAL_FEEDBACK)
 204:Src/util.c    ****         usart_Rx_DMA_config(USART_MAIN, (uint8_t *)rx1_buffer, sizeof(rx1_buffer));
 309              		.loc 1 204 9 is_stmt 1 view .LVU61
 310 000c 4022     		movs	r2, #64
 311 000e 0F49     		ldr	r1, .L18+8
 312 0010 0D48     		ldr	r0, .L18+4
 313 0012 FFF7FEFF 		bl	usart_Rx_DMA_config
 314              	.LVL36:
 205:Src/util.c    ****     #endif
 206:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 207:Src/util.c    ****         usart_Tx_DMA_config(USART_AUX, (uint8_t *)&AuxTx, sizeof(AuxTx));
 208:Src/util.c    ****     #endif
 209:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 210:Src/util.c    ****         usart_Rx_DMA_config(USART_AUX, (uint8_t *)rx0_buffer, sizeof(rx0_buffer));
 211:Src/util.c    ****     #endif
 212:Src/util.c    **** 
 213:Src/util.c    ****     intro_demo_led(100);                                // Short LEDs intro demo with 100 ms delay.
 315              		.loc 1 213 5 view .LVU62
 316 0016 6420     		movs	r0, #100
 317 0018 FFF7FEFF 		bl	intro_demo_led
 318              	.LVL37:
 214:Src/util.c    **** 
 215:Src/util.c    ****     #ifdef MPU_SENSOR_ENABLE
 216:Src/util.c    ****         if(mpu_config()) {                              // IMU MPU-6050 config
 319              		.loc 1 216 9 view .LVU63
 320              		.loc 1 216 12 is_stmt 0 view .LVU64
 321 001c FFF7FEFF 		bl	mpu_config
 322              	.LVL38:
 323 0020 0B4B     		ldr	r3, .L18+12
 324              		.loc 1 216 11 view .LVU65
 325 0022 40B1     		cbz	r0, .L16
 217:Src/util.c    ****             mpuStatus = ERROR;
 326              		.loc 1 217 13 is_stmt 1 view .LVU66
 327              		.loc 1 217 23 is_stmt 0 view .LVU67
 328 0024 0022     		movs	r2, #0
 218:Src/util.c    ****             gpio_bit_set(LED1_GPIO_Port, LED1_Pin);     // Turn on RED LED - sensor enabled and NOT
 329              		.loc 1 218 13 view .LVU68
 330 0026 0121     		movs	r1, #1
 331 0028 4FF09040 		mov	r0, #1207959552
 217:Src/util.c    ****             mpuStatus = ERROR;
 332              		.loc 1 217 23 view .LVU69
 333 002c 1A70     		strb	r2, [r3]
 334              		.loc 1 218 13 is_stmt 1 view .LVU70
 335              	.L17:
 219:Src/util.c    ****         }
 220:Src/util.c    ****         else {
 221:Src/util.c    ****             mpuStatus = SUCCESS;
 222:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 223:Src/util.c    ****         }
 224:Src/util.c    ****     #else
 225:Src/util.c    ****         gpio_bit_set(LED2_GPIO_Port, LED2_Pin);         // Turn on GREEN LED - sensor disabled
 226:Src/util.c    ****     #endif
 227:Src/util.c    **** 
 228:Src/util.c    ****     #ifdef SERIAL_DEBUG
 229:Src/util.c    ****         mpu_handle_input('h');                          // Print the User Help commands to serial
 230:Src/util.c    ****     #endif
ARM GAS  /tmp/ccy0IG4C.s 			page 11


 231:Src/util.c    **** }
 336              		.loc 1 231 1 is_stmt 0 view .LVU71
 337 002e BDE80840 		pop	{r3, lr}
 338              	.LCFI2:
 339              		.cfi_remember_state
 340              		.cfi_restore 14
 341              		.cfi_restore 3
 342              		.cfi_def_cfa_offset 0
 222:Src/util.c    ****         }
 343              		.loc 1 222 13 view .LVU72
 344 0032 FFF7FEBF 		b	gpio_bit_set
 345              	.LVL39:
 346              	.L16:
 347              	.LCFI3:
 348              		.cfi_restore_state
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 349              		.loc 1 221 13 is_stmt 1 view .LVU73
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 350              		.loc 1 221 23 is_stmt 0 view .LVU74
 351 0036 0122     		movs	r2, #1
 222:Src/util.c    ****         }
 352              		.loc 1 222 13 view .LVU75
 353 0038 4FF40071 		mov	r1, #512
 354 003c 0548     		ldr	r0, .L18+16
 221:Src/util.c    ****             gpio_bit_set(LED2_GPIO_Port, LED2_Pin);     // Turn on GREEN LED - sensor enabled and o
 355              		.loc 1 221 23 view .LVU76
 356 003e 1A70     		strb	r2, [r3]
 222:Src/util.c    ****         }
 357              		.loc 1 222 13 is_stmt 1 view .LVU77
 358 0040 F5E7     		b	.L17
 359              	.L19:
 360 0042 00BF     		.align	2
 361              	.L18:
 362 0044 00000000 		.word	.LANCHOR0
 363 0048 00440040 		.word	1073759232
 364 004c 00000000 		.word	.LANCHOR1
 365 0050 00000000 		.word	.LANCHOR2
 366 0054 00040048 		.word	1207960576
 367              		.cfi_endproc
 368              	.LFE63:
 370              		.section	.text.handle_mpu6050,"ax",%progbits
 371              		.align	1
 372              		.global	handle_mpu6050
 373              		.syntax unified
 374              		.thumb
 375              		.thumb_func
 376              		.fpu softvfp
 378              	handle_mpu6050:
 379              	.LFB64:
 232:Src/util.c    **** 
 233:Src/util.c    **** 
 234:Src/util.c    **** /* =========================== Handle Functions =========================== */
 235:Src/util.c    **** 
 236:Src/util.c    **** /*
 237:Src/util.c    ****  * Handle of the MPU-6050 IMU sensor
 238:Src/util.c    ****  */
 239:Src/util.c    **** void handle_mpu6050(void) {
ARM GAS  /tmp/ccy0IG4C.s 			page 12


 380              		.loc 1 239 27 view -0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              		@ link register save eliminated.
 240:Src/util.c    **** #ifdef MPU_SENSOR_ENABLE
 241:Src/util.c    ****     // Get MPU data. Because the MPU-6050 interrupt pin is not wired we have to check DMP data by p
 242:Src/util.c    ****     if (SUCCESS == mpuStatus) {
 385              		.loc 1 242 5 view .LVU79
 386              		.loc 1 242 17 is_stmt 0 view .LVU80
 387 0000 0A4B     		ldr	r3, .L23
 388 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 389              		.loc 1 242 8 view .LVU81
 390 0004 012B     		cmp	r3, #1
 391 0006 01D1     		bne	.L21
 243:Src/util.c    ****         mpu_get_data();
 392              		.loc 1 243 9 is_stmt 1 view .LVU82
 393 0008 FFF7FEBF 		b	mpu_get_data
 394              	.LVL40:
 395              	.L21:
 244:Src/util.c    ****     } else if (ERROR == mpuStatus && main_loop_counter % 100 == 0) {
 396              		.loc 1 244 12 view .LVU83
 397              		.loc 1 244 15 is_stmt 0 view .LVU84
 398 000c 6BB9     		cbnz	r3, .L20
 399 000e 6422     		movs	r2, #100
 400              		.loc 1 244 56 discriminator 1 view .LVU85
 401 0010 074B     		ldr	r3, .L23+4
 402 0012 1B68     		ldr	r3, [r3]
 403 0014 B3FBF2F1 		udiv	r1, r3, r2
 404 0018 02FB1133 		mls	r3, r2, r1, r3
 405              		.loc 1 244 35 discriminator 1 view .LVU86
 406 001c 2BB9     		cbnz	r3, .L20
 245:Src/util.c    ****         toggle_led(LED1_GPIO_Port, LED1_Pin);                    // Toggle the Red LED every 100 ms
 407              		.loc 1 245 9 is_stmt 1 view .LVU87
 408              	.LVL41:
 409              	.LBB14:
 410              	.LBI14:
 148:Src/util.c    **** {
 411              		.loc 1 148 6 view .LVU88
 412              	.LBB15:
 150:Src/util.c    **** }
 413              		.loc 1 150 5 view .LVU89
 150:Src/util.c    **** }
 414              		.loc 1 150 28 is_stmt 0 view .LVU90
 415 001e 4FF09042 		mov	r2, #1207959552
 416 0022 5369     		ldr	r3, [r2, #20]
 417 0024 83F00103 		eor	r3, r3, #1
 418 0028 5361     		str	r3, [r2, #20]
 419              	.LVL42:
 420              	.L20:
 150:Src/util.c    **** }
 421              		.loc 1 150 28 view .LVU91
 422              	.LBE15:
 423              	.LBE14:
 246:Src/util.c    ****     }
 247:Src/util.c    ****     // Print MPU data to Console
 248:Src/util.c    ****     #ifdef SERIAL_DEBUG
ARM GAS  /tmp/ccy0IG4C.s 			page 13


 249:Src/util.c    ****     if (main_loop_counter % 50 == 0) {
 250:Src/util.c    ****         mpu_print_to_console();
 251:Src/util.c    ****     }
 252:Src/util.c    ****     #endif
 253:Src/util.c    **** #endif
 254:Src/util.c    **** }
 424              		.loc 1 254 1 view .LVU92
 425 002a 7047     		bx	lr
 426              	.L24:
 427              		.align	2
 428              	.L23:
 429 002c 00000000 		.word	.LANCHOR2
 430 0030 00000000 		.word	main_loop_counter
 431              		.cfi_endproc
 432              	.LFE64:
 434              		.section	.text.handle_sensors,"ax",%progbits
 435              		.align	1
 436              		.global	handle_sensors
 437              		.syntax unified
 438              		.thumb
 439              		.thumb_func
 440              		.fpu softvfp
 442              	handle_sensors:
 443              	.LFB65:
 255:Src/util.c    **** 
 256:Src/util.c    **** /*
 257:Src/util.c    ****  * Handle of the optical sensors
 258:Src/util.c    ****  */
 259:Src/util.c    **** void handle_sensors(void) {
 444              		.loc 1 259 27 is_stmt 1 view -0
 445              		.cfi_startproc
 446              		@ args = 0, pretend = 0, frame = 0
 447              		@ frame_needed = 0, uses_anonymous_args = 0
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 448              		.loc 1 260 5 view .LVU94
 259:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 449              		.loc 1 259 27 is_stmt 0 view .LVU95
 450 0000 38B5     		push	{r3, r4, r5, lr}
 451              	.LCFI4:
 452              		.cfi_def_cfa_offset 16
 453              		.cfi_offset 3, -16
 454              		.cfi_offset 4, -12
 455              		.cfi_offset 5, -8
 456              		.cfi_offset 14, -4
 457              		.loc 1 260 20 view .LVU96
 458 0002 1021     		movs	r1, #16
 459 0004 4FF09040 		mov	r0, #1207959552
 460 0008 FFF7FEFF 		bl	gpio_input_bit_get
 461              	.LVL43:
 462              		.loc 1 260 18 view .LVU97
 463 000c 1B4D     		ldr	r5, .L30
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 464              		.loc 1 261 20 view .LVU98
 465 000e 4FF48041 		mov	r1, #16384
 260:Src/util.c    ****     sensor1_read = gpio_input_bit_get(SENSOR1_GPIO_Port, SENSOR1_Pin);
 466              		.loc 1 260 18 view .LVU99
 467 0012 2870     		strb	r0, [r5]
ARM GAS  /tmp/ccy0IG4C.s 			page 14


 468              		.loc 1 261 5 is_stmt 1 view .LVU100
 469              		.loc 1 261 20 is_stmt 0 view .LVU101
 470 0014 1A48     		ldr	r0, .L30+4
 471 0016 FFF7FEFF 		bl	gpio_input_bit_get
 472              	.LVL44:
 262:Src/util.c    **** 
 263:Src/util.c    ****     // SENSOR1
 264:Src/util.c    ****     if (sensor1 == RESET && sensor1_read == SET) {
 473              		.loc 1 264 17 view .LVU102
 474 001a 1A4B     		ldr	r3, .L30+8
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 475              		.loc 1 261 18 view .LVU103
 476 001c 1A4C     		ldr	r4, .L30+12
 477              		.loc 1 264 17 view .LVU104
 478 001e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 261:Src/util.c    ****     sensor2_read = gpio_input_bit_get(SENSOR2_GPIO_Port, SENSOR2_Pin);
 479              		.loc 1 261 18 view .LVU105
 480 0020 2070     		strb	r0, [r4]
 481              		.loc 1 264 5 is_stmt 1 view .LVU106
 482              		.loc 1 264 8 is_stmt 0 view .LVU107
 483 0022 A2B9     		cbnz	r2, .L26
 484              		.loc 1 264 26 discriminator 1 view .LVU108
 485 0024 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 486 0026 012A     		cmp	r2, #1
 487 0028 04D1     		bne	.L27
 265:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 266:Src/util.c    ****         sensor1 = SET;
 488              		.loc 1 266 9 is_stmt 1 view .LVU109
 267:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 489              		.loc 1 267 9 is_stmt 0 view .LVU110
 490 002a 2021     		movs	r1, #32
 491 002c 1748     		ldr	r0, .L30+16
 266:Src/util.c    ****         gpio_bit_set(LED4_GPIO_Port, LED4_Pin);
 492              		.loc 1 266 17 view .LVU111
 493 002e 1A70     		strb	r2, [r3]
 494              		.loc 1 267 9 is_stmt 1 view .LVU112
 495 0030 FFF7FEFF 		bl	gpio_bit_set
 496              	.LVL45:
 268:Src/util.c    ****         consoleLog("SENSOR 1 ON\r\n");
 497              		.loc 1 268 9 view .LVU113
 498              	.LBB16:
 499              	.LBI16:
 117:Src/util.c    **** {
 500              		.loc 1 117 6 view .LVU114
 501              	.LBB17:
 122:Src/util.c    **** 
 502              		.loc 1 122 1 view .LVU115
 503              	.L27:
 122:Src/util.c    **** 
 504              		.loc 1 122 1 is_stmt 0 view .LVU116
 505              	.LBE17:
 506              	.LBE16:
 269:Src/util.c    ****     } else if(sensor1 == SET && sensor1_read == RESET) {
 270:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 271:Src/util.c    ****         sensor1 = RESET;
 272:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 273:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
ARM GAS  /tmp/ccy0IG4C.s 			page 15


 274:Src/util.c    ****     }
 275:Src/util.c    **** 
 276:Src/util.c    ****     // SENSOR2
 277:Src/util.c    ****     if (sensor2 == RESET && sensor2_read == SET) {
 507              		.loc 1 277 5 is_stmt 1 view .LVU117
 508              		.loc 1 277 17 is_stmt 0 view .LVU118
 509 0034 164B     		ldr	r3, .L30+20
 510 0036 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 511              		.loc 1 277 8 view .LVU119
 512 0038 A2B9     		cbnz	r2, .L28
 513              		.loc 1 277 26 discriminator 1 view .LVU120
 514 003a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 515 003c 012A     		cmp	r2, #1
 516 003e 1CD1     		bne	.L25
 278:Src/util.c    ****         // Sensor ACTIVE: Do something here (one time task on activation)
 279:Src/util.c    ****         sensor2 = SET;
 517              		.loc 1 279 9 is_stmt 1 view .LVU121
 518              		.loc 1 279 17 is_stmt 0 view .LVU122
 519 0040 1A70     		strb	r2, [r3]
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 520              		.loc 1 280 9 is_stmt 1 view .LVU123
 521 0042 1021     		movs	r1, #16
 281:Src/util.c    ****         consoleLog("SENSOR 2 ON\r\n");
 282:Src/util.c    ****     } else if (sensor2 == SET && sensor2_read == RESET) {
 283:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 284:Src/util.c    ****         sensor2 = RESET;
 285:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 286:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 287:Src/util.c    ****     }
 288:Src/util.c    **** 
 289:Src/util.c    ****     if (sensor1 == SET) {
 290:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 291:Src/util.c    ****     }
 292:Src/util.c    ****     if (sensor2 == SET) {
 293:Src/util.c    ****         // Sensor ACTIVE: Do something here (continuous task)
 294:Src/util.c    ****     }
 295:Src/util.c    **** }
 522              		.loc 1 295 1 is_stmt 0 view .LVU124
 523 0044 BDE83840 		pop	{r3, r4, r5, lr}
 524              	.LCFI5:
 525              		.cfi_remember_state
 526              		.cfi_restore 14
 527              		.cfi_restore 5
 528              		.cfi_restore 4
 529              		.cfi_restore 3
 530              		.cfi_def_cfa_offset 0
 280:Src/util.c    ****         gpio_bit_set(LED5_GPIO_Port, LED5_Pin);
 531              		.loc 1 280 9 view .LVU125
 532 0048 1048     		ldr	r0, .L30+16
 533 004a FFF7FEBF 		b	gpio_bit_set
 534              	.LVL46:
 535              	.L26:
 536              	.LCFI6:
 537              		.cfi_restore_state
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 538              		.loc 1 269 12 is_stmt 1 view .LVU126
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
ARM GAS  /tmp/ccy0IG4C.s 			page 16


 539              		.loc 1 269 14 is_stmt 0 view .LVU127
 540 004e 012A     		cmp	r2, #1
 541 0050 F0D1     		bne	.L27
 269:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 542              		.loc 1 269 30 discriminator 1 view .LVU128
 543 0052 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 544 0054 002A     		cmp	r2, #0
 545 0056 EDD1     		bne	.L27
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 546              		.loc 1 271 9 is_stmt 1 view .LVU129
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 547              		.loc 1 272 9 is_stmt 0 view .LVU130
 548 0058 2021     		movs	r1, #32
 549 005a 0C48     		ldr	r0, .L30+16
 271:Src/util.c    ****         gpio_bit_reset(LED4_GPIO_Port, LED4_Pin);
 550              		.loc 1 271 17 view .LVU131
 551 005c 1A70     		strb	r2, [r3]
 272:Src/util.c    ****         consoleLog("SENSOR 1 OFF\r\n");
 552              		.loc 1 272 9 is_stmt 1 view .LVU132
 553 005e FFF7FEFF 		bl	gpio_bit_reset
 554              	.LVL47:
 273:Src/util.c    ****     }
 555              		.loc 1 273 9 view .LVU133
 556              	.LBB18:
 557              	.LBI18:
 117:Src/util.c    **** {
 558              		.loc 1 117 6 view .LVU134
 559              	.LBB19:
 122:Src/util.c    **** 
 560              		.loc 1 122 1 view .LVU135
 561 0062 E7E7     		b	.L27
 562              	.LVL48:
 563              	.L28:
 122:Src/util.c    **** 
 564              		.loc 1 122 1 is_stmt 0 view .LVU136
 565              	.LBE19:
 566              	.LBE18:
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 567              		.loc 1 282 12 is_stmt 1 view .LVU137
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 568              		.loc 1 282 15 is_stmt 0 view .LVU138
 569 0064 012A     		cmp	r2, #1
 570 0066 08D1     		bne	.L25
 282:Src/util.c    ****         // Sensor DEACTIVE: Do something here (one time task on deactivation)
 571              		.loc 1 282 31 discriminator 1 view .LVU139
 572 0068 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 573 006a 32B9     		cbnz	r2, .L25
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 574              		.loc 1 284 9 is_stmt 1 view .LVU140
 284:Src/util.c    ****         gpio_bit_reset(LED5_GPIO_Port, LED5_Pin);
 575              		.loc 1 284 17 is_stmt 0 view .LVU141
 576 006c 1A70     		strb	r2, [r3]
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 577              		.loc 1 285 9 is_stmt 1 view .LVU142
 578 006e 1021     		movs	r1, #16
 579              		.loc 1 295 1 is_stmt 0 view .LVU143
 580 0070 BDE83840 		pop	{r3, r4, r5, lr}
ARM GAS  /tmp/ccy0IG4C.s 			page 17


 581              	.LCFI7:
 582              		.cfi_remember_state
 583              		.cfi_restore 14
 584              		.cfi_restore 5
 585              		.cfi_restore 4
 586              		.cfi_restore 3
 587              		.cfi_def_cfa_offset 0
 285:Src/util.c    ****         consoleLog("SENSOR 2 OFF\r\n");
 588              		.loc 1 285 9 view .LVU144
 589 0074 0548     		ldr	r0, .L30+16
 590 0076 FFF7FEBF 		b	gpio_bit_reset
 591              	.LVL49:
 592              	.L25:
 593              	.LCFI8:
 594              		.cfi_restore_state
 595              		.loc 1 295 1 view .LVU145
 596 007a 38BD     		pop	{r3, r4, r5, pc}
 597              	.L31:
 598              		.align	2
 599              	.L30:
 600 007c 00000000 		.word	.LANCHOR3
 601 0080 00080048 		.word	1207961600
 602 0084 00000000 		.word	.LANCHOR5
 603 0088 00000000 		.word	.LANCHOR4
 604 008c 00040048 		.word	1207960576
 605 0090 00000000 		.word	.LANCHOR6
 606              		.cfi_endproc
 607              	.LFE65:
 609              		.section	.text.handle_usart,"ax",%progbits
 610              		.align	1
 611              		.global	handle_usart
 612              		.syntax unified
 613              		.thumb
 614              		.thumb_func
 615              		.fpu softvfp
 617              	handle_usart:
 618              	.LFB66:
 296:Src/util.c    **** 
 297:Src/util.c    **** 
 298:Src/util.c    **** 
 299:Src/util.c    **** 
 300:Src/util.c    **** /*
 301:Src/util.c    ****  * Handle of the USART data
 302:Src/util.c    ****  */
 303:Src/util.c    **** void handle_usart(void) {
 619              		.loc 1 303 25 is_stmt 1 view -0
 620              		.cfi_startproc
 621              		@ args = 0, pretend = 0, frame = 16
 622              		@ frame_needed = 0, uses_anonymous_args = 0
 304:Src/util.c    ****     // Tx USART MAIN
 305:Src/util.c    ****     #ifdef SERIAL_CONTROL
 306:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART1_TX_DMA_CH) == 0) {     // 
 623              		.loc 1 306 9 view .LVU147
 624              		.loc 1 306 31 is_stmt 0 view .LVU148
 625 0000 4D4B     		ldr	r3, .L40
 303:Src/util.c    ****     // Tx USART MAIN
 626              		.loc 1 303 25 view .LVU149
ARM GAS  /tmp/ccy0IG4C.s 			page 18


 627 0002 4E4A     		ldr	r2, .L40+4
 628 0004 1B68     		ldr	r3, [r3]
 629 0006 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 630              	.LCFI9:
 631              		.cfi_def_cfa_offset 36
 632              		.cfi_offset 4, -36
 633              		.cfi_offset 5, -32
 634              		.cfi_offset 6, -28
 635              		.cfi_offset 7, -24
 636              		.cfi_offset 8, -20
 637              		.cfi_offset 9, -16
 638              		.cfi_offset 10, -12
 639              		.cfi_offset 11, -8
 640              		.cfi_offset 14, -4
 641 000a 5343     		muls	r3, r2, r3
 642              		.loc 1 306 12 view .LVU150
 643 000c B3F1333F 		cmp	r3, #858993459
 303:Src/util.c    ****     // Tx USART MAIN
 644              		.loc 1 303 25 view .LVU151
 645 0010 85B0     		sub	sp, sp, #20
 646              	.LCFI10:
 647              		.cfi_def_cfa_offset 56
 648              		.loc 1 306 12 view .LVU152
 649 0012 6DD8     		bhi	.L34
 650              		.loc 1 306 43 discriminator 1 view .LVU153
 651 0014 0320     		movs	r0, #3
 652 0016 FFF7FEFF 		bl	dma_transfer_number_get
 653              	.LVL50:
 654              		.loc 1 306 40 discriminator 1 view .LVU154
 655 001a 0028     		cmp	r0, #0
 656 001c 68D1     		bne	.L34
 307:Src/util.c    ****             sideboard_imu.start = (uint16_t)SERIAL_START_FRAME;
 657              		.loc 1 307 13 is_stmt 1 view .LVU155
 658              		.loc 1 307 33 is_stmt 0 view .LVU156
 659 001e 4AF6CD33 		movw	r3, 43981	@ movhi
 660 0022 474C     		ldr	r4, .L40+8
 661 0024 2380     		strh	r3, [r4]	@ movhi
 308:Src/util.c    **** 
 309:Src/util.c    ****             sideboard_imu.gyro_x = (int16_t)mpu.gyro.x;
 662              		.loc 1 309 13 is_stmt 1 view .LVU157
 663              		.loc 1 309 53 is_stmt 0 view .LVU158
 664 0026 474B     		ldr	r3, .L40+12
 310:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 311:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 312:Src/util.c    ****             
 313:Src/util.c    ****             sideboard_imu.accel_x = (int16_t)mpu.accel.x;
 314:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 315:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 316:Src/util.c    ****         
 317:Src/util.c    ****             sideboard_imu.quat_w = (int16_t)mpu.quat.w;
 318:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 665              		.loc 1 318 36 view .LVU159
 666 0028 B3F91020 		ldrsh	r2, [r3, #16]
 314:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 667              		.loc 1 314 55 view .LVU160
 668 002c B3F908E0 		ldrsh	lr, [r3, #8]
 669              		.loc 1 318 36 view .LVU161
ARM GAS  /tmp/ccy0IG4C.s 			page 19


 670 0030 0192     		str	r2, [sp, #4]
 671              		.loc 1 318 34 view .LVU162
 672 0032 2282     		strh	r2, [r4, #16]	@ movhi
 319:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 673              		.loc 1 319 36 view .LVU163
 674 0034 B3F91420 		ldrsh	r2, [r3, #20]
 315:Src/util.c    ****         
 675              		.loc 1 315 55 view .LVU164
 676 0038 B3F90AC0 		ldrsh	ip, [r3, #10]
 677              		.loc 1 319 36 view .LVU165
 678 003c 0292     		str	r2, [sp, #8]
 679              		.loc 1 319 34 view .LVU166
 680 003e 6282     		strh	r2, [r4, #18]	@ movhi
 320:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 681              		.loc 1 320 36 view .LVU167
 682 0040 B3F91820 		ldrsh	r2, [r3, #24]
 317:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 683              		.loc 1 317 36 view .LVU168
 684 0044 B3F90C10 		ldrsh	r1, [r3, #12]
 321:Src/util.c    ****  
 322:Src/util.c    ****             sideboard_imu.euler_pitch = (int16_t)mpu.euler.pitch;
 323:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 324:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 325:Src/util.c    ****             
 326:Src/util.c    ****             sideboard_imu.temperature = (int16_t)mpu.temp;
 685              		.loc 1 326 53 view .LVU169
 686 0048 B3F92200 		ldrsh	r0, [r3, #34]
 309:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 687              		.loc 1 309 53 view .LVU170
 688 004c B3F900A0 		ldrsh	r10, [r3]
 310:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 689              		.loc 1 310 53 view .LVU171
 690 0050 B3F902B0 		ldrsh	fp, [r3, #2]
 311:Src/util.c    ****             
 691              		.loc 1 311 53 view .LVU172
 692 0054 B3F90490 		ldrsh	r9, [r3, #4]
 313:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 693              		.loc 1 313 55 view .LVU173
 694 0058 B3F90680 		ldrsh	r8, [r3, #6]
 322:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 695              		.loc 1 322 59 view .LVU174
 696 005c B3F91E70 		ldrsh	r7, [r3, #30]
 323:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 697              		.loc 1 323 58 view .LVU175
 698 0060 B3F91C60 		ldrsh	r6, [r3, #28]
 324:Src/util.c    ****             
 699              		.loc 1 324 57 view .LVU176
 700 0064 B3F92050 		ldrsh	r5, [r3, #32]
 320:Src/util.c    ****  
 701              		.loc 1 320 36 view .LVU177
 702 0068 0392     		str	r2, [sp, #12]
 320:Src/util.c    ****  
 703              		.loc 1 320 34 view .LVU178
 704 006a A282     		strh	r2, [r4, #20]	@ movhi
 327:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 705              		.loc 1 327 87 view .LVU179
 706 006c 364B     		ldr	r3, .L40+16
ARM GAS  /tmp/ccy0IG4C.s 			page 20


 707              		.loc 1 327 106 view .LVU180
 708 006e 374A     		ldr	r2, .L40+20
 309:Src/util.c    ****             sideboard_imu.gyro_y = (int16_t)mpu.gyro.y;
 709              		.loc 1 309 34 view .LVU181
 710 0070 A4F802A0 		strh	r10, [r4, #2]	@ movhi
 310:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 711              		.loc 1 310 13 is_stmt 1 view .LVU182
 314:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 712              		.loc 1 314 35 is_stmt 0 view .LVU183
 713 0074 A4F80AE0 		strh	lr, [r4, #10]	@ movhi
 315:Src/util.c    ****         
 714              		.loc 1 315 35 view .LVU184
 715 0078 A4F80CC0 		strh	ip, [r4, #12]	@ movhi
 317:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 716              		.loc 1 317 34 view .LVU185
 717 007c E181     		strh	r1, [r4, #14]	@ movhi
 326:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 718              		.loc 1 326 39 view .LVU186
 719 007e A083     		strh	r0, [r4, #28]	@ movhi
 310:Src/util.c    ****             sideboard_imu.gyro_z = (int16_t)mpu.gyro.z;
 720              		.loc 1 310 34 view .LVU187
 721 0080 A4F804B0 		strh	fp, [r4, #4]	@ movhi
 311:Src/util.c    ****             
 722              		.loc 1 311 13 is_stmt 1 view .LVU188
 311:Src/util.c    ****             
 723              		.loc 1 311 34 is_stmt 0 view .LVU189
 724 0084 A4F80690 		strh	r9, [r4, #6]	@ movhi
 313:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 725              		.loc 1 313 13 is_stmt 1 view .LVU190
 313:Src/util.c    ****             sideboard_imu.accel_y = (int16_t)mpu.accel.y;
 726              		.loc 1 313 35 is_stmt 0 view .LVU191
 727 0088 A4F80880 		strh	r8, [r4, #8]	@ movhi
 314:Src/util.c    ****             sideboard_imu.accel_z = (int16_t)mpu.accel.z;
 728              		.loc 1 314 13 is_stmt 1 view .LVU192
 315:Src/util.c    ****         
 729              		.loc 1 315 13 view .LVU193
 317:Src/util.c    ****             sideboard_imu.quat_x = (int16_t)mpu.quat.x;
 730              		.loc 1 317 13 view .LVU194
 318:Src/util.c    ****             sideboard_imu.quat_y = (int16_t)mpu.quat.y;
 731              		.loc 1 318 13 view .LVU195
 319:Src/util.c    ****             sideboard_imu.quat_z = (int16_t)mpu.quat.z;
 732              		.loc 1 319 13 view .LVU196
 320:Src/util.c    ****  
 733              		.loc 1 320 13 view .LVU197
 322:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 734              		.loc 1 322 13 view .LVU198
 322:Src/util.c    ****             sideboard_imu.euler_roll = (int16_t)mpu.euler.roll;
 735              		.loc 1 322 39 is_stmt 0 view .LVU199
 736 008c E782     		strh	r7, [r4, #22]	@ movhi
 323:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 737              		.loc 1 323 13 is_stmt 1 view .LVU200
 323:Src/util.c    ****             sideboard_imu.euler_yaw = (int16_t)mpu.euler.yaw;
 738              		.loc 1 323 38 is_stmt 0 view .LVU201
 739 008e 2683     		strh	r6, [r4, #24]	@ movhi
 324:Src/util.c    ****             
 740              		.loc 1 324 13 is_stmt 1 view .LVU202
 324:Src/util.c    ****             
ARM GAS  /tmp/ccy0IG4C.s 			page 21


 741              		.loc 1 324 37 is_stmt 0 view .LVU203
 742 0090 6583     		strh	r5, [r4, #26]	@ movhi
 326:Src/util.c    ****             sideboard_imu.sensors = (uint16_t)((cmdSwitch << 8) | (sensor1 | (sensor2 << 1) | (mpuS
 743              		.loc 1 326 13 is_stmt 1 view .LVU204
 744              		.loc 1 327 13 view .LVU205
 745              		.loc 1 327 87 is_stmt 0 view .LVU206
 746 0092 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 747              		.loc 1 327 106 view .LVU207
 748 0094 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 328:Src/util.c    **** 
 329:Src/util.c    ****             sideboard_imu.checksum = (uint16_t)(
 330:Src/util.c    ****                 sideboard_imu.start ^ 
 331:Src/util.c    ****                 sideboard_imu.gyro_x ^ sideboard_imu.gyro_y ^ sideboard_imu.gyro_z ^
 332:Src/util.c    ****                 sideboard_imu.accel_x ^ sideboard_imu.accel_y ^ sideboard_imu.accel_z ^
 333:Src/util.c    ****                 sideboard_imu.quat_w ^ sideboard_imu.quat_x ^ sideboard_imu.quat_y ^ sideboard_imu.
 334:Src/util.c    ****                 sideboard_imu.euler_pitch ^ sideboard_imu.euler_roll ^ sideboard_imu.euler_yaw ^
 335:Src/util.c    ****                 sideboard_imu.temperature ^ sideboard_imu.sensors
 749              		.loc 1 335 43 view .LVU208
 750 0096 8AEA0B0A 		eor	r10, r10, fp
 327:Src/util.c    **** 
 751              		.loc 1 327 106 view .LVU209
 752 009a 9200     		lsls	r2, r2, #2
 327:Src/util.c    **** 
 753              		.loc 1 327 93 view .LVU210
 754 009c 42EA4302 		orr	r2, r2, r3, lsl #1
 327:Src/util.c    **** 
 755              		.loc 1 327 76 view .LVU211
 756 00a0 2B4B     		ldr	r3, .L40+24
 757 00a2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 327:Src/util.c    **** 
 758              		.loc 1 327 93 view .LVU212
 759 00a4 1343     		orrs	r3, r3, r2
 327:Src/util.c    **** 
 760              		.loc 1 327 35 view .LVU213
 761 00a6 E383     		strh	r3, [r4, #30]	@ movhi
 329:Src/util.c    ****                 sideboard_imu.start ^ 
 762              		.loc 1 329 13 is_stmt 1 view .LVU214
 763              		.loc 1 335 43 is_stmt 0 view .LVU215
 764 00a8 83EA0A03 		eor	r3, r3, r10
 765 00ac 89EA0303 		eor	r3, r9, r3
 766 00b0 88EA0303 		eor	r3, r8, r3
 767 00b4 8EEA0303 		eor	r3, lr, r3
 768 00b8 8CEA0303 		eor	r3, ip, r3
 769 00bc 7B40     		eors	r3, r3, r7
 770 00be 7340     		eors	r3, r3, r6
 771 00c0 6B40     		eors	r3, r3, r5
 772 00c2 019A     		ldr	r2, [sp, #4]
 773 00c4 4340     		eors	r3, r3, r0
 774 00c6 4B40     		eors	r3, r3, r1
 775 00c8 5340     		eors	r3, r3, r2
 776 00ca 029A     		ldr	r2, [sp, #8]
 336:Src/util.c    ****             );
 337:Src/util.c    ****         
 338:Src/util.c    ****             dma_channel_disable(USART1_TX_DMA_CH);
 777              		.loc 1 338 13 view .LVU216
 778 00cc 0320     		movs	r0, #3
 335:Src/util.c    ****             );
ARM GAS  /tmp/ccy0IG4C.s 			page 22


 779              		.loc 1 335 43 view .LVU217
 780 00ce 5340     		eors	r3, r3, r2
 781 00d0 039A     		ldr	r2, [sp, #12]
 782 00d2 5340     		eors	r3, r3, r2
 783 00d4 83F42B43 		eor	r3, r3, #43776
 784 00d8 83F0CD03 		eor	r3, r3, #205
 329:Src/util.c    ****                 sideboard_imu.start ^ 
 785              		.loc 1 329 36 view .LVU218
 786 00dc 2384     		strh	r3, [r4, #32]	@ movhi
 787              		.loc 1 338 13 is_stmt 1 view .LVU219
 788 00de FFF7FEFF 		bl	dma_channel_disable
 789              	.LVL51:
 339:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 790              		.loc 1 339 13 view .LVU220
 791              		.loc 1 339 45 is_stmt 0 view .LVU221
 792 00e2 2222     		movs	r2, #34
 793 00e4 1B4B     		ldr	r3, .L40+28
 340:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 341:Src/util.c    ****             dma_channel_enable(USART1_TX_DMA_CH);
 794              		.loc 1 341 13 view .LVU222
 795 00e6 0320     		movs	r0, #3
 339:Src/util.c    ****             DMA_CHCNT(USART1_TX_DMA_CH)     = sizeof(sideboard_imu);
 796              		.loc 1 339 45 view .LVU223
 797 00e8 9A64     		str	r2, [r3, #72]
 340:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 798              		.loc 1 340 13 is_stmt 1 view .LVU224
 340:Src/util.c    ****             DMA_CHMADDR(USART1_TX_DMA_CH)   = (uint32_t)&sideboard_imu;
 799              		.loc 1 340 45 is_stmt 0 view .LVU225
 800 00ea 1C65     		str	r4, [r3, #80]
 801              		.loc 1 341 13 is_stmt 1 view .LVU226
 802 00ec FFF7FEFF 		bl	dma_channel_enable
 803              	.LVL52:
 804              	.L34:
 342:Src/util.c    ****         }
 343:Src/util.c    ****     #endif
 344:Src/util.c    ****     // Rx USART MAIN
 345:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 346:Src/util.c    ****         if (timeoutCntSerial1++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 805              		.loc 1 346 9 view .LVU227
 806              		.loc 1 346 30 is_stmt 0 view .LVU228
 807 00f0 194B     		ldr	r3, .L40+32
 808 00f2 1A88     		ldrh	r2, [r3]
 809 00f4 511C     		adds	r1, r2, #1
 810              		.loc 1 346 12 view .LVU229
 811 00f6 B2F5167F 		cmp	r2, #600
 812              		.loc 1 346 30 view .LVU230
 813 00fa 1980     		strh	r1, [r3]	@ movhi
 814 00fc 174A     		ldr	r2, .L40+36
 815              		.loc 1 346 12 view .LVU231
 816 00fe 15D3     		bcc	.L36
 347:Src/util.c    ****             timeoutFlagSerial1 = 1;                                 // Timeout detected
 817              		.loc 1 347 13 is_stmt 1 view .LVU232
 818              		.loc 1 347 32 is_stmt 0 view .LVU233
 819 0100 0121     		movs	r1, #1
 820 0102 1170     		strb	r1, [r2]
 348:Src/util.c    ****             timeoutCntSerial1  = SERIAL_TIMEOUT;                    // Limit timout counter value
 821              		.loc 1 348 13 is_stmt 1 view .LVU234
ARM GAS  /tmp/ccy0IG4C.s 			page 23


 822              		.loc 1 348 32 is_stmt 0 view .LVU235
 823 0104 4FF41672 		mov	r2, #600
 824 0108 1A80     		strh	r2, [r3]	@ movhi
 349:Src/util.c    ****         }
 350:Src/util.c    ****         if (timeoutFlagSerial1 && main_loop_counter % 100 == 0) {   // In case of timeout bring the
 825              		.loc 1 350 9 is_stmt 1 view .LVU236
 826              	.L37:
 827 010a 6422     		movs	r2, #100
 828              		.loc 1 350 53 is_stmt 0 discriminator 1 view .LVU237
 829 010c 0A4B     		ldr	r3, .L40
 830 010e 1B68     		ldr	r3, [r3]
 831 0110 B3FBF2F1 		udiv	r1, r3, r2
 832 0114 02FB1133 		mls	r3, r2, r1, r3
 833              		.loc 1 350 32 discriminator 1 view .LVU238
 834 0118 5BB9     		cbnz	r3, .L32
 351:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 835              		.loc 1 351 13 is_stmt 1 view .LVU239
 836              	.LVL53:
 837              	.LBB20:
 838              	.LBI20:
 148:Src/util.c    **** {
 839              		.loc 1 148 6 view .LVU240
 840              	.LBB21:
 150:Src/util.c    **** }
 841              		.loc 1 150 5 view .LVU241
 150:Src/util.c    **** }
 842              		.loc 1 150 28 is_stmt 0 view .LVU242
 843 011a 4FF09042 		mov	r2, #1207959552
 844 011e D2F81434 		ldr	r3, [r2, #1044]
 845 0122 83F48073 		eor	r3, r3, #256
 846 0126 C2F81434 		str	r3, [r2, #1044]
 847              	.LVL54:
 150:Src/util.c    **** }
 848              		.loc 1 150 28 view .LVU243
 849              	.LBE21:
 850              	.LBE20:
 352:Src/util.c    ****         }
 353:Src/util.c    ****     #endif
 354:Src/util.c    **** 
 355:Src/util.c    ****     // Tx USART AUX
 356:Src/util.c    ****     #ifdef SERIAL_AUX_TX
 357:Src/util.c    ****         if (main_loop_counter % 5 == 0 && dma_transfer_number_get(USART0_TX_DMA_CH) == 0) {     // 
 358:Src/util.c    ****             AuxTx.start     = (uint16_t)SERIAL_START_FRAME;
 359:Src/util.c    ****             AuxTx.signal1   = (int16_t)sensor1;
 360:Src/util.c    ****             AuxTx.signal2   = (int16_t)sensor2;
 361:Src/util.c    ****             AuxTx.checksum  = (uint16_t)(AuxTx.start ^ AuxTx.signal1 ^ AuxTx.signal2);
 362:Src/util.c    ****         
 363:Src/util.c    ****             dma_channel_disable(USART0_TX_DMA_CH);
 364:Src/util.c    ****             DMA_CHCNT(USART0_TX_DMA_CH)     = sizeof(AuxTx);
 365:Src/util.c    ****             DMA_CHMADDR(USART0_TX_DMA_CH)   = (uint32_t)&AuxTx;
 366:Src/util.c    ****             dma_channel_enable(USART0_TX_DMA_CH);
 367:Src/util.c    ****         }
 368:Src/util.c    ****     #endif
 369:Src/util.c    ****     // Rx USART AUX
 370:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 371:Src/util.c    ****         #ifdef CONTROL_IBUS
 372:Src/util.c    ****         if (!timeoutFlagSerial0) {
ARM GAS  /tmp/ccy0IG4C.s 			page 24


 373:Src/util.c    ****             for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 374:Src/util.c    ****                 ibus_captured_value[(i/2)] = CLAMP(command.channels[i] + (command.channels[i+1] << 
 375:Src/util.c    ****             }
 376:Src/util.c    ****             cmd1        = (ibus_captured_value[0] - 500) * 2;                           // Channel 
 377:Src/util.c    ****             cmd2        = (ibus_captured_value[1] - 500) * 2;                           // Channel 
 378:Src/util.c    ****             cmdSwitch   = (uint16_t)(switch_check(ibus_captured_value[6],0)      |      // Channel 
 379:Src/util.c    ****                                      switch_check(ibus_captured_value[7],1) << 1 |      // Channel 
 380:Src/util.c    ****                                      switch_check(ibus_captured_value[8],1) << 3 |      // Channel 
 381:Src/util.c    ****                                      switch_check(ibus_captured_value[9],0) << 5);      // Channel 
 382:Src/util.c    ****         }
 383:Src/util.c    ****         #endif
 384:Src/util.c    **** 
 385:Src/util.c    ****         if (timeoutCntSerial0++ >= SERIAL_TIMEOUT) {                // Timeout qualification
 386:Src/util.c    ****             timeoutFlagSerial0 = 1;                                 // Timeout detected
 387:Src/util.c    ****             timeoutCntSerial0  = SERIAL_TIMEOUT;                    // Limit timout counter value
 388:Src/util.c    ****             cmd1 = cmd2 = 0;                                        // Set commands to 0
 389:Src/util.c    ****             cmdSwitch &= ~(1U << 0);                                // Clear Bit 0, to switch to de
 390:Src/util.c    ****         }
 391:Src/util.c    ****         // if (timeoutFlagSerial0 && main_loop_counter % 100 == 0) {   // In case of timeout bring 
 392:Src/util.c    ****         //     toggle_led(LED2_GPIO_Port, LED2_Pin);                   // Toggle the Green LED ever
 393:Src/util.c    ****         // }
 394:Src/util.c    **** 
 395:Src/util.c    ****         #ifdef SERIAL_DEBUG
 396:Src/util.c    ****             // Print MPU data to Console
 397:Src/util.c    ****             if (main_loop_counter % 50 == 0) {
 398:Src/util.c    ****                 aux_print_to_console();
 399:Src/util.c    ****             }
 400:Src/util.c    ****         #endif
 401:Src/util.c    ****     #endif
 402:Src/util.c    **** }
 851              		.loc 1 402 1 view .LVU244
 852 012a 02E0     		b	.L32
 853              	.L36:
 350:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 854              		.loc 1 350 9 is_stmt 1 view .LVU245
 350:Src/util.c    ****             toggle_led(LED3_GPIO_Port, LED3_Pin);                   // Toggle the Yellow LED every 
 855              		.loc 1 350 12 is_stmt 0 view .LVU246
 856 012c 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 857 012e 002B     		cmp	r3, #0
 858 0130 EBD1     		bne	.L37
 859              	.L32:
 860              		.loc 1 402 1 view .LVU247
 861 0132 05B0     		add	sp, sp, #20
 862              	.LCFI11:
 863              		.cfi_def_cfa_offset 36
 864              		@ sp needed
 865 0134 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 866              	.L41:
 867              		.align	2
 868              	.L40:
 869 0138 00000000 		.word	main_loop_counter
 870 013c CDCCCCCC 		.word	-858993459
 871 0140 00000000 		.word	.LANCHOR7
 872 0144 00000000 		.word	mpu
 873 0148 00000000 		.word	.LANCHOR6
 874 014c 00000000 		.word	.LANCHOR2
 875 0150 00000000 		.word	.LANCHOR5
ARM GAS  /tmp/ccy0IG4C.s 			page 25


 876 0154 00000240 		.word	1073872896
 877 0158 00000000 		.word	.LANCHOR8
 878 015c 00000000 		.word	.LANCHOR9
 879              		.cfi_endproc
 880              	.LFE66:
 882              		.section	.text.handle_leds,"ax",%progbits
 883              		.align	1
 884              		.global	handle_leds
 885              		.syntax unified
 886              		.thumb
 887              		.thumb_func
 888              		.fpu softvfp
 890              	handle_leds:
 891              	.LFB67:
 403:Src/util.c    **** 
 404:Src/util.c    **** /*
 405:Src/util.c    ****  * Handle of the sideboard LEDs
 406:Src/util.c    ****  */
 407:Src/util.c    **** void handle_leds(void) {
 892              		.loc 1 407 24 is_stmt 1 view -0
 893              		.cfi_startproc
 894              		@ args = 0, pretend = 0, frame = 0
 895              		@ frame_needed = 0, uses_anonymous_args = 0
 408:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 409:Src/util.c    ****         if (!timeoutFlagSerial1) {
 896              		.loc 1 409 9 view .LVU249
 407:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 897              		.loc 1 407 24 is_stmt 0 view .LVU250
 898 0000 10B5     		push	{r4, lr}
 899              	.LCFI12:
 900              		.cfi_def_cfa_offset 8
 901              		.cfi_offset 4, -8
 902              		.cfi_offset 14, -4
 903              		.loc 1 409 13 view .LVU251
 904 0002 244B     		ldr	r3, .L55
 905              		.loc 1 409 12 view .LVU252
 906 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 907 0006 002B     		cmp	r3, #0
 908 0008 43D1     		bne	.L42
 410:Src/util.c    ****             if (Feedback.cmdLed & LED1_SET) { gpio_bit_set(LED1_GPIO_Port, LED1_Pin); } else { gpio
 909              		.loc 1 410 13 is_stmt 1 view .LVU253
 910              		.loc 1 410 25 is_stmt 0 view .LVU254
 911 000a 234C     		ldr	r4, .L55+4
 912              		.loc 1 410 47 view .LVU255
 913 000c 0121     		movs	r1, #1
 914              		.loc 1 410 16 view .LVU256
 915 000e E389     		ldrh	r3, [r4, #14]
 916              		.loc 1 410 47 view .LVU257
 917 0010 4FF09040 		mov	r0, #1207959552
 918              		.loc 1 410 16 view .LVU258
 919 0014 DA07     		lsls	r2, r3, #31
 920 0016 29D5     		bpl	.L44
 921              		.loc 1 410 47 is_stmt 1 discriminator 1 view .LVU259
 922 0018 FFF7FEFF 		bl	gpio_bit_set
 923              	.LVL55:
 924              	.L45:
 411:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
ARM GAS  /tmp/ccy0IG4C.s 			page 26


 925              		.loc 1 411 13 view .LVU260
 926              		.loc 1 411 16 is_stmt 0 view .LVU261
 927 001c E389     		ldrh	r3, [r4, #14]
 928              		.loc 1 411 47 view .LVU262
 929 001e 4FF40071 		mov	r1, #512
 930              		.loc 1 411 16 view .LVU263
 931 0022 9B07     		lsls	r3, r3, #30
 932              		.loc 1 411 47 view .LVU264
 933 0024 1D48     		ldr	r0, .L55+8
 934              		.loc 1 411 16 view .LVU265
 935 0026 24D5     		bpl	.L46
 936              		.loc 1 411 47 is_stmt 1 discriminator 1 view .LVU266
 937 0028 FFF7FEFF 		bl	gpio_bit_set
 938              	.LVL56:
 939              	.L47:
 412:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 940              		.loc 1 412 13 view .LVU267
 941              		.loc 1 412 16 is_stmt 0 view .LVU268
 942 002c E389     		ldrh	r3, [r4, #14]
 943              		.loc 1 412 47 view .LVU269
 944 002e 4FF48071 		mov	r1, #256
 945              		.loc 1 412 16 view .LVU270
 946 0032 5A07     		lsls	r2, r3, #29
 947              		.loc 1 412 47 view .LVU271
 948 0034 1948     		ldr	r0, .L55+8
 949              		.loc 1 412 16 view .LVU272
 950 0036 1FD5     		bpl	.L48
 951              		.loc 1 412 47 is_stmt 1 discriminator 1 view .LVU273
 952 0038 FFF7FEFF 		bl	gpio_bit_set
 953              	.LVL57:
 954              	.L49:
 413:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 955              		.loc 1 413 13 view .LVU274
 956              		.loc 1 413 16 is_stmt 0 view .LVU275
 957 003c E389     		ldrh	r3, [r4, #14]
 958              		.loc 1 413 47 view .LVU276
 959 003e 2021     		movs	r1, #32
 960              		.loc 1 413 16 view .LVU277
 961 0040 1B07     		lsls	r3, r3, #28
 962              		.loc 1 413 47 view .LVU278
 963 0042 1648     		ldr	r0, .L55+8
 964              		.loc 1 413 16 view .LVU279
 965 0044 1BD5     		bpl	.L50
 966              		.loc 1 413 47 is_stmt 1 discriminator 1 view .LVU280
 967 0046 FFF7FEFF 		bl	gpio_bit_set
 968              	.LVL58:
 969              	.L51:
 414:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 970              		.loc 1 414 13 view .LVU281
 971              		.loc 1 414 16 is_stmt 0 view .LVU282
 972 004a E389     		ldrh	r3, [r4, #14]
 973              		.loc 1 414 47 view .LVU283
 974 004c 1021     		movs	r1, #16
 975              		.loc 1 414 16 view .LVU284
 976 004e DA06     		lsls	r2, r3, #27
 977              		.loc 1 414 47 view .LVU285
 978 0050 1248     		ldr	r0, .L55+8
ARM GAS  /tmp/ccy0IG4C.s 			page 27


 979              		.loc 1 414 16 view .LVU286
 980 0052 17D5     		bpl	.L52
 981              		.loc 1 414 47 is_stmt 1 discriminator 1 view .LVU287
 982 0054 FFF7FEFF 		bl	gpio_bit_set
 983              	.LVL59:
 984              	.L53:
 415:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 985              		.loc 1 415 13 view .LVU288
 986              		.loc 1 415 16 is_stmt 0 view .LVU289
 987 0058 E389     		ldrh	r3, [r4, #14]
 988              		.loc 1 415 47 view .LVU290
 989 005a 4FF48061 		mov	r1, #1024
 990              		.loc 1 415 16 view .LVU291
 991 005e 1B07     		lsls	r3, r3, #28
 992              		.loc 1 415 47 view .LVU292
 993 0060 0E48     		ldr	r0, .L55+8
 994              		.loc 1 415 16 view .LVU293
 995 0062 12D5     		bpl	.L54
 996              		.loc 1 415 47 is_stmt 1 discriminator 1 view .LVU294
 416:Src/util.c    ****         }
 417:Src/util.c    ****     #endif
 418:Src/util.c    **** }
 997              		.loc 1 418 1 is_stmt 0 discriminator 1 view .LVU295
 998 0064 BDE81040 		pop	{r4, lr}
 999              	.LCFI13:
 1000              		.cfi_remember_state
 1001              		.cfi_restore 14
 1002              		.cfi_restore 4
 1003              		.cfi_def_cfa_offset 0
 415:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 1004              		.loc 1 415 47 discriminator 1 view .LVU296
 1005 0068 FFF7FEBF 		b	gpio_bit_set
 1006              	.LVL60:
 1007              	.L44:
 1008              	.LCFI14:
 1009              		.cfi_restore_state
 410:Src/util.c    ****             if (Feedback.cmdLed & LED2_SET) { gpio_bit_set(LED2_GPIO_Port, LED2_Pin); } else { gpio
 1010              		.loc 1 410 96 is_stmt 1 discriminator 2 view .LVU297
 1011 006c FFF7FEFF 		bl	gpio_bit_reset
 1012              	.LVL61:
 1013 0070 D4E7     		b	.L45
 1014              	.L46:
 411:Src/util.c    ****             if (Feedback.cmdLed & LED3_SET) { gpio_bit_set(LED3_GPIO_Port, LED3_Pin); } else { gpio
 1015              		.loc 1 411 96 discriminator 2 view .LVU298
 1016 0072 FFF7FEFF 		bl	gpio_bit_reset
 1017              	.LVL62:
 1018 0076 D9E7     		b	.L47
 1019              	.L48:
 412:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(LED4_GPIO_Port, LED4_Pin); } else { gpio
 1020              		.loc 1 412 96 discriminator 2 view .LVU299
 1021 0078 FFF7FEFF 		bl	gpio_bit_reset
 1022              	.LVL63:
 1023 007c DEE7     		b	.L49
 1024              	.L50:
 413:Src/util.c    ****             if (Feedback.cmdLed & LED5_SET) { gpio_bit_set(LED5_GPIO_Port, LED5_Pin); } else { gpio
 1025              		.loc 1 413 96 discriminator 2 view .LVU300
 1026 007e FFF7FEFF 		bl	gpio_bit_reset
ARM GAS  /tmp/ccy0IG4C.s 			page 28


 1027              	.LVL64:
 1028 0082 E2E7     		b	.L51
 1029              	.L52:
 414:Src/util.c    ****             if (Feedback.cmdLed & LED4_SET) { gpio_bit_set(AUX3_GPIO_Port, AUX3_Pin); } else { gpio
 1030              		.loc 1 414 96 discriminator 2 view .LVU301
 1031 0084 FFF7FEFF 		bl	gpio_bit_reset
 1032              	.LVL65:
 1033 0088 E6E7     		b	.L53
 1034              	.L54:
 415:Src/util.c    ****         }
 1035              		.loc 1 415 96 discriminator 2 view .LVU302
 1036              		.loc 1 418 1 is_stmt 0 discriminator 2 view .LVU303
 1037 008a BDE81040 		pop	{r4, lr}
 1038              	.LCFI15:
 1039              		.cfi_remember_state
 1040              		.cfi_restore 14
 1041              		.cfi_restore 4
 1042              		.cfi_def_cfa_offset 0
 415:Src/util.c    ****         }
 1043              		.loc 1 415 96 discriminator 2 view .LVU304
 1044 008e FFF7FEBF 		b	gpio_bit_reset
 1045              	.LVL66:
 1046              	.L42:
 1047              	.LCFI16:
 1048              		.cfi_restore_state
 1049              		.loc 1 418 1 view .LVU305
 1050 0092 10BD     		pop	{r4, pc}
 1051              	.L56:
 1052              		.align	2
 1053              	.L55:
 1054 0094 00000000 		.word	.LANCHOR9
 1055 0098 00000000 		.word	.LANCHOR10
 1056 009c 00040048 		.word	1207960576
 1057              		.cfi_endproc
 1058              	.LFE67:
 1060              		.section	.text.usart_process_data,"ax",%progbits
 1061              		.align	1
 1062              		.global	usart_process_data
 1063              		.syntax unified
 1064              		.thumb
 1065              		.thumb_func
 1066              		.fpu softvfp
 1068              	usart_process_data:
 1069              	.LVL67:
 1070              	.LFB69:
 419:Src/util.c    **** 
 420:Src/util.c    **** 
 421:Src/util.c    **** /* =========================== USART1 READ Functions =========================== */
 422:Src/util.c    **** 
 423:Src/util.c    **** void usart1_rx_check(void)
 424:Src/util.c    **** {
 425:Src/util.c    ****     #ifdef SERIAL_DEBUG
 426:Src/util.c    ****     static uint32_t old_pos;
 427:Src/util.c    ****     uint32_t pos;
 428:Src/util.c    **** 
 429:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 430:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
ARM GAS  /tmp/ccy0IG4C.s 			page 29


 431:Src/util.c    ****         if (pos > old_pos) {                                                    // "Linear" buffer 
 432:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], pos - old_pos);           // Process data
 433:Src/util.c    ****         } else {                                                                // "Overflow" buffe
 434:Src/util.c    ****             usart_process_debug(&rx1_buffer[old_pos], rx1_buffer_len - old_pos);// First Process da
 435:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 436:Src/util.c    ****                 usart_process_debug(&rx1_buffer[0], pos);                       // Process remainin
 437:Src/util.c    ****             }
 438:Src/util.c    ****         }
 439:Src/util.c    ****     }
 440:Src/util.c    ****     old_pos = pos;                                                              // Update old posit
 441:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 442:Src/util.c    ****         old_pos = 0;
 443:Src/util.c    ****     }
 444:Src/util.c    ****     #endif // SERIAL_DEBUG
 445:Src/util.c    **** 
 446:Src/util.c    ****     #ifdef SERIAL_FEEDBACK
 447:Src/util.c    ****     static uint32_t old_pos;
 448:Src/util.c    ****     uint32_t pos;
 449:Src/util.c    ****     uint8_t *ptr;
 450:Src/util.c    **** 
 451:Src/util.c    ****     pos = rx1_buffer_len - dma_transfer_number_get(USART1_RX_DMA_CH);           // Calculate curren
 452:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 453:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 454:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 455:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 456:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 457:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 458:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 459:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 460:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 461:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 462:Src/util.c    ****             }
 463:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 464:Src/util.c    ****         }
 465:Src/util.c    ****     }
 466:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 467:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 468:Src/util.c    ****         old_pos = 0;
 469:Src/util.c    ****     }
 470:Src/util.c    ****     #endif // SERIAL_FEEDBACK
 471:Src/util.c    **** }
 472:Src/util.c    **** 
 473:Src/util.c    **** /*
 474:Src/util.c    ****  * Process Rx debug user command input
 475:Src/util.c    ****  */
 476:Src/util.c    **** #ifdef SERIAL_DEBUG
 477:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
 478:Src/util.c    **** {
 479:Src/util.c    ****     for (; len > 0; len--, userCommand++) {
 480:Src/util.c    ****         if (*userCommand != '\n' && *userCommand != '\r') {     // Do not accept 'new line' and 'ca
 481:Src/util.c    ****             log_i("Command = %c\r\n", *userCommand);
 482:Src/util.c    ****             mpu_handle_input(*userCommand);
 483:Src/util.c    ****         }
 484:Src/util.c    ****     }
 485:Src/util.c    **** }
 486:Src/util.c    **** #endif // SERIAL_DEBUG
 487:Src/util.c    **** 
ARM GAS  /tmp/ccy0IG4C.s 			page 30


 488:Src/util.c    **** /*
 489:Src/util.c    ****  * Process Rx data
 490:Src/util.c    ****  * - if the Feedback_in data is valid (correct START_FRAME and checksum) copy the Feedback_in to Fe
 491:Src/util.c    ****  */
 492:Src/util.c    **** #ifdef SERIAL_FEEDBACK
 493:Src/util.c    **** void usart_process_data(SerialFeedback *Feedback_in, SerialFeedback *Feedback_out)
 494:Src/util.c    **** {
 1071              		.loc 1 494 1 is_stmt 1 view -0
 1072              		.cfi_startproc
 1073              		@ args = 0, pretend = 0, frame = 0
 1074              		@ frame_needed = 0, uses_anonymous_args = 0
 495:Src/util.c    ****     uint16_t checksum;
 1075              		.loc 1 495 5 view .LVU307
 496:Src/util.c    ****     if (Feedback_in->start == SERIAL_START_FRAME) {
 1076              		.loc 1 496 5 view .LVU308
 1077              		.loc 1 496 8 is_stmt 0 view .LVU309
 1078 0000 4AF6CD33 		movw	r3, #43981
 1079 0004 0288     		ldrh	r2, [r0]
 494:Src/util.c    ****     uint16_t checksum;
 1080              		.loc 1 494 1 view .LVU310
 1081 0006 10B5     		push	{r4, lr}
 1082              	.LCFI17:
 1083              		.cfi_def_cfa_offset 8
 1084              		.cfi_offset 4, -8
 1085              		.cfi_offset 14, -4
 1086              		.loc 1 496 8 view .LVU311
 1087 0008 9A42     		cmp	r2, r3
 1088 000a 20D1     		bne	.L57
 1089              	.LVL68:
 1090              	.LBB24:
 1091              	.LBI24:
 493:Src/util.c    **** {
 1092              		.loc 1 493 6 is_stmt 1 view .LVU312
 1093              	.LBB25:
 497:Src/util.c    ****         checksum = (uint16_t)(Feedback_in->start ^ Feedback_in->cmd1 ^ Feedback_in->cmd2 ^ Feedback
 1094              		.loc 1 497 9 view .LVU313
 498:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 499:Src/util.c    ****         if (Feedback_in->checksum == checksum) {
 1095              		.loc 1 499 9 view .LVU314
 498:Src/util.c    ****                             ^ Feedback_in->batVoltage ^ Feedback_in->boardTemp ^ Feedback_in->cmdLe
 1096              		.loc 1 498 80 is_stmt 0 view .LVU315
 1097 000c 8488     		ldrh	r4, [r0, #4]
 1098 000e 4388     		ldrh	r3, [r0, #2]
 1099 0010 6340     		eors	r3, r3, r4
 1100 0012 C489     		ldrh	r4, [r0, #14]
 1101 0014 6340     		eors	r3, r3, r4
 1102 0016 C488     		ldrh	r4, [r0, #6]
 1103 0018 6340     		eors	r3, r3, r4
 1104 001a 0489     		ldrh	r4, [r0, #8]
 1105 001c 6340     		eors	r3, r3, r4
 1106 001e 4489     		ldrh	r4, [r0, #10]
 1107 0020 6340     		eors	r3, r3, r4
 1108 0022 8489     		ldrh	r4, [r0, #12]
 1109 0024 6340     		eors	r3, r3, r4
 1110 0026 5A40     		eors	r2, r2, r3
 1111              		.loc 1 499 12 view .LVU316
 1112 0028 038A     		ldrh	r3, [r0, #16]
ARM GAS  /tmp/ccy0IG4C.s 			page 31


 1113 002a 92B2     		uxth	r2, r2
 1114 002c 9342     		cmp	r3, r2
 1115 002e 0ED1     		bne	.L57
 500:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1116              		.loc 1 500 13 is_stmt 1 view .LVU317
 1117              		.loc 1 500 27 is_stmt 0 view .LVU318
 1118 0030 00F11003 		add	r3, r0, #16
 1119              	.LVL69:
 1120              	.L59:
 1121              		.loc 1 500 27 view .LVU319
 1122 0034 50F8042B 		ldr	r2, [r0], #4	@ unaligned
 1123 0038 9842     		cmp	r0, r3
 1124 003a 41F8042B 		str	r2, [r1], #4	@ unaligned
 1125 003e F9D1     		bne	.L59
 1126 0040 0388     		ldrh	r3, [r0]	@ unaligned
 1127              	.LVL70:
 501:Src/util.c    ****             timeoutCntSerial1  = 0;     // Reset timeout counter
 1128              		.loc 1 501 32 view .LVU320
 1129 0042 034A     		ldr	r2, .L61
 500:Src/util.c    ****             *Feedback_out = *Feedback_in;
 1130              		.loc 1 500 27 view .LVU321
 1131 0044 0B80     		strh	r3, [r1]	@ unaligned
 1132              		.loc 1 501 13 is_stmt 1 view .LVU322
 1133              		.loc 1 501 32 is_stmt 0 view .LVU323
 1134 0046 0023     		movs	r3, #0
 1135 0048 1380     		strh	r3, [r2]	@ movhi
 502:Src/util.c    ****             timeoutFlagSerial1 = 0;     // Clear timeout flag
 1136              		.loc 1 502 13 is_stmt 1 view .LVU324
 1137              		.loc 1 502 32 is_stmt 0 view .LVU325
 1138 004a 024A     		ldr	r2, .L61+4
 1139 004c 1370     		strb	r3, [r2]
 1140              	.LVL71:
 1141              	.L57:
 1142              		.loc 1 502 32 view .LVU326
 1143              	.LBE25:
 1144              	.LBE24:
 503:Src/util.c    ****         }
 504:Src/util.c    ****     }
 505:Src/util.c    **** }
 1145              		.loc 1 505 1 view .LVU327
 1146 004e 10BD     		pop	{r4, pc}
 1147              	.L62:
 1148              		.align	2
 1149              	.L61:
 1150 0050 00000000 		.word	.LANCHOR8
 1151 0054 00000000 		.word	.LANCHOR9
 1152              		.cfi_endproc
 1153              	.LFE69:
 1155              		.section	.text.usart1_rx_check,"ax",%progbits
 1156              		.align	1
 1157              		.global	usart1_rx_check
 1158              		.syntax unified
 1159              		.thumb
 1160              		.thumb_func
 1161              		.fpu softvfp
 1163              	usart1_rx_check:
 1164              	.LFB68:
ARM GAS  /tmp/ccy0IG4C.s 			page 32


 424:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1165              		.loc 1 424 1 is_stmt 1 view -0
 1166              		.cfi_startproc
 1167              		@ args = 0, pretend = 0, frame = 0
 1168              		@ frame_needed = 0, uses_anonymous_args = 0
 447:Src/util.c    ****     uint32_t pos;
 1169              		.loc 1 447 5 view .LVU329
 448:Src/util.c    ****     uint8_t *ptr;
 1170              		.loc 1 448 5 view .LVU330
 449:Src/util.c    **** 
 1171              		.loc 1 449 5 view .LVU331
 451:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1172              		.loc 1 451 5 view .LVU332
 424:Src/util.c    ****     #ifdef SERIAL_DEBUG
 1173              		.loc 1 424 1 is_stmt 0 view .LVU333
 1174 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1175              	.LCFI18:
 1176              		.cfi_def_cfa_offset 24
 1177              		.cfi_offset 3, -24
 1178              		.cfi_offset 4, -20
 1179              		.cfi_offset 5, -16
 1180              		.cfi_offset 6, -12
 1181              		.cfi_offset 7, -8
 1182              		.cfi_offset 14, -4
 451:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1183              		.loc 1 451 28 view .LVU334
 1184 0002 0420     		movs	r0, #4
 1185 0004 FFF7FEFF 		bl	dma_transfer_number_get
 1186              	.LVL72:
 452:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1187              		.loc 1 452 13 view .LVU335
 1188 0008 1A4D     		ldr	r5, .L74
 451:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 1189              		.loc 1 451 9 view .LVU336
 1190 000a C0F14004 		rsb	r4, r0, #64
 1191              	.LVL73:
 452:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1192              		.loc 1 452 5 is_stmt 1 view .LVU337
 452:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1193              		.loc 1 452 13 is_stmt 0 view .LVU338
 1194 000e 2968     		ldr	r1, [r5]
 452:Src/util.c    ****         ptr = (uint8_t *)&FeedbackRaw;                                          // Initialize the p
 1195              		.loc 1 452 8 view .LVU339
 1196 0010 A142     		cmp	r1, r4
 1197 0012 14D0     		beq	.L64
 453:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == Feedback_len) {                 // "Linear" buffer 
 1198              		.loc 1 453 9 is_stmt 1 view .LVU340
 1199              	.LVL74:
 454:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1200              		.loc 1 454 9 view .LVU341
 454:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1201              		.loc 1 454 12 is_stmt 0 view .LVU342
 1202 0014 19D2     		bcs	.L65
 454:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
 1203              		.loc 1 454 35 discriminator 1 view .LVU343
 1204 0016 631A     		subs	r3, r4, r1
 454:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], Feedback_len);                    // Copy data. This 
ARM GAS  /tmp/ccy0IG4C.s 			page 33


 1205              		.loc 1 454 27 discriminator 1 view .LVU344
 1206 0018 122B     		cmp	r3, #18
 1207 001a 16D1     		bne	.L65
 455:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1208              		.loc 1 455 13 is_stmt 1 view .LVU345
 455:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1209              		.loc 1 455 25 is_stmt 0 view .LVU346
 1210 001c 164B     		ldr	r3, .L74+4
 1211 001e 1944     		add	r1, r1, r3
 455:Src/util.c    ****             usart_process_data(&FeedbackRaw, &Feedback);                        // Process data
 1212              		.loc 1 455 13 view .LVU347
 1213 0020 164B     		ldr	r3, .L74+8
 1214 0022 01F11002 		add	r2, r1, #16
 1215              	.L66:
 1216 0026 51F8040B 		ldr	r0, [r1], #4	@ unaligned
 1217 002a 9142     		cmp	r1, r2
 1218 002c 43F8040B 		str	r0, [r3], #4	@ unaligned
 1219 0030 F9D1     		bne	.L66
 1220 0032 0A88     		ldrh	r2, [r1]	@ unaligned
 1221 0034 1A80     		strh	r2, [r3]	@ unaligned
 456:Src/util.c    ****         } else if ((rx1_buffer_len - old_pos + pos) == Feedback_len) {          // "Overflow" buffe
 1222              		.loc 1 456 13 is_stmt 1 view .LVU348
 1223              	.LVL75:
 1224              	.L67:
 463:Src/util.c    ****         }
 1225              		.loc 1 463 13 view .LVU349
 1226 0036 1249     		ldr	r1, .L74+12
 1227 0038 1048     		ldr	r0, .L74+8
 1228 003a FFF7FEFF 		bl	usart_process_data
 1229              	.LVL76:
 1230              	.L64:
 466:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1231              		.loc 1 466 5 view .LVU350
 467:Src/util.c    ****         old_pos = 0;
 1232              		.loc 1 467 5 view .LVU351
 467:Src/util.c    ****         old_pos = 0;
 1233              		.loc 1 467 8 is_stmt 0 view .LVU352
 1234 003e 402C     		cmp	r4, #64
 468:Src/util.c    ****     }
 1235              		.loc 1 468 17 view .LVU353
 1236 0040 0ABF     		itet	eq
 1237 0042 0023     		moveq	r3, #0
 466:Src/util.c    ****     if (old_pos == rx1_buffer_len) {                                            // Check and manual
 1238              		.loc 1 466 13 view .LVU354
 1239 0044 2C60     		strne	r4, [r5]
 468:Src/util.c    ****     }
 1240              		.loc 1 468 9 is_stmt 1 view .LVU355
 468:Src/util.c    ****     }
 1241              		.loc 1 468 17 is_stmt 0 view .LVU356
 1242 0046 2B60     		streq	r3, [r5]
 471:Src/util.c    **** 
 1243              		.loc 1 471 1 view .LVU357
 1244 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1245              	.LVL77:
 1246              	.L65:
 457:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1247              		.loc 1 457 16 is_stmt 1 view .LVU358
ARM GAS  /tmp/ccy0IG4C.s 			page 34


 457:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1248              		.loc 1 457 36 is_stmt 0 view .LVU359
 1249 004a C1F14006 		rsb	r6, r1, #64
 457:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1250              		.loc 1 457 46 view .LVU360
 1251 004e 3319     		adds	r3, r6, r4
 457:Src/util.c    ****             memcpy(ptr, &rx1_buffer[old_pos], rx1_buffer_len - old_pos);        // First copy data 
 1252              		.loc 1 457 19 view .LVU361
 1253 0050 122B     		cmp	r3, #18
 1254 0052 F4D1     		bne	.L64
 458:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1255              		.loc 1 458 13 is_stmt 1 view .LVU362
 1256 0054 094B     		ldr	r3, .L74+8
 458:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1257              		.loc 1 458 25 is_stmt 0 view .LVU363
 1258 0056 084F     		ldr	r7, .L74+4
 458:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 1259              		.loc 1 458 13 view .LVU364
 1260 0058 3246     		mov	r2, r6
 1261 005a 1846     		mov	r0, r3
 1262 005c 3944     		add	r1, r1, r7
 1263 005e FFF7FEFF 		bl	memcpy
 1264              	.LVL78:
 459:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1265              		.loc 1 459 13 is_stmt 1 view .LVU365
 459:Src/util.c    ****                 ptr += rx1_buffer_len - old_pos;                                // Move to correct 
 1266              		.loc 1 459 16 is_stmt 0 view .LVU366
 1267 0062 002C     		cmp	r4, #0
 1268 0064 E7D0     		beq	.L67
 460:Src/util.c    ****                 memcpy(ptr, &rx1_buffer[0], pos);                               // Copy remaining d
 1269              		.loc 1 460 17 is_stmt 1 view .LVU367
 1270              	.LVL79:
 461:Src/util.c    ****             }
 1271              		.loc 1 461 17 view .LVU368
 1272 0066 2246     		mov	r2, r4
 1273 0068 3946     		mov	r1, r7
 1274 006a 3044     		add	r0, r0, r6
 1275 006c FFF7FEFF 		bl	memcpy
 1276              	.LVL80:
 1277 0070 E1E7     		b	.L67
 1278              	.L75:
 1279 0072 00BF     		.align	2
 1280              	.L74:
 1281 0074 00000000 		.word	.LANCHOR11
 1282 0078 00000000 		.word	.LANCHOR1
 1283 007c 00000000 		.word	.LANCHOR12
 1284 0080 00000000 		.word	.LANCHOR10
 1285              		.cfi_endproc
 1286              	.LFE68:
 1288              		.section	.text.usart0_rx_check,"ax",%progbits
 1289              		.align	1
 1290              		.global	usart0_rx_check
 1291              		.syntax unified
 1292              		.thumb
 1293              		.thumb_func
 1294              		.fpu softvfp
 1296              	usart0_rx_check:
ARM GAS  /tmp/ccy0IG4C.s 			page 35


 1297              	.LFB70:
 506:Src/util.c    **** #endif // SERIAL_FEEDBACK
 507:Src/util.c    **** 
 508:Src/util.c    **** 
 509:Src/util.c    **** /* =========================== USART0 READ Functions =========================== */
 510:Src/util.c    **** 
 511:Src/util.c    **** /*
 512:Src/util.c    ****  * Check for new data received on USART with DMA: refactored function from https://github.com/MaJer
 513:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 514:Src/util.c    ****  */
 515:Src/util.c    **** void usart0_rx_check(void)
 516:Src/util.c    **** {
 1298              		.loc 1 516 1 view -0
 1299              		.cfi_startproc
 1300              		@ args = 0, pretend = 0, frame = 0
 1301              		@ frame_needed = 0, uses_anonymous_args = 0
 1302              		@ link register save eliminated.
 517:Src/util.c    ****     #ifdef SERIAL_AUX_RX
 518:Src/util.c    ****     static uint32_t old_pos;
 519:Src/util.c    ****     uint32_t pos;
 520:Src/util.c    ****     uint8_t *ptr;
 521:Src/util.c    **** 
 522:Src/util.c    ****     pos = rx0_buffer_len - dma_transfer_number_get(USART0_RX_DMA_CH);           // Calculate curren
 523:Src/util.c    ****     if (pos != old_pos) {                                                       // Check change in 
 524:Src/util.c    ****         ptr = (uint8_t *)&command_raw;                                          // Initialize the p
 525:Src/util.c    ****         if (pos > old_pos && (pos - old_pos) == command_len) {                  // "Linear" buffer 
 526:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], command_len);                     // Copy data. This 
 527:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 528:Src/util.c    ****         } else if ((rx0_buffer_len - old_pos + pos) == command_len) {           // "Overflow" buffe
 529:Src/util.c    ****             memcpy(ptr, &rx0_buffer[old_pos], rx0_buffer_len - old_pos);        // First copy data 
 530:Src/util.c    ****             if (pos > 0) {                                                      // Check and contin
 531:Src/util.c    ****                 ptr += rx0_buffer_len - old_pos;                                // Update position
 532:Src/util.c    ****                 memcpy(ptr, &rx0_buffer[0], pos);                               // Copy remaining d
 533:Src/util.c    ****             }
 534:Src/util.c    ****             usart_process_command(&command_raw, &command);                      // Process data
 535:Src/util.c    ****         }
 536:Src/util.c    ****     }
 537:Src/util.c    ****     old_pos = pos;                                                              // Updated old posi
 538:Src/util.c    ****     if (old_pos == rx0_buffer_len) {                                            // Check and manual
 539:Src/util.c    ****         old_pos = 0;
 540:Src/util.c    ****     }
 541:Src/util.c    ****     #endif  // SERIAL_AUX_RX
 542:Src/util.c    **** }
 1303              		.loc 1 542 1 view .LVU370
 1304 0000 7047     		bx	lr
 1305              		.cfi_endproc
 1306              	.LFE70:
 1308              		.section	.text.aux_print_to_console,"ax",%progbits
 1309              		.align	1
 1310              		.global	aux_print_to_console
 1311              		.syntax unified
 1312              		.thumb
 1313              		.thumb_func
 1314              		.fpu softvfp
 1316              	aux_print_to_console:
 1317              	.LFB80:
 1318              		.cfi_startproc
ARM GAS  /tmp/ccy0IG4C.s 			page 36


 1319              		@ args = 0, pretend = 0, frame = 0
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              		@ link register save eliminated.
 1322 0000 7047     		bx	lr
 1323              		.cfi_endproc
 1324              	.LFE80:
 1326              		.section	.text.i2c_writeBytes,"ax",%progbits
 1327              		.align	1
 1328              		.global	i2c_writeBytes
 1329              		.syntax unified
 1330              		.thumb
 1331              		.thumb_func
 1332              		.fpu softvfp
 1334              	i2c_writeBytes:
 1335              	.LVL81:
 1336              	.LFB72:
 543:Src/util.c    **** 
 544:Src/util.c    **** /*
 545:Src/util.c    ****  * Process command UART0 Rx data
 546:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
 547:Src/util.c    ****  */
 548:Src/util.c    **** #ifdef SERIAL_AUX_RX
 549:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out)
 550:Src/util.c    **** {
 551:Src/util.c    ****   #ifdef CONTROL_IBUS
 552:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
 553:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
 554:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
 555:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
 556:Src/util.c    ****       }
 557:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
 558:Src/util.c    ****         *command_out = *command_in;
 559:Src/util.c    ****         timeoutCntSerial0  = 0;        // Reset timeout counter
 560:Src/util.c    ****         timeoutFlagSerial0 = 0;        // Clear timeout flag
 561:Src/util.c    ****       }
 562:Src/util.c    ****     }
 563:Src/util.c    ****   #endif
 564:Src/util.c    **** }
 565:Src/util.c    **** #endif
 566:Src/util.c    **** 
 567:Src/util.c    **** 
 568:Src/util.c    **** /* =========================== AUX Serial Print data =========================== */
 569:Src/util.c    **** 
 570:Src/util.c    **** void aux_print_to_console(void)
 571:Src/util.c    **** {
 572:Src/util.c    **** #if defined(SERIAL_DEBUG) && defined(SERIAL_AUX_RX)
 573:Src/util.c    ****     #ifdef CONTROL_IBUS
 574:Src/util.c    ****     if (print_aux & PRINT_AUX) {
 575:Src/util.c    ****         log_i( "Ch1: %d Ch2: %d Sw: %u\r\n", cmd1, cmd2, cmdSwitch);
 576:Src/util.c    ****     }
 577:Src/util.c    ****     #endif
 578:Src/util.c    **** #endif
 579:Src/util.c    **** }
 580:Src/util.c    **** 
 581:Src/util.c    **** 
 582:Src/util.c    **** /* =========================== I2C WRITE Functions =========================== */
 583:Src/util.c    **** 
ARM GAS  /tmp/ccy0IG4C.s 			page 37


 584:Src/util.c    **** /*
 585:Src/util.c    ****  * write bytes to chip register
 586:Src/util.c    ****  */
 587:Src/util.c    **** int8_t i2c_writeBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data)
 588:Src/util.c    **** {
 1337              		.loc 1 588 1 view -0
 1338              		.cfi_startproc
 1339              		@ args = 0, pretend = 0, frame = 0
 1340              		@ frame_needed = 0, uses_anonymous_args = 0
 589:Src/util.c    **** 
 590:Src/util.c    ****     // assign WRITE command
 591:Src/util.c    ****     i2c_ReadWriteCmd    = WRITE;
 1341              		.loc 1 591 5 view .LVU372
 588:Src/util.c    **** 
 1342              		.loc 1 588 1 is_stmt 0 view .LVU373
 1343 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1344              	.LCFI19:
 1345              		.cfi_def_cfa_offset 24
 1346              		.cfi_offset 4, -24
 1347              		.cfi_offset 5, -20
 1348              		.cfi_offset 6, -16
 1349              		.cfi_offset 7, -12
 1350              		.cfi_offset 8, -8
 1351              		.cfi_offset 14, -4
 1352              		.loc 1 591 25 view .LVU374
 1353 0004 0124     		movs	r4, #1
 592:Src/util.c    **** 
 593:Src/util.c    ****     // assign inputs
 594:Src/util.c    ****     i2c_status          = -1;
 1354              		.loc 1 594 25 view .LVU375
 1355 0006 FF26     		movs	r6, #255
 591:Src/util.c    **** 
 1356              		.loc 1 591 25 view .LVU376
 1357 0008 184D     		ldr	r5, .L91
 595:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1358              		.loc 1 595 37 view .LVU377
 1359 000a A040     		lsls	r0, r0, r4
 1360              	.LVL82:
 591:Src/util.c    **** 
 1361              		.loc 1 591 25 view .LVU378
 1362 000c 2C70     		strb	r4, [r5]
 594:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1363              		.loc 1 594 5 is_stmt 1 view .LVU379
 594:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1364              		.loc 1 594 25 is_stmt 0 view .LVU380
 1365 000e 184D     		ldr	r5, .L91+4
 1366              		.loc 1 595 37 view .LVU381
 1367 0010 C0B2     		uxtb	r0, r0
 594:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;       // Address is shifted one position to the left. LSB
 1368              		.loc 1 594 25 view .LVU382
 1369 0012 2E70     		strb	r6, [r5]
 1370              		.loc 1 595 5 is_stmt 1 view .LVU383
 1371              		.loc 1 595 25 is_stmt 0 view .LVU384
 1372 0014 174E     		ldr	r6, .L91+8
 596:Src/util.c    ****     i2c_regAddress      = regAddr;
 597:Src/util.c    ****     i2c_txbuffer        = data;
 598:Src/util.c    ****     i2c_nDABytes        = length;
ARM GAS  /tmp/ccy0IG4C.s 			page 38


 599:Src/util.c    ****     i2c_nRABytes        = 1;
 600:Src/util.c    **** 
 601:Src/util.c    ****     uint16_t i2c_timeout = 0;
 602:Src/util.c    **** 
 603:Src/util.c    ****     // enable the I2C0 interrupt
 604:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 605:Src/util.c    **** 
 606:Src/util.c    ****     // the master waits until the I2C bus is idle
 607:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1373              		.loc 1 607 11 view .LVU385
 1374 0016 184F     		ldr	r7, .L91+12
 595:Src/util.c    ****     i2c_regAddress      = regAddr;
 1375              		.loc 1 595 25 view .LVU386
 1376 0018 3070     		strb	r0, [r6]
 596:Src/util.c    ****     i2c_regAddress      = regAddr;
 1377              		.loc 1 596 5 is_stmt 1 view .LVU387
 596:Src/util.c    ****     i2c_regAddress      = regAddr;
 1378              		.loc 1 596 25 is_stmt 0 view .LVU388
 1379 001a 1848     		ldr	r0, .L91+16
 598:Src/util.c    ****     i2c_nRABytes        = 1;
 1380              		.loc 1 598 25 view .LVU389
 1381 001c 184E     		ldr	r6, .L91+20
 596:Src/util.c    ****     i2c_regAddress      = regAddr;
 1382              		.loc 1 596 25 view .LVU390
 1383 001e 0170     		strb	r1, [r0]
 597:Src/util.c    ****     i2c_nDABytes        = length;
 1384              		.loc 1 597 5 is_stmt 1 view .LVU391
 597:Src/util.c    ****     i2c_nDABytes        = length;
 1385              		.loc 1 597 25 is_stmt 0 view .LVU392
 1386 0020 1849     		ldr	r1, .L91+24
 1387              	.LVL83:
 604:Src/util.c    **** 
 1388              		.loc 1 604 5 view .LVU393
 1389 0022 1948     		ldr	r0, .L91+28
 597:Src/util.c    ****     i2c_nDABytes        = length;
 1390              		.loc 1 597 25 view .LVU394
 1391 0024 0B60     		str	r3, [r1]
 598:Src/util.c    ****     i2c_nRABytes        = 1;
 1392              		.loc 1 598 5 is_stmt 1 view .LVU395
 599:Src/util.c    **** 
 1393              		.loc 1 599 25 is_stmt 0 view .LVU396
 1394 0026 194B     		ldr	r3, .L91+32
 1395              	.LVL84:
 604:Src/util.c    **** 
 1396              		.loc 1 604 5 view .LVU397
 1397 0028 4FF4E061 		mov	r1, #1792
 598:Src/util.c    ****     i2c_nRABytes        = 1;
 1398              		.loc 1 598 25 view .LVU398
 1399 002c 3270     		strb	r2, [r6]
 1400              	.LVL85:
 599:Src/util.c    **** 
 1401              		.loc 1 599 5 is_stmt 1 view .LVU399
 599:Src/util.c    **** 
 1402              		.loc 1 599 25 is_stmt 0 view .LVU400
 1403 002e 1C70     		strb	r4, [r3]
 601:Src/util.c    **** 
 1404              		.loc 1 601 5 is_stmt 1 view .LVU401
ARM GAS  /tmp/ccy0IG4C.s 			page 39


 1405              	.LVL86:
 604:Src/util.c    **** 
 1406              		.loc 1 604 5 view .LVU402
 1407 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1408              	.LVL87:
 1409              		.loc 1 607 5 view .LVU403
 1410              		.loc 1 607 10 is_stmt 0 view .LVU404
 1411 0034 44F62164 		movw	r4, #20001
 1412              		.loc 1 607 11 view .LVU405
 1413 0038 DFF84C80 		ldr	r8, .L91+28
 1414              	.LVL88:
 1415              	.L80:
 1416              		.loc 1 607 75 is_stmt 1 discriminator 2 view .LVU406
 1417              		.loc 1 607 10 discriminator 2 view .LVU407
 1418              		.loc 1 607 11 is_stmt 0 discriminator 2 view .LVU408
 1419 003c 3946     		mov	r1, r7
 1420 003e 4046     		mov	r0, r8
 1421 0040 FFF7FEFF 		bl	i2c_flag_get
 1422              	.LVL89:
 1423              		.loc 1 607 10 discriminator 2 view .LVU409
 1424 0044 18B1     		cbz	r0, .L79
 1425              	.LVL90:
 1426              		.loc 1 607 50 discriminator 1 view .LVU410
 1427 0046 013C     		subs	r4, r4, #1
 1428              	.LVL91:
 1429              		.loc 1 607 50 discriminator 1 view .LVU411
 1430 0048 A4B2     		uxth	r4, r4
 1431 004a 002C     		cmp	r4, #0
 1432 004c F6D1     		bne	.L80
 1433              	.L79:
 608:Src/util.c    **** 
 609:Src/util.c    ****     // the master sends a start condition to I2C bus
 610:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1434              		.loc 1 610 5 is_stmt 1 view .LVU412
 1435 004e 0E48     		ldr	r0, .L91+28
 1436 0050 FFF7FEFF 		bl	i2c_start_on_bus
 1437              	.LVL92:
 611:Src/util.c    ****     
 612:Src/util.c    ****     // Wait until all data bytes are sent/received
 613:Src/util.c    ****     i2c_timeout = 0;
 1438              		.loc 1 613 5 view .LVU413
 614:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1439              		.loc 1 614 5 view .LVU414
 1440              		.loc 1 614 10 is_stmt 0 view .LVU415
 1441 0054 44F62163 		movw	r3, #20001
 1442              	.LVL93:
 1443              	.L82:
 1444              		.loc 1 614 53 is_stmt 1 discriminator 2 view .LVU416
 1445              		.loc 1 614 10 discriminator 2 view .LVU417
 1446              		.loc 1 614 24 is_stmt 0 discriminator 2 view .LVU418
 1447 0058 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1448              		.loc 1 614 10 discriminator 2 view .LVU419
 1449 005a 1AB1     		cbz	r2, .L81
 1450              	.LVL94:
 1451              		.loc 1 614 28 discriminator 1 view .LVU420
 1452 005c 013B     		subs	r3, r3, #1
 1453              	.LVL95:
ARM GAS  /tmp/ccy0IG4C.s 			page 40


 1454              		.loc 1 614 28 discriminator 1 view .LVU421
 1455 005e 9BB2     		uxth	r3, r3
 1456 0060 002B     		cmp	r3, #0
 1457 0062 F9D1     		bne	.L82
 1458              	.L81:
 615:Src/util.c    **** 
 616:Src/util.c    ****     return i2c_status;
 1459              		.loc 1 616 5 is_stmt 1 view .LVU422
 1460              		.loc 1 616 12 is_stmt 0 view .LVU423
 1461 0064 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 617:Src/util.c    **** 
 618:Src/util.c    **** }
 1462              		.loc 1 618 1 view .LVU424
 1463 0066 40B2     		sxtb	r0, r0
 1464 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1465              	.L92:
 1466              		.align	2
 1467              	.L91:
 1468 006c 00000000 		.word	.LANCHOR13
 1469 0070 00000000 		.word	.LANCHOR14
 1470 0074 00000000 		.word	.LANCHOR15
 1471 0078 02000080 		.word	-2147483646
 1472 007c 00000000 		.word	.LANCHOR16
 1473 0080 00000000 		.word	.LANCHOR18
 1474 0084 00000000 		.word	.LANCHOR17
 1475 0088 00540040 		.word	1073763328
 1476 008c 00000000 		.word	.LANCHOR19
 1477              		.cfi_endproc
 1478              	.LFE72:
 1480              		.section	.text.i2c_writeByte,"ax",%progbits
 1481              		.align	1
 1482              		.global	i2c_writeByte
 1483              		.syntax unified
 1484              		.thumb
 1485              		.thumb_func
 1486              		.fpu softvfp
 1488              	i2c_writeByte:
 1489              	.LVL96:
 1490              	.LFB73:
 619:Src/util.c    **** 
 620:Src/util.c    **** 
 621:Src/util.c    **** /*
 622:Src/util.c    ****  * write 1 byte to chip register
 623:Src/util.c    ****  */
 624:Src/util.c    **** int8_t i2c_writeByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t data)
 625:Src/util.c    **** {
 1491              		.loc 1 625 1 is_stmt 1 view -0
 1492              		.cfi_startproc
 1493              		@ args = 0, pretend = 0, frame = 8
 1494              		@ frame_needed = 0, uses_anonymous_args = 0
 626:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1495              		.loc 1 626 5 view .LVU426
 625:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1496              		.loc 1 625 1 is_stmt 0 view .LVU427
 1497 0000 07B5     		push	{r0, r1, r2, lr}
 1498              	.LCFI20:
 1499              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccy0IG4C.s 			page 41


 1500              		.cfi_offset 14, -4
 625:Src/util.c    ****     return i2c_writeBytes(slaveAddr, regAddr, 1, &data);
 1501              		.loc 1 625 1 view .LVU428
 1502 0002 8DF80720 		strb	r2, [sp, #7]
 1503              		.loc 1 626 12 view .LVU429
 1504 0006 0DF10703 		add	r3, sp, #7
 1505 000a 0122     		movs	r2, #1
 1506              	.LVL97:
 1507              		.loc 1 626 12 view .LVU430
 1508 000c FFF7FEFF 		bl	i2c_writeBytes
 1509              	.LVL98:
 627:Src/util.c    **** }
 1510              		.loc 1 627 1 view .LVU431
 1511 0010 03B0     		add	sp, sp, #12
 1512              	.LCFI21:
 1513              		.cfi_def_cfa_offset 4
 1514              		@ sp needed
 1515 0012 5DF804FB 		ldr	pc, [sp], #4
 1516              		.cfi_endproc
 1517              	.LFE73:
 1519              		.section	.text.i2c_readBytes,"ax",%progbits
 1520              		.align	1
 1521              		.global	i2c_readBytes
 1522              		.syntax unified
 1523              		.thumb
 1524              		.thumb_func
 1525              		.fpu softvfp
 1527              	i2c_readBytes:
 1528              	.LVL99:
 1529              	.LFB75:
 628:Src/util.c    **** 
 629:Src/util.c    **** 
 630:Src/util.c    **** /*
 631:Src/util.c    ****  * write one bit to chip register
 632:Src/util.c    ****  */
 633:Src/util.c    **** int8_t i2c_writeBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 634:Src/util.c    ****     uint8_t b;
 635:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 636:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 637:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 638:Src/util.c    **** }
 639:Src/util.c    **** 
 640:Src/util.c    **** 
 641:Src/util.c    **** 
 642:Src/util.c    **** /* =========================== I2C READ Functions =========================== */
 643:Src/util.c    **** 
 644:Src/util.c    **** /*
 645:Src/util.c    ****  * read bytes from chip register
 646:Src/util.c    ****  */
 647:Src/util.c    **** int8_t i2c_readBytes(uint8_t slaveAddr, uint8_t regAddr, uint8_t length, uint8_t *data) 
 648:Src/util.c    **** {
 1530              		.loc 1 648 1 is_stmt 1 view -0
 1531              		.cfi_startproc
 1532              		@ args = 0, pretend = 0, frame = 0
 1533              		@ frame_needed = 0, uses_anonymous_args = 0
 649:Src/util.c    **** 
 650:Src/util.c    ****     // assign READ command
ARM GAS  /tmp/ccy0IG4C.s 			page 42


 651:Src/util.c    ****     i2c_ReadWriteCmd    = READ;
 1534              		.loc 1 651 5 view .LVU433
 648:Src/util.c    **** 
 1535              		.loc 1 648 1 is_stmt 0 view .LVU434
 1536 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1537              	.LCFI22:
 1538              		.cfi_def_cfa_offset 24
 1539              		.cfi_offset 4, -24
 1540              		.cfi_offset 5, -20
 1541              		.cfi_offset 6, -16
 1542              		.cfi_offset 7, -12
 1543              		.cfi_offset 8, -8
 1544              		.cfi_offset 14, -4
 1545              		.loc 1 651 25 view .LVU435
 1546 0004 0024     		movs	r4, #0
 652:Src/util.c    ****     
 653:Src/util.c    ****     // assign inputs
 654:Src/util.c    ****     i2c_status          = -1;
 1547              		.loc 1 654 25 view .LVU436
 1548 0006 FF26     		movs	r6, #255
 651:Src/util.c    ****     
 1549              		.loc 1 651 25 view .LVU437
 1550 0008 1C4D     		ldr	r5, .L108
 655:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1551              		.loc 1 655 37 view .LVU438
 1552 000a 4000     		lsls	r0, r0, #1
 1553              	.LVL100:
 651:Src/util.c    ****     
 1554              		.loc 1 651 25 view .LVU439
 1555 000c 2C70     		strb	r4, [r5]
 654:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1556              		.loc 1 654 5 is_stmt 1 view .LVU440
 654:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1557              		.loc 1 654 25 is_stmt 0 view .LVU441
 1558 000e 1C4D     		ldr	r5, .L108+4
 1559              		.loc 1 655 37 view .LVU442
 1560 0010 C0B2     		uxtb	r0, r0
 654:Src/util.c    ****     i2c_slaveAddress    = slaveAddr << 1;   // Address is shifted one position to the left. LSB is 
 1561              		.loc 1 654 25 view .LVU443
 1562 0012 2E70     		strb	r6, [r5]
 1563              		.loc 1 655 5 is_stmt 1 view .LVU444
 1564              		.loc 1 655 25 is_stmt 0 view .LVU445
 1565 0014 1B4E     		ldr	r6, .L108+8
 1566 0016 3070     		strb	r0, [r6]
 656:Src/util.c    ****     i2c_regAddress      = regAddr;
 1567              		.loc 1 656 5 is_stmt 1 view .LVU446
 1568              		.loc 1 656 25 is_stmt 0 view .LVU447
 1569 0018 1B48     		ldr	r0, .L108+12
 657:Src/util.c    ****     i2c_rxbuffer        = data;
 658:Src/util.c    ****     i2c_nDABytes        = length;
 1570              		.loc 1 658 25 view .LVU448
 1571 001a 1C4E     		ldr	r6, .L108+16
 656:Src/util.c    ****     i2c_regAddress      = regAddr;
 1572              		.loc 1 656 25 view .LVU449
 1573 001c 0170     		strb	r1, [r0]
 657:Src/util.c    ****     i2c_rxbuffer        = data;
 1574              		.loc 1 657 5 is_stmt 1 view .LVU450
ARM GAS  /tmp/ccy0IG4C.s 			page 43


 1575              		.loc 1 658 25 is_stmt 0 view .LVU451
 1576 001e 3270     		strb	r2, [r6]
 659:Src/util.c    ****     i2c_nRABytes        = 1;
 1577              		.loc 1 659 25 view .LVU452
 1578 0020 0122     		movs	r2, #1
 1579              	.LVL101:
 657:Src/util.c    ****     i2c_rxbuffer        = data;
 1580              		.loc 1 657 25 view .LVU453
 1581 0022 1B49     		ldr	r1, .L108+20
 1582              	.LVL102:
 660:Src/util.c    **** 
 661:Src/util.c    ****     uint16_t i2c_timeout = 0;
 662:Src/util.c    **** 
 663:Src/util.c    ****     // enable the I2C0 interrupt
 664:Src/util.c    ****     i2c_interrupt_enable(MPU_I2C, I2C_INT_ERR | I2C_INT_BUF | I2C_INT_EV);
 1583              		.loc 1 664 5 view .LVU454
 1584 0024 1B48     		ldr	r0, .L108+24
 657:Src/util.c    ****     i2c_nDABytes        = length;
 1585              		.loc 1 657 25 view .LVU455
 1586 0026 0B60     		str	r3, [r1]
 658:Src/util.c    ****     i2c_nRABytes        = 1;
 1587              		.loc 1 658 5 is_stmt 1 view .LVU456
 659:Src/util.c    **** 
 1588              		.loc 1 659 5 view .LVU457
 659:Src/util.c    **** 
 1589              		.loc 1 659 25 is_stmt 0 view .LVU458
 1590 0028 1B4B     		ldr	r3, .L108+28
 1591              	.LVL103:
 1592              		.loc 1 664 5 view .LVU459
 1593 002a 4FF4E061 		mov	r1, #1792
 659:Src/util.c    **** 
 1594              		.loc 1 659 25 view .LVU460
 1595 002e 1A70     		strb	r2, [r3]
 1596              	.LVL104:
 661:Src/util.c    **** 
 1597              		.loc 1 661 5 is_stmt 1 view .LVU461
 1598              		.loc 1 664 5 view .LVU462
 1599 0030 FFF7FEFF 		bl	i2c_interrupt_enable
 1600              	.LVL105:
 665:Src/util.c    **** 
 666:Src/util.c    ****     if(2 == i2c_nDABytes){
 1601              		.loc 1 666 5 view .LVU463
 1602              		.loc 1 666 10 is_stmt 0 view .LVU464
 1603 0034 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1604              		.loc 1 666 7 view .LVU465
 1605 0036 022B     		cmp	r3, #2
 1606 0038 03D1     		bne	.L95
 667:Src/util.c    ****         i2c_ackpos_config(MPU_I2C, I2C_ACKPOS_NEXT);    // send ACK for the next byte
 1607              		.loc 1 667 9 is_stmt 1 view .LVU466
 1608 003a 2146     		mov	r1, r4
 1609 003c 1548     		ldr	r0, .L108+24
 1610 003e FFF7FEFF 		bl	i2c_ackpos_config
 1611              	.LVL106:
 1612              	.L95:
 648:Src/util.c    **** 
 1613              		.loc 1 648 1 is_stmt 0 discriminator 2 view .LVU467
 1614 0042 44F62164 		movw	r4, #20001
ARM GAS  /tmp/ccy0IG4C.s 			page 44


 668:Src/util.c    ****     }
 669:Src/util.c    **** 
 670:Src/util.c    ****     // the master waits until the I2C bus is idle
 671:Src/util.c    ****     while(i2c_flag_get(MPU_I2C, I2C_FLAG_I2CBSY) && i2c_timeout++ < 20000);
 1615              		.loc 1 671 11 discriminator 2 view .LVU468
 1616 0046 154F     		ldr	r7, .L108+32
 1617 0048 DFF84880 		ldr	r8, .L108+24
 1618              	.LVL107:
 1619              	.L97:
 1620              		.loc 1 671 75 is_stmt 1 discriminator 2 view .LVU469
 1621              		.loc 1 671 10 discriminator 2 view .LVU470
 1622              		.loc 1 671 11 is_stmt 0 discriminator 2 view .LVU471
 1623 004c 3946     		mov	r1, r7
 1624 004e 4046     		mov	r0, r8
 1625 0050 FFF7FEFF 		bl	i2c_flag_get
 1626              	.LVL108:
 1627              		.loc 1 671 10 discriminator 2 view .LVU472
 1628 0054 18B1     		cbz	r0, .L96
 1629              	.LVL109:
 1630              		.loc 1 671 50 discriminator 1 view .LVU473
 1631 0056 013C     		subs	r4, r4, #1
 1632              	.LVL110:
 1633              		.loc 1 671 50 discriminator 1 view .LVU474
 1634 0058 A4B2     		uxth	r4, r4
 1635 005a 002C     		cmp	r4, #0
 1636 005c F6D1     		bne	.L97
 1637              	.L96:
 672:Src/util.c    **** 
 673:Src/util.c    ****     // the master sends a start condition to I2C bus
 674:Src/util.c    ****     i2c_start_on_bus(MPU_I2C);
 1638              		.loc 1 674 5 is_stmt 1 view .LVU475
 1639 005e 0D48     		ldr	r0, .L108+24
 1640 0060 FFF7FEFF 		bl	i2c_start_on_bus
 1641              	.LVL111:
 675:Src/util.c    **** 
 676:Src/util.c    ****     // Wait until all data bytes are sent/received
 677:Src/util.c    ****     i2c_timeout = 0;
 1642              		.loc 1 677 5 view .LVU476
 678:Src/util.c    ****     while(i2c_nDABytes > 0 && i2c_timeout++ < 20000);
 1643              		.loc 1 678 5 view .LVU477
 1644              		.loc 1 678 10 is_stmt 0 view .LVU478
 1645 0064 44F62163 		movw	r3, #20001
 1646              	.LVL112:
 1647              	.L99:
 1648              		.loc 1 678 53 is_stmt 1 discriminator 2 view .LVU479
 1649              		.loc 1 678 10 discriminator 2 view .LVU480
 1650              		.loc 1 678 24 is_stmt 0 discriminator 2 view .LVU481
 1651 0068 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1652              		.loc 1 678 10 discriminator 2 view .LVU482
 1653 006a 1AB1     		cbz	r2, .L98
 1654              	.LVL113:
 1655              		.loc 1 678 28 discriminator 1 view .LVU483
 1656 006c 013B     		subs	r3, r3, #1
 1657              	.LVL114:
 1658              		.loc 1 678 28 discriminator 1 view .LVU484
 1659 006e 9BB2     		uxth	r3, r3
 1660 0070 002B     		cmp	r3, #0
ARM GAS  /tmp/ccy0IG4C.s 			page 45


 1661 0072 F9D1     		bne	.L99
 1662              	.L98:
 679:Src/util.c    **** 
 680:Src/util.c    ****     // Return status
 681:Src/util.c    ****     return i2c_status;
 1663              		.loc 1 681 5 is_stmt 1 view .LVU485
 1664              		.loc 1 681 12 is_stmt 0 view .LVU486
 1665 0074 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 682:Src/util.c    **** 
 683:Src/util.c    **** }
 1666              		.loc 1 683 1 view .LVU487
 1667 0076 40B2     		sxtb	r0, r0
 1668 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1669              	.L109:
 1670              		.align	2
 1671              	.L108:
 1672 007c 00000000 		.word	.LANCHOR13
 1673 0080 00000000 		.word	.LANCHOR14
 1674 0084 00000000 		.word	.LANCHOR15
 1675 0088 00000000 		.word	.LANCHOR16
 1676 008c 00000000 		.word	.LANCHOR18
 1677 0090 00000000 		.word	.LANCHOR20
 1678 0094 00540040 		.word	1073763328
 1679 0098 00000000 		.word	.LANCHOR19
 1680 009c 02000080 		.word	-2147483646
 1681              		.cfi_endproc
 1682              	.LFE75:
 1684              		.section	.text.i2c_readByte,"ax",%progbits
 1685              		.align	1
 1686              		.global	i2c_readByte
 1687              		.syntax unified
 1688              		.thumb
 1689              		.thumb_func
 1690              		.fpu softvfp
 1692              	i2c_readByte:
 1693              	.LVL115:
 1694              	.LFB76:
 684:Src/util.c    **** 
 685:Src/util.c    **** 
 686:Src/util.c    **** /*
 687:Src/util.c    ****  * read 1 byte from chip register
 688:Src/util.c    ****  */
 689:Src/util.c    **** int8_t i2c_readByte(uint8_t slaveAddr, uint8_t regAddr, uint8_t *data)
 690:Src/util.c    **** {
 1695              		.loc 1 690 1 is_stmt 1 view -0
 1696              		.cfi_startproc
 1697              		@ args = 0, pretend = 0, frame = 0
 1698              		@ frame_needed = 0, uses_anonymous_args = 0
 1699              		@ link register save eliminated.
 691:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1700              		.loc 1 691 5 view .LVU489
 690:Src/util.c    ****     return i2c_readBytes(slaveAddr, regAddr, 1, data);
 1701              		.loc 1 690 1 is_stmt 0 view .LVU490
 1702 0000 1346     		mov	r3, r2
 1703              		.loc 1 691 12 view .LVU491
 1704 0002 0122     		movs	r2, #1
 1705              	.LVL116:
ARM GAS  /tmp/ccy0IG4C.s 			page 46


 1706              		.loc 1 691 12 view .LVU492
 1707 0004 FFF7FEBF 		b	i2c_readBytes
 1708              	.LVL117:
 1709              		.loc 1 691 12 view .LVU493
 1710              		.cfi_endproc
 1711              	.LFE76:
 1713              		.section	.text.i2c_writeBit,"ax",%progbits
 1714              		.align	1
 1715              		.global	i2c_writeBit
 1716              		.syntax unified
 1717              		.thumb
 1718              		.thumb_func
 1719              		.fpu softvfp
 1721              	i2c_writeBit:
 1722              	.LVL118:
 1723              	.LFB74:
 633:Src/util.c    ****     uint8_t b;
 1724              		.loc 1 633 87 is_stmt 1 view -0
 1725              		.cfi_startproc
 1726              		@ args = 0, pretend = 0, frame = 8
 1727              		@ frame_needed = 0, uses_anonymous_args = 0
 634:Src/util.c    ****     i2c_readByte(slaveAddr, regAddr, &b);
 1728              		.loc 1 634 5 view .LVU495
 635:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1729              		.loc 1 635 5 view .LVU496
 633:Src/util.c    ****     uint8_t b;
 1730              		.loc 1 633 87 is_stmt 0 view .LVU497
 1731 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 1732              	.LCFI23:
 1733              		.cfi_def_cfa_offset 32
 1734              		.cfi_offset 4, -24
 1735              		.cfi_offset 5, -20
 1736              		.cfi_offset 6, -16
 1737              		.cfi_offset 7, -12
 1738              		.cfi_offset 8, -8
 1739              		.cfi_offset 14, -4
 633:Src/util.c    ****     uint8_t b;
 1740              		.loc 1 633 87 view .LVU498
 1741 0004 9046     		mov	r8, r2
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1742              		.loc 1 636 31 view .LVU499
 1743 0006 0124     		movs	r4, #1
 633:Src/util.c    ****     uint8_t b;
 1744              		.loc 1 633 87 view .LVU500
 1745 0008 1F46     		mov	r7, r3
 635:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1746              		.loc 1 635 5 view .LVU501
 1747 000a 0DF10702 		add	r2, sp, #7
 1748              	.LVL119:
 633:Src/util.c    ****     uint8_t b;
 1749              		.loc 1 633 87 view .LVU502
 1750 000e 0546     		mov	r5, r0
 1751 0010 0E46     		mov	r6, r1
 635:Src/util.c    ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1752              		.loc 1 635 5 view .LVU503
 1753 0012 FFF7FEFF 		bl	i2c_readByte
 1754              	.LVL120:
ARM GAS  /tmp/ccy0IG4C.s 			page 47


 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1755              		.loc 1 636 5 is_stmt 1 view .LVU504
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1756              		.loc 1 636 31 is_stmt 0 view .LVU505
 1757 0016 04FA08F2 		lsl	r2, r4, r8
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1758              		.loc 1 636 26 view .LVU506
 1759 001a 52B2     		sxtb	r2, r2
 1760 001c 9DF80740 		ldrb	r4, [sp, #7]	@ zero_extendqisi2
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1761              		.loc 1 636 7 view .LVU507
 1762 0020 57B1     		cbz	r7, .L112
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1763              		.loc 1 636 26 discriminator 1 view .LVU508
 1764 0022 2243     		orrs	r2, r2, r4
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1765              		.loc 1 636 7 discriminator 1 view .LVU509
 1766 0024 D2B2     		uxtb	r2, r2
 1767              	.L113:
 637:Src/util.c    **** }
 1768              		.loc 1 637 12 discriminator 4 view .LVU510
 1769 0026 3146     		mov	r1, r6
 1770 0028 2846     		mov	r0, r5
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1771              		.loc 1 636 7 discriminator 4 view .LVU511
 1772 002a 8DF80720 		strb	r2, [sp, #7]
 637:Src/util.c    **** }
 1773              		.loc 1 637 5 is_stmt 1 discriminator 4 view .LVU512
 637:Src/util.c    **** }
 1774              		.loc 1 637 12 is_stmt 0 discriminator 4 view .LVU513
 1775 002e FFF7FEFF 		bl	i2c_writeByte
 1776              	.LVL121:
 638:Src/util.c    **** 
 1777              		.loc 1 638 1 discriminator 4 view .LVU514
 1778 0032 02B0     		add	sp, sp, #8
 1779              	.LCFI24:
 1780              		.cfi_remember_state
 1781              		.cfi_def_cfa_offset 24
 1782              		@ sp needed
 1783 0034 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1784              	.L112:
 1785              	.LCFI25:
 1786              		.cfi_restore_state
 636:Src/util.c    ****     return i2c_writeByte(slaveAddr, regAddr, b);
 1787              		.loc 1 636 7 discriminator 2 view .LVU515
 1788 0038 24EA0202 		bic	r2, r4, r2
 1789 003c F3E7     		b	.L113
 1790              		.cfi_endproc
 1791              	.LFE74:
 1793              		.section	.text.i2c_readBit,"ax",%progbits
 1794              		.align	1
 1795              		.global	i2c_readBit
 1796              		.syntax unified
 1797              		.thumb
 1798              		.thumb_func
 1799              		.fpu softvfp
 1801              	i2c_readBit:
ARM GAS  /tmp/ccy0IG4C.s 			page 48


 1802              	.LVL122:
 1803              	.LFB77:
 692:Src/util.c    **** }
 693:Src/util.c    **** 
 694:Src/util.c    **** 
 695:Src/util.c    **** /*
 696:Src/util.c    ****  * read 1 bit from chip register
 697:Src/util.c    ****  */
 698:Src/util.c    **** int8_t i2c_readBit(uint8_t slaveAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data)
 699:Src/util.c    **** {
 1804              		.loc 1 699 1 is_stmt 1 view -0
 1805              		.cfi_startproc
 1806              		@ args = 0, pretend = 0, frame = 8
 1807              		@ frame_needed = 0, uses_anonymous_args = 0
 700:Src/util.c    ****     uint8_t b;
 1808              		.loc 1 700 5 view .LVU517
 701:Src/util.c    ****     int8_t status = i2c_readByte(slaveAddr, regAddr, &b);
 1809              		.loc 1 701 5 view .LVU518
 699:Src/util.c    ****     uint8_t b;
 1810              		.loc 1 699 1 is_stmt 0 view .LVU519
 1811 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1812              	.LCFI26:
 1813              		.cfi_def_cfa_offset 24
 1814              		.cfi_offset 4, -12
 1815              		.cfi_offset 5, -8
 1816              		.cfi_offset 14, -4
 699:Src/util.c    ****     uint8_t b;
 1817              		.loc 1 699 1 view .LVU520
 1818 0002 1546     		mov	r5, r2
 1819              		.loc 1 701 21 view .LVU521
 1820 0004 0DF10702 		add	r2, sp, #7
 1821              	.LVL123:
 699:Src/util.c    ****     uint8_t b;
 1822              		.loc 1 699 1 view .LVU522
 1823 0008 1C46     		mov	r4, r3
 1824              		.loc 1 701 21 view .LVU523
 1825 000a FFF7FEFF 		bl	i2c_readByte
 1826              	.LVL124:
 702:Src/util.c    ****     *data = b & (1 << bitNum);
 1827              		.loc 1 702 5 is_stmt 1 view .LVU524
 1828              		.loc 1 702 20 is_stmt 0 view .LVU525
 1829 000e 0121     		movs	r1, #1
 1830              		.loc 1 702 15 view .LVU526
 1831 0010 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1832              		.loc 1 702 20 view .LVU527
 1833 0014 01FA05F2 		lsl	r2, r1, r5
 1834              		.loc 1 702 15 view .LVU528
 1835 0018 1A40     		ands	r2, r2, r3
 1836              		.loc 1 702 11 view .LVU529
 1837 001a 2270     		strb	r2, [r4]
 703:Src/util.c    ****     return status;
 1838              		.loc 1 703 5 is_stmt 1 view .LVU530
 704:Src/util.c    **** }
 1839              		.loc 1 704 1 is_stmt 0 view .LVU531
 1840 001c 03B0     		add	sp, sp, #12
 1841              	.LCFI27:
 1842              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccy0IG4C.s 			page 49


 1843              		@ sp needed
 1844 001e 30BD     		pop	{r4, r5, pc}
 1845              		.loc 1 704 1 view .LVU532
 1846              		.cfi_endproc
 1847              	.LFE77:
 1849              		.global	buffer
 1850              		.global	i2c_nRABytes
 1851              		.global	i2c_nDABytes
 1852              		.global	i2c_rxbuffer
 1853              		.global	i2c_txbuffer
 1854              		.global	i2c_slaveAddress
 1855              		.global	i2c_regAddress
 1856              		.global	i2c_ReadWriteCmd
 1857              		.global	i2c_status
 1858              		.section	.bss.Feedback,"aw",%nobits
 1859              		.align	1
 1860              		.set	.LANCHOR10,. + 0
 1863              	Feedback:
 1864 0000 00000000 		.space	18
 1864      00000000 
 1864      00000000 
 1864      00000000 
 1864      0000
 1865              		.section	.bss.FeedbackRaw,"aw",%nobits
 1866              		.align	1
 1867              		.set	.LANCHOR12,. + 0
 1870              	FeedbackRaw:
 1871 0000 00000000 		.space	18
 1871      00000000 
 1871      00000000 
 1871      00000000 
 1871      0000
 1872              		.section	.bss.Sideboard,"aw",%nobits
 1873              		.align	1
 1874              		.set	.LANCHOR0,. + 0
 1877              	Sideboard:
 1878 0000 00000000 		.space	14
 1878      00000000 
 1878      00000000 
 1878      0000
 1879              		.section	.bss.buffer,"aw",%nobits
 1882              	buffer:
 1883 0000 00000000 		.space	14
 1883      00000000 
 1883      00000000 
 1883      0000
 1884              		.section	.bss.i2c_ReadWriteCmd,"aw",%nobits
 1885              		.set	.LANCHOR13,. + 0
 1888              	i2c_ReadWriteCmd:
 1889 0000 00       		.space	1
 1890              		.section	.bss.i2c_nDABytes,"aw",%nobits
 1891              		.set	.LANCHOR18,. + 0
 1894              	i2c_nDABytes:
 1895 0000 00       		.space	1
 1896              		.section	.bss.i2c_nRABytes,"aw",%nobits
 1897              		.set	.LANCHOR19,. + 0
 1900              	i2c_nRABytes:
ARM GAS  /tmp/ccy0IG4C.s 			page 50


 1901 0000 00       		.space	1
 1902              		.section	.bss.i2c_regAddress,"aw",%nobits
 1903              		.set	.LANCHOR16,. + 0
 1906              	i2c_regAddress:
 1907 0000 00       		.space	1
 1908              		.section	.bss.i2c_rxbuffer,"aw",%nobits
 1909              		.align	2
 1910              		.set	.LANCHOR20,. + 0
 1913              	i2c_rxbuffer:
 1914 0000 00000000 		.space	4
 1915              		.section	.bss.i2c_slaveAddress,"aw",%nobits
 1916              		.set	.LANCHOR15,. + 0
 1919              	i2c_slaveAddress:
 1920 0000 00       		.space	1
 1921              		.section	.bss.i2c_status,"aw",%nobits
 1922              		.set	.LANCHOR14,. + 0
 1925              	i2c_status:
 1926 0000 00       		.space	1
 1927              		.section	.bss.i2c_txbuffer,"aw",%nobits
 1928              		.align	2
 1929              		.set	.LANCHOR17,. + 0
 1932              	i2c_txbuffer:
 1933 0000 00000000 		.space	4
 1934              		.section	.bss.mpuStatus,"aw",%nobits
 1935              		.set	.LANCHOR2,. + 0
 1938              	mpuStatus:
 1939 0000 00       		.space	1
 1940              		.section	.bss.old_pos.0,"aw",%nobits
 1941              		.align	2
 1942              		.set	.LANCHOR11,. + 0
 1945              	old_pos.0:
 1946 0000 00000000 		.space	4
 1947              		.section	.bss.rx1_buffer,"aw",%nobits
 1948              		.set	.LANCHOR1,. + 0
 1951              	rx1_buffer:
 1952 0000 00000000 		.space	64
 1952      00000000 
 1952      00000000 
 1952      00000000 
 1952      00000000 
 1953              		.section	.bss.sensor1,"aw",%nobits
 1954              		.set	.LANCHOR5,. + 0
 1957              	sensor1:
 1958 0000 00       		.space	1
 1959              		.section	.bss.sensor1_read,"aw",%nobits
 1960              		.set	.LANCHOR3,. + 0
 1963              	sensor1_read:
 1964 0000 00       		.space	1
 1965              		.section	.bss.sensor2,"aw",%nobits
 1966              		.set	.LANCHOR6,. + 0
 1969              	sensor2:
 1970 0000 00       		.space	1
 1971              		.section	.bss.sensor2_read,"aw",%nobits
 1972              		.set	.LANCHOR4,. + 0
 1975              	sensor2_read:
 1976 0000 00       		.space	1
 1977              		.section	.bss.sideboard_imu,"aw",%nobits
ARM GAS  /tmp/ccy0IG4C.s 			page 51


 1978              		.align	1
 1979              		.set	.LANCHOR7,. + 0
 1982              	sideboard_imu:
 1983 0000 00000000 		.space	34
 1983      00000000 
 1983      00000000 
 1983      00000000 
 1983      00000000 
 1984              		.section	.bss.timeoutCntSerial1,"aw",%nobits
 1985              		.align	1
 1986              		.set	.LANCHOR8,. + 0
 1989              	timeoutCntSerial1:
 1990 0000 0000     		.space	2
 1991              		.section	.bss.timeoutFlagSerial1,"aw",%nobits
 1992              		.set	.LANCHOR9,. + 0
 1995              	timeoutFlagSerial1:
 1996 0000 00       		.space	1
 1997              		.text
 1998              	.Letext0:
 1999              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 2000              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 2001              		.file 4 "Drivers/CMSIS/Include/gd32f1x0.h"
 2002              		.file 5 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dma.h"
 2003              		.file 6 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_dbg.h"
 2004              		.file 7 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_rcu.h"
 2005              		.file 8 "Inc/util.h"
 2006              		.file 9 "Inc/defines.h"
 2007              		.file 10 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_i2c.h"
 2008              		.file 11 "Drivers/GD32F1x0_standard_peripheral/Include/gd32f1x0_gpio.h"
 2009              		.file 12 "Inc/mpu6050.h"
 2010              		.file 13 "Inc/setup.h"
 2011              		.file 14 "Inc/systick.h"
 2012              		.file 15 "<built-in>"
ARM GAS  /tmp/ccy0IG4C.s 			page 52


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccy0IG4C.s:16     .text.consoleLog:0000000000000000 $t
     /tmp/ccy0IG4C.s:24     .text.consoleLog:0000000000000000 consoleLog
     /tmp/ccy0IG4C.s:39     .text.toggle_led:0000000000000000 $t
     /tmp/ccy0IG4C.s:46     .text.toggle_led:0000000000000000 toggle_led
     /tmp/ccy0IG4C.s:65     .text.intro_demo_led:0000000000000000 $t
     /tmp/ccy0IG4C.s:72     .text.intro_demo_led:0000000000000000 intro_demo_led
     /tmp/ccy0IG4C.s:223    .text.intro_demo_led:00000000000000cc $d
     /tmp/ccy0IG4C.s:228    .text.switch_check:0000000000000000 $t
     /tmp/ccy0IG4C.s:235    .text.switch_check:0000000000000000 switch_check
     /tmp/ccy0IG4C.s:283    .text.input_init:0000000000000000 $t
     /tmp/ccy0IG4C.s:290    .text.input_init:0000000000000000 input_init
     /tmp/ccy0IG4C.s:362    .text.input_init:0000000000000044 $d
     /tmp/ccy0IG4C.s:371    .text.handle_mpu6050:0000000000000000 $t
     /tmp/ccy0IG4C.s:378    .text.handle_mpu6050:0000000000000000 handle_mpu6050
     /tmp/ccy0IG4C.s:429    .text.handle_mpu6050:000000000000002c $d
     /tmp/ccy0IG4C.s:435    .text.handle_sensors:0000000000000000 $t
     /tmp/ccy0IG4C.s:442    .text.handle_sensors:0000000000000000 handle_sensors
     /tmp/ccy0IG4C.s:600    .text.handle_sensors:000000000000007c $d
     /tmp/ccy0IG4C.s:610    .text.handle_usart:0000000000000000 $t
     /tmp/ccy0IG4C.s:617    .text.handle_usart:0000000000000000 handle_usart
     /tmp/ccy0IG4C.s:869    .text.handle_usart:0000000000000138 $d
     /tmp/ccy0IG4C.s:883    .text.handle_leds:0000000000000000 $t
     /tmp/ccy0IG4C.s:890    .text.handle_leds:0000000000000000 handle_leds
     /tmp/ccy0IG4C.s:1054   .text.handle_leds:0000000000000094 $d
     /tmp/ccy0IG4C.s:1061   .text.usart_process_data:0000000000000000 $t
     /tmp/ccy0IG4C.s:1068   .text.usart_process_data:0000000000000000 usart_process_data
     /tmp/ccy0IG4C.s:1150   .text.usart_process_data:0000000000000050 $d
     /tmp/ccy0IG4C.s:1156   .text.usart1_rx_check:0000000000000000 $t
     /tmp/ccy0IG4C.s:1163   .text.usart1_rx_check:0000000000000000 usart1_rx_check
     /tmp/ccy0IG4C.s:1281   .text.usart1_rx_check:0000000000000074 $d
     /tmp/ccy0IG4C.s:1289   .text.usart0_rx_check:0000000000000000 $t
     /tmp/ccy0IG4C.s:1296   .text.usart0_rx_check:0000000000000000 usart0_rx_check
     /tmp/ccy0IG4C.s:1309   .text.aux_print_to_console:0000000000000000 $t
     /tmp/ccy0IG4C.s:1316   .text.aux_print_to_console:0000000000000000 aux_print_to_console
     /tmp/ccy0IG4C.s:1327   .text.i2c_writeBytes:0000000000000000 $t
     /tmp/ccy0IG4C.s:1334   .text.i2c_writeBytes:0000000000000000 i2c_writeBytes
     /tmp/ccy0IG4C.s:1468   .text.i2c_writeBytes:000000000000006c $d
     /tmp/ccy0IG4C.s:1481   .text.i2c_writeByte:0000000000000000 $t
     /tmp/ccy0IG4C.s:1488   .text.i2c_writeByte:0000000000000000 i2c_writeByte
     /tmp/ccy0IG4C.s:1520   .text.i2c_readBytes:0000000000000000 $t
     /tmp/ccy0IG4C.s:1527   .text.i2c_readBytes:0000000000000000 i2c_readBytes
     /tmp/ccy0IG4C.s:1672   .text.i2c_readBytes:000000000000007c $d
     /tmp/ccy0IG4C.s:1685   .text.i2c_readByte:0000000000000000 $t
     /tmp/ccy0IG4C.s:1692   .text.i2c_readByte:0000000000000000 i2c_readByte
     /tmp/ccy0IG4C.s:1714   .text.i2c_writeBit:0000000000000000 $t
     /tmp/ccy0IG4C.s:1721   .text.i2c_writeBit:0000000000000000 i2c_writeBit
     /tmp/ccy0IG4C.s:1794   .text.i2c_readBit:0000000000000000 $t
     /tmp/ccy0IG4C.s:1801   .text.i2c_readBit:0000000000000000 i2c_readBit
     /tmp/ccy0IG4C.s:1882   .bss.buffer:0000000000000000 buffer
     /tmp/ccy0IG4C.s:1900   .bss.i2c_nRABytes:0000000000000000 i2c_nRABytes
     /tmp/ccy0IG4C.s:1894   .bss.i2c_nDABytes:0000000000000000 i2c_nDABytes
     /tmp/ccy0IG4C.s:1913   .bss.i2c_rxbuffer:0000000000000000 i2c_rxbuffer
     /tmp/ccy0IG4C.s:1932   .bss.i2c_txbuffer:0000000000000000 i2c_txbuffer
     /tmp/ccy0IG4C.s:1919   .bss.i2c_slaveAddress:0000000000000000 i2c_slaveAddress
     /tmp/ccy0IG4C.s:1906   .bss.i2c_regAddress:0000000000000000 i2c_regAddress
ARM GAS  /tmp/ccy0IG4C.s 			page 53


     /tmp/ccy0IG4C.s:1888   .bss.i2c_ReadWriteCmd:0000000000000000 i2c_ReadWriteCmd
     /tmp/ccy0IG4C.s:1925   .bss.i2c_status:0000000000000000 i2c_status
     /tmp/ccy0IG4C.s:1859   .bss.Feedback:0000000000000000 $d
     /tmp/ccy0IG4C.s:1863   .bss.Feedback:0000000000000000 Feedback
     /tmp/ccy0IG4C.s:1866   .bss.FeedbackRaw:0000000000000000 $d
     /tmp/ccy0IG4C.s:1870   .bss.FeedbackRaw:0000000000000000 FeedbackRaw
     /tmp/ccy0IG4C.s:1873   .bss.Sideboard:0000000000000000 $d
     /tmp/ccy0IG4C.s:1877   .bss.Sideboard:0000000000000000 Sideboard
     /tmp/ccy0IG4C.s:1883   .bss.buffer:0000000000000000 $d
     /tmp/ccy0IG4C.s:1889   .bss.i2c_ReadWriteCmd:0000000000000000 $d
     /tmp/ccy0IG4C.s:1895   .bss.i2c_nDABytes:0000000000000000 $d
     /tmp/ccy0IG4C.s:1901   .bss.i2c_nRABytes:0000000000000000 $d
     /tmp/ccy0IG4C.s:1907   .bss.i2c_regAddress:0000000000000000 $d
     /tmp/ccy0IG4C.s:1909   .bss.i2c_rxbuffer:0000000000000000 $d
     /tmp/ccy0IG4C.s:1920   .bss.i2c_slaveAddress:0000000000000000 $d
     /tmp/ccy0IG4C.s:1926   .bss.i2c_status:0000000000000000 $d
     /tmp/ccy0IG4C.s:1928   .bss.i2c_txbuffer:0000000000000000 $d
     /tmp/ccy0IG4C.s:1938   .bss.mpuStatus:0000000000000000 mpuStatus
     /tmp/ccy0IG4C.s:1939   .bss.mpuStatus:0000000000000000 $d
     /tmp/ccy0IG4C.s:1941   .bss.old_pos.0:0000000000000000 $d
     /tmp/ccy0IG4C.s:1945   .bss.old_pos.0:0000000000000000 old_pos.0
     /tmp/ccy0IG4C.s:1951   .bss.rx1_buffer:0000000000000000 rx1_buffer
     /tmp/ccy0IG4C.s:1952   .bss.rx1_buffer:0000000000000000 $d
     /tmp/ccy0IG4C.s:1957   .bss.sensor1:0000000000000000 sensor1
     /tmp/ccy0IG4C.s:1958   .bss.sensor1:0000000000000000 $d
     /tmp/ccy0IG4C.s:1963   .bss.sensor1_read:0000000000000000 sensor1_read
     /tmp/ccy0IG4C.s:1964   .bss.sensor1_read:0000000000000000 $d
     /tmp/ccy0IG4C.s:1969   .bss.sensor2:0000000000000000 sensor2
     /tmp/ccy0IG4C.s:1970   .bss.sensor2:0000000000000000 $d
     /tmp/ccy0IG4C.s:1975   .bss.sensor2_read:0000000000000000 sensor2_read
     /tmp/ccy0IG4C.s:1976   .bss.sensor2_read:0000000000000000 $d
     /tmp/ccy0IG4C.s:1978   .bss.sideboard_imu:0000000000000000 $d
     /tmp/ccy0IG4C.s:1982   .bss.sideboard_imu:0000000000000000 sideboard_imu
     /tmp/ccy0IG4C.s:1985   .bss.timeoutCntSerial1:0000000000000000 $d
     /tmp/ccy0IG4C.s:1989   .bss.timeoutCntSerial1:0000000000000000 timeoutCntSerial1
     /tmp/ccy0IG4C.s:1995   .bss.timeoutFlagSerial1:0000000000000000 timeoutFlagSerial1
     /tmp/ccy0IG4C.s:1996   .bss.timeoutFlagSerial1:0000000000000000 $d

UNDEFINED SYMBOLS
gpio_bit_set
gpio_bit_reset
delay_1ms
usart_Tx_DMA_config
usart_Rx_DMA_config
mpu_config
mpu_get_data
main_loop_counter
gpio_input_bit_get
dma_transfer_number_get
dma_channel_disable
dma_channel_enable
mpu
memcpy
i2c_interrupt_enable
i2c_flag_get
i2c_start_on_bus
i2c_ackpos_config
ARM GAS  /tmp/ccy0IG4C.s 			page 54


